<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>技术文章摘抄 – 极客专栏</title><link>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/</link><description>Recent content in 极客专栏 on 技术文章摘抄</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Tue, 07 Jun 2022 00:00:00 +0000</lastBuildDate><atom:link href="/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/index.xml" rel="self" type="application/rss+xml"/><item><title>极客专栏: 00丨导读丨如何学习这个专栏？</title><link>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E5%85%A8%E6%A0%88%E5%B7%A5%E7%A8%8B%E5%B8%88%E4%BF%AE%E7%82%BC%E6%8C%87%E5%8D%97/00%E4%B8%A8%E5%AF%BC%E8%AF%BB%E4%B8%A8%E5%A6%82%E4%BD%95%E5%AD%A6%E4%B9%A0%E8%BF%99%E4%B8%AA%E4%B8%93%E6%A0%8F/</link><pubDate>Tue, 07 Jun 2022 00:00:00 +0000</pubDate><guid>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E5%85%A8%E6%A0%88%E5%B7%A5%E7%A8%8B%E5%B8%88%E4%BF%AE%E7%82%BC%E6%8C%87%E5%8D%97/00%E4%B8%A8%E5%AF%BC%E8%AF%BB%E4%B8%A8%E5%A6%82%E4%BD%95%E5%AD%A6%E4%B9%A0%E8%BF%99%E4%B8%AA%E4%B8%93%E6%A0%8F/</guid><description>
&lt;p>你好，欢迎来到&amp;quot;全栈工程师修炼指南&amp;quot;，我是专栏编辑王冬青，很高兴认识你。&lt;/p>
&lt;p>这个专栏我们邀请了西雅图 Oracle 首席软件工程师四火，历时半年打磨完成。为了帮助你更好地了解专栏的内容设计，收获更好的学习效果，我们特别提供了这篇导读，希望你能在这里找到学习这个专栏的最佳姿势。&lt;/p>
&lt;h2 id="课程设计">课程设计&lt;/h2>
&lt;p>本专栏围绕基于 Web 的全栈技术进行展开，主要包括&amp;quot;网络协议和 Web 接口、服务端 MVC、前端技术、数据持久化、最佳实践和专题&amp;quot;。&lt;/p>
&lt;h3 id="1-学习目标">1. 学习目标&lt;/h3>
&lt;p>学完之后，你可以对基于 Web 的全栈技术有一个系统的认识，深度掌握全栈工程师必备技能，理解技术本质，而不仅仅是停留在技术配置和使用的表象，能够将作者交付的知识复用到自己的实际进阶中去。另外，你还可以将零散的知识点联结成一棵全栈技能树，培养&amp;quot;全栈思维&amp;quot;。&lt;/p>
&lt;h3 id="2-内容优势">2. 内容优势&lt;/h3>
&lt;p>专栏内容可以帮助你在入门或者进阶全栈的道路上，梳理出一条高效的学习路径，并掌握这条路径上有代表性的技术。&lt;/p>
&lt;p>目前市面上针对单一 、具体技术的教程有很多，但我们独辟蹊径，以系统的全栈技术关系树为基石，重点关注核心技术栈主流技术之间的关联和演进，介绍这些技术间的权衡，探究它们的本质，结合实践、沉淀知识、带动思考。&lt;/p>
&lt;h3 id="3-特色板块">3. 特色板块&lt;/h3>
&lt;p>**热点答疑：**基于内容性质，我们在前五章的最后一讲都设置了热点答疑，目的就是综合你的留言反馈进行分享，定位是较为开放式的，不局限于每一讲中的问题解答。关于&amp;quot;全栈工程师&amp;quot;这一职位，除了某一特定技术点，如果你有更感兴趣的内容，也可以在留言区中告知我们，这个专栏是可以有一些外延性质的话题分享的，比如已定的 《06 | 特别放送：北美大厂如何招聘全栈工程师？》，希望能帮助你拓展技术视野，你可以对照北美大厂的招聘标准和流程重新界定下自己所处的位置，进而有针对性地进行学习。&lt;/p>
&lt;p>**总结思考：**鉴于这个专栏的总结和思考是有强关联的，所以我们合并到了一起，总结主要就是回顾这一讲所学的内容，很好理解了。要特别说明下思考题部分，每一讲的末尾我们会设置两道思考题，一道难度较低，另一道难度略有升级，你可以根据自己的学习程度和本身积累在留言区中分享答案，作者会有针对性地进行回复。当然了，如果可以，十分鼓励你两道都解答一下，对于消化理解所学的知识内容，培养自己的全栈思维很有帮助。&lt;/p>
&lt;p>**选修课堂：**这是一个全新的板块，如果我们将总结思考之前的内容，定位为必修，那么选修课堂的功能就一目了然了。这部分的内容你可以结合自身情况，选择性阅读，它们是与该讲主题强相关的知识，但不会影响必修部分的学习，它们可能该讲中某一步骤的实践过程，帮助你强化认识，也可能是某一重要知识点的详细讲解，帮助你查漏补缺。同时，这个板块是根据每一讲的主题进行考虑的，对于无需增设选修课堂的主题，总结思考之后会直接进入&amp;quot;扩展阅读&amp;quot;板块。&lt;/p>
&lt;p>**扩展阅读：**同上，也是一个全新的板块，每一讲作者都精心准备了一组链接，大致 3~5 篇，每个链接都有文字说明。出于对质量的考虑，这里有部分是英文资料，这里要再强调一下，英文能力也是软件工程师进阶的必备能力之一，这一点作者在学习路径中已经谈过了，但修炼英文非朝夕之事，你也不必过于担心，同等质量下作者会优先选择中文资料进行推荐，如果理解上有困难，还可以借助一些翻译软件，遇到难点，也可以在留言区中与作者探讨。&lt;/p>
&lt;p>这些资料有自己的定位，不是&amp;quot;有了更好、没有也行&amp;quot;的可有可无的内容，而是可以帮助你进一步展开学习的重要资料。考虑到每个人的基础不同，它们有的是简单的教程，也有的是技术背景介绍，还有某一技术长项和短处的拓展分析等等。&lt;/p>
&lt;p>值得注意的是，少数资料前会标有【基础】字样，这表示该内容涉及的知识点较为基础，如果你对该讲的理解有困难，可以去这样的链接中找找答案。另外，这些资料中没有大厚书，并不是说它们不好，而是作者希望每一讲的内容，你都能在有限的时间内完成阅读、思考、练习和拓展这样的一个闭环。&lt;/p>
&lt;h2 id="学习攻略">学习攻略&lt;/h2>
&lt;p>除了介绍课程设计之外，我还为你准备了六大攻略，都是针对这个专栏的学习方法，帮助你提升学习效率和收获感。&lt;/p>
&lt;h3 id="攻略一利用好特色板块">攻略一：利用好特色板块&lt;/h3>
&lt;p>鉴于全栈工程师的学习性质，这个专栏我们开创了不少特色板块，每个板块的作用在上面我都做了详细说明。请你一定要结合自身情况利用好它们，尽可能不要错过&amp;quot;选修课堂&amp;quot;和&amp;quot;扩展阅读&amp;quot;，它们是可以帮助你快速提升，且拓展你知识版图的内容。&lt;/p>
&lt;h3 id="攻略二勤于动手实践">攻略二：勤于动手实践&lt;/h3>
&lt;p>全栈所包含的知识点非常多，最好的记忆方式就是实践，亲身操作一遍，你会打开一扇新世界的大门&amp;mdash;&amp;mdash;原来全栈并没有那么难。跟着作者文章中分享的小案例亲自做一做，跑一跑代码，自己验证下结论，这是个很高效的学习方法，我十分鼓励你这样做。&lt;/p>
&lt;p>不过也正因为这些案例，我推荐你首选文字 + 音频这样的学习方式，只听音频的话，对于这个专栏来说，理解上会有一定难度。&lt;/p>
&lt;h3 id="攻略三在联想和比较中学习">攻略三：在联想和比较中学习&lt;/h3>
&lt;p>基于全栈知识树庞大和繁杂的特点，它的学习方法会有所不同，它需要你多去尝试比较同类技术，并且将所学理论和工作中实际应用的技术、遇到的问题结合起来。它需要你掌握隐藏在具体技术背后的通用&amp;quot;套路&amp;quot;，联结不同技术，使之成为一个健壮的知识网格，真正将技术的理解落实到本质上去。&lt;/p>
&lt;h3 id="攻略四充分利用留言区">攻略四：充分利用留言区&lt;/h3>
&lt;p>留言区最直观的作用就是完成思考题，每一讲的思考题都是作者精选的，如果你能解答，并分享出来，得到作者和其他同学的肯定，相信你已经对该讲的内容有了深度的认识了，通过这样的方式对所学进行自我检验，是个非常高效的方法。&lt;/p>
&lt;p>除此之外，你还可以在这里进行学习总结、强化输出，提出问题、解决困惑，回复他人留言、发起互动，从&amp;quot;消费者&amp;quot;角色升级到&amp;quot;生产者&amp;quot;角色。&lt;/p>
&lt;p>如果你在留言区中写下的增量信息够硬核，还有机会让作者精选出来，在该章的最后一讲&amp;quot;热点答疑&amp;quot;中做深度讲解。&lt;/p>
&lt;h3 id="攻略五善于分享">攻略五：善于分享&lt;/h3>
&lt;p>极客时间平台提供了很多分享功能。比如，看到硬核知识点、金句或深有感触的内容，你可以长按做划线笔记，点击分享就可以生成精美的知识卡片，将所学随手记录或分享出去。如果你希望分享整篇文章，或者邀请你的朋友一起打卡学习，还可以点击文稿右上角的&amp;quot;请朋友读&amp;quot;，把这门课推荐给朋友。&lt;/p>
&lt;p>这里的分享更像是一种知识交换，给予越多，收获自然也就越多，期待在这个过程中，你的知识体系也能得到锤炼。&lt;/p>
&lt;h3 id="攻略六有计划地学习">攻略六：有计划地学习&lt;/h3>
&lt;p>这个专栏的更新频率为每周一、三、五，共计 40 讲，更新时间 14 周，你可以跟着作者的更新频率进行学习。一篇文章发布后你有两天的学习时间，你可以一天学习每讲的必修内容，一天学习选修课堂和扩展阅读，当然了，你也可以根据自身情况，自己制定合理的学习计划。&lt;/p>
&lt;p>修炼全栈，横向对比技术，纵向挖掘技术，再串联知识，形成一个知识体系，这本身并不是一件容易的事儿。在有作者引导的基础上，希望你能充分调动自身内驱力，将学习坚持下去，期待在最后的《全栈回顾》中见到你的打卡哦～&lt;/p>
&lt;p>最后，祝你学以致用、实现进阶。加油！&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/11/8b/1181246bbd51ce348d5729696d1dc28b.jpg" alt="unpreview">&lt;/p></description></item><item><title>极客专栏: 00丨开篇词丨从成长角度看，为什么你应该成为全栈工程师？</title><link>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E5%85%A8%E6%A0%88%E5%B7%A5%E7%A8%8B%E5%B8%88%E4%BF%AE%E7%82%BC%E6%8C%87%E5%8D%97/00%E4%B8%A8%E5%BC%80%E7%AF%87%E8%AF%8D%E4%B8%A8%E4%BB%8E%E6%88%90%E9%95%BF%E8%A7%92%E5%BA%A6%E7%9C%8B%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%A0%E5%BA%94%E8%AF%A5%E6%88%90%E4%B8%BA%E5%85%A8%E6%A0%88%E5%B7%A5%E7%A8%8B%E5%B8%88/</link><pubDate>Tue, 07 Jun 2022 00:00:00 +0000</pubDate><guid>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E5%85%A8%E6%A0%88%E5%B7%A5%E7%A8%8B%E5%B8%88%E4%BF%AE%E7%82%BC%E6%8C%87%E5%8D%97/00%E4%B8%A8%E5%BC%80%E7%AF%87%E8%AF%8D%E4%B8%A8%E4%BB%8E%E6%88%90%E9%95%BF%E8%A7%92%E5%BA%A6%E7%9C%8B%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%A0%E5%BA%94%E8%AF%A5%E6%88%90%E4%B8%BA%E5%85%A8%E6%A0%88%E5%B7%A5%E7%A8%8B%E5%B8%88/</guid><description>
&lt;p>你好，我是软件工程师熊燚，网上大家都叫我四火，很高兴在这个专栏和你见面。&lt;/p>
&lt;p>先介绍下我自己。最早我在华为工作，曾是华为某大型视频门户和视频平台的初创人员，也是一名不折不扣的长期看护其基线版本的全栈工程师，这段经历其实为我的全栈技能打下了一个很好的基础。&lt;/p>
&lt;p>后来我加入了亚马逊（Amazon），负责数千万商品销量预测系统和成本利润计算平台的研发，从 0 到 1 重新设计并开发了数据分析和可视化系统，还维护和优化过数据分发的高可用服务，也改进过核算平台的分布式计算架构和工作流引擎，这些多领域的工作让我快速成长，并积累了大量的宝贵经验。&lt;/p>
&lt;p>现在，我在西雅图甲骨文（Oracle）的云计算部门就职，职位是首席软件工程师，主要负责研发云基础设施的分布式工作流引擎。&lt;/p>
&lt;p>入行这十来年，从前端页面到后端服务，从大小网站到分布式系统，从数据分析处理到可视化，从设计开发到线上运维，我都参与过，并带领团队攻克了很多大的项目堡垒，也以全栈工程师的身份上线了不少核心业务产品。&lt;/p>
&lt;p>可以说，我是一名全栈工程的实践者，也是一名程序员综合发展的信奉者，还是一名工程师文化的鼓吹者，有一个建立了很长时间的独立博客&amp;quot;&lt;a href="https://www.raychase.net/">四火的唠叨&lt;/a>&amp;quot;。&lt;/p>
&lt;p>那提到全栈工程师，你可能第一时间会想到 &amp;ldquo;全能&amp;quot;&amp;ldquo;大神&amp;quot;这些词语，也可能听到过其他人对它或褒或贬的评价。那么，究竟该怎么恰如其分地认识这个角色呢？我想和你说说我的看法。&lt;/p>
&lt;p>&lt;strong>软件工程的范畴里，人类创造了大量的概念和术语，绝大多数都清晰而精确，但&amp;quot;全栈工程师&amp;quot;却是个反例&lt;/strong>。在互联网出现以前，甚至在客户端和服务端模式出现以前，大多数的程序员，就已经是一定意义上的&amp;quot;全栈&amp;quot;了，他们往往涉足硬件、软件，完成程序从开始到终结各个阶段的工作。&lt;/p>
&lt;p>千禧年之后，Web，特别是 Ajax 等前端技术迅猛发展，而技术的进步就自然而然地带来了分工，于是有人负责前端，有人负责后端，甚至划分得更细，此时能够做两头事情的人，才显得更加珍贵。因此，我认为 &lt;strong>Web 技术的发展和自然而然引发的分工才是全栈工程师出现的最重要的因素&lt;/strong>。&lt;/p>
&lt;p>2008 年，在 forge38 上面出现了一篇题目为&amp;rdquo;&lt;a href="http://web.archive.org/web/20101204221657/http://forge38.com/blog/2008/06/full-stack-web-developers/">Full Stack Web Developers&lt;/a>&amp;ldquo;的文章，被认为是最早提及这个概念的媒体之一。&lt;/p>
&lt;p>文中是这样说的：&lt;/p>
&lt;blockquote>
&lt;p>A full stack web developer is someone that does design, markup, styling, behavior, and programming.&lt;/p>
&lt;/blockquote>
&lt;p>大概意思就是说，一个全栈的 web 开发者，会负责设计、标记、样式、行为和编程这些全部的事情。&lt;/p>
&lt;p>虽然从现在的眼光看，这个概念的解释似乎有些古老而片面 ，可从上面的历史文字中足以看出，为什么当我们提及全栈，往往总是基于&amp;quot;Web&amp;rdquo;，而非其他领域了。&lt;/p>
&lt;p>到了今天，全栈工程师已经变成了一个有些被滥用的概念，不同人有着天差地别的理解。&lt;/p>
&lt;p>我认为，首先必须明确的是，&amp;ldquo;全栈&amp;quot;不是&amp;quot;全能&amp;rdquo;，当然，在这个标准下我们依然可以将全栈理解为&amp;quot;广义&amp;quot;的全栈和&amp;quot;狭义&amp;quot;的全栈。显然前者的包容性和不确定性过大，我觉得只有后者才有更实际的讨论价值，并且，&lt;strong>广泛的 Web 技术才是一名通常意义上的全栈工程师最该专注的核心内容&lt;/strong>，而此处的 Web 技术，包括网络、前端、后端 MVC、持久化技术等多个层次。&lt;/p>
&lt;p>那从成长角度看，为什么我说你应该成为全栈工程师呢？&lt;/p>
&lt;p>和其他软件工程师发展的路线相比，除了通用工程师的技能以外，我认为基于 Web 的全栈技术是一种非常适合用来进一步发展和修炼的技能树，和其它的技术类别比起来，它至少有下面这样几个明显的优势。&lt;/p>
&lt;h2 id="关于个人发展">关于个人发展&lt;/h2>
&lt;p>首先，互联网是全栈概念的诞生地，也是软件领域最激动人心的产品和技术的诞生地，这是传统软件所无法比拟的。这些互联网的全栈工程师，每天都在接收新的资讯，每天都&amp;quot;不得不&amp;quot;和这些全新的技术理念搏斗，他们拥有着和这些产品与技术最近距离访问、全面接触和深入研究的机会。你可能很难预测下一波互联网的技术浪潮什么时候到来，技术主角又是谁，但全栈技术是可以帮你打好基础，做好随时拥抱它的准备的。&lt;/p>
&lt;p>其次，可以掌握能够快速获得反馈的学习方法，这对于保持持续学习的动力和热情很有助益。比如说，几行 HTML 代码就可以马上看到效果，简单安装和配置，就可以搭建一个健壮的 Web 服务，对当前浏览器即时的标签、脚本、样式修改，立即就能看到变化。&lt;/p>
&lt;p>再次，全栈技术的学习之路上有很多纷繁精彩的&amp;quot;套路&amp;rdquo;，而它们可以应用在软件工程的其它领域。可以说，&lt;strong>全栈技术中，有太多能帮助程序员开启新世界大门的东西了&lt;/strong>，比如 JavaScript 的异步编程，比如各种数据、模板和逻辑的解耦和分层，再比如说持久层技术里面的读写模型分析。&lt;/p>
&lt;p>最后，必然是视野的拓展。工程师的成长过程中，在早、中期可以利用全栈技术拓宽视野，并养成思考的习惯。&lt;strong>最终也许我们需要&amp;quot;学得精&amp;quot;，但是一开始我们一定要&amp;quot;学得杂&amp;quot;&lt;/strong>。只有在广度上有足够的积累，足够的内容去比较，才能养成思考的习惯，拥有更全面地看待问题的视野。&lt;/p>
&lt;p>拿我自己来说，工作以来我花了很多时间去做一些不同领域的项目，比如我现在的工作是研发一个分布式工作流引擎，从 Web 全栈技术上学到的东西，是能够帮助我快速上手这些技术的。同时，理解它们的本质，也能拓宽分析和解决问题的思路。毕竟，在软件领域，技术都是相通的。&lt;/p>
&lt;h2 id="关于就业和创业">关于就业和创业&lt;/h2>
&lt;p>首先，全栈工程师本身就拥有多技能、多角色。团队非常欢迎这样的人，因为当一个人可以扮演多个人的角色，就减少了沟通和配合的损耗，提高了效率。出了问题，从客户端到服务端，对多个层面都有所了解的全栈工程师可以更高效地分析和定位问题。这个世界需要专家，但我觉得更需要通晓各个层面知识，能够快速解决问题的人。&lt;/p>
&lt;p>其次，全栈工程师是创业的最佳技术角色。有了创意和点子，全栈工程师就可以快速地开发原型，迅速实现第一个版本，并能马上提供优质的宣传推广和用户体验。不要小看这一点，在很多情况下，&lt;strong>全栈工程师不需要其它额外的协助，自己就可以很快地将想法变现&lt;/strong>。&lt;/p>
&lt;p>再次，全栈工程师拥有最多的就业机会。有朋友半开玩笑说，你知道世界上什么类型的应用最多见吗？网站！各式各样的网站，内部的管理系统、报表系统、论坛、博客，但无论是哪种类型，它们都是全栈工程师最熟悉的东西。你可能耳闻过著名的 &lt;a href="https://www.laurencegellert.com/2012/08/what-is-a-full-stack-developer/">Facebook 只招全栈工程师&lt;/a>这样听起来似乎有些&amp;quot;极端&amp;quot;的故事，可事实上，几乎所有的互联网大型公司，都会招聘大量的全栈工程师。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/f9/9e/f90b92c41ca6ecedc5d8af2224aa9f9e.jpeg" alt="">&lt;/p>
&lt;p>（上图来自 &lt;a href="https://blog.hackerrank.com/full-stack-developer/">HackerRank&lt;/a>，报告原引用于 HackerRank 2018 Developer Skills Report，在开发者评价自己角色的时候，最多的人投票给了&amp;quot;全栈开发者&amp;quot;。）&lt;/p>
&lt;p>最后，不妨考虑下未来的职业延伸。&lt;strong>有了全栈工程师的底子，未来面对软件行业进一步细化，选择其它细分职业时，会因为有了全面而扎实的基础而更有利。&lt;/strong>&lt;/p>
&lt;p>举例来说，假如你做过一段时间的前端程序员，那往往对用户交互设计是有一定的心得的，我有朋友就是从一个擅长前端的全栈程序员转行做了产品经理；而在 MVC 部分学习的分层和解耦经验，持久层部分积攒的那些对于一致性、可用性的理解，对于将来想投身于分布式系统设计开发的程序员朋友会很有帮助。&lt;/p>
&lt;p>我认为对于大多数程序员来说，全栈工程师这个职位对于自己的发展而言，是个非常好的进阶方向。而基于 Web 的全栈技术学习，充满必要性，无论你今后是否志在互联网，无论你的远期目标是在哪个软件领域。&lt;/p>
&lt;p>最后，我想认识一下你。你可以在留言区中做个自我介绍，说说你现在的工作、学习情况。或是说说你眼中的全栈工程师是怎样的？你认为应该具备怎样的特质，才能成为全栈工程师呢？欢迎你在留言区和我交流。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/11/8b/1181246bbd51ce348d5729696d1dc28b.jpg" alt="unpreview">&lt;/p></description></item><item><title>极客专栏: 00丨开篇词你为什么需要学习并发编程？</title><link>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/00%E4%B8%A8%E5%BC%80%E7%AF%87%E8%AF%8D%E4%BD%A0%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%AD%A6%E4%B9%A0%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</link><pubDate>Sun, 29 May 2022 00:00:00 +0000</pubDate><guid>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/00%E4%B8%A8%E5%BC%80%E7%AF%87%E8%AF%8D%E4%BD%A0%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%AD%A6%E4%B9%A0%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</guid><description>
&lt;p>你好，我是王宝令，资深架构师，目前从事电商架构的设计工作。从毕业到现在，我前前后后写了 15 年的程序，刚毕业的时候从事证券业务的开发，开发语言是 C/C++，之后从事 ERP 产品的研发，开发语言主要是 C# 和 Java，最近几年主要是从事 Java 开发平台和基础中间件的设计开发工作。&lt;/p>
&lt;p>还记得毕业后我接触的第一个项目是证券相关的，国外的同事用 C 语言写了一个内存数据库，代码写得极为简练优美，我当时怀着无比崇敬的心情把代码看了又看，看完感觉受益匪浅。不过兴奋之余，我也有些焦虑，因为其中一块并发相关的代码，我看得是云里雾里，总感觉自己没有悟透。&lt;/p>
&lt;p>我下意识地告诉自己说这块的知识积累还不够，所以要勤学苦练。你可知道，15 年前相关的学习资料并不多，我的师傅向我推荐了《操作系统原理》这本教材，他说：&amp;ldquo;并发编程最早的应用领域就是操作系统的实现，你把这本书看懂了，并发的问题自然就解决了。&amp;ldquo;但是理论和实践之间总是有鸿沟的，之后好多年，最让我感到无助的还是处理并发相关的问题。&lt;/p>
&lt;p>并发编程的掌握过程并不容易。我相信为了解决这个问题，你也听别人总结过并发编程的第一原则，那就是不要写并发程序。这个原则在我刚毕业的那几年曾经是行得通的，那个时候多核服务器还是一种奢侈品，系统的并发量也很低，借助数据库和类似 Tomcat 这种中间件，我们基本上不用写并发程序。或者说，并发问题基本上都被中间件和数据库解决了。&lt;/p>
&lt;p>&lt;strong>但是最近几年，并发编程已经慢慢成为一项必备技能。&lt;/strong>&lt;/p>
&lt;p>这主要是硬件的驱动以及国内互联网行业的飞速发展决定的，现在 64 核的服务器已经飞入寻常百姓家，大型互联网厂商的系统并发量轻松过百万，传统的中间件和数据库已经不能为我们遮风挡雨，反而成了瓶颈所在。&lt;/p>
&lt;p>于是，并发编程最近几年成为非常热门的领域，人才稀缺。但与此同时，关于并发编程的书籍也渐渐丰富起来了。所以当极客时间团队和我聊这个专栏的时候，我的第一个疑问就是目前市面上已经有很多这方面的图书了，而且很多都非常优秀，是否还有必要搞一个这样的专栏。&lt;/p>
&lt;p>但是深入想过之后，我坚定了写作的信心。这些年接触的大部分同学，都是工作几年后很多技术突飞猛进，却只有并发编程成为瓶颈，虽然并发相关的类库他们也熟悉，却总是写不出正确、高效的并发程序，原因在哪里？我发现很多人是因为某个地方有了盲点，忽略了一些细节，但恰恰是这些细节决定了程序的正确性和效率。&lt;/p>
&lt;p>而这个盲点有时候涉及对操作系统的理解，有时候又涉及一点硬件知识，非常复杂，如果要推荐相关图书，可能要推荐好几本，这就有点&amp;quot;大炮打蚊子&amp;quot;的感觉了，效率很差。同时图书更追求严谨性，却也因此失掉了形象性，所以阅读的过程也确实有点艰辛。&lt;/p>
&lt;p>&lt;strong>我想，如果能够把这些问题解决，那么做这个事情应该是有意义的。&lt;/strong>&lt;/p>
&lt;p>例如，Java 里 synchronized、wait()/notify() 相关的知识很琐碎，看懂难，会用更难。但实际上 synchronized、wait()、notify() 不过是操作系统领域里管程模型的一种实现而已，Java SDK 并发包里的条件变量 Condition 也是管程里的概念，synchronized、wait()/notify()、条件变量这些知识如果单独理解，自然是管中窥豹。但是如果站在管程这个理论模型的高度，你就会发现这些知识原来这么简单，同时用起来也就得心应手了。&lt;/p>
&lt;p>管程作为一种解决并发问题的模型，是继信号量模型之后的一项重大创新，它与信号量在逻辑上是等价的（可以用管程实现信号量，也可以用信号量实现管程），但是相比之下管程更易用。而且，很多编程语言都支持管程，搞懂管程，对学习其他很多语言的并发编程有很大帮助。然而，很多人急于学习 Java 并发编程技术，却忽略了技术背后的理论和模型，而理论和模型却往往比具体的技术更为重要。&lt;/p>
&lt;p>此外，Java 经过这些年的发展，Java SDK 并发包提供了非常丰富的功能，对于初学者来说可谓是眼花缭乱，好多人觉得无从下手。但是，Java SDK 并发包乃是并发大师 Doug Lea 出品，堪称经典，它内部一定是有章可循的。那它的章法在哪里呢？&lt;/p>
&lt;p>&lt;strong>其实并发编程可以总结为三个核心问题：分工、同步、互斥。&lt;/strong>&lt;/p>
&lt;p>所谓&lt;strong>分工&lt;/strong> 指的是如何高效地拆解任务并分配给线程，而&lt;strong>同步&lt;/strong> 指的是线程之间如何协作，&lt;strong>互斥&lt;/strong>则是保证同一时刻只允许一个线程访问共享资源。Java SDK 并发包很大部分内容都是按照这三个维度组织的，例如 Fork/Join 框架就是一种分工模式，CountDownLatch 就是一种典型的同步方式，而可重入锁则是一种互斥手段。&lt;/p>
&lt;p>当把并发编程核心的问题搞清楚，再回过头来看 Java SDK 并发包，你会感觉豁然开朗，它不过是针对并发问题开发出来的工具而已，此时的 SDK 并发包可以任你&amp;quot;盘&amp;quot;了。&lt;/p>
&lt;p>而且，这三个核心问题是跨语言的，你如果要学习其他语言的并发编程类库，完全可以顺着这三个问题按图索骥。Java SDK 并发包其余的一部分则是并发容器和原子类，这些比较容易理解，属于辅助工具，其他语言里基本都能找到对应的。&lt;/p>
&lt;p>&lt;strong>所以，你说并发编程难学吗？&lt;/strong>&lt;/p>
&lt;p>首先，难是肯定的。因为这其中涉及操作系统、CPU、内存等等多方面的知识，如果你缺少某一块，那理解起来自然困难。其次，难不难学也可能因人而异，就我的经验来看，很多人在学习并发编程的时候，总是喜欢从点出发，希望能从点里找到规律或者本质，最后却把自己绕晕了。&lt;/p>
&lt;p>我前面说过，并发编程并不是 Java 特有的语言特性，它是一个通用且早已成熟的领域。Java 只是根据自身情况做了实现罢了，当你理解或学习并发编程的时候，如果能够站在较高层面，系统且有体系地思考问题，那就会容易很多。&lt;/p>
&lt;p>所以，我希望这个专栏更多地谈及问题背后的本质、问题的起源，同时站在理论、模型的角度讲解 Java 并发，让你的知识更成体系，融会贯通。最终让你能够得心应手地解决各种并发难题，同时将这些知识用于其他编程语言，让你的一分辛劳三分收获。&lt;/p>
&lt;p>下面就是这个专栏的目录，你可以快速了解下整个专栏的知识结构体系。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/d5/c0/d513beec13a20d5e858257313b3605c0.jpg" alt="">&lt;/p>
&lt;p>&lt;strong>当然，我们要坚持下去，不能三天打鱼两天晒网，因为滴水穿石非一日之功。&lt;/strong>&lt;/p>
&lt;p>很多人都说学习是反人性的，开始容易，但是长久的坚持却很难。这个我也认同，我面试的时候，就经常问候选人一个问题：&amp;ldquo;工作中，有没有一件事你自己坚持了很久，并且从中获益？&amp;ldquo;如果候选人能够回答出来，那会是整个面试的加分项，因为我觉得，坚持真是一个可贵的品质，一件事情，有的人三分热度，而有的人，一做就能做一年，或者更久。你放长到时间的维度里看，这两种人，最后的成就绝对是指数级的差距。&lt;/p>
&lt;p>我希望你能和我坚持下来，我们一起学习，一起交流，遇到问题不是简单地抱怨和逃避，而是努力探寻答案与解决方法。这一次，就让我们一起来坚持探索并发编程的奥秘，体会探索知识的乐趣。今天的文章是开篇词，我们的主菜很快就来，如果可以的话，还请在留言区中做个自我介绍，和我聊聊你目前的工作、学习情况，以及你在并发编程方面的学习痛点，方便我在后面针对性地给你讲解，这样，我们可以彼此了解。&lt;/p>
&lt;p>最后，感谢你对我的信任，我定会努力实现完美交付。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/cf/aa/cf393cd748a4f0e6451807c4b61843aa.jpg" alt="">&lt;/p></description></item><item><title>极客专栏: 《数据结构与算法之美》学习指导手册</title><link>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%AF%BC%E6%89%8B%E5%86%8C/</link><pubDate>Fri, 27 May 2022 00:00:00 +0000</pubDate><guid>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%AF%BC%E6%89%8B%E5%86%8C/</guid><description>
&lt;p>你好，我是王争。&lt;/p>
&lt;p>在设计专栏内容的时候，为了兼顾不同基础的同学，我在内容上做到了难易结合，既有简单的数组、链表、栈、队列这些基础内容，也有红黑树、BM、KMP 这些难度较大的算法。但是，对于初学者来说，一下子面对这么多知识，可能还是比较懵。&lt;/p>
&lt;p>我觉得，对于初学者来说，先把最简单、最基础、最重要的知识点掌握好，再去研究难度较高、更加高级的知识点，这样由易到难、循序渐进的学习路径，无疑是最合理的。&lt;/p>
&lt;p>基于这个路径，我对专栏内容，重新做了一次梳理，希望给你一份具体、明确、有效的学习指导。我会写清楚&lt;strong>每个知识点的难易程度、需要你掌握到什么程度、具体如何来学习&lt;/strong>。&lt;/p>
&lt;p>如果你是数据结构和算法的初学者，或者你觉得自己的基础比较薄弱，希望这份学习指导，能够让你学起来能更加有的放矢，能把精力、时间花在刀刃上，获得更好的学习效果。&lt;/p>
&lt;p>下面，我先给出一个大致的学习路线。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/54/48/54163f16e152f71b8f91d3fba652cf48.jpg" alt="">
（建议保存后查看大图）&lt;/p>
&lt;p>现在，针对每个知识点，我再给你逐一解释一下。我这里先说明一下，下面标记的难易程度、是否重点、掌握程度，都只是针对初学者来说的，如果你已经有一定基础，可以根据自己的情况，安排自己的学习。&lt;/p>
&lt;ol>
&lt;li>复杂度分析&lt;/li>
&lt;/ol>
&lt;hr>
&lt;p>尽管在专栏中，我只用了两节课的内容，来讲复杂度分析这个知识点。但是，我想说的是，它真的非常重要。你必须要牢牢掌握这两节，基本上要做到，简单代码能很快分析出时间、空间复杂度；对于复杂点的代码，比如递归代码，你也要掌握专栏中讲到的两种分析方法：递推公式和递归树。&lt;/p>
&lt;p>对于初学者来说，光看入门篇的两节复杂度分析文章，可能还不足以完全掌握复杂度分析。不过，在后续讲解每种数据结构和算法的时候，我都有详细分析它们的时间、空间复杂度。所以，你可以在学习专栏中其他章节的时候，再不停地、有意识地去训练自己的复杂度分析能力。&lt;/p>
&lt;p>难易程度：Medium&lt;/p>
&lt;p>是否重点：10 分&lt;/p>
&lt;p>掌握程度：在不看我的分析的情况下，能自行分析专栏中大部分数据结构和算法的时间、空间复杂度&lt;/p>
&lt;ol start="2">
&lt;li>数组、栈、队列&lt;/li>
&lt;/ol>
&lt;hr>
&lt;p>这一部分内容非常简单，初学者学起来也不会很难。但是，作为基础的数据结构，数组、栈、队列，是后续很多复杂数据结构和算法的基础，所以，这些内容你一定要掌握。&lt;/p>
&lt;p>难易程度：Easy&lt;/p>
&lt;p>是否重点：8 分&lt;/p>
&lt;p>掌握程度：能自己实现动态数组、栈、队列&lt;/p>
&lt;ol start="3">
&lt;li>链表&lt;/li>
&lt;/ol>
&lt;hr>
&lt;p>链表非常重要！虽然理论内容不多，但链表上的操作却很复杂。所以，面试中经常会考察，你一定要掌握。而且，我这里说&amp;quot;掌握&amp;quot;不只是能看懂专栏中的内容，还能将专栏中提到的经典链表题目，比如链表反转、求中间结点等，轻松无 bug 地实现出来。&lt;/p>
&lt;p>难易程度：Medium&lt;/p>
&lt;p>是否重点：9 分&lt;/p>
&lt;p>掌握程度：能轻松写出经典链表题目代码&lt;/p>
&lt;ol start="4">
&lt;li>递归&lt;/li>
&lt;/ol>
&lt;hr>
&lt;p>对于初学者来说，递归代码非常难掌握，不管是读起来，还是写起来。但是，这道坎你必须要跨过，跨不过就不能算是入门数据结构和算法。我们后面讲到的很多数据结构和算法的代码实现，都要用到递归。&lt;/p>
&lt;p>递归相关的理论知识也不多，所以还是要多练。你可以先在网上找些简单的题目练手，比如斐波那契数列、求阶乘等，然后再慢慢过渡到更加有难度的，比如归并排序、快速排序、二叉树的遍历、求高度，最后是回溯八皇后、背包问题等。&lt;/p>
&lt;p>难易程度：Hard&lt;/p>
&lt;p>是否重点：10 分&lt;/p>
&lt;p>掌握程度：轻松写出二叉树遍历、八皇后、背包问题、DFS 的递归代码&lt;/p>
&lt;ol start="5">
&lt;li>排序、二分查找&lt;/li>
&lt;/ol>
&lt;hr>
&lt;p>这一部分并不难，你只需要能看懂我专栏里的内容即可。&lt;/p>
&lt;p>难易程度：Easy&lt;/p>
&lt;p>是否重点：7 分&lt;/p>
&lt;p>掌握程度：能自己把各种排序算法、二分查找及其变体代码写一遍就可以了&lt;/p>
&lt;ol start="6">
&lt;li>跳表&lt;/li>
&lt;/ol>
&lt;hr>
&lt;p>对于初学者来说，并不需要非得掌握跳表，所以，如果没有精力，这一章节可以先跳过。&lt;/p>
&lt;p>难易程度：Medium&lt;/p>
&lt;p>是否重点：6 分&lt;/p>
&lt;p>掌握程度：初学者可以先跳过。如果感兴趣，看懂专栏内容即可，不需要掌握代码实现&lt;/p>
&lt;ol start="7">
&lt;li>散列表&lt;/li>
&lt;/ol>
&lt;hr>
&lt;p>尽管散列表的内容我讲了很多，有三节课。但是，总体上来讲，这块内容理解起来并不难。但是，作为一种应用非常广泛的数据结构，你还是要掌握牢固散列表。&lt;/p>
&lt;p>难易程度：Medium&lt;/p>
&lt;p>是否重点：8 分&lt;/p>
&lt;p>掌握程度：对于初学者来说，自己能代码实现一个拉链法解决冲突的散列表即可&lt;/p>
&lt;ol start="8">
&lt;li>哈希算法&lt;/li>
&lt;/ol>
&lt;hr>
&lt;p>这部分纯粹是为了开拓思路，初学者可以略过。&lt;/p>
&lt;p>难易程度：Easy&lt;/p>
&lt;p>是否重点：3 分&lt;/p>
&lt;p>掌握程度：可以暂时不看&lt;/p>
&lt;ol start="9">
&lt;li>二叉树&lt;/li>
&lt;/ol>
&lt;hr>
&lt;p>这一部分非常重要！二叉树在面试中经常会被考到，所以要重点掌握。但是我这里说的二叉树，并不包含专栏中红黑树的内容。红黑树我们待会再讲。&lt;/p>
&lt;p>难易程度：Medium&lt;/p>
&lt;p>是否重点：9 分&lt;/p>
&lt;p>掌握程度：能代码实现二叉树的三种遍历算法、按层遍历、求高度等经典二叉树题目&lt;/p>
&lt;ol start="10">
&lt;li>红黑树&lt;/li>
&lt;/ol>
&lt;hr>
&lt;p>对于初学者来说，这一节课完全可以不看。&lt;/p>
&lt;p>难易程度：Hard&lt;/p>
&lt;p>是否重点：3 分&lt;/p>
&lt;p>掌握程度：初学者不用把时间浪费在上面&lt;/p>
&lt;ol start="11">
&lt;li>B+ 树&lt;/li>
&lt;/ol>
&lt;hr>
&lt;p>虽然 B+ 树也算是比较高级的一种数据结构了，但是对初学者来说，也不是重点。有时候面试的时候还是会问的，所以这一部分内容，你能看懂专栏里的讲解就可以了。&lt;/p>
&lt;p>难易程度：Medium&lt;/p>
&lt;p>是否重点：5 分&lt;/p>
&lt;p>掌握程度：可看可不看&lt;/p>
&lt;ol start="12">
&lt;li>堆与堆排序&lt;/li>
&lt;/ol>
&lt;hr>
&lt;p>这一部分内容不是很难，初学者也是要掌握的。&lt;/p>
&lt;p>难易程度：Medium&lt;/p>
&lt;p>是否重点：8 分&lt;/p>
&lt;p>掌握程度：能代码实现堆、堆排序，并且掌握堆的三种应用（优先级队列、Top k、中位数）&lt;/p>
&lt;ol start="13">
&lt;li>图的表示&lt;/li>
&lt;/ol>
&lt;hr>
&lt;p>图的内容很多，但是初学者不需要掌握那么多。一般 BAT 等大厂面试，不怎么会面试有关图的内容，因为面试官可能也对这块不会很熟悉哈：）。但是，最基本图的概念、表示方法还是要掌握的。&lt;/p>
&lt;p>难易程度：Easy&lt;/p>
&lt;p>是否重点：8 分&lt;/p>
&lt;p>掌握程度：理解图的三种表示方法（邻接矩阵、邻接表、逆邻接表），能自己代码实现&lt;/p>
&lt;ol start="14">
&lt;li>深度广度优先搜索&lt;/li>
&lt;/ol>
&lt;hr>
&lt;p>这算是图上最基础的遍历或者说是搜索算法了，所以还是要掌握一下。这两种算法的原理都不难哈，但是代码实现并不简单，一个用到了队列，另一个用到了递归。对于初学者来说，看懂这两个代码实现就是一个挑战！可以等到其他更重要的内容都掌握之后，再来挑战，也是可以的。&lt;/p>
&lt;p>难易程度：Hard&lt;/p>
&lt;p>是否重点：8 分&lt;/p>
&lt;p>掌握程度：能代码实现广度优先、深度优先搜索算法&lt;/p>
&lt;ol start="15">
&lt;li>拓扑排序、最短路径、A* 算法&lt;/li>
&lt;/ol>
&lt;hr>
&lt;p>这几个算法稍微高级点。如果你能轻松实现深度、广度优先搜索，那看懂这三个算法不成问题。不过，这三种算法不是重点。面试不会考的。&lt;/p>
&lt;p>难易程度：Hard&lt;/p>
&lt;p>是否重点：5 分&lt;/p>
&lt;p>掌握程度：有时间再看，暂时可以不看&lt;/p>
&lt;ol start="16">
&lt;li>字符串匹配（BF、RK）&lt;/li>
&lt;/ol>
&lt;hr>
&lt;p>BF 非常简单，RK 稍微复杂点，但都不难。这个最好还是掌握下。&lt;/p>
&lt;p>难易程度：Easy&lt;/p>
&lt;p>是否重点：7 分&lt;/p>
&lt;p>掌握程度：能实践 BF 算法，能看懂 RK 算法&lt;/p>
&lt;ol start="17">
&lt;li>字符串匹配（BM、KMP、AC 自动机）&lt;/li>
&lt;/ol>
&lt;hr>
&lt;p>这三个算法都挺难的，对于算法有一定基础的人来说，看懂也不容易。所以，对于初学者来说，千万别浪费时间在这上面。即便有余力，看懂就好了，不用非得能自己实现。&lt;/p>
&lt;p>难易程度：Hard&lt;/p>
&lt;p>是否重点：3 分&lt;/p>
&lt;p>掌握程度：初学者不用把时间浪费在上面&lt;/p>
&lt;ol start="18">
&lt;li>字符串匹配（Trie）&lt;/li>
&lt;/ol>
&lt;hr>
&lt;p>这个还是要能看懂，不过不需要能代码实现。有些面试官喜欢考这个东西，主要是结合应用场景来考察，只是看你知不知道要用 Trie 树这个东西。&lt;/p>
&lt;p>难易程度：Medium&lt;/p>
&lt;p>是否重点：7 分&lt;/p>
&lt;p>掌握程度：能看懂，知道特点、应用场景即可，不要求代码实现&lt;/p>
&lt;ol start="19">
&lt;li>位图&lt;/li>
&lt;/ol>
&lt;hr>
&lt;p>位图不是重点，如果有余力最好掌握一下。&lt;/p>
&lt;p>难易程度：Easy&lt;/p>
&lt;p>是否重点：6 分&lt;/p>
&lt;p>掌握程度：看懂即可，能自己实现一个位图结构最好&lt;/p>
&lt;ol start="20">
&lt;li>四种算法思想&lt;/li>
&lt;/ol>
&lt;hr>
&lt;p>这个是重点，也是难点。贪心、分治、回溯、动态规划，每一个都不简单，其中动态规划又是最难、最烧脑的。要应付 FLAG 这样公司的面试，必须拿下这块内容。但是呢，学习要循序渐进，这块能内容的学习可以放到最后，做个长时间的学习计划来攻克。&lt;/p>
&lt;p>这块内容理论的东西不多，要想真的掌握，还是要大量刷题。&lt;/p>
&lt;p>难易程度：Hard&lt;/p>
&lt;p>是否重点：10 分&lt;/p>
&lt;p>掌握程度：可以放到最后，但是一定要掌握！做到能实现 Leetcode 上 Medium 难度的题目&lt;/p>
&lt;hr>
&lt;p>学而时习之，专栏虽然已经结束，但是学习的同学和留言依旧源源不断。希望这份学习指导手册对你有帮助，也欢迎你继续给我留言，和大家一起交流、学习、进步。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/8e/d3/8e603e3d795fc0ab2698f6f5eabf14d3.jpg" alt="">&lt;/p></description></item><item><title>极客专栏: 00丨一键直达丨法律专栏“食用”指南</title><link>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E7%99%BD%E8%AF%9D%E6%B3%95%E5%BE%8B/00%E4%B8%A8%E4%B8%80%E9%94%AE%E7%9B%B4%E8%BE%BE%E4%B8%A8%E6%B3%95%E5%BE%8B%E4%B8%93%E6%A0%8F%E9%A3%9F%E7%94%A8%E6%8C%87%E5%8D%97/</link><pubDate>Tue, 07 Jun 2022 00:00:00 +0000</pubDate><guid>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E7%99%BD%E8%AF%9D%E6%B3%95%E5%BE%8B/00%E4%B8%A8%E4%B8%80%E9%94%AE%E7%9B%B4%E8%BE%BE%E4%B8%A8%E6%B3%95%E5%BE%8B%E4%B8%93%E6%A0%8F%E9%A3%9F%E7%94%A8%E6%8C%87%E5%8D%97/</guid><description>
&lt;p>你好，很荣幸我们能够一起走过三个多月的时间，我是这个专栏的编辑 Lisa。&lt;/p>
&lt;p>在法律专栏中，周律师特别针对职场、技术、生活三大领域的法律问题以及认知常识，进行了细致而通俗的讲解。不过，这些文章，并非严格按照领域次序更新，所以在专栏最后，我特别整理了各领域法律文章的直达目录，方便你来回顾。&lt;/p>
&lt;p>点击相关领域下的标题，直达你最需要了解的那篇。&lt;/p>
&lt;h2 id="认知篇">认知篇&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>&lt;a href="https://time.geekbang.org/column/article/42553">&amp;ldquo;老周，我想知道&amp;rdquo; | 常见法律认知盲区（一）&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://time.geekbang.org/column/article/76454">&amp;ldquo;老周，我想知道&amp;rdquo; | 律师就在你身边（二）&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://time.geekbang.org/column/article/77460">&amp;ldquo;老周，我想知道&amp;rdquo; | 律师就在你身边（三）&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://time.geekbang.org/column/article/79422">&amp;ldquo;老周，我想知道&amp;rdquo; | 律师就在你身边（四）&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h2 id="职场篇">职场篇&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>&lt;a href="https://time.geekbang.org/column/article/42724">创业未捷老板跑，社保工资哪里讨？&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://time.geekbang.org/column/article/64970">保密还是卖身，霸王条款怎么看？&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://time.geekbang.org/column/article/70867">又见猝死！工&amp;quot;殇&amp;quot;究竟是不是工伤？&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://time.geekbang.org/column/article/67836">合同在手欠款难收，报警有用吗？&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://time.geekbang.org/column/article/67842">编造流言蹭热度？看守所里降温度&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://time.geekbang.org/column/article/69879">致创业：谁动了我的股权？&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://time.geekbang.org/column/article/71474">致创业：期权的前世今生&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://time.geekbang.org/column/article/72839">抄袭、盗图为什么做不得？&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://time.geekbang.org/column/article/73207">加班、工资、休假，你知道多少？&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://time.geekbang.org/column/article/74280">受贿原来这么&amp;quot;容易&amp;quot;&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://time.geekbang.org/column/article/71821">裁员面前，你能做的还有什么？&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h2 id="技术篇">技术篇&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>&lt;a href="https://time.geekbang.org/column/article/44260">今天你用 VPN 了吗？&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://time.geekbang.org/column/article/67379">漏洞在眼前，可以悄悄破解吗？&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://time.geekbang.org/column/article/68668">&amp;ldquo;爬虫&amp;quot;真的合法吗？&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://time.geekbang.org/column/article/69697">技术做宣传竟是非法集资？&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://time.geekbang.org/column/article/79140">&amp;ldquo;网络诈骗&amp;quot;真的离你很远吗？&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://time.geekbang.org/column/article/70578">黄色网站？不仅仅是&amp;quot;黄色&amp;quot;而已&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://time.geekbang.org/column/article/73856">是谁修改了我的积分资产？&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://time.geekbang.org/column/article/77144">伪基站是你的避风湾吗？&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://time.geekbang.org/column/article/74778">外挂真能&amp;quot;大吉大利&amp;quot;吗？&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://time.geekbang.org/column/article/75673">如何看待&amp;quot;从删库到跑路&amp;rdquo;？&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h2 id="生活篇">生活篇&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>&lt;a href="https://time.geekbang.org/column/article/42676">智斗中介：&amp;ldquo;北上广&amp;quot;租房图鉴&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://time.geekbang.org/column/article/64417">买买买！买房的&amp;quot;避坑&amp;quot;指南&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://time.geekbang.org/column/article/65208">闪婚又闪离，彩礼怎么理？&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://time.geekbang.org/column/article/67977">离婚还想和平？你要这么做&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://time.geekbang.org/column/article/70217">骗术升级？假结婚、假离婚的那些事儿&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://time.geekbang.org/column/article/69350">遗产继承的爱恨情仇&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://time.geekbang.org/column/article/71169">孩子学校受伤，到底谁的&amp;quot;锅&amp;rdquo;？&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://time.geekbang.org/column/article/72315">如何让欠债还钱真正&amp;quot;天经地义&amp;rdquo;？&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://time.geekbang.org/column/article/73518">从透支到盗刷：人人须知的银行卡纠纷&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://time.geekbang.org/column/article/75249">远离&amp;quot;套路贷&amp;quot;的套路大全&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://time.geekbang.org/column/article/76196">老人倒地，&amp;ldquo;扶&amp;quot;&amp;ldquo;不服&amp;rdquo;？&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://time.geekbang.org/column/article/75815">危险！酒驾为什么被罚那么重？&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://time.geekbang.org/column/article/76848">&amp;ldquo;能动手就别吵吵&amp;rdquo;，代价你真的知道吗？&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://time.geekbang.org/column/article/77808">发生交通事故，如何处理？&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://time.geekbang.org/column/article/78459">婚姻家庭综合法宝&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://time.geekbang.org/column/article/78014">交通事故综合法宝&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://time.geekbang.org/column/article/78784">买卖房屋综合法宝&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/cc/ff/cc229a6309f93017826a07452f3250ff.jpg" alt="">&lt;/p></description></item><item><title>极客专栏: 00丨学习路径丨怎样成为一名优秀的全栈工程师？</title><link>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E5%85%A8%E6%A0%88%E5%B7%A5%E7%A8%8B%E5%B8%88%E4%BF%AE%E7%82%BC%E6%8C%87%E5%8D%97/00%E4%B8%A8%E5%AD%A6%E4%B9%A0%E8%B7%AF%E5%BE%84%E4%B8%A8%E6%80%8E%E6%A0%B7%E6%88%90%E4%B8%BA%E4%B8%80%E5%90%8D%E4%BC%98%E7%A7%80%E7%9A%84%E5%85%A8%E6%A0%88%E5%B7%A5%E7%A8%8B%E5%B8%88/</link><pubDate>Tue, 07 Jun 2022 00:00:00 +0000</pubDate><guid>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E5%85%A8%E6%A0%88%E5%B7%A5%E7%A8%8B%E5%B8%88%E4%BF%AE%E7%82%BC%E6%8C%87%E5%8D%97/00%E4%B8%A8%E5%AD%A6%E4%B9%A0%E8%B7%AF%E5%BE%84%E4%B8%A8%E6%80%8E%E6%A0%B7%E6%88%90%E4%B8%BA%E4%B8%80%E5%90%8D%E4%BC%98%E7%A7%80%E7%9A%84%E5%85%A8%E6%A0%88%E5%B7%A5%E7%A8%8B%E5%B8%88/</guid><description>
&lt;p>你好，我是四火。&lt;/p>
&lt;p>每一项综合技术都有自己的特点，基于 Web 的全栈技术也不例外。它五花八门，涉及面广，同类技术多，技术迭代迅猛，技术资料新等等，就如同下山的猛虎，成为了很多程序员朋友迈向全栈大门的一道阻碍。经常听到这样的抱怨：&lt;/p>
&lt;blockquote>
&lt;p>想学 Web 全栈技术，期待能独立交付产品，但真的很迷茫。&lt;br>
具体某项技术还好说，可全栈包含了那么多技术，眼都要看花了。&lt;br>
我该从哪里开始，遵循哪些原则，学习哪些技术？&lt;/p>
&lt;/blockquote>
&lt;p>今天，专栏伊始，徙木为信，言能践行，就让我带你一起打破这道障碍。想要入门或者正在进阶的你，期待这个专栏能让你产生不一样的理解，收获独特的方法，在全栈技术的道路上迈上一个更高的台阶。&lt;/p>
&lt;h2 id="怎样修炼全栈技术">怎样修炼全栈技术？&lt;/h2>
&lt;p>首先，我想说的是，&lt;strong>先成为合格的工程师，再谈全栈&lt;/strong>。&lt;/p>
&lt;p>就像相声演员的说学逗唱一样，工程师也有自己的必修课，比如数据结构和算法，可以说没有基础代码能力时一切都无从谈起。对于任何一个领域的软件工程师而言，它们都是基础，怎样强调其重要性都不为过。并且无论你是刚入行的程序员，还是打拼了几十年的架构师，标准都是一样的。&lt;/p>
&lt;p>就拿我工作过的 Amazon 和 Oracle 来说，我们面试的时候，虽然对技术级别高的程序员候选人，会更多地考察基于经验和思路的系统设计等方面，但代码层面的要求，包括数据结构和算法，对于不同级别的工程师来说 ，基本是一样的。&lt;/p>
&lt;p>请注意，这里的要求不只是能够写代码，而是要在面试现场，在有限的时间内，在白板上写代码。而在这个专栏里，我不讲解这些最基础的知识，但并不代表它们不重要。&lt;/p>
&lt;p>对于进阶的工程师来说，英文能力是突破天花板的一个必选项。我觉得英文是所有进阶的软件工程师应当强化的能力，对全栈工程师来说更甚。因为基于 Web 的全栈技术迭代很快，新的技术资料一般都是英文的，英文能力，尤其是英文的阅读能力会很大程度地影响知识获取的速度。&lt;/p>
&lt;p>其次，&lt;strong>在获取知识的基础上思考，尤其是从比较中思考&lt;/strong>。&lt;/p>
&lt;p>思考，我认为是一个软件工程师所有习惯中最重要的一项。我们在实际工作中需要解决各种各样不可预料的问题，缺乏思考的人只会用自己所知道的技术生硬地往上套，而不去考虑是否适合问题本身，不去分析和比对不同解决方法的优劣。&lt;strong>对于全栈技术学习而言，由于技术种类多，同类技术多，基于比较的思考就显得更为重要&lt;/strong>。但在这方面，我认为入门和进阶的工程师应当有所区别：&lt;/p>
&lt;ul>
&lt;li>如果你在这方面入门不久，那么我建议你还是以知识性学习为主，先建立概念，了解全局。在选择要学习的技术时，要找那些经典的、使用的人多，以及接受度高的技术。在此基础上，尝试去思考这些技术的特点，为什么要这样做，好处和坏处各是什么。了解背景，即在所介绍的技术出现以前，程序员都是怎样做的，比较一下二者的区别是什么，或者说，新技术，带来了什么。&lt;/li>
&lt;li>如果你是这方面的进阶工程师，那么&amp;quot;思考&amp;quot;的比重需要更高。全栈的技术太多太杂，不思考而以知识堆叠的方式记忆，是根本学不过来的。因此需要结合自身经验，尤其是针对同类的不同技术，要不断地去权衡，并强化自己的思考习惯&amp;mdash;&amp;mdash;针对学习材料，哪些观点是自己不同意的，哪些内容是自己需要补充的，哪些部分是自己需要延伸学习一下的。&lt;/li>
&lt;/ul>
&lt;p>通过耐心地思考和比较，知识积累能够逐渐形成体系，而它，是帮助你融会贯通和保证记忆的最佳方法。请不要在开始时担心这一点，只有具备一定量的积累才能自然而然地孕育出体系来。&lt;/p>
&lt;p>最后，&lt;strong>请不要忽视实践的力量&lt;/strong>。&lt;/p>
&lt;p>对于感兴趣的内容，请打开浏览器，打开命令行，打开 IDE，使用 Google 去搜索，把软件包下载下来，照着学习材料中的例子做一下，按着自己的理解试验一下。&lt;/p>
&lt;p>这样的过程听起来很简单，却是能让你形成深刻印象的捷径。有时候你可能对于内容表述不理解，可动手操作一下，往往就突然领悟了。毕竟，最终我们的能力都要落到关于程序代码的实践上去。&lt;/p>
&lt;h2 id="专栏内容是怎样设计的">专栏内容是怎样设计的？&lt;/h2>
&lt;p>说到专栏，特别是关于内容定位、广度和深度，我必须要做一个说明。这个说明于我们彼此都非常重要，它能够保证你我对专栏文章持有一个正确的预期。&lt;/p>
&lt;p>我希望这个专栏的主要目的是介绍原理、分享认识、探讨观点、串联知识，并引发思考，带给你进一步学习和实践的机会，而不是完全一步一步教导具体怎么做。因此，这个专栏最直接的目标不是希望你了解所有的细节，或者一下子精通其中的某一项技术。&lt;/p>
&lt;p>比如，我不会具体而全面地讲解 Spring MVC 怎么配置，Tomcat 怎么搭建，而是希望能突出某几项有代表性的技术特性来介绍&amp;mdash;&amp;mdash;它们为什么被创建出来，它们的价值在哪里，都有什么优劣，并在整体上着眼于全局，对基于 Web 的全栈技术有一个认识和把握。如果你初涉 Web 全栈技术不久，我更希望你能在阅读学习之后感慨，哇～居然有这么多有意思的技术，技术还能这样玩！&lt;/p>
&lt;p>即便没有这个专栏，我相信你也一定可以学习自己感兴趣的全栈技术，但是，这个专栏可以帮助你开拓眼界，将这些知识点逐项整理并系统化，帮助你养成在学习实践中思考的良好习惯。先知道&amp;quot;有什么&amp;quot;，才知道&amp;quot;学什么&amp;quot;，最后才能具体去学习，虽然具体的学习往往是没有捷径的，但是&amp;quot;有什么&amp;quot;和&amp;quot;学什么&amp;quot;却可以充分借由他人经验。&lt;/p>
&lt;p>再进一步说说内容广度和深度的问题。&lt;/p>
&lt;ul>
&lt;li>**内容广度：我会选择每个核心领域的代表性技术来介绍。**全栈的技术集合就像一个大观园，每一个子领域，技术往往都非常丰富，因此我们在学习它们的的时候，代表性技术的挑选尤为重要。专栏中每一讲涉及的技术，都是我精心比较后挑选出来的，它们典型、常用，而且深刻，专注于不同的问题领域，在全栈体系中有非常强的代表性，很适合拿来和同类技术做比较。&lt;/li>
&lt;li>**内容深度：我会把深度控制在合适的位置，让入门到进阶的工程师都有收获。**如果你刚刚入门，你可以看得懂大部分内容，并产生兴趣、建立概念；如果你处于进阶阶段，有的内容可能之前有了解过，但学习以后会有新的认识，或者是能把已经掌握的知识点串联起来。同时，请尽可能不要略过总结思考之后的选修课堂和扩展阅读，它们是可以帮助你快速提升的。&lt;/li>
&lt;/ul>
&lt;p>具体内容上，专栏包含网络协议和 Web 接口，MVC 架构相关，前端技术，持久层技术和最佳实践等几大章，这些内容会覆盖到基于 Web 的全栈技术最核心的部分。最后还有一章是综合性、自恰性强的专题，比如网站的性能优化、分页技术等。&lt;/p>
&lt;p>这里再来个小提示。在文章中，我经常会提到一些工具，也会谈到一些关键的命令执行和配置过程，但具体到某些工具的安装，部分我会给出网址，还有一部分工具则是可以使用常规的包管理工具下载安装，比如 macOS 下的 Homebrew，比如 Ubuntu 的 apt-get。通常情况下，请尽量使用 *nix（包括 Linux 和 MacOS） 而不是 Windows。&lt;/p>
&lt;p>最后，我想说每个全栈工程师的学习路径都是独特的，全栈和许多其它软件领域的技术一样，五花八门，日新月异，因此并不好学。我想很少有职业和程序员一样，需要持续、广泛地学习。有诸多品质在学习的过程中都起着至关重要的作用，但是我认为，恒心的作用尤为突出。&lt;/p>
&lt;p>我不想提著名的&amp;quot;一万小时理论&amp;quot;，但这个过程也绝不会一帆风顺，特别是在这个专栏的学习过程中，如果你有困惑、茫然，甚至是沮丧，欢迎你和我聊一聊，一起想想办法，让我们把全栈技术学习这件意义非凡的事情坚持下去。&lt;/p>
&lt;p>谈到这儿，我很想听听你的想法，进而有针对性地为你讲解，更好地帮助你进阶。请来留言区和我讨论吧：&lt;/p>
&lt;ul>
&lt;li>对于全栈技术的学习，和其它技术相比，你觉得有什么样的特点，学习它们最需要做到什么？&lt;/li>
&lt;li>对于专栏的内容设计，你最想听关于全栈技术哪一部分的知识讲解呢？&lt;/li>
&lt;/ul>
&lt;p>现在，就让我们正式开始全栈之旅吧！而故事，就从你输入网址、按下回车的那一瞬间开始&amp;hellip;&amp;hellip;&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/11/8b/1181246bbd51ce348d5729696d1dc28b.jpg" alt="unpreview">&lt;/p></description></item><item><title>极客专栏: 00丨开篇词丨你写的每一行代码，都是你的名片</title><link>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E4%BB%A3%E7%A0%81%E7%B2%BE%E8%BF%9B%E4%B9%8B%E8%B7%AF/00%E4%B8%A8%E5%BC%80%E7%AF%87%E8%AF%8D%E4%B8%A8%E4%BD%A0%E5%86%99%E7%9A%84%E6%AF%8F%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%E9%83%BD%E6%98%AF%E4%BD%A0%E7%9A%84%E5%90%8D%E7%89%87/</link><pubDate>Tue, 07 Jun 2022 00:00:00 +0000</pubDate><guid>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E4%BB%A3%E7%A0%81%E7%B2%BE%E8%BF%9B%E4%B9%8B%E8%B7%AF/00%E4%B8%A8%E5%BC%80%E7%AF%87%E8%AF%8D%E4%B8%A8%E4%BD%A0%E5%86%99%E7%9A%84%E6%AF%8F%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%E9%83%BD%E6%98%AF%E4%BD%A0%E7%9A%84%E5%90%8D%E7%89%87/</guid><description>
&lt;p>你好，我是范学雷，现在是 Oracle 的主任工程师，也是 OpenJDK 和 Java 安全的评审成员。很高兴和你一起聊聊怎么写好代码这个话题。&lt;/p>
&lt;p>我第一次接触计算机，是在 1994 年。那时候，我还是大学一年级的一枚青瓜。当时的计算机发展，正处于青涩的少年阶段。&amp;ldquo;互联网&amp;quot;也还是一个非常生僻的名词。当时，我们用的计算机是&amp;quot;286&amp;rdquo;，操作系统是 DOS，编程语言还是 Fortran 和 C 语言，Java 语言还没有正式诞生。每次上课，都要随身携带容量为 360KB 的 5.25 英寸软盘。娇气的软盘啊，可是不好伺候，动不动就损坏。那时候最渴望的事情，就是能有一张存储容量高达 1.44MB 的高密度 3.5 英寸软盘。&lt;/p>
&lt;p>计算机启蒙课给我印象最深的是什么呢？不是怎么写程序，而是不停地折腾软盘，一直重复&amp;quot;修复、备份&amp;quot;这个过程。也许是因为软盘的拷贝和修复太无聊，我一直对计算机以及编程没有特别大的兴趣。&lt;/p>
&lt;p>但大学最后一年，两件小事让我改变了对计算机和编程的态度，给我带来了巨大的影响。&lt;/p>
&lt;p>第一件事是，我一个同学编写的五子棋人机对弈程序，当时打遍全班无敌手。厉害吧！用现在的话说，就是&amp;quot;怎么可以这么炸&amp;quot;！这可不是使蛮力，用穷举法就可以搞定的，到底是怎么做到的？这引起了我对计算机程序的强烈兴趣。&lt;/p>
&lt;p>第二件事是，我另一个同学的毕业论文选择了密码学作为研究方向。这个同学有一个优点，不管什么事情，都特别喜欢分享。用东北话说，就是爱嘚瑟，逢人便絮叨。最后差不多全班都知道了密码学的一些基本概念，了解了与之相关的好多传奇故事。密码学这种超神秘、超有趣、超复杂的存在，简直吊足了我的胃口。&lt;/p>
&lt;p>**我们的每一次经历，都塑造着我们自己。**写人机对弈程序的同学，第一次面试就找好了工作，进了最好的公司。研究密码学的同学，是中国商业密码产业化最早的参与者之一。而我自己呢，在他们的影响下，也找到了计算机的乐趣，享受着解决复杂问题带来的喜悦。&lt;/p>
&lt;p>编程和密码学这两个东西合在一起，就是我现在每天工作的主要内容。具体来说就是两件事：&lt;strong>写代码和看代码&lt;/strong>。&lt;/p>
&lt;p>写代码这件事，就我自己的经历来说，有点像过山车。&lt;/p>
&lt;p>我刚开始学习编程时，写几十行代码都觉得痛苦、费劲，不知道从哪儿下手。这种状况一直持续了很多年，直到 1998 年我参加工作，编写程序成了我的职业。职业也就意味着，编码有了具体的目标，代码有了具体的质量要求。&lt;/p>
&lt;p>我是幸运的。目标，有人掰碎了、揉烂了给我讲；质量，有人睁大了眼睛盯着看，也有人不顾情面地给我指出各种问题。有了目标就有了思路，有了要求就有了动力。如果再有人不离不弃地帮助，每一个度日如年的煎熬，最终都会变成&amp;quot;士别三日&amp;quot;的惊喜。慢慢地，我就可以写几百行、几千行、几万行甚至十几万行的代码了。而且越写越快，越写越好。&lt;/p>
&lt;p>大概到了 2000 年的时候，代码设计对我来说可能依然很费时间，但是只要写起代码来，一天数千行也是很常见的。一天洋洋洒洒写数千行代码，暗暗觉得自己挺牛，挺了不起的。&lt;/p>
&lt;p>&amp;ldquo;&lt;strong>无知要比知识更容易产生自信&lt;/strong> &amp;ldquo;。幸运的是，这种盲目的自信没有持续太久，我很快就见识到了更宽阔的世界。2004 年，我加入了 Java 安全组，真正地见识到了，优秀的设计和优秀的代码，是怎么一步一个脚印地出炉的，了解到代码背后的各种综合考量和艰难取舍。慢慢地，我自己也完成了从&amp;quot;代码数量优先&amp;quot;到&amp;quot;代码质量优先&amp;quot;的思路转变**。**&lt;/p>
&lt;p>如果回头看十多年前编写的代码，就像是看筛子一样，到处都是清清楚楚的破洞。也许，这是每个程序员都要经历的过程吧。&lt;/p>
&lt;p>&lt;strong>我们总是先要解决掉数量问题，然后才能解决掉质量问题。&lt;/strong>&lt;/p>
&lt;p>这个过程，还真的有点&amp;quot;看山是山，看山不是山，看山还是山&amp;quot;的味道。&lt;/p>
&lt;p>看代码这件事，对我来说，其实是一个收获大于付出的过程。&lt;/p>
&lt;p>OpenJDK 的代码必须通过评审才可以提交。OpenJDK 社区有非常广泛的代码贡献群体，有些是还没有毕业的年轻学生，也有些资深的业界老专家。新手当然有新手的困惑，而老辣的程序员，也会犯简单的错误。&lt;/p>
&lt;p>一个代码评审者的主要工作，不是批准或者拒绝提交的代码，而是提出合理的建议，帮助代码提交者规避这些失误或者错误，编写出更优秀的代码。&lt;/p>
&lt;p>看代码看得多了，对代码就有更多的了解。 比如，&lt;strong>什么样的代码更容易出问题？ 什么样的代码会招惹麻烦？ 什么样的代码出力不讨好？ 什么样的代码小问题闯大祸？&lt;/strong>&lt;/p>
&lt;p>同时，也对程序员有了更多的了解。 比如，&lt;strong>为什么我们不愿意写注释呢？ 为什么代码写完就不愿意修改了呢？为什么我们不愿意做测试呢？ 为什么我们向往自由而不愿意遵守规范呢？&lt;/strong>&lt;/p>
&lt;p>每一行代码，都体现着程序员的修为，思考问题的深度，甚至是处理问题的习惯和态度。&lt;strong>代码，是我们交流的语言和处世的名片。&lt;/strong>&lt;/p>
&lt;p>这些问题，思考总结下来，就是代码评审的经历馈赠给我的礼物，而且是天大的礼物。&lt;/p>
&lt;p>现在我把这份礼物沉淀下来，就是我们这个专栏的主要内容。我想通过这样一个专栏，让你拥有和我一样的收获。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/56/f6/56a1b164ece4b2c70ee4e49521eb06f6.jpg" alt="">&lt;/p>
&lt;p>回顾我这二十多年的程序员经历，我觉得自己是非常幸运的。现在，我们常常调侃&amp;quot;35 岁码农大龄恐惧症&amp;rdquo;。幸运的是，当这种病毒一般的焦虑开始流传开来的时候，我早已经过了 35 岁，已经来不及担心了。&lt;/p>
&lt;p>这种焦虑之所以广泛流传，背后传达的一个本质问题就是：&lt;strong>作为一名软件工程师，我们该怎么快速成长，并且保持长久的竞争力？&lt;/strong>&lt;/p>
&lt;p>解决这个问题的终极方法，只有一个，那就是&lt;strong>持续地交付优秀的结果&lt;/strong>。宜早不宜迟。&lt;/p>
&lt;p>作为解决现实问题的软件工程师，不管资历深、资历浅，我们都需要编写优秀的代码，并且是越来越优秀的代码，因为这是我们生存的基本依靠。作为活在现实世界的技术工程师，我们需要保持长久的竞争力，甚至是越来越强的竞争力，因为这是改善我们生存质量的最好方式。&lt;/p>
&lt;p>在这个专栏里，我会带着你开始一段代码精进的旅程。和你一起来看一看、摸一摸那些年别人踩过的坑，来聊一聊、试一试我们的代码可以写得有多棒，享受这个打怪升级的过程。&lt;/p>
&lt;p>那么现在，给你一个机会，你敢不敢吐槽一下你见过的或者写过的，最&amp;quot;差劲儿&amp;quot;的代码？或者，你愿不愿意秀秀你自己最中意的代码？&lt;/p>
&lt;p>也欢迎你在留言区写下自己的编程故事，等到专栏结束后，我们再回过头来，看看你走出了怎样的成长轨迹。&lt;/p>
&lt;blockquote>
&lt;p>我渴望做那些伟大而高贵的任务，但是，我首要的责任和快乐却是去完成那些卑微的任务，把它们也当作伟大而且高贵的一样。世界在前行，不只是那些英雄们的力量在推动，也同样包括那些来自每个诚实的工作者微小推动的积累。&amp;mdash;&amp;mdash; 海伦•凯勒&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/5a/98/5a96a612403912b80de030e742e2e598.jpg" alt="">&lt;/p></description></item><item><title>极客专栏: 00丨开篇词丨怎样成长为优秀的软件架构师？</title><link>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E8%AE%B8%E5%BC%8F%E4%BC%9F%E7%9A%84%E6%9E%B6%E6%9E%84%E8%AF%BE/00%E4%B8%A8%E5%BC%80%E7%AF%87%E8%AF%8D%E4%B8%A8%E6%80%8E%E6%A0%B7%E6%88%90%E9%95%BF%E4%B8%BA%E4%BC%98%E7%A7%80%E7%9A%84%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E5%B8%88/</link><pubDate>Tue, 07 Jun 2022 00:00:00 +0000</pubDate><guid>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E8%AE%B8%E5%BC%8F%E4%BC%9F%E7%9A%84%E6%9E%B6%E6%9E%84%E8%AF%BE/00%E4%B8%A8%E5%BC%80%E7%AF%87%E8%AF%8D%E4%B8%A8%E6%80%8E%E6%A0%B7%E6%88%90%E9%95%BF%E4%B8%BA%E4%BC%98%E7%A7%80%E7%9A%84%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E5%B8%88/</guid><description>
&lt;p>你好，我是许式伟。从今天起，我想和你一起来聊聊架构的话题。&lt;/p>
&lt;p>开始之前，我先来和你简单介绍下我自己。&lt;/p>
&lt;p>我是 2000 年开始工作的，曾经做过 WPS 的首席架构师，也在盛大从事过技术研究方面的工作，后来在 2011 年创立了七牛云，现在我是一名创业者、CEO。但不管角色怎么轮换，我觉得我的另一面始终是一名程序员、架构师（如果你想了解更多我的经历，可以观看下面的短视频）。&lt;/p>
&lt;br />
&lt;br />
&lt;p>让我们来想象一下，如果把信息世界看成一座大厦，把程序员看成这个世界的建筑师，那么，现在的你在负责什么样的工作呢？&lt;/p>
&lt;p>当我们把程序员类比成建筑师时，按照能力水平来分，我觉得大体可以分为三个层次：搬砖师、工程师、架构师。&lt;/p>
&lt;p>软件搬砖师之名对应到建筑行业的建筑工人，他们的编程能力和业务基本上停留在堆叠代码，按照要求去实现功能需求的层面。&lt;/p>
&lt;p>只要能让程序跑起来，能正确地实现业务逻辑，就可以称为&amp;quot;会编程&amp;quot;的人。有时候，我们也会看见程序员自称为&amp;quot;码农&amp;quot;&amp;ldquo;搬砖的&amp;rdquo;，虽然二者的工种不同，但从基础工作的相似度来说，确实有可类比的成分。&lt;/p>
&lt;p>很多外行的人都会觉得程序员是一个很神秘的职业，但实际上程序员的基础门槛并不算高。我自己从 2016 年 2 月开始至今，一直在教几位 8~12 岁的小朋友学习编程。这个实践经验告诉我：小学生完全有能力学编程。而且，并不是只有部分小学生可以，而是任何一位小学生都可以学会。&lt;/p>
&lt;p>然而，只让代码跑起来是不够的。这个世界是不断变化的，作为程序员，我们更多的时间是用来维护代码：增加新的需求，对已有的功能进行调整，修改之前代码遗留下来的问题，优化性能等等。&lt;/p>
&lt;p>这是因为一个软件诞生之后，后续就是需要花费大量的代价去维护它，演进它。一个人是完全维护不过来的，需要更多的人，很多的团队一起协作。如果面临了员工离职、岗位调整等情况，还会导致软件代码在不同人之间流转。&lt;/p>
&lt;p>所以，一些有追求的程序员会关注代码的质量。代码质量的评判可以有这样一些基本维度：可阅读性（方便代码流转）、可扩展性 / 可维护性（方便修改功能，添加新功能）、可测试性（质量管理）、可复用性（简化后续功能开发的难度）。&lt;/p>
&lt;p>这一类致力于不断提升软件代码的工程质量的程序员，我们可以称他们为软件工程师。&lt;/p>
&lt;p>工程师不会简单把写代码看作一门工作，把任务交代过去就完事。他们会有&amp;quot;洁癖&amp;quot;，代码在他们眼里是一种艺术，是自己生命的一部分。&lt;/p>
&lt;p>他们会把写出来的代码改了又改，直到让自己满意为止。阅读和维护软件工程师写的代码会有一种赏心悦目的感觉。&lt;/p>
&lt;p>但是，大部分商业软件都是一项极其复杂的工程，它们远比很多传统的建筑工程复杂得多，无论是涉及的人力、时间还是业务的变数都要多很多。&lt;/p>
&lt;p>人力上，大部分大型的软件系统都有几千甚至几万人的规模，而这几千几万人中，却没有两个人的工作是重复的，他们都是在从事着前所未有的创造性工作。&lt;/p>
&lt;p>时间上，只要软件还在服务客户中，程序员们的创造过程便不会停止，软件系统仍然持续迭代更新，以便形成更好的市场竞争力。&lt;/p>
&lt;p>这些都与传统建筑工程的模式大相径庭。一幢建筑自它完成之后，所有的变化便主要集中在一些软装的细节上，很少会再发生剧烈的变动，更不会持续地发生变动。但软件却不是这样，它从诞生之初到其生命周期结束，自始至终都在迭代变化，从未停止。&lt;/p>
&lt;p>所以，光靠把控软件工程师的水平，依赖他们自觉保障的工程质量，是远远不够的。软件工程是一项非常复杂的系统工程，它需要依赖一个能够掌控整个工程全局的团队，来规划和引导整个系统的演变过程。这个团队就是架构师团队。&lt;/p>
&lt;p>软件架构师的职责，并不单单是我们通常理解的，对软件系统进行边界划分和模块规格的定义。&lt;/p>
&lt;p>从根本目标来说，软件架构师要对软件工程的执行结果负责，这包括：按时按质进行软件的迭代和发布、敏捷地响应需求变更、防范软件质量风险（避免发生软件质量事故）、降低迭代维护成本。&lt;/p>
&lt;p>&lt;strong>那怎么才能成长为优秀的软件架构师？软件架构师和软件工程师最根本的差别又在哪里？我认为关键在于四个字：掌控全局。&lt;/strong>&lt;/p>
&lt;p>掌控全局，就是对系统的全貌了然于胸。从传统的建筑工程来说，建筑架构师并不单单要会画建筑图纸，而是要对地基构建、土质、材料、建筑工艺等等所有有可能影响建筑质量的因素都要了然于胸。&lt;/p>
&lt;p>掌控全局，并不是无所不能，不是成为全栈，怎么做到掌控全局？核心在于对知识脉络的体系化梳理。这是架构能力构建和全面提升的关键。这种方法不单单是在软件工程中适用。&lt;/p>
&lt;p>比如学数学，我个人非常喜欢做的一件事情是自己去推导书上所有的公式。每一个公式我都亲自推导而来。&lt;/p>
&lt;p>这样做的核心意义在于，我在尝试从 0 开始，去构建整个精彩纷呈的数学世界，整个数学发展史在自己的笔下重新演绎了一遍，来龙去脉清清楚楚。有时候你甚至会推导出还没有学到的公式，但是在后面学到了。这种体验非常有趣而又让人满足。&lt;/p>
&lt;p>是的，掌控全局的前提是：在自己心中去重新构建出整个世界。在这个过程中，你不需要一上来沉浸在某个技术的实现细节（除非它影响了你对这个世界构建过程的理解），但是你知道整个世界的脉络，知道整个世界的骨架。&lt;/p>
&lt;p>这个时候，你对这个世界的感觉是完全不同的，因为，你已经成为了这个世界的构建者。&lt;/p>
&lt;p>而架构的本质，不也正是构建和创造么？&lt;/p>
&lt;p>作为一个软件行业的从业人员，我们可能接触各种各样的技术书籍。有讲编程语言的、讲数据结构与算法的、讲操作系统的、讲编译原理的、讲架构设计的，还有领域技术类的（比如数据库、存储、大数据、人工智能之类）。&lt;/p>
&lt;p>大部分类别的技术书，多多少少都能够找到几本经典著作。但是，架构设计很可能是个例外，当我想推荐一本经典的架构设计书时，我并不能非常快速地想到应该推荐哪本。&lt;/p>
&lt;p>从个人经验来说，我接触过的与架构相关的图书，大概有如下这些分类。&lt;/p>
&lt;ul>
&lt;li>架构思维类。这类图书通常从一些著名的架构理论讲起，比如开闭原则、单一职责原则、依赖倒置原则、接口分离原则，等等。这种图书的问题在于过度理论化。计算机科学归根到底属于工程技术类，实践第一。&lt;/li>
&lt;li>设计模式类。这一类图书则一下子进入架构的局部细节，每个模式的来龙去脉并不容易理解。就算理解了某个具体的模式，但是也很难真正做到活学活用，不知道还是不知道。&lt;/li>
&lt;li>分布式系统架构设计类。这类图书通常从服务端的通用问题如一致性、高可用、高并发挑战等话题讲起，讲大型业务系统面临的挑战。这些知识是非常有价值的，但无法延伸到通用业务架构，对大部分企业的架构实践并不具备真正的指导意义。&lt;/li>
&lt;li>重构类。这类图书主要讲怎么把坏代码一步步改进到好代码。我认为这是最实用的一类。但在没有优秀架构师主导的情况下，大部分公司的代码不可避免地越变越坏，直到不堪重负最后不得不重写。实际上，一个模块最初的地基是最重要的，基本决定了这座大厦能够撑多久，而重构更多侧重于大厦建成之后，在服务于人的前提下怎么去修修补补，延长生命。&lt;/li>
&lt;/ul>
&lt;p>这些架构类的图书并没有达到我个人的期望。因为它们都没有揭开架构设计的全貌。&lt;/p>
&lt;p>我自己在职业生涯中前后大概做过十几次的架构类演讲，这也是我最为重视、重复次数最多的一类演讲。但同样地，这样零星的演讲对于传递架构设计思想来说，仍然远远不够。&lt;/p>
&lt;p>&lt;strong>所以一直以来，我就心存着这样一个念头：&amp;ldquo;要写一本不一样的架构类图书&amp;rdquo;。这个念想，也正是今天这个专栏的由来。&lt;/strong>&lt;/p>
&lt;p>这个专栏的内容组织算是我的一次尝试。它和今天你看得到的大部分架构书并不太一样。我基本上围绕着两个脉络主线来展开内容：&lt;/p>
&lt;ul>
&lt;li>如何从零开始一步步构建出整个信息世界；&lt;/li>
&lt;li>在整个信息世界的构建过程中，都用了哪些重要的架构思维范式，以及这些范式如何去运用于你平常的工程实践中。&lt;/li>
&lt;/ul>
&lt;p>这两大脉络相辅相成。首先，我们通过还原信息世界的构建过程，剥离出了整个信息世界的核心骨架，这也是最真实、最宏大的架构实践案例。其次，我们结合这个宏大的架构实践来谈架构思维，避免因对架构思维的阐述过于理论化而让人难以理解。&lt;/p>
&lt;p>我想，每个程序员都有一颗成为架构师的心。所以，从内容设计来说，我希望这是一个门槛最低的架构设计专栏，也希望它可以帮助到想成为架构师的初学者，达成自己的目标。&lt;/p>
&lt;p>在行文上，我会尽量避免深奥的术语，尽可能以通俗易懂的文字，来描述信息世界构建者们的所思所想。如果你在阅读的过程中遇到了理解上的障碍，非常欢迎你来给我留言，我将尽可能地根据你的反馈，做出必要的调整。&lt;/p>
&lt;p>如果你已经成为了架构师，我也希望可以为你规避一些错误的经验。在过去的工作经历里，我看到不少架构师都会倾向于把架构看作一项纯技术性的行为。他们的工作流程是这样的：产品经理根据用户的需求做出产品设计，然后架构师再依据产品设计给出实现，也就是软件的架构设计方案。&lt;/p>
&lt;p>在我看来，这其实是个误解。架构关乎的是整个复杂的软件工程，它关乎实现它的人，它又因团队的能力而异。&lt;/p>
&lt;p>同时，架构也关乎用户需求，作为架构师，我们不只是要知道当前的用户需求是什么，我们还要预测需求未来可能的变化，预判什么会发生，而什么一定不会发生。预测什么不会发生最为重要，只有做到这一点，才能真正防止架构的过度设计，把简单的事情复杂化。&lt;/p>
&lt;p>谈了这么多，那么，应该怎样成长为优秀的软件架构师？**我想，一靠匠心，二靠悟心。**架构设计并无标准答案，但我仍然希望把我这些年的所思所想分享给你，更希望这些内容能给你一些启发。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/43/00/43231f3789095eb4cdb38e67ff3d7900.jpg" alt="">&lt;/p></description></item><item><title>极客专栏: 00丨开篇词丨这年头，你真应该懂点法律常识</title><link>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E7%99%BD%E8%AF%9D%E6%B3%95%E5%BE%8B/00%E4%B8%A8%E5%BC%80%E7%AF%87%E8%AF%8D%E4%B8%A8%E8%BF%99%E5%B9%B4%E5%A4%B4%E4%BD%A0%E7%9C%9F%E5%BA%94%E8%AF%A5%E6%87%82%E7%82%B9%E6%B3%95%E5%BE%8B%E5%B8%B8%E8%AF%86/</link><pubDate>Tue, 07 Jun 2022 00:00:00 +0000</pubDate><guid>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E7%99%BD%E8%AF%9D%E6%B3%95%E5%BE%8B/00%E4%B8%A8%E5%BC%80%E7%AF%87%E8%AF%8D%E4%B8%A8%E8%BF%99%E5%B9%B4%E5%A4%B4%E4%BD%A0%E7%9C%9F%E5%BA%94%E8%AF%A5%E6%87%82%E7%82%B9%E6%B3%95%E5%BE%8B%E5%B8%B8%E8%AF%86/</guid><description>
&lt;p>你好，我是周甲德，是北京市京师律师事务所的一名律师，你可以叫我老周。工作十年，我办过大大小小一百多起案件，杀人放火的、骗财骗色的，各种或奇葩或惊悚的事儿都没少见。按理来说经历过这么多，人的心态应该很&amp;quot;淡定&amp;quot;。但是，一年前的一条新闻还是震惊到了我，这也是我接受&amp;quot;极客时间&amp;quot;的邀请来写这个专栏的原因。&lt;/p>
&lt;p>你大概猜到了是哪个新闻，没错，就是技术圈有名的 WePhone 开发者苏享茂事件。苏享茂是一名创业的程序员，因为跟前妻离婚被索要了巨额钱财，同时公司的资金链断裂，不堪重负跳楼自杀。这个案件本身很普通，但让我震惊的是，像苏享茂这样的技术人才，却丝毫不懂法。&lt;/p>
&lt;p>我甚至怀疑他没有咨询过律师，不然他起码了解前妻的要求是否有法律依据，也会知道，&lt;strong>即使一个人做了错事犯了法，也只有法律才有定罪的资格&lt;/strong>。如果他稍微有点法律意识，可能就是另外一个结局，起码不用付出生命的代价。&lt;/p>
&lt;p>如果觉得这个话题太沉重，再看看下面的新闻，是不是你非常熟悉的情节？&lt;/p>
&lt;ul>
&lt;li>
&lt;p>程序员非法出售 VPN，被判刑三年并罚款一万&lt;/p>
&lt;/li>
&lt;li>
&lt;p>男子卖&amp;quot;绝地求生&amp;quot;外挂月入数万，最后却被抓&lt;/p>
&lt;/li>
&lt;li>
&lt;p>腾讯 23 岁工程师检查酒店 WiFi 漏洞，被新加坡安全局逮捕&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>你看，这些事情触目惊心，并不是因为事件本身多恶劣、罪名多严重，而是&lt;strong>这些都是你习以为常的&amp;quot;小事&amp;quot;&lt;/strong>！你不以为意，承担后果时才唏嘘不已！&lt;/p>
&lt;p>每当发生这样的事情，媒体上就会有各种&amp;quot;技术人单纯&amp;quot;的言论。作为一名律师，我看到的其实是大多数人都没有基本的法律常识，甚至是精英的技术人也不例外。&lt;/p>
&lt;p>别等到身陷囹圄或人财两空才后悔，预防永远是上乘之选。&lt;strong>事实上，法律作为一种底层能力，最重要的价值正是风险防范&lt;/strong>。事想到前头做，话想到前面说，就更容易有好结果。但要做到这些并不容易，是需要懂点法律、有点风险意识的。&lt;/p>
&lt;p>你是不是这么想过，我又不去招惹是非，一直本本份份，法与我何关？我想和你说，法律就在我们每个人生活中，一呼一吸都关乎法律。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/97/5e/97cdda494c3cfb7b702f2af5bf3b535e.jpeg" alt="">&lt;/p>
&lt;p>比如在刚入职签劳动合同时，我会仔细阅读工资待遇、五险一金和保密事项等内容，因为我清楚，一旦&lt;strong>落笔&lt;/strong>，这张纸便成了我板上钉钉的法律责任，即使有不合理的地方也得认了。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/f4/43/f481267482baad8312466364e25b4543.jpeg" alt="">&lt;/p>
&lt;p>再如租房时，我会查清楚中介的资质和房东的手续，正式入住之前也会&lt;strong>记录好&lt;/strong>所有大件物品的交接，然后严肃对待租房合同，这样在出问题时，才知道怎么保护自己的利益。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/0c/26/0cadacc872e167b32376295229345226.jpeg" alt="">&lt;/p>
&lt;p>哪怕是我身边做技术的朋友，也会死死记住不去碰一些&amp;quot;&lt;strong>雷区&lt;/strong>&amp;quot;，像是给私人建设黄色网站、帮人搭建套现平台这些活儿，甚至只是&amp;quot;爬虫&amp;quot;获取一些数据信息，他们也会注意不能&amp;quot;过了线&amp;quot;。因为我平常总强调相关罪行的具体场景和后果界定，他们也就记住了。&lt;/p>
&lt;p>这些都是懂点法、有风险意识的具体体现，也是专栏中我想要教给你、让你能做到的东西。我选取了职场上、技术上和生活中的 40 多个经典场景，结合自已多年的执业经验和感受，把我见过的&amp;quot;雷区&amp;quot;和解决手段都告诉你，让你尽可能不走或少走法律的弯路。&lt;strong>我们一起，从现实场景出发，再回到现实的风险意识和解决方案。&lt;/strong>&lt;/p>
&lt;p>你不用害怕会有晦涩的法律条文，这其实是一个认识误区，很多人都以为学法就是去背数不清又难懂的法律条文。其实，对于大多数人来说，这完全没有必要。实际上，你需要学的是法律常识，是法律在日常的应用。这些东西，我会用最直白的语言和真实的案例来讲，保证你能轻松学懂、会用。&lt;/p>
&lt;p>另外每天学习结束，我会给你留一个思考题，帮你加深对内容的印象，同时也是为了让留言区成为我们交流的平台。除了回答问题，我还希望你有更多的想法，比如可以总结你的学习笔记，分享你的某些故事，或是对某句话、某个观点的感触，你都可以记录下来。你还可以写下你的疑惑，提出最关心的法律问题，我也会抽空回复你。&lt;/p>
&lt;p>参与、思考并输出，才是学习的最佳途径。这样，&amp;ldquo;我的&amp;quot;才可以内化成&amp;quot;你的&amp;rdquo;。&lt;/p>
&lt;p>说了这么多，其实我的目的很简单，那就是希望你学完这个专栏后，可以解锁这三个成就：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>了解法律常识，有风险防范意识；&lt;/strong>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>会用法律思维处理问题，不走弯路；&lt;/strong>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>做到&amp;quot;我不坑人，不被人坑&amp;quot;。&lt;/strong>&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>这是我的期许，在正式开始学习之前也很想听听你的声音，你觉得法律和自己的关系是怎样的？有没有什么问题或者困惑，希望可以咨询律师呢？你都可以给我留言。&lt;/p>
&lt;p>我很喜欢一句话，上帝只救自救之人。我不希望你坑人或是被人坑，只想让法律给你生存底气，成为保护你的&amp;quot;三级盔甲&amp;quot;。接下来，就让我们一起为你组装专属的法律盔甲吧！&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/10/ae/109d74bf33e68fa4206ce2ae524c75ae.jpg" alt="">&lt;/p></description></item><item><title>极客专栏: 00丨开篇词丨业务代码真的会有这么多坑？</title><link>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/java%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF100%E4%BE%8B/00%E4%B8%A8%E5%BC%80%E7%AF%87%E8%AF%8D%E4%B8%A8%E4%B8%9A%E5%8A%A1%E4%BB%A3%E7%A0%81%E7%9C%9F%E7%9A%84%E4%BC%9A%E6%9C%89%E8%BF%99%E4%B9%88%E5%A4%9A%E5%9D%91/</link><pubDate>Sun, 29 May 2022 00:00:00 +0000</pubDate><guid>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/java%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF100%E4%BE%8B/00%E4%B8%A8%E5%BC%80%E7%AF%87%E8%AF%8D%E4%B8%A8%E4%B8%9A%E5%8A%A1%E4%BB%A3%E7%A0%81%E7%9C%9F%E7%9A%84%E4%BC%9A%E6%9C%89%E8%BF%99%E4%B9%88%E5%A4%9A%E5%9D%91/</guid><description>
&lt;p>你好，我是朱晔，贝壳金服的资深架构师。&lt;/p>
&lt;p>我先和你说说我这 15 年的工作经历吧，以加深彼此的了解。前 7 年，我专注于.NET 领域，负责业务项目的同时，也做了很多社区工作。在 CSDN 做版主期间，我因为回答了大量有关.NET 的问题，并把很多问题的答案总结成了博客，获得了 3 次微软 MVP 的称号。&lt;/p>
&lt;p>后来，我转到了 Java 领域，也从程序员变为了架构师，更关注开源项目和互联网架构设计。在空中网，我整体负责了百万人在线的大型 MMO 网游《激战》技术平台的架构设计，期间和团队开发了许多性能和稳定性都不错的 Java 框架；在饿了么，我负责过日千万订单量的物流平台的开发管理和架构工作，遇到了许多只有高并发下才会出现的问题，积累了大量的架构经验；现在，我在贝壳金服的基础架构团队，负责基础组件、中间件、基础服务开发规划，制定一些流程和规范，带领团队自研 Java 后端开发框架、微服务治理平台等，在落地 Spring Cloud 结合 Kubernetes 容器云平台技术体系的过程中，摸索出了很多适合公司项目的基础组件和最佳实践。&lt;/p>
&lt;p>这 15 年来，我一直没有脱离编码工作，接触过大大小小的项目不下 400 个，自己亲身经历的、见别人踩过的坑不计其数。我感触很深的一点是，业务代码中真的有太多的坑：有些是看似非常简单的知识点反而容易屡次踩坑，比如 Spring 声明式事务不生效的问题；而有些坑因为&amp;quot;潜伏期&amp;quot;长，引发的线上事故造成了大量的人力和资金损失。因此，我系统梳理了这些案例和坑点，最终筛选出 100 个案例，涉及 130 多个坑点，组成了这个课程。&lt;/p>
&lt;h1 id="意识不到业务代码的坑很危险">意识不到业务代码的坑，很危险&lt;/h1>
&lt;p>我想看到 100、130 这两个数字，你不禁要问了：&amp;ldquo;我写了好几年的业务代码了，遇到问题时上网搜一下就有答案，遇到最多的问题就是服务器不稳定，重启一下基本就可以解决，哪里会有这么多坑呢？&amp;ldquo;带着这个问题，你继续听我往下说吧。&lt;/p>
&lt;p>据我观察，很多开发同学没意识到这些坑，有以下三种可能：&lt;/p>
&lt;ul>
&lt;li>意识不到坑的存在，比如所谓的服务器不稳定很可能是代码问题导致的，很多时候遇到 OOM、死锁、超时问题在运维层面通过改配置、重启、扩容等手段解决了，没有反推到开发层面去寻找根本原因。&lt;/li>
&lt;li>有些问题只会在特定情况下暴露。比如，缓存击穿、在多线程环境使用非线程安全的类，只有在多线程或高并发的情况才会暴露问题。&lt;/li>
&lt;li>有些性能问题不会导致明显的 Bug，只会让程序运行缓慢、内存使用增加，但会在量变到质变的瞬间爆发。&lt;/li>
&lt;/ul>
&lt;p>而正是因为没有意识到这些坑和问题，采用了错误的处理方式，最后问题一旦爆发，处理起来就非常棘手，这是非常可怕的。下面这些场景有没有感觉似曾相识呢？&lt;/p>
&lt;p>比如，我曾听说过有一个订单量很大的项目，每天总有上千份订单的状态或流程有问题，需要花费大量的时间来核对数据，修复订单状态。开发同学因为每天牵扯太多经历在排查问题上，根本没时间开发新需求。技术负责人为此头痛不已，无奈之下招了专门的技术支持人员。最后痛定思痛，才决定开启明细日志彻查这个问题，结果发现是自调用方法导致事务没生效的坑。&lt;/p>
&lt;p>再比如，有个朋友告诉我，他们的金融项目计算利息的代码中，使用了 float 类型而不是 BigDecimal 类来保存和计算金额，导致给用户结算的每一笔利息都多了几分钱。好在，日终对账及时发现了问题。试想一下，结算的有上千个用户，每个用户有上千笔小订单，如果等月终对账的时候再发现，可能已经损失了几百万。&lt;/p>
&lt;p>再比如，我们使用 RabbitMQ 做异步处理，业务处理失败的消息会循环不断地进入 MQ。问题爆发之前，可能只影响了消息处理的时效性。但等 MQ 彻底瘫痪时，面对 MQ 中堆积的、混杂了死信和正常消息的几百万条数据，你除了清空又能怎么办。但清空 MQ，就意味着要花费几小时甚至几十小时的时间，来补正常的业务数据，对业务影响时间很长。&lt;/p>
&lt;p>像这样由一个小坑引发的重大事故，不仅仅会给公司造成损失，还会因为自责影响工作状态，降低编码的自信心。我就曾遇到过一位比较负责的核心开发同学，因为一个 Bug 给公司带来数万元的经济损失，最后心理上承受不住提出了辞职。&lt;/p>
&lt;p>其实，很多时候不是我们不想从根本上解决问题，只是不知道问题到底在了哪里。要避开这些坑、找到这些定时炸弹，第一步就是得知道它们是什么、在哪里、为什么会出现。而讲清楚这些坑点和相关的最佳实践，正是本课程的主要内容。&lt;/p>
&lt;h1 id="这个课程是什么">这个课程是什么？&lt;/h1>
&lt;p>如果用几个关键词概括这个课程的话，那我会选择&amp;quot;Java&amp;quot;&amp;ldquo;业务开发&amp;quot;&amp;ldquo;避坑 100 例&amp;quot;这 3 个。接下来，我就和你详细说说这个课程是什么，以及有什么特点。&lt;/p>
&lt;p>&lt;strong>第一个关键词是&amp;quot;Java&amp;rdquo;&lt;/strong>，指的是课程内所有 Demo 都是基于 Java 语言的。&lt;/p>
&lt;p>如果你熟悉 Java，那可以 100% 体会到这些坑点，也可以直接用这些 Demo 去检查你的业务代码是否也有类似的错误实现。&lt;/p>
&lt;p>如果你不熟悉 Java 问题也不大，现在大部分高级语言的特性和结构都差不多，许多都是共性问题。此外&amp;quot;设计篇&amp;quot;&amp;ldquo;安全篇&amp;quot;的内容，基本是脱离具体语言层面的、高层次的问题。因此，即使不使用 Java，你也可以有不少收获，这也是本课程的第一个特点。&lt;/p>
&lt;p>讲到这里，我要说明的是，这个课程是围绕坑点而不是 Java 语言体系展开的，因此不是系统学习 Java 的教材。&lt;/p>
&lt;p>&lt;strong>第二个关键词是&amp;quot;业务开发&amp;rdquo;，也就是说课程内容限定在业务项目的开发，侧重业务项目开发时可能遇到的坑。&lt;/strong>&lt;/p>
&lt;p>我们先看&amp;quot;业务&amp;quot;这个词。做业务开发时间长的同学尤其知道，业务项目有两大特点：&lt;/p>
&lt;ul>
&lt;li>工期紧、逻辑复杂，开发人员会更多地考虑主流程逻辑的正确实现，忽略非主流程逻辑，或保障、补偿、一致性逻辑的实现；&lt;/li>
&lt;li>往往缺乏详细的设计、监控和容量规划的闭环，结果就是随着业务发展出现各种各样的事故。&lt;/li>
&lt;/ul>
&lt;p>根据这些性质，我总结出了近 30 个方面的内容，力求覆盖业务项目开发的关键问题。案例的全面性，是本课程的第二大特点。&lt;/p>
&lt;p>这些案例可以看作是 Java 业务代码的避坑大全，帮助你写出更好的代码，也能帮你进一步补全知识网增加面试的信心。你甚至可以把二级目录当作代码审核的 Checklist，帮助业务项目一起成长和避坑。&lt;/p>
&lt;p>我们再看&amp;quot;开发&amp;quot;这个词。为了更聚焦，也更有针对性，我把专栏内容限定在业务开发，不会过多地讨论架构、测试、部署运维等阶段的问题。而&amp;quot;设计篇&amp;rdquo;，重在讲述架构设计上可能会遇到的坑，不会全面、完整地介绍高可用、高并发、可伸缩性等架构因素。&lt;/p>
&lt;p>&lt;strong>第三个关键词是&amp;quot;避坑 100 例&amp;rdquo;。坑就是容易犯的错，避坑就是踩坑后分析根因，避免重复踩同样的坑。&lt;/strong>&lt;/p>
&lt;p>整个课程 30 篇文章，涉及 100 个案例、约 130 个小坑，其中 40% 来自于我经历过或者是见过的 200 多个线上生产事故，剩下的 60% 来自于我开发业务项目，以及日常审核别人的代码发现的问题。贴近实际，而不是讲述过时的或日常开发根本用不到的技术或框架，就是本课程的第三大特点了。&lt;/p>
&lt;p>大部分案例我会配合一个可执行的 Demo 来演示，Demo 中不仅有错误实现（踩坑），还有修正后的正确实现（避坑）。完整且连续、授人以渔，是本课程的第四大特点。&lt;/p>
&lt;ul>
&lt;li>完整且连续，知其所以然。我会按照&amp;quot;知识介绍 -&amp;gt; 还原业务场景 -&amp;gt; 错误实现 -&amp;gt; 正确实现 -&amp;gt; 原理分析 -&amp;gt; 小总结 &amp;ldquo;来讲解每个案例，针对每个坑点我至少会给出一个解决方案，并会挑选核心的点和你剖析源码。这样一来，你不仅能避坑，更能知道产生坑的根本原因，提升自己的技术能力。&lt;/li>
&lt;li>授人以渔。在遇到问题的时候，我们一定是先通过经验和工具来定位分析问题，然后才能定位到坑，并不是一开始就知道为什么的。在这个课程中，我会尽可能地把分析问题的过程完整地呈现给你，而不是直接告诉你为什么，这样你以后遇到问题时也能有解决问题的思路。&lt;/li>
&lt;/ul>
&lt;p>这也是为什么，网络上虽然有很多关于 Java 代码踩坑的资料，但很多同学却和我反馈说，看过之后印象不深刻，也因为没吃透导致在一个知识点上重复踩坑。鉴于此，我还会与你分析我根据多年经验和思考，梳理出的一些最佳实践。&lt;/p>
&lt;p>看到这里，是不是迫不及待地想要看看这个专栏的内容都会涉及哪些坑点了呢？那就看看下面这张思维导图吧：&lt;br>
&lt;img src="https://static001.geekbang.org/resource/image/0e/20/0ee7e3490bae45d6f0ce06a050695020.jpg" alt="">&lt;/p>
&lt;p>鉴于这个专栏的内容和特点，我再和你说说最佳的学习方式是什么。&lt;/p>
&lt;h1 id="学习课程的最佳方法">学习课程的最佳方法&lt;/h1>
&lt;p>我们都知道，编程是一门实践科学，只看不练、不思考，效果通常不会太好。因此，我建议你打开每篇文章后，能够按照下面的方式深入学习：&lt;/p>
&lt;ul>
&lt;li>对于每一个坑点，实际运行调试一下源码，使用文中提到的工具和方法重现问题，眼见为实。&lt;/li>
&lt;li>对于每一个坑点，再思考下除了文内的解决方案和思路外，是否还有其他修正方式。&lt;/li>
&lt;li>对于坑点根因中涉及的 JDK 或框架源码分析，你可以找到相关类再系统阅读一下源码。&lt;/li>
&lt;li>实践课后思考题。这些思考题，有的是对文章内容的补充，有的是额外容易踩的坑。&lt;/li>
&lt;/ul>
&lt;p>理解了课程涉及的所有案例后，你应该就对业务代码大部分容易犯错的点了如指掌了，不仅仅自己可以写出更高质量的业务代码，还可以在审核别人代码时发现可能存在的问题，帮助整个团队成长。&lt;/p>
&lt;p>当然了，你从这个课程收获的将不仅是解决案例中那些问题的方法，还可以提升自己分析定位问题、阅读源码的能力。当你再遇到其他诡异的坑时，也能有清晰的解决思路，也可以成长为一名救火专家，帮助大家一起定位、分析问题。&lt;/p>
&lt;p>好了，以上就是我今天想要和你分享的内容了。请赶快跟随我们的课程开启避坑之旅吧，也欢迎你留言说说自己的情况，你都踩过哪些坑、对写业务代码又有哪些困惑？我们下一讲见！&lt;/p></description></item><item><title>极客专栏: 00丨开篇词丨跟着学，你也能成为Go语言高手</title><link>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/go-%E8%AF%AD%E8%A8%80%E6%A0%B8%E5%BF%83-36-%E8%AE%B2/00%E4%B8%A8%E5%BC%80%E7%AF%87%E8%AF%8D%E4%B8%A8%E8%B7%9F%E7%9D%80%E5%AD%A6%E4%BD%A0%E4%B9%9F%E8%83%BD%E6%88%90%E4%B8%BAgo%E8%AF%AD%E8%A8%80%E9%AB%98%E6%89%8B/</link><pubDate>Sun, 29 May 2022 00:00:00 +0000</pubDate><guid>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/go-%E8%AF%AD%E8%A8%80%E6%A0%B8%E5%BF%83-36-%E8%AE%B2/00%E4%B8%A8%E5%BC%80%E7%AF%87%E8%AF%8D%E4%B8%A8%E8%B7%9F%E7%9D%80%E5%AD%A6%E4%BD%A0%E4%B9%9F%E8%83%BD%E6%88%90%E4%B8%BAgo%E8%AF%AD%E8%A8%80%E9%AB%98%E6%89%8B/</guid><description>
&lt;p>你好，我是郝林。今天想跟你聊聊我和 Go 语言的故事。&lt;/p>
&lt;p>Go 语言是由 Google 出品的一门通用型计算机编程语言。作为在近年来快速崛起的编程语言，Go 已经成功跻身主流编程语言的行列。&lt;/p>
&lt;p>它的种种亮点都受到了广大编程爱好者的追捧。特别是一些对团队协作有较高要求的公司和技术团队，已经在有意识地大量使用 Go 语言编程，并且，使用的人群还在持续迅猛增长。&lt;/p>
&lt;p>我个人很喜欢 Go 语言。我是从 2012 年底开始关注 Go 语言的，虽然这个日期与 Go 语言诞生的 2009 年 11 月 10 日相比并不算早，但我也算得上国内比较早期的使用者了。&lt;/p>
&lt;p>Go 程序可以在装有 Windows、Linux、FreeBSD 等操作系统的服务器上运行，并用于提供基础软件支撑、API 服务、Web 服务、网页服务等等。&lt;/p>
&lt;p>Go 语言也在移动端进行了积极的探索，现在在 Android 和 iOS 上都可以运行其程序。另外，Go 语言也已经与 WebAssembly 强强联合，加入了 WASM 平台。这意味着过不了多久，互联网浏览器也可以运行 Go 编写的程序了。&lt;/p>
&lt;p>从业务维度看，在云计算、微服务、大数据、区块链、物联网等领域，Go 语言早已蓬勃发展。有的使用率已经非常之高，有的已有一席之地。即使是在 Python 为王的数据科学和人工智能领域，Go 语言也在缓慢渗透，并初露头角。&lt;/p>
&lt;p>从公司角度看，许多大厂都已经拥抱 Go 语言，包括以 Java 打天下的阿里巴巴，更别提深爱着 Go 语言的滴滴、今日头条、小米、奇虎 360、京东等明星公司。同时，创业公司也很喜欢 Go 语言，主要因为其入门快、程序库多、运行迅速，很适合快速构建互联网软件产品，比如轻松筹、快手、知乎、探探、美图、猎豹移动等等。&lt;/p>
&lt;p>我从 2013 年开始准备撰写《Go 并发编程实战》这本书，在经历了一些艰辛和坎坷之后，本书终于在 2014 年底由人民邮电出版社的图灵公司正式出版。&lt;/p>
&lt;p>时至今日，《Go 并发编程实战》的第 2 版已经出版一年多了，也受到了广大 Go 语言爱好者的欢迎。同时，我也发起和维护着一个 Go 语言爱好者组织 GoHackers，至今已有近 4000 人的规模。我们每年都会举办一些活动，交流技术、互通有无。当然，我们平常都会在一些线上的群组里交流。欢迎你的加入。&lt;/p>
&lt;p>2015 年初，我开始帮助公司和团队招聘 Go 程序员。我面试过的 Go 程序员应该已经有几百个了。虽然一场面试的交流内容远不止技术能力这种硬技能，更别提只限于一门编程语言。&lt;/p>
&lt;p>但是就事论事，我在这里只说 Go 语言。在所有的应聘者当中，真正掌握 Go 语言基础知识的比例恐怕超不过 50%，而真正熟悉 Go 语言高阶技术的比例也不超过 30%。当然了，情况是明显一年比一年好的，尤其是今年。&lt;/p>
&lt;p>我写此专栏的初衷是，让希望迅速掌握 Go 语言的爱好者们，通过一种比较熟悉和友好的路径去学习。我并不想事无巨细地去阐述 Go 语言规范的每个细节以及其标准库中的每个 API，更不想写那种填鸭式的教学文章，我更想去做的是详细论述这门语言的重点和主线。&lt;/p>
&lt;p>我会努力探究我们对新技能，尤其是编程语言的学习方式，并以这种方式一步步带领和引导你去记忆和实践。我几乎总会以一道简单的题目为引子，并以一连串相关且重要的概念和知识为主线，而后再进行扩充，以助你进行发散性的思考。&lt;/p>
&lt;p>我希望用这种先点、后线、再面的方式，帮你占领一个个重要的阵地。别的不敢说，如果你认真地跟我一起走完这个专栏，那么基本掌握 Go 语言是肯定的。&lt;/p>
&lt;p>为什么说基本掌握？因为软件技术，尤其是编程技术，必须经过很多的实践甚至历练才能完全掌握，这需要时间而不能速成。不过，本专栏一定会成为你学习 Go 语言最重要的敲门砖和垫脚石。&lt;/p>
&lt;p>下面，我们一起浏览一下本专栏的主要模块，一共分成 3 大模块，5 个章节。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>基础概念：我会讲述 Go 语言基础中的基础，包括一些基本概念和运作机制。它们都应该是你初识 Go 语言时必须知道的，同时也有助于你理解后面的知识。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>数据类型和语句：Go 语言中的数据类型大都是很有特色的，你只有理解了它们才能真正玩转 Go 语言。我将和你一起与探索它们的奥妙。另外，我也会一一揭示怎样使用各种语法和语句操纵它们。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Go 程序的测试：很多程序员总以为测试是另一个团队的事情，其实不然。单元测试甚至接口测试其实都应该是程序员去做的，并且应该受到重视。在 Go 语言中怎样做好测试这件事？我会跟你说清楚、讲明白。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>标准库的用法：虽然 Go 语言提供了自己的高效并发编程方式，但是同步方法依然不容忽视。这些方法集中在&lt;code>sync&lt;/code>代码包及其子包中。这部分还涉及了字节和字符问题、OS 操控方法和 Web 服务写法等，这些都是我们在日常工作中很可能会用到的。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Go 语言拾遗：这部分将会讲述一些我们使用 Go 语言做软件项目的过程中很可能会遇到的问题，至少会包含两篇文章，是附赠给广大 Go 语言爱好者的。虽然我已经有一个计划了，但是具体会讲哪些内容我还是选择暂时保密。请你和我一起小期待一下吧。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>我希望本专栏能帮助或推动你去做更多的实践和思考。同时我也希望，你能通过学习本专栏感受到学习的快乐，并能够在应聘 Go 语言相关岗位的时候更加游刃有余。&lt;/p>
&lt;p>所以，如果学，请深学。我不敢自称布道师，但很愿意去做推广优秀技术的事情。如果我的输出能为你的宝塔添砖加瓦，那将会是我的快乐之源。我也相信这几十篇文章可以做到这一点。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/35/48/358e4e8578a706598e18a7dfed3ed648.jpg" alt="">&lt;/p></description></item><item><title>极客专栏: 00丨预习篇丨写给0基础入门的Go语言学习者</title><link>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/go-%E8%AF%AD%E8%A8%80%E6%A0%B8%E5%BF%83-36-%E8%AE%B2/00%E4%B8%A8%E9%A2%84%E4%B9%A0%E7%AF%87%E4%B8%A8%E5%86%99%E7%BB%990%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E7%9A%84go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E8%80%85/</link><pubDate>Sun, 29 May 2022 00:00:00 +0000</pubDate><guid>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/go-%E8%AF%AD%E8%A8%80%E6%A0%B8%E5%BF%83-36-%E8%AE%B2/00%E4%B8%A8%E9%A2%84%E4%B9%A0%E7%AF%87%E4%B8%A8%E5%86%99%E7%BB%990%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E7%9A%84go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E8%80%85/</guid><description>
&lt;p>你好，我是郝林，今天我分享的内容是：0 基础的你，如何开始入门学习 Go 语言。&lt;/p>
&lt;ol>
&lt;li>你需要遵循怎样的学习路径来学习 Go 语言？&lt;/li>
&lt;/ol>
&lt;hr>
&lt;p>我们发现，订阅本专栏的同学们都在非常积极的学习和讨论，这让我们非常欣慰，并且和你一样干劲十足。不过，我在留言中发现，大家的基础好像都不太一样，大致可以分为这么几类。&lt;/p>
&lt;ul>
&lt;li>零基础的同学：可能正准备入行或者刚刚对编程感兴趣，可以熟练操作电脑，但是对计算机、操作系统以及网络方面的知识不太了解。&lt;/li>
&lt;li>无编程经验或者编程经验较少的同学：可能正在从事其他的技术相关工作，也许可以熟练编写脚本，但是对程序设计的通用知识和技巧还不太了解。&lt;/li>
&lt;li>有其他语言编程经验的同学：可能已成为程序员或软件工程师，可以用其他的编程语言熟练编写程序，但是对 Go 语言还不太了解。&lt;/li>
&lt;li>有一定 Go 语言编程经验的同学：已有 Go 语言编程基础，写过一些 Go 语言程序，但是急需进阶却看不清途径。&lt;/li>
&lt;/ul>
&lt;p>基于以上分类，我为大家制定了一份 Go 语言学习路径。不论你属于上面的哪一类，都可以按照此路径去学习深造。具体请看下面的思维导图。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/c7/b7/c702df29da67be3c4083ecce1d0eadb7.png" alt="">&lt;/p>
&lt;p>（长按保存大图）&lt;/p>
&lt;ol start="2">
&lt;li>学习本专栏前，你需要有哪些基础知识储备？&lt;/li>
&lt;/ol>
&lt;hr>
&lt;p>在这个专栏里，我会假设你有一定的计算机基础，比如，知道操作系统是什么、环境变量怎么设置、命令行怎样使用，等等。&lt;/p>
&lt;p>另外，我还会假定你具备一点点编程知识，比如，知道程序是什么、程序通常会以怎样的形式存在，以及程序与操作系统和计算机有哪些关系，等等。&lt;/p>
&lt;p>对了，还有在这个早已成熟的移动互联网时代，想学编程的你，一定也应该知道那些最最基本的网络知识。&lt;/p>
&lt;p>我在本专栏里只会讨论 Go 语言的代码和程序，而不会提及太多计算机体系结构或软件工程方面的事情。所以你即使没有专门学过计算机系统或者软件工程也没有关系，我会尽量连带讲一些必要的基础概念和知识。&lt;/p>
&lt;p>从 2018 年开始，随着 Google 逐渐重回中国，Go 语言的官方网站在 Google 中国的域名下也有了镜像，毕竟中国是 Go 语言爱好者最多的国家，同时也是 Go 语言使用最广泛的一片土地。如果你在国内，可以敲入&lt;a href="https://golang.google.cn">这个网址&lt;/a>来访问 Go 语言的官网。&lt;/p>
&lt;p>这个专栏专注于 Go 语言的核心知识，因此我并不会深入说明所有关于语法和命令的细枝末节。如果你想去全面了解 Go 语言的所有语法，那么可以去 Go 语言官网的&lt;a href="https://golang.google.cn/ref/spec">语言规范页面&lt;/a>仔细查阅。&lt;/p>
&lt;p>当然了，这里的语言规范是全英文的，如果你想看汉化的内容也是有选择的，我记得先后有几拨国内的 Go 语言爱好者自发组织翻译过。不过我都没有仔细看过，不知道质量如何，所以在这里就不特别推荐了。&lt;/p>
&lt;p>对于从事计算机和软件开发相关工作的同学，我强烈建议你们要有意地训练快速阅读英文文档的能力，不论是否借助字典和翻译工具。&lt;/p>
&lt;p>不过，如果你想专门学习一下 Go 命令方面的知识和技巧，那么我推荐你看看我之前写的免费开源教程《&lt;a href="https://github.com/hyper0x/go_command_tutorial">Go 命令教程&lt;/a>》。这份教程的内容虽然稍显陈旧，但是帮助你学会使用 Go 语言自带的常用命令和工具肯定是没问题的。&lt;/p>
&lt;p>好了，其实即使你是个编程小白也不用过于担心，我们会一起帮助你的。至于我刚刚说的 Go 语言规范和 Go 命令教程，你也可以在学习本专栏的过程中根据实际需要去有针对性的阅读。&lt;/p>
&lt;ol start="3">
&lt;li>这里有一份基础知识列表，请查收&lt;/li>
&lt;/ol>
&lt;hr>
&lt;p>如果你阅读本专栏的第一个模块时感觉有些吃力，那可能是你还没有熟悉 Go 语言的一些基础概念和知识。我为你精心制作了一张 Go 语言基础知识的导图，里面几乎包含了入门 Go 语言所需的所有知识点。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/ad/85/add8566dc5431378bda313a32a6ebb85.jpg" alt="">&lt;br>
（长按保存大图）&lt;/p>
&lt;p>有了这些，你是否已经感觉学习本专栏会更加轻松了呢？&lt;/p>
&lt;p>总之，教程、资料和助推就交给我和极客时间的编辑、运营们来共同负责。而你需要做的，就是保存好这一份对 Go 语言学习的决心，你可以自己去尝试整理一份 Go 语言的学习笔记，遇见不懂的地方，你也可以在文章下面留言，我们一起讨论。&lt;/p>
&lt;p>好了，感谢你的收听，我们下期再见。&lt;/p>
&lt;p>&lt;a href="https://github.com/hyper0x/Golang_Puzzlers">戳此查看 Go 语言专栏文章配套详细代码。&lt;/a>&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/35/48/358e4e8578a706598e18a7dfed3ed648.jpg" alt="">&lt;/p></description></item><item><title>极客专栏: 学习攻略如何才能学好并发编程？</title><link>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/%E5%AD%A6%E4%B9%A0%E6%94%BB%E7%95%A5%E5%A6%82%E4%BD%95%E6%89%8D%E8%83%BD%E5%AD%A6%E5%A5%BD%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</link><pubDate>Sun, 29 May 2022 00:00:00 +0000</pubDate><guid>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/%E5%AD%A6%E4%B9%A0%E6%94%BB%E7%95%A5%E5%A6%82%E4%BD%95%E6%89%8D%E8%83%BD%E5%AD%A6%E5%A5%BD%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</guid><description>
&lt;p>并发编程并不是一门相对独立的学科，而是一个综合学科。并发编程相关的概念和技术看上非常零散，相关度也很低，总给你一种这样的感觉：我已经学习很多相关技术了，可还是搞不定并发编程。那如何才能学习好并发编程呢？&lt;/p>
&lt;p>其实很简单，只要你能从两个方面突破一下就可以了。一个是&amp;quot;跳出来，看全景&amp;quot;，另一个是&amp;quot;钻进去，看本质&amp;quot;。&lt;/p>
&lt;h2 id="跳出来看全景">跳出来，看全景&lt;/h2>
&lt;p>我们先说&amp;quot;跳出来&amp;quot;。你应该也知道，学习最忌讳的就是&amp;quot;盲人摸象&amp;quot;，只看到局部，而没有看到全局。所以，你需要从一个个单一的知识和技术中&amp;quot;跳出来&amp;quot;，高屋建瓴地看并发编程。当然，这&lt;strong>首要之事就是你建立起一张全景图&lt;/strong>。&lt;/p>
&lt;p>不过，并发编程相关的知识和技术还真是错综复杂，时至今日也还没有一张普遍认可的全景图，也许这正是很多人在并发编程方面难以突破的原因吧。好在经过多年摸爬滚打，我自己已经&amp;quot;勾勒&amp;quot;出了一张全景图，不一定科学，但是在某种程度上我想它还是可以指导你学好并发编程的。&lt;/p>
&lt;p>在我看来，并发编程领域可以抽象成&lt;strong>三个核心问题：分工、同步和互斥&lt;/strong>。&lt;/p>
&lt;h3 id="1-分工">1. 分工&lt;/h3>
&lt;p>所谓分工，类似于现实中一个组织完成一个项目，项目经理要拆分任务，安排合适的成员去完成。&lt;/p>
&lt;p>在并发编程领域，你就是项目经理，线程就是项目组成员。任务分解和分工对于项目成败非常关键，不过在并发领域里，分工更重要，它直接决定了并发程序的性能。在现实世界里，分工是很复杂的，著名数学家华罗庚曾用&amp;quot;烧水泡茶&amp;quot;的例子通俗地讲解了统筹方法（一种安排工作进程的数学方法），&amp;ldquo;烧水泡茶&amp;quot;这么简单的事情都这么多说道，更何况是并发编程里的工程问题呢。&lt;/p>
&lt;p>既然分工很重要又很复杂，那一定有前辈努力尝试解决过，并且也一定有成果。的确，在并发编程领域这方面的成果还是很丰硕的。Java SDK 并发包里的 Executor、Fork/Join、Future 本质上都是一种分工方法。除此之外，并发编程领域还总结了一些设计模式，基本上都是和分工方法相关的，例如生产者 - 消费者、Thread-Per-Message、Worker Thread 模式等都是用来指导你如何分工的。&lt;/p>
&lt;p>学习这部分内容，最佳的方式就是和现实世界做对比。例如生产者 - 消费者模式，可以类比一下餐馆里的大厨和服务员，大厨就是生产者，负责做菜，做完放到出菜口，而服务员就是消费者，把做好的菜给你端过来。不过，我们经常会发现，出菜口有时候一下子出了好几个菜，服务员是可以把这一批菜同时端给你的。其实这就是生产者 - 消费者模式的一个优点，生产者一个一个地生产数据，而消费者可以批处理，这样就提高了性能。&lt;/p>
&lt;h3 id="2-同步">2. 同步&lt;/h3>
&lt;p>分好工之后，就是具体执行了。在项目执行过程中，任务之间是有依赖的，一个任务结束后，依赖它的后续任务就可以开工了，后续工作怎么知道可以开工了呢？这个就是靠沟通协作了，这是一项很重要的工作。&lt;/p>
&lt;p>在并发编程领域里的同步，主要指的就是线程间的协作，本质上和现实生活中的协作没区别，不过是&lt;strong>一个线程执行完了一个任务，如何通知执行后续任务的线程开工&lt;/strong>而已。&lt;/p>
&lt;p>协作一般是和分工相关的。Java SDK 并发包里的 Executor、Fork/Join、Future 本质上都是分工方法，但同时也能解决线程协作的问题。例如，用 Future 可以发起一个异步调用，当主线程通过 get() 方法取结果时，主线程就会等待，当异步执行的结果返回时，get() 方法就自动返回了。主线程和异步线程之间的协作，Future 工具类已经帮我们解决了。除此之外，Java SDK 里提供的 CountDownLatch、CyclicBarrier、Phaser、Exchanger 也都是用来解决线程协作问题的。&lt;/p>
&lt;p>不过还有很多场景，是需要你自己来处理线程之间的协作的。&lt;/p>
&lt;p>工作中遇到的线程协作问题，基本上都可以描述为这样的一个问题：&lt;strong>当某个条件不满足时，线程需要等待，当某个条件满足时，线程需要被唤醒执行&lt;/strong>。例如，在生产者 - 消费者模型里，也有类似的描述，&amp;ldquo;当队列满时，生产者线程等待，当队列不满时，生产者线程需要被唤醒执行；当队列空时，消费者线程等待，当队列不空时，消费者线程需要被唤醒执行。&amp;rdquo;&lt;/p>
&lt;p>在 Java 并发编程领域，解决协作问题的核心技术是&lt;strong>管程&lt;/strong> ，上面提到的所有线程协作技术底层都是利用管程解决的。管程是一种解决并发问题的通用模型，除了能解决线程协作问题，还能解决下面我们将要介绍的互斥问题。可以这么说，&lt;strong>管程是解决并发问题的万能钥匙&lt;/strong>。&lt;/p>
&lt;p>所以说，这部分内容的学习，关键是理解管程模型，学好它就可以解决所有问题。其次是了解 Java SDK 并发包提供的几个线程协作的工具类的应用场景，用好它们可以妥妥地提高你的工作效率。&lt;/p>
&lt;h3 id="3-互斥">3. 互斥&lt;/h3>
&lt;p>分工、同步主要强调的是性能，但并发程序里还有一部分是关于正确性的，用专业术语叫&amp;rdquo;&lt;strong>线程安全&lt;/strong>&amp;quot;。并发程序里，当多个线程同时访问同一个共享变量的时候，结果是不确定的。不确定，则意味着可能正确，也可能错误，事先是不知道的。而导致不确定的主要源头是可见性问题、有序性问题和原子性问题，为了解决这三个问题，Java 语言引入了内存模型，内存模型提供了一系列的规则，利用这些规则，我们可以避免可见性问题、有序性问题，但是还不足以完全解决线程安全问题。解决线程安全问题的核心方案还是互斥。&lt;/p>
&lt;p>&lt;strong>所谓互斥，指的是同一时刻，只允许一个线程访问共享变量。&lt;/strong>&lt;/p>
&lt;p>实现互斥的核心技术就是锁，Java 语言里 synchronized、SDK 里的各种 Lock 都能解决互斥问题。虽说锁解决了安全性问题，但同时也带来了性能问题，那如何保证安全性的同时又尽量提高性能呢？可以分场景优化，Java SDK 里提供的 ReadWriteLock、StampedLock 就可以优化读多写少场景下锁的性能。还可以使用无锁的数据结构，例如 Java SDK 里提供的原子类都是基于无锁技术实现的。&lt;/p>
&lt;p>除此之外，还有一些其他的方案，原理是不共享变量或者变量只允许读。这方面，Java 提供了 Thread Local 和 final 关键字，还有一种 Copy-on-write 的模式。&lt;/p>
&lt;p>使用锁除了要注意性能问题外，还需要注意死锁问题。&lt;/p>
&lt;p>这部分内容比较复杂，往往还是跨领域的，例如要理解可见性，就需要了解一些 CPU 和缓存的知识；要理解原子性，就需要理解一些操作系统的知识；很多无锁算法的实现往往也需要理解 CPU 缓存。这部分内容的学习，需要博览群书，在大脑里建立起 CPU、内存、I/O 执行的模拟器。这样遇到问题就能得心应手了。&lt;/p>
&lt;p>跳出来，看全景，可以让你的知识成体系，所学知识也融汇贯通起来，由点成线，由线及面，画出自己的知识全景图。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/11/65/11e0c64618c04edba52619f41aaa3565.png" alt="">
并发编程全景图之思维导图&lt;/p>
&lt;h2 id="钻进去看本质">钻进去，看本质&lt;/h2>
&lt;p>但是光跳出来还不够，还需要下一步，就是在某个问题上钻进去，深入理解，找到本质。&lt;/p>
&lt;p>就拿我个人来说，我已经烦透了去讲述或被讲述一堆概念和结论，而不分析这些概念和结论是怎么来的，以及它们是用来解决什么问题的。在大学里，这样的教材很流行，直接导致了芸芸学子成绩很高，但解决问题的能力很差。其实，知其然知其所以然，才算真的学明白了。&lt;/p>
&lt;p>我属于理论派，&lt;strong>我认为工程上的解决方案，一定要有理论做基础&lt;/strong>。所以在学习并发编程的过程中，我都会探索它背后的理论是什么。比如，当看到 Java SDK 里面的条件变量 Condition 的时候，我会下意识地问，&amp;ldquo;它是从哪儿来的？是 Java 的特有概念，还是一个通用的编程概念？&amp;ldquo;当我知道它来自管程的时候，我又会问，&amp;ldquo;管程被提出的背景和解决的问题是什么？&amp;ldquo;这样一路探索下来，我发现 Java 语言里的并发技术基本都是有理论基础的，并且这些理论在其他编程语言里也有类似的实现。所以我认为，技术的本质是背后的理论模型。&lt;/p>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>当初我学习 Java 并发编程的时候，试图上来就看 Java SDK 的并发包，但是很快就放弃了。原因是我觉得东西太多，眼花缭乱的，虽然借助网络上的技术文章，感觉都看懂了，但是很快就又忘了。实际应用的时候大脑也一片空白，根本不知道从哪里下手，有时候好不容易解决了个问题，也不知道这个方案是不是合适的。&lt;/p>
&lt;p>我知道根本原因是，我的并发知识还没有成体系。&lt;/p>
&lt;p>我想，要让自己的知识成体系，一定要挖掘 Java SDK 并发包背后的设计理念。Java SDK 并发包是并发大师 Doug Lea 设计的，他一定不是随意设计的，一定是深思熟虑的，其背后是 Doug Lea 对并发问题的深刻认识。可惜这个设计的思想目前并没有相关的论文，所以只能自己琢磨了。&lt;/p>
&lt;p>分工、同步和互斥的全景图，是我对并发问题的个人总结，不一定正确，但是可以帮助我快速建立解决并发问题的思路，梳理并发编程的知识，加深认识。我将其分享给你，希望对你也有用。&lt;/p>
&lt;p>对于某个具体的技术，我建议你探索它背后的理论本质，理论的应用面更宽，一项优秀的理论往往在多个语言中都有体现，在多个不同领域都有应用。所以探求理论本质，既能加深对技术本身的理解，也能拓展知识深度和广度，这是个一举多得的方法。这方面，希望我们一起探讨，共同进步。&lt;/p>
&lt;p>欢迎在留言区跟我分享你的经历与想法。感谢阅读，如果你觉得这篇文章对你有帮助的话，也欢迎把它分享给更多的朋友。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/cf/aa/cf393cd748a4f0e6451807c4b61843aa.jpg" alt="">&lt;/p></description></item><item><title>极客专栏: 00丨开篇词丨别老想着怎么用好RPC框架，你得多花时间琢磨原理</title><link>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/rpc%E5%AE%9E%E6%88%98%E4%B8%8E%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/00%E4%B8%A8%E5%BC%80%E7%AF%87%E8%AF%8D%E4%B8%A8%E5%88%AB%E8%80%81%E6%83%B3%E7%9D%80%E6%80%8E%E4%B9%88%E7%94%A8%E5%A5%BDrpc%E6%A1%86%E6%9E%B6%E4%BD%A0%E5%BE%97%E5%A4%9A%E8%8A%B1%E6%97%B6%E9%97%B4%E7%90%A2%E7%A3%A8%E5%8E%9F%E7%90%86/</link><pubDate>Sat, 28 May 2022 00:00:00 +0000</pubDate><guid>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/rpc%E5%AE%9E%E6%88%98%E4%B8%8E%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/00%E4%B8%A8%E5%BC%80%E7%AF%87%E8%AF%8D%E4%B8%A8%E5%88%AB%E8%80%81%E6%83%B3%E7%9D%80%E6%80%8E%E4%B9%88%E7%94%A8%E5%A5%BDrpc%E6%A1%86%E6%9E%B6%E4%BD%A0%E5%BE%97%E5%A4%9A%E8%8A%B1%E6%97%B6%E9%97%B4%E7%90%A2%E7%A3%A8%E5%8E%9F%E7%90%86/</guid><description>
&lt;p>你好，我是何小锋。欢迎你和我一起学习 RPC。&lt;/p>
&lt;p>在专栏开始之前，我先简单介绍下自己。我是 1998 年从北航毕业的，毕业以后我就一直在一线编程写代码。2011 年，我正式加入京东，刚好赶上了京东的快速发展期，一路做到了现在的技术架构部首席架构师。盘点下在京东的这 9 年时间，我参加过 17 次大促备战，和我的技术团队一起见证了京东的技术演进过程。我也曾带领团队攻克过很多技术领域难题，包括自主研发微服务框架、高性能消息中间件、智能监控以及容器平台等等。&lt;/p>
&lt;p>近几年，我主攻分布式系统架构与设计，这也是我的专长所在。而在搭建分布式系统的过程中，我发现 RPC 总能充当较为关键的角色，它对整个分布式系统性能的提升起到了非常重要的作用。&lt;/p>
&lt;p>我期待通过这个专栏，能把我这些年积攒的一些有关 RPC 的实战经验分享给你。&lt;/p>
&lt;h1 id="为什么要学习-rpc">为什么要学习 RPC？&lt;/h1>
&lt;p>做任何事情都应该 Start with Why，那我们就先来说说为什么要学习 RPC。要回答这个问题，我们就得先考虑下 RPC 的实际应用场景。&lt;/p>
&lt;p>说到 RPC，可能你的第一反应就是&amp;quot;微服务&amp;quot;。RPC 最大的特点就是可以让我们像调用本地一样发起远程调用，这一特点常常会让人感觉 RPC 就是为&amp;quot;微服务&amp;quot;或 SOA 而生的。现在的大多数应用系统发展到一定规模之后，都会向&amp;quot;微服务化&amp;quot;演进，演进后的大型应用系统也的确是由一个个&amp;quot;微服务&amp;quot;组成的。&lt;/p>
&lt;p>我们可以说 RPC 是&amp;quot;微服务&amp;quot;的基础，这一点是毋庸置疑的。现在我们就可以反过来想这样一个问题&amp;mdash;&amp;mdash;RPC 是不是只应用在&amp;quot;微服务&amp;quot;中呢？&lt;/p>
&lt;p>**当然不是，只要涉及到网络通信，我们就可能用到 RPC。**一起看这样两个例子。&lt;/p>
&lt;p>例 1：大型分布式应用系统可能会依赖消息队列、分布式缓存、分布式数据库以及统一配置中心等，应用程序与依赖的这些中间件之间都可以通过 RPC 进行通信。比如 etcd，它作为一个统一的配置服务，客户端就是通过 gRPC 框架与服务端进行通信的。&lt;/p>
&lt;p>例 2：我们经常会谈到的容器编排引擎 Kubernetes，它本身就是分布式的，Kubernetes 的 kube-apiserver 与整个分布式集群中的每个组件间的通讯，都是通过 gRPC 框架进行的。&lt;/p>
&lt;p>所以说，RPC 的应用场景还是非常广泛的。既然应用如此广泛，那它的核心价值又在哪里呢？&lt;/p>
&lt;p>&lt;strong>在我看来，RPC 是解决分布式系统通信问题的一大利器。&lt;/strong>&lt;/p>
&lt;p>分布式系统中的网络通信一般都会采用四层的 TCP 协议或七层的 HTTP 协议，在我的了解中，前者占大多数，这主要得益于 TCP 协议的稳定性和高效性。网络通信说起来简单，但实际上是一个非常复杂的过程，这个过程主要包括：对端节点的查找、网络连接的建立、传输数据的编码解码以及网络连接的管理等等，每一项都很复杂。&lt;/p>
&lt;p>你可以想象一下，在搭建一个复杂的分布式系统过程中，如果开发人员在编码时要对每个涉及到网络通信的逻辑都进行一系列的复杂编码，这将是件多么恐怖的事儿。所以说，网络通信是搭建分布式系统的一个大难题，是一点不为过的，我们必须给予足够的重视。&lt;/p>
&lt;p>而 RPC 对网络通信的整个过程做了完整包装，在搭建分布式系统时，它会使网络通信逻辑的开发变得更加简单，同时也会让网络通信变得更加安全可靠。&lt;/p>
&lt;p>现在你是不是感觉到学好 RPC 是很有必要的？&lt;/p>
&lt;h1 id="如何学习-rpc">如何学习 RPC？&lt;/h1>
&lt;p>那我们应该怎么去学习 RPC 呢？&lt;/p>
&lt;p>其实，深刻了解了为什么之后，怎么学这个问题并不难找到答案。就我自己的经验来看，我觉得可以用&amp;quot;&lt;strong>逐步深入&lt;/strong>&amp;ldquo;这四个字来概括我的学习方式。&lt;/p>
&lt;p>说起来也特别简单。当我们认识到，使用 RPC 就可以像调用本地一样发起远程调用，用它可以解决通信问题，这时候我们肯定要去学序列化、编解码以及网络传输这些内容。&lt;/p>
&lt;p>把这些内容掌握后，你就会发现，原来这些只是 RPC 的基础，RPC 还有更吸引人的点，它真正强大的地方是它的治理功能，比如连接管理、健康检测、负载均衡、优雅启停机、异常重试、业务分组以及熔断限流等等。突然间，你会感觉自己走进了一个新世界，这些内容会成为你今后学习 RPC 的重点和难点。&lt;/p>
&lt;p>这个逐步深入的过程，一定离不开真实的实践场景。学习知识，解决问题，遇到新问题，继续学习，不断解决问题，最后你会发现自己的学习曲线大概是这样的。&lt;br>
&lt;img src="https://static001.geekbang.org/resource/image/74/8c/74539ca9da65ee0461ddb9299c277f8c.jpeg" alt="">&lt;/p>
&lt;p>总结一下，学习 RPC 时，我们先要了解其基本原理以及关键的网络通信部分，不要一味依赖现成的框架；之后我们再学习 RPC 的重点和难点，了解 RPC 框架中的治理功能以及集群管理功能等；这个时候你已经很厉害了，但这还不是终点，我们要对 RPC 活学活用，学会提升 RPC 的性能以及它在分布式环境下如何定位问题等等。&lt;/p>
&lt;h1 id="整个专栏能让你学到什么">整个专栏能让你学到什么？&lt;/h1>
&lt;p>上面提到的这些内容，就是我想通过这个专栏和你分享的。下面我来讲下本专栏的设计思路。&lt;/p>
&lt;p>我把整个专栏的内容分为了三大部分，分别是基础篇、进阶篇和高级篇。&lt;/p>
&lt;p>**基础篇：**重点讲解 RPC 的基础知识，包括 RPC 的基本原理以及它的基本功能模块，夯实基础之后，我们会以一场实战，通过剖析一款 RPC 框架来将知识点串联起来。&lt;/p>
&lt;p>**进阶篇：**重点讲解 RPC 框架的架构设计，以及 RPC 框架集群、治理相关的知识。这部分我会列举很多我在运营 RPC 框架中遇到的实际问题，以及这些问题的解决方案。&lt;/p>
&lt;p>**高级篇：**通过对上述两部分的学习，你已经对 RPC 有了较高层次的理解了。在这部分，我主要会从性能优化、线上问题排查以及一些比较有特色的功能设计上讲解 RPC 的应用。&lt;br>
&lt;img src="https://static001.geekbang.org/resource/image/d1/bf/d15af80828fc3a9da2fea7a1aa232dbf.jpg" alt="">&lt;/p>
&lt;p>整个专栏跟下来，虽然主要讲解的都是 RPC 相关的知识，但你会接触到很多的案例和解决方案，它们首先会使你对 RPC 的理解到达一个较高的层次；其次就是这些知识和解决方案会有相通性，只要你能举一反三，对你今后的工作就会有很大的帮助。&lt;/p>
&lt;p>最后，我也很想听听你的想法。我们可以在留言区认识一下，期待你和我讲讲你的工作经历，你对 RPC 的认识，以及学习它的痛点、难点，我也好有针对性地为你讲解。现在，就让我们共同开启这段学习之旅吧！&lt;/p></description></item><item><title>极客专栏: 00丨开篇词丨这一次，我们从“丑”代码出发</title><link>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E4%BB%A3%E7%A0%81%E4%B9%8B%E4%B8%91/00%E4%B8%A8%E5%BC%80%E7%AF%87%E8%AF%8D%E4%B8%A8%E8%BF%99%E4%B8%80%E6%AC%A1%E6%88%91%E4%BB%AC%E4%BB%8E%E4%B8%91%E4%BB%A3%E7%A0%81%E5%87%BA%E5%8F%91/</link><pubDate>Sat, 28 May 2022 00:00:00 +0000</pubDate><guid>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E4%BB%A3%E7%A0%81%E4%B9%8B%E4%B8%91/00%E4%B8%A8%E5%BC%80%E7%AF%87%E8%AF%8D%E4%B8%A8%E8%BF%99%E4%B8%80%E6%AC%A1%E6%88%91%E4%BB%AC%E4%BB%8E%E4%B8%91%E4%BB%A3%E7%A0%81%E5%87%BA%E5%8F%91/</guid><description>
&lt;p>你好，我是郑晔！我又回来了！&lt;/p>
&lt;p>我在&amp;quot;极客时间&amp;quot;里已经写了两个专栏，分别是《10x 程序员工作法》和《软件设计之美》，从工作原则和设计原则两个方面对软件开发的各种知识进行了探讨，帮助你搭建了一个开启程序员精进之路的框架。&lt;/p>
&lt;p>不过，无论懂得多少道理，程序员依然要回归到写代码的本职工作上。所以，这次我准备和你从代码的坏味道出发，一起探讨如何写代码。&lt;/p>
&lt;h1 id="千里之堤毁于蚁穴">千里之堤毁于蚁穴&lt;/h1>
&lt;p>为什么要讲这个话题，就让我们先从一次代码评审讲起。在一次代码评审中，我注意到了这样一段代码：&lt;/p>
&lt;pre tabindex="0">&lt;code>public void approve(final long bookId) {
...
book.setReviewStatus(ReviewStatus.APPROVED);
...
}
&lt;/code>&lt;/pre>&lt;p>这是在一个服务类里面写的，它的主要逻辑就是从仓库中找出一个作品，然后，将它的状态设置为审核通过，再将它存回去。前后的代码都属于常规的代码，但是，设置作品评审状态的代码引起了我的注意，于是有了下面这段对话。&lt;/p>
&lt;blockquote>
&lt;p>我：这个地方为什么要这么写？
同事：我要将作品的审核状态设置为审核通过。
我：这个我知道，但为什么要在这里写 setter 呢？
同事：你的意思是？
我：这个审核的状态是作品的一个内部状态，为什么服务需要知道它呢？也就是说，这里通过 setter，将一个类的内部行为暴露了出来，这是一种破坏封装的做法。&lt;/p>
&lt;/blockquote>
&lt;p>同事被我说动了，于是这段代码变成了下面这个样子：&lt;/p>
&lt;pre tabindex="0">&lt;code>public void approve(final long bookId) {
...
book.approve();
...
}
&lt;/code>&lt;/pre>&lt;p>之所以我注意到这段代码，完全是因为这里用到了 setter。在我看来，setter 就是一个坏味道，每次一看到 setter，我就会警觉起来。&lt;/p>
&lt;p>setter 的出现，是对于封装的破坏，它把一个类内部的实现细节暴露了出来。我在《软件设计之美》中讲过，面向对象的封装，关键点是行为，而使用 setter 多半只是做了数据的聚合，缺少了行为的设计，这段代码改写后的 approve 函数，就是这里缺少的行为。&lt;/p>
&lt;p>再扩展一步，setter 通常还意味着变化，而我在《软件设计之美》中讲函数式编程时也说过，一个好的设计应该尽可能追求不变性。所以，setter 也是一个提示符，告诉我们，这个地方的设计可能有问题。&lt;/p>
&lt;p>你看，一个小小的 setter，背后却隐藏着这么多的问题。而所有这些问题，都会让代码在未来的日子变得更加不可维护，这就是软件团队陷入泥潭的开始。&lt;/p>
&lt;p>我也一直和我团队的同学说，&amp;ldquo;写代码&amp;quot;有两个维度：正确性和可维护性，不要只关注正确性。能把代码写对，是每个程序员的必备技能，&lt;strong>但能够把代码写得更具可维护性，这是一个程序员从业余迈向职业的第一步&lt;/strong>。&lt;/p>
&lt;h1 id="将坏味道重构为整洁代码">将坏味道重构为整洁代码&lt;/h1>
&lt;p>或许你也认同代码要有可维护性，也看了很多书，比如《程序设计实践》《代码整洁之道》等等，这些无一不是经典中的经典，甚至连怎么改代码，都有《重构》等着我们。没错，这些书我都读过，也觉得从中受益匪浅。&lt;/p>
&lt;p>不过，回到真实的工作中，我发现了一个无情的事实：&lt;strong>程序员们大多会认同这些书上的观点，但每个人对于这些观点的理解却是千差万别的。&lt;/strong>&lt;/p>
&lt;p>比如书上说：&amp;ldquo;命名是要有意义的&amp;rdquo;，但什么样的命名才算是有意义的呢？有的人只理解到不用 xyz 命名，虽然他起出了自认为&amp;quot;有意义&amp;quot;的名字，但这些名字依然是难以理解的。事实上，大部分程序员在真实世界中面对的代码，就是这样难懂的代码。&lt;/p>
&lt;p>这是因为，&lt;strong>很多人虽然知道正面的代码是什么样子，却不知道反面的代码是什么样子&lt;/strong>。这些反面代码，Martin Fowler 在《重构》这本书中给起了一个好名字，代码的坏味道（Bad Smell）。&lt;/p>
&lt;p>在我写代码的这 20 多年里，一直对代码的坏味道非常看重，因为它是写出好代码的起点。有对代码坏味道的嗅觉，能够识别出坏味道，接下来，你才有机会去&amp;quot;重构（Refactoring）&amp;quot;，把代码一点点打磨成一个整洁的代码（Clean Code）。Linux 内核开发者 Linus Torvalds 在行业里有个爱骂人的坏名声，原因之一就是他对于坏味道的不容忍。&lt;/p>
&lt;p>所以，我也推荐那些想要提高自己编程水平的人读《重构》，如果时间比较少，就去读第三章&amp;quot;代码的坏味道&amp;rdquo;。&lt;/p>
&lt;p>不过，《重构》中的&amp;quot;代码的坏味道&amp;quot;意图虽好，但却需要一个人对于整洁代码有着深厚的理解，才能识别出这些坏味道。否则，即使你知道有哪些坏味道，但真正有坏味道的代码出现在你面前时，你仍然无法认得它。&lt;/p>
&lt;p>比如，你可以看看 Info、Data、Manager 是不是代码库经常使用的词汇，而它们往往是命名没有经过仔细思考的地方。在很多人眼中，这些代码是没有问题的。正因如此，才有很多坏味道的代码才堂而皇之地留在你的眼皮底下。&lt;/p>
&lt;p>所以，我才想做一个讲坏味道的专栏，把最常见的坏味道直接用代码形式展现出来。在这个专栏里，我给你的都是即学即用的&amp;quot;坏味道&amp;quot;，我不仅会告诉你典型的坏味道是什么，而且也能让你在实际的编程过程中发现它们。比如前面那个例子里面的 setter，只要它一出现，你就需要立即警觉起来。&lt;/p>
&lt;p>这里我也整理了一份&amp;quot;坏味道自查表&amp;quot;，把一些明显的&amp;quot;坏味道&amp;quot;信号列了出来，你可以和自己的代码做对比。&lt;br>
&lt;img src="https://static001.geekbang.org/resource/image/2e/f1/2e543283f04aa3706d60a7b1e0f257f1.jpg" alt="">&lt;/p>
&lt;p>除了为你列出来哪些代码有坏味道之外，我还会给你讲支撑这些&amp;quot;坏味道&amp;quot;之所以为&amp;quot;坏味道&amp;quot;的原因，比如说：长方法和大类之所以为坏味道，因为它们都违背了单一职责的原则。&lt;/p>
&lt;p>有坏味道的代码需要经过重构才能长成新的样子，在这个专栏里，我也会提到一些重构的手法，比如，改名（Rename）、提取方法（Extract Method）等等。在今天，拜许多能力强大的 IDE 所赐，重构已经变得越来越自动化，《重构》里的很多手法已经成为了 IDE 中的一个选项。&lt;/p>
&lt;p>我还想给你一个安全提示，即便 IDE 功能再强大，也不要忘了重构的重要根基：测试。即便像 Java 这样，IDE 功能已经非常强大了，依然会有一些像反射之类的场景可能会从自动化重构的鼻子底下溜走。所以，重构一段代码之前，最好能够给它写下测试，确保改动前后的代码，功能上是一致的。&lt;/p>
&lt;p>如果你订阅过我的《10x 程序员工作法》和《软件设计之美》，你就会发现，三个专栏一脉相承，这些背后的道理恰恰就是我在那两个专栏中已经提到过的内容。所以，三个专栏一并服用，效果会更佳。&lt;/p>
&lt;h1 id="写在最后">写在最后&lt;/h1>
&lt;p>最后，还是要做一个自我介绍。我叫郑晔，一个写代码超过二十年的程序员，做过与软件开发的各种工作：编代码、带团队、做咨询、写开源。正如前面所说，我已经在极客时间平台上写了两个专栏，分享我在软件开发中的各种思考。这次，我会带你进入到我的基本功里，帮你一起写好代码。&lt;/p>
&lt;p>十年前，我在 InfoQ 写过一个专栏《代码之丑》，把一些真实世界的代码展示了出来，让大家看到丑陋代码是什么样子的。&lt;/p>
&lt;p>不少读者都表示，那个专栏让他们受益匪浅。不过，那个系列只是我日常工作的随手之作，没有更好地整理。这个专栏就是脱胎于 InfoQ 上的《代码之丑》，我对相关内容进行了更系统地整理，保证即便看过那个《代码之丑》专栏，你依然能够在这里有所收获。&lt;/p>
&lt;p>这是一条通往代码精进之路，我愿意与你一起前行，成为你在这条路上的向导。如果你想摆脱平庸的小白程序员状态，成为一个更优秀的程序员，那么，请加入我的专栏，让我们一起修炼，日益精进写代码的手艺！&lt;/p></description></item><item><title>极客专栏: 00丨开篇词丨从今天起，跨过“数据结构与算法”这道坎</title><link>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/00%E4%B8%A8%E5%BC%80%E7%AF%87%E8%AF%8D%E4%B8%A8%E4%BB%8E%E4%BB%8A%E5%A4%A9%E8%B5%B7%E8%B7%A8%E8%BF%87%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%BF%99%E9%81%93%E5%9D%8E/</link><pubDate>Fri, 27 May 2022 00:00:00 +0000</pubDate><guid>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/00%E4%B8%A8%E5%BC%80%E7%AF%87%E8%AF%8D%E4%B8%A8%E4%BB%8E%E4%BB%8A%E5%A4%A9%E8%B5%B7%E8%B7%A8%E8%BF%87%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%BF%99%E9%81%93%E5%9D%8E/</guid><description>
&lt;p>你好，我是王争，毕业于西安交通大学计算机专业。现在回想起来，本科毕业的时候，我的编程水平其实是很差的。直到读研究生的时候，一个师兄给了我一本《算法导论》，说你可以看看，对你的编程会很有帮助。&lt;/p>
&lt;p>没想到，从此我对算法的&amp;quot;迷恋&amp;quot;便一发不可收拾。之后，我如饥似渴地把图书馆里几乎所有数据结构和算法书籍都读了一遍。&lt;/p>
&lt;p>我常常边读边练。没多久，我就发现，写代码的时候，我会不由自主考虑很多性能方面的问题。我写出时间复杂度高、空间复杂度高的垃圾代码越来越少了，算法能力提升了很多，编程能力也有了质的飞跃。得益于此，研究生毕业后，我直接进入 Google，从事 Google 翻译相关的开发工作。&lt;/p>
&lt;p>这是我自己学习数据结构与算法的经历，现在，你可以想想你的情况。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>是不是从学校开始，你就觉得数据结构难学，然后一直没认真学？&lt;/p>
&lt;/li>
&lt;li>
&lt;p>工作中，一遇到数据结构这个坑，你又发自本能地迅速避让，因为你觉得自己不懂，所以也不想深究，反正看起来无关大局？&lt;/p>
&lt;/li>
&lt;li>
&lt;p>当你想换工作面试，或者研究某个开源项目源码，亦或者和团队讨论某个非框架层面的高可用难题的时候，你又发现，自己的基础跟不上别人的节奏？&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>如果你是这种情况，其实你并不孤独，这不是你一个人遇到的问题。工作十年间，我见过许多程序员。他们有着各种各样的背景，有很多既有潜力又非常努力，但始终无法在自己现有水平上更进一步。&lt;/p>
&lt;p>在技术圈里，我们经常喜欢谈论高大上的架构，比如高可用、微服务、服务治理等等。鲜有人关注代码层面的编程能力，而愿意沉下心来，花几个月时间啃一啃计算机基础知识、认认真真夯实基础的人，简直就是凤毛麟角。&lt;/p>
&lt;p>我认识一位原来腾讯 T4 的技术大牛。在区块链大潮之前，他在腾讯工作了 10 多年，长期负责手机 QQ 后台整体建设。他经历了手机 QQ 从诞生到亿级用户在线的整个过程。后来他去了微众银行，有一天老板让他去做区块链。&lt;strong>他用了不到半年时间，就把区块链的整个技术脉络摸清楚了。&lt;/strong> 现在，他是微众银行的区块链负责人，微众科技创新产品部的老总。你说厉害不？你可以花半年时间就能精通一个新的领域吗？为什么他就可以做到？&lt;/p>
&lt;p>我觉得这其中最重要的就是基础足够扎实。他曾经跟我说，像区块链、人工智能这些看似很新的技术，其实一点儿都不&amp;quot;新&amp;quot;。最初学编程的时候，他就把那些基础的知识都学透了。当面临行业变动、新技术更迭的时候，他不断发现，那些所谓的新技术，核心和本质的东西其实就是当初学的那些知识。掌握了这个&amp;quot;规律&amp;quot;之后，他学任何东西都很快，任何新技术都能快速迎头赶上。这就是他快速学习并且获得成功的秘诀。&lt;/p>
&lt;p>所以说，&lt;strong>基础知识就像是一座大楼的地基，它决定了我们的技术高度。而要想快速做出点事情，前提条件一定是基础能力过硬，&amp;ldquo;内功&amp;quot;要到位&lt;/strong>。&lt;/p>
&lt;p>那技术人究竟都需要修炼哪些&amp;quot;内功&amp;quot;呢？我觉得，无外乎就是大学里的那些基础课程，操作系统、计算机网络、编译原理等等，当然还有数据结构和算法。&lt;/p>
&lt;p>可是，我们都知道，像《算法导论》这些经典书籍，虽然很全面，但是过于理论，学起来非常枯燥；而市面很多课程大多缺失真实的开发场景，费劲学完感觉好像还是用不上，过不了几天就忘了。&lt;/p>
&lt;p>所以，我尝试做一个让你能真正受用的数据结构与算法课程，希望给你指明一个简洁、高效的学习路径，教你一个学习基础知识的通用方法 。那么，关于专栏内容，我是怎样设计的呢？&lt;/p>
&lt;ol>
&lt;li>
&lt;p>我根据自己研读数十本算法书籍和多年项目开发的经验，在众多的数据结构和算法中，精选了最实用的内容进行讲解。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>我不只会教你怎么用，还会告诉你，我们为什么需要这种数据结构和算法，一点点帮你捋清它们背后的设计思想，培养你举一反三的能力。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>对于每种数据结构和算法，我都会结合真实的软件开发案例来讲解，让你知道，数据结构和算法，究竟应该如何应用到实际的编码中。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>为了&lt;strong>由浅入深&lt;/strong> 地带你学习，我把专栏分成四个&lt;strong>递进&lt;/strong>的模块。&lt;/p>
&lt;ol>
&lt;li>&lt;strong>入门篇&lt;/strong>&lt;/li>
&lt;/ol>
&lt;p>时间、空间复杂度分析是数据结构和算法中非常重要的知识点，贯穿整个专栏的学习过程。但同时也是比较难掌握的，所以我用了 2 节课来讲这部分内容，而且还举了大量的实例，让你一边学一边练，真正能掌握复杂度分析，为后面的学习铺路。&lt;/p>
&lt;p>我希望通过这一模块，你能掌握时间、空间复杂度的概念，大 O 表示法的由来，各种复杂度分析技巧，以及最好、最坏、平均、均摊复杂度分析方法。之后，面对任何代码的复杂度分析，你都能游刃有余、毫不畏惧！&lt;/p>
&lt;ol start="2">
&lt;li>&lt;strong>基础篇&lt;/strong>&lt;/li>
&lt;/ol>
&lt;p>这部分是专栏中篇幅最大的内容，也是我们学习的重点，共有 26 节内容，涵盖了最基础、最常用的数据结构和算法。针对每种数据结构和算法，我都会结合具体的软件开发实例，由浅入深进行讲解，并适时总结一些实用&amp;quot;宝典&amp;rdquo;，保证你印象深刻、学有所用。&lt;/p>
&lt;p>比如递归这一节，我会讲到，为什么递归代码比较难写？如何避免堆栈溢出？如何避免递归冗余计算？如何将递归代码转化为非递归代码？&lt;/p>
&lt;ol start="3">
&lt;li>&lt;strong>高级篇&lt;/strong>&lt;/li>
&lt;/ol>
&lt;p>这部分我会讲一些不是那么常用的数据结构和算法。虽然不常用，但是这些内容你也需要知道。设置这一部分的目的，是为了让你开拓视野，强化训练算法思维、逻辑思维。如果说学完基础部分可以考 80 分，那掌握这一部分就能让你成为尖子生！&lt;/p>
&lt;ol start="4">
&lt;li>&lt;strong>实战篇&lt;/strong>&lt;/li>
&lt;/ol>
&lt;p>我们整个专栏都是围绕数据结构和算法在具体软件实践中的应用来讲的，所以最后我会通过实战部分串讲一下前面讲到的数据结构和算法。我会拿一些开源项目、框架或者系统设计问题，剖析它们背后的数据结构和算法，让你有一个更加直观的感受。&lt;/p>
&lt;p>人生路上，我们会遇到很多的坎。跨过去，你就可以成长，跨不过去就是困难和停滞。而在后面很长的一段时间里，你都需要为这个困难买单。对于我们技术人来说，更是这样。&lt;strong>既然数据结构和算法这个坎，我们总归是要跨过去，为什么不是现在呢？&lt;/strong>&lt;/p>
&lt;p>我很感激师兄当年给我的那本《算法导论》，这是我人生中为数不多的转折点之一。没有那本书，也可能就没有今天的我。我希望这个专栏也能成为你的一个人生转折点。&lt;/p>
&lt;p>我希望，通过这个专栏，不仅能帮你跨过数据结构与算法这个坎，还能帮你掌握一种学习知识和技能的方法，帮你度过职场甚至人生的重要时刻！一起加油吧！&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/8e/d3/8e603e3d795fc0ab2698f6f5eabf14d3.jpg" alt="">&lt;/p></description></item><item><title>极客专栏: 00丨开篇词丨洞悉技术的本质，享受科技的乐趣</title><link>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E/00%E4%B8%A8%E5%BC%80%E7%AF%87%E8%AF%8D%E4%B8%A8%E6%B4%9E%E6%82%89%E6%8A%80%E6%9C%AF%E7%9A%84%E6%9C%AC%E8%B4%A8%E4%BA%AB%E5%8F%97%E7%A7%91%E6%8A%80%E7%9A%84%E4%B9%90%E8%B6%A3/</link><pubDate>Fri, 27 May 2022 00:00:00 +0000</pubDate><guid>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E/00%E4%B8%A8%E5%BC%80%E7%AF%87%E8%AF%8D%E4%B8%A8%E6%B4%9E%E6%82%89%E6%8A%80%E6%9C%AF%E7%9A%84%E6%9C%AC%E8%B4%A8%E4%BA%AB%E5%8F%97%E7%A7%91%E6%8A%80%E7%9A%84%E4%B9%90%E8%B6%A3/</guid><description>
&lt;p>你好，我是陈皓，网名左耳朵耗子。我目前在创业，MegaEase 是我的公司，致力于为企业提供高可用、高并发、高性能的分布式技术产品，同时也提供物联网（IoT）方向的技术产品。&lt;/p>
&lt;p>我之前在阿里巴巴、亚马逊、汤森路透等公司任职，职业背景是金融和电子商务行业，主要研究的技术方向是一些大规模分布式系统的基础架构。&lt;/p>
&lt;p>从大学毕业一直做技术工作，到今天有 20 年了，还在写代码，因为我对技术有很大的热情。我从 2002 年开始写技术博客，到 2009 年左右开始在独立的域名 &lt;a href="http://CoolShell.cn">CoolShell.cn&lt;/a>（酷壳）上分享我对技术的一些见解和心得。&lt;/p>
&lt;p>本来只想记录一下，没想到得到了很多人的认可，这对我来说是一个不小的鼓励。我的文章和分享始终坚持观点鲜明的特点，因为我希望可以引发大家的讨论和批评，这样分享才更有意义。&lt;/p>
&lt;p>无论我的观点是否偏激、不成熟，或者言辞犀利，在经历过大家的批评和讨论后，我都能够从中得到不在我视角内的思考和认知，这对我来说是非常重要的补充，对我的个人成长非常重要。&lt;/p>
&lt;p>我相信，看到这些文章和讨论的人，也能从中收获到更多的东西。&lt;/p>
&lt;p>坦率地讲，刚收到专栏撰写邀请的时候，我心里面是拒绝的。正如前面所说的，我分享的目的是跟大家交流和讨论，我认为，全年付费专栏这样的方式可能并不好。而且，付费专栏还有文章更新频率的 KPI，这对于像我这样一定要有想法才会写文章的人来说是很痛苦的，因为我不想为了写而写。&lt;/p>
&lt;p>所以，最初，我是非常不情愿的。&lt;/p>
&lt;p>极客邦科技的编辑跟我沟通过很多次，也问过我是否在做一些收费的咨询或是培训，并表明这个专栏就是面对这样的场景的。我想想也是。我其实从 2003 年就开始为很多企业做内部的培训和分享了。&lt;/p>
&lt;p>这些培训涵盖了很多方面，如软件团队管理、架构技术、编程语言、操作系统等，以及一些为企业量身定制的咨询或软件开发，这些都是收费的。&lt;/p>
&lt;p>而我一直以来也没有把这些内容分享在我的博客里，主要原因是我觉得这些内容是有商业价值的，是适合收费的。它们都是实实在在的，是我多年来对实战经验的深入总结和思考，非常来之不易。&lt;/p>
&lt;p>我不太舍得拿出来大范围地分享，以前基本上仅小范围地在企业内部比较封闭的环境里讲讲。所以说，我这边其实是有两种分享，一种是企业内的分享，一种则是像 CoolShell 或是大会这样的公开分享。&lt;/p>
&lt;p>前者更企业化一些，后者更通俗化一些。&lt;/p>
&lt;p>在这个付费专栏中，除了继续保持观点鲜明的行文风格，我会分享一些与个人或企业切身利益更为相关的内容，或者说更具指导性、更有商业价值的东西。而 CoolShell，我还会保持现有的风格继续写下去。&lt;/p>
&lt;p>正如这个专栏的 Slogan 所说：&amp;ldquo;洞悉技术的本质，享受科技的乐趣&amp;rdquo;，我会在这个专栏里分享包括但不限于如下这些内容。&lt;/p>
&lt;h1 id="技术">技术&lt;/h1>
&lt;p>对于技术方面，我不会写太多关于知识点的东西，因为这些知识点你可以自行 Google 可以 RTFM。我要写的一定是以体系化的，而且要能直达技术的本质。入行这 20 年来，我最擅长的就是架构和开发各种大规模的系统，所以，我会有 2-3 个和分布式系统相关的系列文章。&lt;/p>
&lt;p>我学过也用过好多编程语言，所以，也会有一系列的关于编程本质的文章。而我对一些基础知识研究得也比较多，所以，还会有一系列与基础知识相关的文章。&lt;/p>
&lt;p>当然，其中还会穿插一些其它的技术文章，比如一些热点事件，还有一些经验之谈，包括我会把我的《程序员技术练级攻略》在这个专栏里重新再写一遍。这些东西一定会让你有醍醐灌顶的感觉。&lt;/p>
&lt;h1 id="成长">成长&lt;/h1>
&lt;p>在过去这 20 年中，我感觉到，很多人都非常在意自己的成长。所以，我会分享一堆我亲身经历的，也是我自己实验的与个人发展相关的文章。&lt;/p>
&lt;p>比如，如何利用技术变现、如何面试、如何选择新的技术、如何学习、如何管理自己的时间、如何管理自己的老板和工作、如何成为一个 Leader&amp;hellip;&amp;hellip;这些东西一定会对你有用。（但是，我这里一定不会有速成的东西。一切都是要花时间和精力的。如果你想要速成，你不应该来订阅我的专栏。）&lt;/p>
&lt;h1 id="管理">管理&lt;/h1>
&lt;p>这 20 年，我觉得做好技术工作的前提是，得做好技术的管理工作。只有管理好了软件工程和技术团队，技术才能发挥出最大的潜力。大多数的技术问题都是管理上的问题。&lt;/p>
&lt;p>所以，我会写上一系列的和管理相关的文章，涵盖管理三个要素：团队、项目和管理者自己。比如，人员招聘、绩效考核、提升士气、解决冲突、面对变化、沟通说服、项目管理、任务排期、会议、远程管理，等等。&lt;/p>
&lt;p>这些内容都是我在外企工作时，接受到的世界顶级管理培训机构培训内容，我会把我的实践写出来分享给你。这其中一定少不了亚马逊相关的各种实践。这些东西，我和很多公司和大佬都讲过，到目前为止还没有人不赞的。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/7f/7b/7f428c8dd8f26668a727bd46227ec17b.jpg" alt="">&lt;/p>
&lt;p>为了对付费用户负责，保证文章能够达到收费的质量，我承诺这个专栏的每一篇文章一定是用心创作的，而且是可以让你从中受益的。&lt;/p>
&lt;p>但因为是第一次做全年专栏，收费也让我有一定的压力，所以，我非常希望你能够跟我分享你的感受和体会。&lt;/p>
&lt;p>我会根据你的反馈及时做出调整和修正，并不断努力提高文章的质量和思想高度，以满足你对有价值、有营养的文章的需求。&lt;/p></description></item><item><title>极客专栏: 00丨开篇词丨这一次，让我们一起来搞懂MySQL</title><link>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/mysql-%E5%AE%9E%E6%88%98-45-%E8%AE%B2/00%E4%B8%A8%E5%BC%80%E7%AF%87%E8%AF%8D%E4%B8%A8%E8%BF%99%E4%B8%80%E6%AC%A1%E8%AE%A9%E6%88%91%E4%BB%AC%E4%B8%80%E8%B5%B7%E6%9D%A5%E6%90%9E%E6%87%82mysql/</link><pubDate>Fri, 27 May 2022 00:00:00 +0000</pubDate><guid>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/mysql-%E5%AE%9E%E6%88%98-45-%E8%AE%B2/00%E4%B8%A8%E5%BC%80%E7%AF%87%E8%AF%8D%E4%B8%A8%E8%BF%99%E4%B8%80%E6%AC%A1%E8%AE%A9%E6%88%91%E4%BB%AC%E4%B8%80%E8%B5%B7%E6%9D%A5%E6%90%9E%E6%87%82mysql/</guid><description>
&lt;p>你好，我是林晓斌，网名&amp;quot;丁奇&amp;quot;，欢迎加入我的专栏，和我一起开始 MySQL 学习之旅。我曾先后在百度和阿里任职，从事 MySQL 数据库方面的工作，一步步地从一个数据库小白成为 MySQL 内核开发人员。回想起来，从我第一次带着疑问翻 MySQL 的源码查到答案至今，已经有十个年头了。在这个过程中，走了不少弯路，但同时也收获了很多的知识和思考，希望能在这个专栏里分享给你。&lt;/p>
&lt;p>记得刚开始接触 MySQL，是我在百度贴吧做权限系统的时候。我们遇到了一个奇怪的问题，一个正常 10 毫秒就能完成的 SQL 查询请求偶尔要执行 100 多毫秒才结束。当时主管问我是什么原因，我其实也搞不清楚，就上网查答案，但怎么找都找不到，又脸皮薄不想说自己不知道，只好硬着头皮翻源码。后来遇到了越来越多的问题，也是类似的情景，所以我逐步养成了通过分析源码理解原理的习惯。&lt;/p>
&lt;p>当时，我自己的感觉是，即使我只是一个开发工程师，只是 MySQL 的用户，在了解了一个个系统模块的原理后，再来使用它，感觉是完全不一样的。当在代码里写下一行数据库命令的时候，我就能想到它在数据库端将怎么执行，它的性能是怎么样的，怎样写能让我的应用程序访问数据库的性能最高。进一步，哪些数据处理让数据库系统来做性能会更好，哪些数据处理在缓存里做性能会更好，我心里也会更清楚。在建表和建索引的时候，我也会更有意识地为将来的查询优化做综合考虑，比如确定是否使用递增主键、主键的列怎样选择，等等。&lt;/p>
&lt;p>但随后我又有了一个新的困惑，我觉得自己了解的 MySQL 知识点是零散的，没有形成网络。于是解决完一个问题后，很容易忘记。再碰到类似的问题，我又得再翻一次代码。&lt;/p>
&lt;p>所幸在阿里工作的时候，我参与了阿里云关系型数据库服务内核的开发，并且负责开发开源分支 AliSQL，让我对 MySQL 内核和源码有了更深层次的研究和理解。在服务内部客户和公有云客户的过程中，我有机会面对和解决足够多的问题，再通过手册进行系统的学习，算是比较坎坷地将 MySQL 的知识网络补了起来。&lt;/p>
&lt;p>所以，在回顾这个过程的时候，我的第一个感受是，如果一开始就有一些从理论到实战的系统性指导，那该多好啊，也许我可以学习得更快些。&lt;/p>
&lt;p>在极客时间团队跟我联系策划这个专栏的时候，我还是持怀疑态度的。为什么呢？现在不比当年了，犹记得十余年前，你使用 MySQL 的过程中碰到问题的话，基本上都只能到代码里去找答案，因为那时网上的资料太少了。&lt;/p>
&lt;p>而近十年来，MySQL 在中国广泛普及，技术分享文章可以说是浩如烟海。所以，现在要系统地介绍一遍 MySQL 的话，恐怕里面提及的大多数知识点，都可以在社区文章中找到。那么我们做这个专栏的意义在哪里，而它又凭什么可以收费呢？&lt;/p>
&lt;p>直到收到极客时间团队的答复，我才开始对这个专栏&amp;quot;想做和可以做&amp;quot;的事情感觉清晰起来。数据库是一个综合系统，其背后是发展了几十年的数据库理论。同时，数据库系统也是一个应用系统，可能一个业务开发人员用了两三年 MySQL，还未必清楚那些自己一直在用的&amp;quot;最佳实践&amp;quot;为什么是最佳的。&lt;/p>
&lt;p>于是，我希望这个专栏能够帮助这样的一些开发者：他们正在使用 MySQL，知道如何写出逻辑正确的 SQL 语句来实现业务目标，却不确定这个语句是不是最优的；他们听说了一些使用数据库的最佳实践，但是更想了解为什么这么做；他们使用的数据库偶尔会出问题，亟需了解如何更快速、更准确地定位问题，甚至自己解决问题&amp;hellip;&amp;hellip;&lt;/p>
&lt;p>在过去的七年里，我带过十几个应届毕业生，看着他们成长，要求他们原理先行，再实践验证。几年下来，他们的成长速度都很快，其中好几个毕业没两年就成为团队的骨干力量了。我也在社招的时候面试过很多有着不错的运维实践经验和能力的候选人，但都因为对数据库原理仅有一知半解的了解，而最终遗憾地没有通过面试。&lt;/p>
&lt;p>因此，我希望这个专栏能够激发开发者对数据库原理的探索欲，从而更好地理解工作中遇到的问题，更能知道背后的为什么。所以&lt;strong>我会选那些平时使用数据库时高频出现的知识，如事务、索引、锁等内容构成专栏的主线&lt;/strong>。这些主线上是一个个的知识点。每个点就是一个概念、一个机制或者一个原理说明。在每个说明之后，我会和你讨论一个实践相关的问题。&lt;/p>
&lt;p>希望能以这样的方式，让你对 MySQL 的几条主线有一个整体的认识，并且了解基本概念。在之后的实践篇中，我会引用到这些主线的知识背景，并着力说明它们是怎样指导实践的。这样，&lt;strong>你可以从点到线，再到面，形成自己的 MySQL 知识网络。&lt;/strong>&lt;/p>
&lt;p>在这里，有一份目录，你也可以先了解下整个专栏的知识结构。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/a7/7e/a78db0b99bbf1149c39b7960f7183c7e.jpg" alt="">&lt;/p>
&lt;p>如前面说的，这几条主线上的每个知识点几乎都不是最新的，有些甚至十年前就这样，并没有改过。但我希望针对这些点的说明，可以让你在使用 MySQL 时心里更有底，知道怎么做选择，并且明白为什么。了解了原理，才能在实践中不断创新，提升个人的价值和工作输出。&lt;/p>
&lt;p>从这里开始，跟我一起搞懂 MySQL!&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/ce/d9/ce7f4e35916ed1aa49206a53a0547bd9.jpg" alt="">&lt;/p></description></item><item><title>极客专栏: 01丨“老周，我想知道”丨常见法律认知盲区（一）</title><link>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E7%99%BD%E8%AF%9D%E6%B3%95%E5%BE%8B/01%E4%B8%A8%E8%80%81%E5%91%A8%E6%88%91%E6%83%B3%E7%9F%A5%E9%81%93%E4%B8%A8%E5%B8%B8%E8%A7%81%E6%B3%95%E5%BE%8B%E8%AE%A4%E7%9F%A5%E7%9B%B2%E5%8C%BA%E4%B8%80/</link><pubDate>Tue, 07 Jun 2022 00:00:00 +0000</pubDate><guid>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E7%99%BD%E8%AF%9D%E6%B3%95%E5%BE%8B/01%E4%B8%A8%E8%80%81%E5%91%A8%E6%88%91%E6%83%B3%E7%9F%A5%E9%81%93%E4%B8%A8%E5%B8%B8%E8%A7%81%E6%B3%95%E5%BE%8B%E8%AE%A4%E7%9F%A5%E7%9B%B2%E5%8C%BA%E4%B8%80/</guid><description>
&lt;p>在学习三大主题之前，我想先帮你扫除一些常识上的盲区，所以选取了以往咨询者最迷惑的十个问题，并给出了相应的解答。接下来我们来看这些问答。&lt;/p>
&lt;p>&lt;strong>第一问：到法院打官司最重要的是找关系？打官司就是打关系吗？&lt;/strong>&lt;/p>
&lt;p>&lt;strong>老周答&lt;/strong>：当律师到现在，我最大的感受就是，如果你一遇事，就急慌慌地先去找关系，去找那些号称关系很&amp;quot;硬&amp;quot;的人，那么往往会走向歪路，把简单的问题复杂化，最后的结局基本上不是被骗就是被黑。要么你的事情根本解决不了，要么你就得多花好几倍的冤枉钱。&lt;/p>
&lt;p>我想从法律人的视角告诉你，打官司就是打是非曲直，靠的是证据。遇到事情时，尽可能先找专业人士了解一下原则性问题，会用证据和法律才是真正的保障。&lt;/p>
&lt;p>&lt;strong>第二问：打官司的流程是什么？&lt;/strong>&lt;/p>
&lt;p>&lt;strong>老周答&lt;/strong>：打官司，其实就是我们在法律上所说的&amp;quot;诉讼&amp;quot;，我总结为&amp;quot;告状七步曲&amp;quot;。&lt;/p>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>准备&lt;/strong>：搜集证据，并写好起诉状。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>立案&lt;/strong>：带上起诉状、身份证原件及复印件、相关证据的复印件到有管辖权的法院立案。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>等通知&lt;/strong>：立案后会当场发传票确定开庭时间，或者等法院的后续通知确定，现在一般为后者。如果收到法院的快递，一定要仔细阅读，里面可能有举证期限、答辩时间等，都很重要。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>开庭&lt;/strong>：按规定的时间到法院开庭，要带上证据原件，涉及到的法律法规也要充分准备好。也许只有这一次庭审机会，一定要带齐证据，不然&amp;quot;有证不举等于无证&amp;quot;。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>等待一审判决&lt;/strong>：开完庭后，就该等待接收判决结果了，由于每个法官手中案子较多，等待时间可能会比较长。判决书主要邮寄送达或者通知领取，现在也在推行电子送达。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>等待生效或二审&lt;/strong>：如果任意一方对一审的判决结果不服，可以在 15 天内提起上诉，进入二审；如果双方都服从一审的判决，那就等待判决生效。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>判决生效并执行&lt;/strong>：判决生效后，正常按照判决执行；如果对方没执行，可以向法院申请强制执行。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>第三问：打官司，需要多少钱？&lt;/strong>&lt;/p>
&lt;p>&lt;strong>老周答&lt;/strong> ：打官司的主要费用分两块：一个是&lt;strong>诉讼费&lt;/strong> 。去法院起诉时，法院会根据诉讼费收费标准，对不同案件收取不同的费用；另一个是律师费，如果聘请律师，你就需要支付&lt;strong>律师费&lt;/strong>。每个律师事务所的收费标准都不太一样，每个律师报价方式也不同，所以具体费用要看双方协商的结果。&lt;/p>
&lt;p>这里我要强调一点，&lt;strong>符合法律援助条件的案件不收取律师费用&lt;/strong>。你可以向当地司法局的法律援助中心咨询，如果符合条件，申请法律援助，便会有律师来免费代理。&lt;/p>
&lt;p>另外，律师每年也会做&lt;strong>公益案件&lt;/strong>，如果家里经济困难或有特殊情况，可以和律师事务所或者律师直接沟通。&lt;/p>
&lt;p>&lt;strong>第四问：符合法律援助的条件是什么？&lt;/strong>&lt;/p>
&lt;p>&lt;strong>老周答&lt;/strong> ：首先要&lt;strong>符合经济困难的情况&lt;/strong>，这里的经济困难主要是指各地的低保户水平。如果符合，在遇到下列几种情况时，可以向法律援助机构申请法律援助。&lt;/p>
&lt;ol>
&lt;li>
&lt;p>请求国家赔偿。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>请求发放抚恤金、抚养费等。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>请求支付劳动报酬。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>请求社保或低保待遇。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>解决因见义勇为而产生的民事纠纷。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>另外，&lt;strong>刑事案件辩护&lt;/strong>目前正在北京、上海等地试点。也就是说，在这些地方，刑事案件的被告人即使没律师，也会有法律援助律师来为其辩护。试点期结束后，这一措施预计会在全国推行。&lt;/p>
&lt;p>&lt;strong>第五问：什么情况下我需要请律师？&lt;/strong>&lt;/p>
&lt;p>&lt;strong>老周答&lt;/strong>：事实上，如果经济条件允许，我建议遇到法律纠纷时，都优先考虑请律师，毕竟专业事情让专业人士来处理，更能找到关键来解决问题。&lt;/p>
&lt;p>此外，如果你有这两种困扰，就该考虑请律师了。&lt;/p>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>证据不足&lt;/strong>。如果手头的证据不足，或者是取证本身比较困难时，尽量请律师代理。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>案件复杂&lt;/strong>。比如在合同问题上，如果钱财的流转复杂，或者是有争议的数目比较大，就应该找专业人士来分析。再如，民事诉讼是根据你的请求来判决的，通常适用&amp;quot;不告不理&amp;quot;的原则，也就是说，哪怕你符合了某个赔偿的规定，如果自己没有主动提出赔偿的请求，法院就不会去判决，而有律师在，你就不会吃这个亏了。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>第六问：如何选择律师？&lt;/strong>&lt;/p>
&lt;p>&lt;strong>老周答&lt;/strong> ：我可以给出几点选择律师的参考意见，你可以简单记为&amp;quot;&lt;strong>三要两不要&lt;/strong>&amp;quot;。&lt;/p>
&lt;p>三要：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>要挑选正规的律师事务所，并要约定在律师的执业办公地点见面，考察律师事务所的实力；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>要查清楚律师的资质，必须有《律师执业证》；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>要和律师当面交流、谈案子，听律师的法律分析是否专业、理性，判断律师的能力。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>两不要：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>不要选择所谓的&amp;quot;关系&amp;quot;律师，张嘴就是和法院某某很熟的，一般不靠谱；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>不要选择那些吹牛的律师，有一大堆头衔还号称必赢的，一般都是忽悠。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>最后，一定要明确知道你在事务所最终请到的律师是谁，是谁替你出庭。在选好律师后，还要和律师事务所&lt;strong>签订一份委托代理协议&lt;/strong>，协议会明确规定收费的问题，包括具体费用、付款方式及期限等。所以，在签协议时一定要细心耐心，确认好这些地方。&lt;/p>
&lt;p>&lt;strong>第七问：请律师打官司，输了还要给律师钱吗？&lt;/strong>&lt;/p>
&lt;p>&lt;strong>老周答&lt;/strong>：这里我们需要分民事诉讼、刑事诉讼两种情况来了解律师费用。&lt;/p>
&lt;p>如果律师代理的是民事诉讼，一般有两种方式。一种是&lt;strong>风险代理&lt;/strong> ，其中就有根据结果来收费的情况，当然，这种代理方式相对来说比较少。另一种是&lt;strong>普通代理&lt;/strong>，通常是签合同并收取律师费，不管最后的结果如何，费用都不会退还，所以前期挑个好律师很重要。&lt;/p>
&lt;p>如果律师代理的是刑事诉讼，那就只有普通代理这一种方式，跟民事诉讼一样，签合同并收费，与最终的结果无关。&lt;/p>
&lt;p>因此，大部分情况下，律师费和&amp;quot;输赢&amp;quot;没有关系。只有少部分的民事诉讼，可以根据双方的约定来付费，也就可能存在&amp;quot;输了不用给钱&amp;quot;的情况。但是，具体什么算是&amp;quot;输了&amp;quot;，还是要看一开始签订的协议的规定。&lt;/p>
&lt;p>事实上，&amp;ldquo;胜了才付费、输了不付费&amp;quot;一般只能当宣传语听听，一个专业、负责的律师，会更客观理性地对待案件，而不是打包票来吸引注意。我们还是要记住&amp;quot;三要两不要&amp;quot;的挑选原则，再有就是重点关注代理协议了。&lt;/p>
&lt;p>&lt;strong>第八问：民事案件与刑事案件的差别是什么？&lt;/strong>&lt;/p>
&lt;p>&lt;strong>老周答&lt;/strong>：简单来说，民事案件是指民事纠纷不能协商时，需要向法院起诉来解决。我们生活中的大多数问题属于民事纠纷，比如合同纠纷、交通事故纠纷、婚姻家庭纠纷、继承纠纷等。民事案件的一般流程是，某一方向法院起诉，获得判决。起诉的一方叫原告，被起诉的一方叫被告。&lt;/p>
&lt;p>刑事案件可以理解为，某人犯了罪，触犯了刑法，然后被抓了。这就是一个简单的刑事案件模型，而这个犯罪的人，被称为犯罪嫌疑人或被告人。刑事案件的一般流程是公安立案侦察、检察院审查起诉、最后法院来审判，并进行刑事处罚。罚金、拘役、有期徒刑、死刑、剥夺政治权利等这些熟悉的名词，都属于刑事处罚。&lt;/p>
&lt;p>共同点：两种案件都以起诉作为法院审判的前提。刑事案件一般由检察机关提起公诉，民事案件则是由原告人起诉，这样法院才会审判。&lt;/p>
&lt;p>不同点：后果上来看，民事案件的结果一般为要求停止侵权行为、赔偿经济损失或者违约金等；刑事案件的结果一般会有判刑，除了罚钱还需要坐牢。&lt;/p>
&lt;p>&lt;strong>第九问：劳动仲裁需要花多长时间、多少钱呢？&lt;/strong>&lt;/p>
&lt;p>&lt;strong>老周答&lt;/strong> ：劳动仲裁与职场问题关系密切，我们在讲职场纠纷时经常会提到。它一般解决员工和单位在劳动合同上的纠纷，并且是&lt;strong>不收费&lt;/strong>的。&lt;/p>
&lt;p>通常整个流程会花费 45 天时间，延长的话&lt;strong>最多也会在 60 天内结案&lt;/strong>。如果被仲裁的一方，对劳动仲裁的结果不服，可以在收到裁决书起的 15 天内向法院起诉，由法院审理；如果不起诉，满 15 天裁决书就会生效了。&lt;/p>
&lt;p>&lt;strong>第十问：能不能介绍下与个人关系比较密切的法律，并说说它们分别覆盖什么领域？&lt;/strong>&lt;/p>
&lt;p>&lt;strong>老周答&lt;/strong>：我们生活中会接触到的法律主要有这么几个。&lt;/p>
&lt;ol>
&lt;li>
&lt;p>《劳动合同法》解决职工和单位在劳动合同上的纠纷，覆盖职场领域。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>《婚姻法》解决基本的婚姻家庭关系纠纷，其中一些有争议的事项在相关的司法解释里，覆盖婚姻家庭领域。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>《合同法》内容比较多，劳动合同之外的其他合同规定都包括在内，因此，职场、生活领域都有覆盖。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>《刑法》讲的是什么事儿犯罪、什么事儿不犯罪以及犯了罪怎么罚的问题，可以说是成年人的行为准则，覆盖面也很广。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>今天我们主要扫清这十个盲区，当然，比较常见、常用的法律知识，在后续课程中我都会讲到。&lt;/p>
&lt;p>那么，在法律的认知方面，你还有什么疑惑想问我，或者有什么心得想要和我分享的吗？欢迎留言告诉我，也欢迎点击右下方的&amp;rdquo;&lt;strong>请朋友读&lt;/strong>&amp;quot;，把今天所学分享给你的家人、朋友。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/10/ae/109d74bf33e68fa4206ce2ae524c75ae.jpg" alt="">&lt;/p></description></item><item><title>极客专栏: 01丨从条件运算符说起，反思什么是好代码</title><link>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E4%BB%A3%E7%A0%81%E7%B2%BE%E8%BF%9B%E4%B9%8B%E8%B7%AF/01%E4%B8%A8%E4%BB%8E%E6%9D%A1%E4%BB%B6%E8%BF%90%E7%AE%97%E7%AC%A6%E8%AF%B4%E8%B5%B7%E5%8F%8D%E6%80%9D%E4%BB%80%E4%B9%88%E6%98%AF%E5%A5%BD%E4%BB%A3%E7%A0%81/</link><pubDate>Tue, 07 Jun 2022 00:00:00 +0000</pubDate><guid>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E4%BB%A3%E7%A0%81%E7%B2%BE%E8%BF%9B%E4%B9%8B%E8%B7%AF/01%E4%B8%A8%E4%BB%8E%E6%9D%A1%E4%BB%B6%E8%BF%90%E7%AE%97%E7%AC%A6%E8%AF%B4%E8%B5%B7%E5%8F%8D%E6%80%9D%E4%BB%80%E4%B9%88%E6%98%AF%E5%A5%BD%E4%BB%A3%E7%A0%81/</guid><description>
&lt;p>写出优秀的代码是我们每一个程序员的毕生追求，毕竟写代码本身就是个技术活，代码的好坏，其实也就是我们工艺的好坏。作为一个技术类的工种，我们没有理由不去思考如何写出优秀、让人惊叹的代码。&lt;/p>
&lt;p>那什么样的代码才是优秀的代码呢？对于这个问题，我想每个人心中都会有自己的答案。今天我就来和你聊聊我的思考。&lt;/p>
&lt;p>对于条件运算符（?:）的使用，我估摸着你看到过相关的争论，或者自己写代码的时候也不知道到底该不该使用条件运算符，或者什么情况下使用？这些微不足道的小话题随时都可以挑起激烈的争论。&lt;/p>
&lt;p>C 语言之父丹尼斯·里奇就属于支持者。在《C 程序设计语言》这本书里，他使用了大量简短、直观的条件运算符。&lt;/p>
&lt;p>然而还有一些人，对条件运算符完全丧失了好感，甚至把&amp;quot;永远不要使用条件运算符&amp;quot;作为一条 C 语言高效编程的重要技巧。&lt;/p>
&lt;p>比如说吧，下面的这个例子，第一段代码使用条件语句，第二段代码使用条件运算符。 你觉得哪一段代码更&amp;quot;优秀&amp;quot;呢？&lt;/p>
&lt;pre>&lt;code>if (variable != null) {
return variable.getSomething();
}
return null;
return variable != null ? variable.getSomething() : null;
&lt;/code>&lt;/pre>
&lt;p>同样使用条件运算符，你会喜欢下面代码吗？&lt;/p>
&lt;pre>&lt;code>return x &amp;gt;= 90 ? &amp;quot;A&amp;quot; : x &amp;gt;= 80 ? &amp;quot;B&amp;quot; : x &amp;gt;= 70 ? &amp;quot;C&amp;quot; : x &amp;gt;= 60 ? &amp;quot;D&amp;quot; : &amp;quot;E&amp;quot;;
&lt;/code>&lt;/pre>
&lt;p>十多年前，作为一名 C 语言程序员，我非常喜欢使用条件运算符。因为条件运算符的这种压缩方式，使代码看起来简短、整洁、干净。 而且，如果能把代码以最少的行数、最简短的方式表达出来，心里也颇有成就感。&lt;/p>
&lt;p>后来，我的一位同事告诉我，对于我使用的条件运算符的部分代码，他要仔细分析才知道这一小行代码想要表达的逻辑，甚至有时候还要翻翻书、查查操作符的优先级和运算顺序，拿笔画一画逻辑关系，才能搞清楚这一小行代码有没有疏漏。&lt;/p>
&lt;p>这么简单的代码，为什么还要确认运算符的优先级和运算顺序呢？因为只是&amp;quot;看起来&amp;quot;对的代码，其实特别容易出问题。所以，一定要反复查验、确认无误才能放心。&lt;/p>
&lt;p>这么简单的代码，真的需要这么认真检查吗？超级简单的代码的错误，往往是我们最容易犯的一类编码错误。我个人就是犯过很多次这种低级、幼稚的错误，并且以后一定还会再犯。比如下面的这段有问题的代码，就是我最近犯的一个非常低级的代码错误：&lt;/p>
&lt;pre>&lt;code>// Map for debug logging. Enable debug log if SSLLogger is on.
private final Map&amp;lt;Integer, byte[]&amp;gt; logMap =
SSLLogger.isOn ? null : new LinkedHashMap&amp;lt;&amp;gt;();
&lt;/code>&lt;/pre>
&lt;p>正确的代码应该是：&lt;/p>
&lt;pre>&lt;code>// Map for debug logging. Enable debug log if SSLLogger is on.
private final Map&amp;lt;Integer, byte[]&amp;gt; logMap =
SSLLogger.isOn ? new LinkedHashMap&amp;lt;&amp;gt;() : null;
&lt;/code>&lt;/pre>
&lt;p>你可能会说，这个代码错误看起来太幼稚、太低级、太可笑了吧？ 确实是这样的。这段错误的代码，我的眼睛不知道看过了它们多少次，可是这个小虫子（bug）还是华丽丽地逃脱了我的注意，进入了&lt;strong>JDK 11 的最终发布版&lt;/strong>。&lt;/p>
&lt;p>如果使用条件语句，而不是条件运算符，这个幼稚错误发生的概率会急剧下降。 &lt;strong>坚持使用最直观的编码方式，而不是追求代码简短，真的可以避免很多不必要的错误&lt;/strong>。所以说啊，选择适合的编码方式，强调代码的检查、评审、校验，真的怎么都不算过分。&lt;/p>
&lt;p>现在，如果你要再问我喜欢哪种编码方式，毫无疑问，我喜欢使用条件语句，而不是条件运算符。因为，用条件语句这种编码方式，可以给我确定感，我也不需要挑战什么高难度动作；而看代码的人，也可以很确定，很轻松，不需要去查验什么模糊的东西。&lt;/p>
&lt;p>这种阅读起来的确定性至少有三点好处，第一点是可以减少代码错误；第二点是可以节省我思考的时间；第三点是可以节省代码阅读者的时间。&lt;/p>
&lt;p>&lt;strong>减少错误、节省时间，是我们现在选择编码方式的一个最基本的原则。&lt;/strong>&lt;/p>
&lt;p>《C 程序设计语言》这本 C 程序员的圣经，初次发表于 1978 年。那个年代的代码，多数很简单直接。简短的代码，意味着节省昂贵的计算能力，是当时流行的编码偏好。而现在，计算能力不再是瓶颈，如何更高效率地开发复杂的软件，成了我们首先需要考虑的问题。&lt;/p>
&lt;p>有一些新设计的编程语言，不再提供条件运算符。 比如，Kotlin 语言的设计者认为，编写简短的代码绝对不是 Kotlin 的目标。所以，Kotlin 不支持条件运算符。 Go 语言的设计者认为，条件运算符的滥用，产生了许多难以置信的、难以理解的复杂表达式。所以，Go 语言也不支持条件运算符。&lt;/p>
&lt;p>我们看到，&lt;strong>现实环境的变化，影响着我们对于代码&amp;quot;好&amp;quot;与&amp;quot;坏&amp;quot;的判断标准。&lt;/strong>&lt;/p>
&lt;h2 id="好的代码与坏的代码">&amp;ldquo;好&amp;quot;的代码与&amp;quot;坏&amp;quot;的代码&lt;/h2>
&lt;p>虽然对于&amp;quot;什么是优秀的代码&amp;quot;难以形成一致意见，但是这么多年的经验，让我对代码&amp;quot;好&amp;quot;与&amp;quot;坏&amp;quot;积累了一些自己的看法。&lt;/p>
&lt;p>比如说，&amp;ldquo;好&amp;quot;的代码应该：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>容易理解；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>没有明显的安全问题；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>能够满足最关键的需求；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>有充分的注释；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>使用规范的命名；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>经过充分的测试。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>&amp;ldquo;坏&amp;quot;的代码包括：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>难以阅读的代码；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>浪费大量计算机资源的代码；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>代码风格混乱的代码；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>复杂的、不直观的代码；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>没有经过适当测试的代码。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>当然，上面的列表还可以很长很长，长到一篇文章都列不完、长到我们都记不住的程度。&lt;/p>
&lt;h2 id="优秀的代码是经济的代码">优秀的代码是&amp;quot;经济&amp;quot;的代码&lt;/h2>
&lt;p>大概也没人想记住这么多条标准吧？所以，&lt;strong>关于优秀代码的特点，我想用&amp;quot;经济&amp;quot;这一个词语来表达&lt;/strong> 。这里的&amp;quot;经济&amp;rdquo;，指的是使用较少的人力、物力、财力、时间、空间，来获取较大的成果或收益 。或者简单地说，&lt;strong>投入少、收益大、投资回报高&lt;/strong>。为了方便，你也可以先理解为节俭或者抠门儿的意思。&lt;/p>
&lt;p>当然，使用一个词语表达肯定是以偏概全的。但是，比起一长串的准则，一个关键词的好处是，更容易让人记住。我想这点好处可以大致弥补以偏概全的损失。&lt;/p>
&lt;p>该怎么理解&amp;quot;经济&amp;quot;呢？这需要我们把代码放到软件的整个生命周期里来考察。&lt;/p>
&lt;p>关于软件生命周期，我想你应该很熟悉了，我们一起来复习一下。一般而言，一个典型的软件生命周期，大致可以划分计划、分析和设计、代码实现、测试、运营和维护这六个阶段。在软件维护阶段，可能会有新的需求出现、新的问题产生、旧问题的浮现，这些因素可能就又要推动新一轮的计划，分析、设计、实现、测试、运营。这样，这个周期就会反复迭代，反复的循环，像一个周而复始的流水线。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/14/04/144679d37d552e4d5c436cab88582f04.png" alt="">&lt;/p>
&lt;p>当我们说投入少的时候，说的是这整个生命周期，甚至是这个周而复始的生命周期的投入少。 比如说，代码写得快，可是测试起来一大堆问题，就不是经济的。&lt;/p>
&lt;p>现代的大型软件开发，一般都会有比较细致的分工，在各个阶段参与的人是不同的；甚至在相同的阶段，也会有多人参与。一个稍有规模的软件，可能需要数人参与设计和实现。而为了使测试相对独立，软件测试人员和软件实现人员也是相对独立的，而且他们具备不同的优势和技能。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/89/df/89bb4250efc6702f638f8981030927df.png" alt="">&lt;/p>
&lt;p>所以，当我们考虑投入的时候，还要考虑这个生命周期里所有的参与人员。这些参与人员所处的立场、看问题的角度，所具有的资源禀赋，可能千差万别。比如说，如果客户需要阅读代码，才知道系统怎么使用，就不是经济的。&lt;/p>
&lt;p>是不是所有的软件都有这六个阶段呢？显然不是的，我本科的毕业论文程序，就完全没有运营和维护阶段，甚至也不算有测试阶段。我当时的毕业论文是一个关于加快神经网络学习的数学算法。只要验证了这个算法收缩得比较快，程序的使命就完成了，程序就可以退出销毁了。 所以，运营和维护阶段，甚至测试阶段，对当时的我而言，都是不需要投入的阶段。&lt;/p>
&lt;p>在现代商业社会里，尤其我们越来越倾向于敏捷开发、精益创业，提倡&amp;quot;快速地失败、廉价地失败&amp;rdquo;，很多软件走不到维护阶段就已经结束了。而且，由于人力资源的限制，当然包括资金的限制，一个程序员可能要承担很多种角色，甚至从开始有了想法，到软件实现结束，都是一个人在战斗，哪里分什么设计人员、测试人员。&lt;/p>
&lt;p>对软件开发流程选择的差异，就带来了我们对代码质量理解，以及对代码质量重视程度的千差万别。 比如说，一个创业公司是万万不能照搬大型成熟软件的开发流程的。因为，全面的高质量、高可靠、高兼容性的软件可能并不是创业公司最核心的目标。如果过分纠缠于这些代码指标，创始人的时间、投资人的金钱可能都没有办法得到最有效的使用。&lt;/p>
&lt;p>当然，越成熟的软件开发机制越容易写出优秀的代码。但是，&lt;strong>最适合当前现实环境的代码，才是最优秀的代码。&lt;/strong>&lt;/p>
&lt;p>所以，当我们考虑具体投入的时候，还要考虑我们所处的现实环境。 如果我们超出现实环境去讨论代码的质量，有时候会有失偏颇，丧失我们讨论代码质量的意义。&lt;/p>
&lt;p>既然具体环境千差万别，那我们还有必要讨论什么是优秀的代码吗？优秀的代码还能有什么共同的规律吗？ 即使一个人做所有的事情，即使代码用完一次就废弃，我们长期积累下来的编写优秀代码的经验，依然可以帮助到很多人。&lt;/p>
&lt;p>比如说，虽然创业公司的软件刚开始最核心的追求不是全面的高可靠性。可是，你也要明白，创业的目的不是为了失败，一旦创业公司稳住了阵脚，这个时候如果它们没有高可靠性的软件作为支撑，很快就会有反噬作用。 而程序员背锅，就是反噬的其中一个后果。&lt;/p>
&lt;p>如何使用最少的时间、最少的资源，提供最可靠的软件，什么时候开始把可靠性提高到不可忽视的程度，有没有可能一开始就是高可靠的, 这些就都是一个富有经验的创业公司技术负责人不得不考虑的问题。而我们总结出来的编写代码的经验，毫无疑问，可以为这些问题提供一些思路和出路。&lt;/p>
&lt;p>为什么我们要从&amp;quot;经济&amp;quot;这个角度来衡量优秀的代码呢？ 因为这是一个可以让我们更加理性的概念。&lt;/p>
&lt;p>一个营利性的公司，必须考虑投入产出比，没有人愿意做亏本的买卖，股东追求的是利润最大化。作为程序员，我们也必须考虑投入和产出。 首先，我们的产出必须大幅度大于公司对我们的投入，否则就有随时被扫地出门的风险。然后，我们必须使用好我们的时间，在单位时间内创造更多的价值，否则，真的是没有功劳，只有徒劳。&lt;/p>
&lt;p>编写代码的时候，如果遇到困惑或者两难，你要想一想，怎么做才能做到投资少、收益大？&lt;/p>
&lt;p>即便具体环境千差万别，我还是有一些例子，可以和你一起分享：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>代码写得又快又好，是&amp;quot;经济&amp;quot;的；代码写得快，但是错误多，不是一个&amp;quot;经济&amp;quot;的行为。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>代码跑得又快又好，是&amp;quot;经济&amp;quot;的；代码跑得快，但是安全问题突出，不是一个&amp;quot;经济&amp;quot;的行为。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>代码写得精简易懂，是&amp;quot;经济&amp;quot;的；代码写得精简，但是没人看得懂，不是一个&amp;quot;经济&amp;quot;的行为。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>对于所有的程序员来说，每个人都会遇到两个有名的捣蛋鬼，一个捣蛋鬼是&amp;quot;合作&amp;rdquo;，另一个捣蛋鬼是&amp;quot;错误&amp;quot;。&lt;/p>
&lt;p>要合作，就需要用大部分人都舒服的方式。程序员间合作交流最重要的语言便是代码，换句话说，这就需要我们规范地编写代码，使用大家都接受的风格。不规范的代码，我们可能节省了眼前的时间，但是测试、运营、维护阶段，就需要更多的时间。而一旦问题出现，这些代码会重新返工，又回到我们手里，需要阅读、修改，再一次浪费我们自己的时间。对于这些代码，每一点时间的付出，都意味着投入，意味着浪费，意味着我们损失了做更有意义事情的机会。&lt;/p>
&lt;p>人人都会犯错误，代码都会有 bug，可是有些错误的破坏力是我们无法承受的，其中，最典型的就是安全问题。很多安全问题对公司和个人造成不容忽视的恶劣影响。我见过因为安全问题破产的公司。这时候，甚至都不要谈什么投入产出比、经济效益了，所有的投入归零，公司破产，员工解散。这需要我们分外地卖力，拿出十二分的精神来处理潜在的安全威胁，编写安全的代码。&lt;/p>
&lt;p>如果我们把规范和安全作为独立的话题，优秀的代码需要具备三个特征： 经济、规范、安全。这些内容就是我们接下来要在专栏里一起学习的主体。&lt;/p>
&lt;p>好了，今天我们一口气聊了很多，主要是在探讨到底什么样的代码才是优秀的代码。这个问题你之前考虑过吗？和我今天讲的是否一样呢？欢迎你在留言区写写自己的想法，我们可以进一步讨论。也欢迎你把今天的文章分享给跟你协作的同学，看看你们之间的理解是否一致。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/5a/98/5a96a612403912b80de030e742e2e598.jpg" alt="">&lt;/p></description></item><item><title>极客专栏: 01丨架构设计的宏观视角</title><link>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E8%AE%B8%E5%BC%8F%E4%BC%9F%E7%9A%84%E6%9E%B6%E6%9E%84%E8%AF%BE/01%E4%B8%A8%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E7%9A%84%E5%AE%8F%E8%A7%82%E8%A7%86%E8%A7%92/</link><pubDate>Tue, 07 Jun 2022 00:00:00 +0000</pubDate><guid>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E8%AE%B8%E5%BC%8F%E4%BC%9F%E7%9A%84%E6%9E%B6%E6%9E%84%E8%AF%BE/01%E4%B8%A8%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E7%9A%84%E5%AE%8F%E8%A7%82%E8%A7%86%E8%A7%92/</guid><description>
&lt;p>你好，我是七牛云许式伟。今天我们来谈谈架构设计的宏观视角。&lt;/p>
&lt;p>在信息科技高度发展的今天，我们每个人随时随地都可以接触到由程序驱动的智能电子设备，包括手机（如 iPhone、oppo 拍照手机）、平板电脑（如 iPad）、手表（如 iWatch、小天才智能手表）、音箱（如天猫精灵）、汽车（如特斯拉）等等。&lt;/p>
&lt;p>这些东西背后是怎么工作的？单就其中的软件系统而言，这些小小的设备上往往运行着成千上万个软件模块，这些模块是如何如此精密地一起协作的？&lt;/p>
&lt;p>对此，我过去接触过很多的软件开发工程师，或者架构师，很多人对这些原理也是一知半解，虽然&amp;quot;知其然&amp;quot;，但却&amp;quot;不知其所以然&amp;quot;。甚至有些朋友可能觉得，学这些有什么用处呢，在我看来，这部分内容恰恰是我们成为架构师很重要的一门基础课。&lt;/p>
&lt;h2 id="为什么需要建立宏观视角">为什么需要建立宏观视角？&lt;/h2>
&lt;p>如同造房子有建筑工人（负责搬砖）和建筑师（负责架构设计）一样，软件系统的开发过程同样需要有程序员（负责搬&amp;quot;砖&amp;quot;）和架构师（负责架构设计）。作为架构师，我们需要的第一个能力是宏观的全局掌控能力。&lt;/p>
&lt;p>如果把应用程序比作一座大厦，那么我们作为大厦的架构师，需要把大厦的结构搭建好，让程序员可以把砖填充进去，我们都知道，一个大厦的结构建得是否稳固，与地基密不可分。&lt;/p>
&lt;p>所以，我们首先就需要从大厦的地基开始，熟悉这座大厦。毕竟，你对所依赖的基础架构了解得越全面，做业务架构设计就会越发从容。&lt;/p>
&lt;p>介绍基础架构的知识点并不是让你真的去实现它们。但你仍然需要懂得它们的核心思想是什么，知道有哪些信息是你必须深刻理解的，以便可以更好地驾驭它们。&lt;/p>
&lt;p>&lt;strong>我们的整个专栏内容也会从基础架构开始讲起，最后逐步过渡到业务架构，到最终完成一个完整应用程序的设计过程。&lt;/strong>&lt;/p>
&lt;p>那么，在今天的开篇第一篇，我们需要站在宏观视角，从基础架构开始，逐渐来解剖一个应用程序的整体构成，我希望，通过今天的文章，可以让你对于一个程序的全貌，形成完整的认识。&lt;/p>
&lt;p>我们从头开始。&lt;/p>
&lt;h2 id="应用程序的基础架构">应用程序的基础架构&lt;/h2>
&lt;p>我们想学习一个程序的基础架构，其实就是弄清楚电脑的工作原理，以及程序的运行原理。&lt;/p>
&lt;p>无论是什么样的智能电子设备，手机也好，汽车也罢，它们都可以称为&amp;quot;电脑&amp;quot;。所有的电脑都可以统一看作由&amp;quot;&lt;strong>中央处理器 + 存储 + 一系列的输入输出设备&lt;/strong>&amp;ldquo;构成。&lt;/p>
&lt;p>中央处理器，也就是我们平常说的 CPU，负责按指令执行命令；存储负责保存数据，包括我们要执行的命令，也是以数据形式保存在存储中的。&lt;/p>
&lt;p>每次在打开电脑的电源后，中央处理器都会从存储的某个固定位置处开始读入数据（也就是指令），并且按指令执行命令，执行完一条指令就会继续执行下一条指令。电脑就这样开始工作了。&lt;/p>
&lt;p>你可能会说，就这么简单？是的，就是这么简单。&lt;/p>
&lt;p>&lt;strong>那这么简单的话，为何电脑能够完成这么多复杂而多样化的工作？&lt;/strong>&lt;/p>
&lt;p>这整个过程，在我看来主要依赖两点。&lt;/p>
&lt;p>**第一是可编程性。**大体来说，中央处理器（CPU）的指令分为如下这几类。&lt;/p>
&lt;ul>
&lt;li>计算类，也就是支持我们大家都熟知的各类数学运算，如加减乘除、sin/cos 等等。&lt;/li>
&lt;li>I/O 类，（从存储读写数据）从输入输出设备读数据、写数据。&lt;/li>
&lt;li>指令跳转类，在满足特定条件下跳转到新的当前程序执行位置。&lt;/li>
&lt;/ul>
&lt;p>虽然， CPU 指令是一个很有限的指令集，但是 CPU 执行的指令序列（或者叫&amp;quot;程序&amp;rdquo;）并不是固定的，而是依赖保存在存储中的数据&amp;mdash;&amp;mdash; 由软件工程师（或者叫&amp;quot;程序员&amp;quot;）编写的软件来决定。指令序列的可能性是无穷的，这也就意味着电脑能够做的事情的可能性也是无穷的。&lt;/p>
&lt;p>**第二是开放设计的外部设备支持。**虽然我们电脑可以连接非常非常多种类的外部设备，比如键盘、打印机、屏幕、汽车马达等等，但 CPU 并不理解这些设备具体有什么样的能力，它只和这些设备交换数据。它能够做的是从某个编号的设备（通常这个设备编号被称为&amp;quot;端口&amp;quot;）读入一段数据，或者向设备的端口写入一段数据。&lt;/p>
&lt;p>例如，当你在键盘上按下了 A 的时候，CPU 可以从键盘连接的端口读到一段数据，通过这段数据来表达你按了&amp;quot;A&amp;quot;，可能 CPU 会向打印机连接的端口发送一段数据，来驱动打印机打印特定的文本；还有可能 CPU 会向汽车马达所在的端口发送数据，来驱动马达转动，从而让汽车按照预期来行驶。&lt;/p>
&lt;p>值得注意的是，CPU 知道的是如何和这些设备交换数据，但是并不理解数据代表什么含义。这些外部设备的厂商在提供设备硬件的同时，往往也需要提供和硬件匹配的软件，来完成和 CPU 的协作，让软件工程师可以轻松使用这些设备。&lt;/p>
&lt;p>从上面可以看出，**电脑的 CPU 是一个非常简洁的模型，它只读入和写出数据，对数据进行计算。**这也是为什么我们往往把电脑也叫作&amp;quot;计算机&amp;quot;，这是因为 CPU 这个计算机的大脑的确只会做&amp;quot;计算&amp;quot;。&lt;/p>
&lt;p>这个基础的设计体系，我们很多人都知道，这就是冯·诺依曼计算机体系。1945 年 6 月，冯·诺依曼以&amp;quot;关于 EDVAC 的报告草案&amp;quot;为题起草的长达 101 页的总结报告，定义了&amp;quot;冯·诺依曼体系结构&amp;quot;，他现在也被称为计算机之父。我想看到这里，你应该不难理解他的伟大之处了吧？&lt;/p>
&lt;p>有了这个基础的计算机体系之后，我们就可以编写软件了。&lt;/p>
&lt;p>当然我们遇到的第一个问题是&lt;strong>直接用机器指令编写软件太累，而且这些机器指令像天书一样没人看得懂，没法维护。&lt;/strong>&lt;/p>
&lt;p>所以，&lt;strong>编程语言 + 编译器&lt;/strong>就出现了。编译器负责把我们人类容易理解的语言，转换为机器可以理解的机器指令，这样一来就大大解放了编写软件的门槛。&lt;/p>
&lt;p>在编写软件不是问题时，我们遇到的第二个问题，就是&lt;strong>多个软件在同一个电脑上怎么共处。多个软件大家往同一个存储地址写数据冲突怎么办？一起往打印机去发送打印指令怎么办？有的软件可能偷偷搞破坏怎么办？&lt;/strong>&lt;/p>
&lt;p>于是，&lt;strong>操作系统&lt;/strong>就出现了。&lt;/p>
&lt;p>**它首先要解决的是软件治理的问题。**它要建立安全保护机制，确保你的电脑免受恶意软件侵害。同时，它也要建立软件之间的协作秩序，让大家按照期望的方式进行协作。比如存储你写到这里，那么我就要写到别处；使用打印机要排队，你打完了，我才能接着去打印。&lt;/p>
&lt;p>操作系统**其次解决的是基础编程接口问题。**这些编程接口一方面简化了软件开发，另一方面提供了多软件共存（多任务）的环境，实现了软件治理。&lt;/p>
&lt;p>例如，对于屏幕设备，操作系统需要提供多任务窗口系统，以避免屏幕被多个软件画得乱七八糟；对于键盘输入设备，操作系统引入焦点窗口，以确定键盘输入的事件被正确发送到正确的软件程序。&lt;/p>
&lt;p>你会发现，今天的我们开发软件的时候，已经处于一些基础的架构设计之中。像冯·诺依曼计算机体系，像操作系统和编程语言，这些都是我们开发一个应用程序所依赖的基础架构。&lt;/p>
&lt;p>基础架构解决的是与业务无关的一些通用性的问题，这些问题往往无论你具体要做什么样的应用都需要面对。而且，基础架构通常以独立的软件存在，所以也称为基础软件。&lt;/p>
&lt;p>例如，我们熟知的 Linux、Nginx、MySQL、PHP 等这些软件都属于基础软件，这些基础软件极大地降低了应用开发的难度。在今天软件服务化的大趋势下，很多基础软件最终以互联网服务的方式提供，这就是所谓的&amp;quot;云计算&amp;quot;。&lt;/p>
&lt;h2 id="完整的程序架构是怎样的">完整的程序架构是怎样的？&lt;/h2>
&lt;p>讲完了程序的地基，让我们来总览一下程序的完整架构。&lt;/p>
&lt;p>在越强大的基础架构支撑下，应用程序开发需要关注的问题就越收敛，我们的开发效率就越高。&lt;strong>在我们只需要关注应用程序本身的业务问题如何构建时，我们说自己是在设计应用程序的业务架构（或者叫&amp;quot;应用架构&amp;quot;）。&lt;/strong>&lt;/p>
&lt;p>业务架构虽然会因为应用的领域不同而有很大的差异，但不同业务架构之间，仍然会有许多共通的东西。它们不只遵循相同的架构原则，还可以遵循相同的设计范式。&lt;/p>
&lt;p>一些设计范式被人们以应用程序框架的方式固化下来。例如，在用户交互领域有著名的 MVC 框架（如 JavaScript 语言的 Angular，PHP 语言的 Zend，Python 语言的 Django），在游戏开发领域有各种游戏引擎（如 JavaScript 语言的 Phaser，C# 语言的 Unity3D），等等。&lt;/p>
&lt;p>**对于一个服务端应用程序来说，其完整的架构体系大体如下，**如果你在收听音频，你可以点击文稿查看：&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/55/37/5553453858eb86bf88a5623255f20037.png" alt="">&lt;/p>
&lt;p>对于客户端应用程序来说，和服务端的情况会有非常大的差别。客户端首先面临的是多样性的挑战。&lt;/p>
&lt;p>单就操作系统来说，PC 就有 Windows、Mac、Linux 等数十种，手机也有 Android、iOS，Windows Mobile 等等。而设备种类而言就更多了，不只有笔记本、平板电脑，还有手机、手表、汽车，未来只会更加多样化。&lt;/p>
&lt;p>第一个想消除客户端的多样性，并且跨平台提供统一编程接口的，是浏览器。&lt;/p>
&lt;p>可能在很多人看来，浏览器主要改变的是软件分发的方式，让软件可以即取即用，无需安装。但从技术角度来说，底层操作系统对软件的支持同样可以做到即取即用。&lt;/p>
&lt;p>这方面苹果在 iOS 上已经在尝试，大家可能已经留意到，如果你一个软件很久没有用，iPhone 就会把这个软件从本地清理出去，而在你下一次使用它时又自动安装回来。&lt;/p>
&lt;p>假如软件包足够小，那么这种行为和 Web 应用就毫无区别。不同之处只在于 Web 应用基于的指令不是机器码，而是更高阶的 JavaScript 脚本。&lt;/p>
&lt;p>JavaScript 因为指令更高阶，所以程序的尺寸比机器码会有优势。但另一方面来说 JavaScript 是文本指令，表达效率又要比机器码低。&lt;/p>
&lt;p>但这一点也在发生变化，近年来 WebAssembly 技术开始蓬勃发展，JavaScript 作为浏览器的机器码的地位会被逐步改变，我们前端开发会面临更多的可能性。&lt;/p>
&lt;p>浏览器的地位非常特殊，我们可以看作操作系统之上的操作系统。一旦某种浏览器流行起来，开发人员都在浏览器上做应用，那么必然会导致底层操作系统管道化，这是操作系统厂商所不愿意看到的。&lt;/p>
&lt;p>而如果浏览器用户量比较少，那么通过它能够触达的用户量就太少，消除不同底层操作系统差异的价值就不存在，开发人员也就不乐意在上面开发应用。&lt;/p>
&lt;p>我们知道，PC 的浏览器之战打到今天，基本上就剩下 Chrome、Internet Explorer、Safari、Firefox 等。&lt;/p>
&lt;p>有趣的是，移动浏览器的战场似乎是从中国开始打起的，这就是微信引发的小程序之战，它本质上是一场浏览器的战争。&lt;/p>
&lt;p>浏览器是一个基础软件，它能够解决多大的问题，依赖于它的市场占有率。但是基于同样的浏览器技术核心也可以构建出跨平台的应用框架。我们看到 React Native 就是沿着这个思路走的。当然这不是唯一的一条路，还有人会基于类似 QT 这样的传统跨平台方案。&lt;/p>
&lt;p>&lt;strong>整体来说，对于一个客户端应用程序来说，其完整的架构体系大体如下&lt;/strong>，你可以点击文稿查看：&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/3a/c7/3af7a4830566a5b3e1058f409422b7c7.png" alt="">&lt;/p>
&lt;p>对于架构师来说，不仅仅只是想清楚业务应该怎么去做好分解，整个应用从底到最顶层的上层建筑，每一层都需要进行各种决策。先做 iOS 版本，还是先做小程序？是选择 Java 还是 Go 语言？这些都是架构的一部分。&lt;/p>
&lt;h2 id="结语">结语&lt;/h2>
&lt;p>今天，我们从&amp;quot;计算机是如何工作&amp;quot;开始，一起登高鸟瞰，总览了程序完整的架构体系。&lt;/p>
&lt;p>&lt;strong>可能有人看到今天的内容心里会有些担心：&amp;ldquo;原来架构师要学这么多东西，看来我离成为架构师好远。&amp;rdquo;&lt;/strong>&lt;/p>
&lt;p>好消息是：我们就是来打消这个担心的。如果我们把写代码的能力比作武功招式，那么架构能力就好比内功。内功修炼好了，武功招式的运用才能得心应手。&lt;/p>
&lt;p>**而架构能力的提升，本质上是对你的知识脉络（全身经络）的反复梳理与融会贯通的过程。**具备架构思维并不难，而且极有必要。不管今天的你是不是团队里的一位架构师，对任何一位程序员来说，具备架构思维将会成为让你脱颖而出的关键。&lt;/p>
&lt;p>这就像你没有从事云计算行业，但是你仍然需要理解云计算的本质，需要驾驭云计算。你也不必去做出一个浏览器，但是你需要理解它们的思考方式，因为你在深度依赖于它们。&lt;/p>
&lt;p>接下来我们将进一步展开来谈这个程序架构体系里面的每一个环节。你对今天的内容有什么思考与解读，欢迎给我留言，我们一起讨论。如果你觉得有所收获，也欢迎把文章分享给你的朋友。感谢你的收听，我们下期再见。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/43/00/43231f3789095eb4cdb38e67ff3d7900.jpg" alt="">&lt;/p></description></item><item><title>极客专栏: 01丨网络互联的昨天、今天和明天：HTTP协议的演化</title><link>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E5%85%A8%E6%A0%88%E5%B7%A5%E7%A8%8B%E5%B8%88%E4%BF%AE%E7%82%BC%E6%8C%87%E5%8D%97/01%E4%B8%A8%E7%BD%91%E7%BB%9C%E4%BA%92%E8%81%94%E7%9A%84%E6%98%A8%E5%A4%A9%E4%BB%8A%E5%A4%A9%E5%92%8C%E6%98%8E%E5%A4%A9http%E5%8D%8F%E8%AE%AE%E7%9A%84%E6%BC%94%E5%8C%96/</link><pubDate>Tue, 07 Jun 2022 00:00:00 +0000</pubDate><guid>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E5%85%A8%E6%A0%88%E5%B7%A5%E7%A8%8B%E5%B8%88%E4%BF%AE%E7%82%BC%E6%8C%87%E5%8D%97/01%E4%B8%A8%E7%BD%91%E7%BB%9C%E4%BA%92%E8%81%94%E7%9A%84%E6%98%A8%E5%A4%A9%E4%BB%8A%E5%A4%A9%E5%92%8C%E6%98%8E%E5%A4%A9http%E5%8D%8F%E8%AE%AE%E7%9A%84%E6%BC%94%E5%8C%96/</guid><description>
&lt;p>你好，我是四火。&lt;/p>
&lt;p>HTTP 协议是互联网基础中的基础，和很多技术谈具体应用场景不同的是，几乎所有的互联网服务都是它的应用，没有它，互联网的&amp;quot;互联&amp;quot;将无从谈起，因此我们把它作为正式学习的开篇。&lt;/p>
&lt;p>说到其原理和协议本身，我相信大多数人都能说出个大概来，比如，有哪些常见的方法，常见 HTTP 头，返回码的含义等等。但你是否想过，这个古老而富有生命力的互联网&amp;quot;基石&amp;quot;是怎样发展演化过来的呢？从它身上，我们能否管中窥豹，一叶知秋，找到互联网成长和演进的影子？&lt;/p>
&lt;p>今天，我想带你从实践的角度，亲身感受下这个过程，相信除了 HTTP 本身，你还可以发现网络协议发展过程中的一些通用和具有共性的东西。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/ac/2a/ac90bdd14bced3d81e314a7eddf6972a.png" alt="">&lt;/p>
&lt;h2 id="http09">HTTP/0.9&lt;/h2>
&lt;p>和很多其它协议一样，1991 年，HTTP 在最开始的 0.9 版就定义了协议最核心的内容，虽说从功能上看只是具备了如今内容的一个小小的子集。比如，确定了客户端、服务端的这种基本结构，使用域名 /IP 加端口号来确定目标地址的方式，还有换行回车作为基本的分隔符。&lt;/p>
&lt;p>它非常简单，不支持请求正文，不支持除了 GET 以外的其它方法，不支持头部，甚至没有版本号的显式指定，而且整个请求只有一行，因而也被称为&amp;quot;The One-line Protocol&amp;quot;。比如：&lt;/p>
&lt;pre>&lt;code>GET /target.html
&lt;/code>&lt;/pre>
&lt;p>虽说 0.9 版本如今已经极少见到了，但幸运的是 Google 还依然支持（Bing 和 Baidu 不支持）。我们不妨自己动手，实践一下！虽然不能使用浏览器，但别忘了，我们还有一个更古老的工具 telnet。在命令行下建立连接：&lt;/p>
&lt;pre>&lt;code>telnet www.google.com 80
&lt;/code>&lt;/pre>
&lt;p>你会看到类似这样的提示：&lt;/p>
&lt;pre>&lt;code>Trying 2607:f8b0:400a:803::2004...
Connected to www.google.com.
Escape character is '^]'.
&lt;/code>&lt;/pre>
&lt;p>好，现在输入以下请求：&lt;/p>
&lt;pre>&lt;code>GET /
&lt;/code>&lt;/pre>
&lt;p>（请注意这里没有版本号，并不代表 HTTP 协议没有版本号，而是 0.9 版本的协议定义的请求中就是不带有版本号，这其实是该版本的一个缺陷）&lt;/p>
&lt;p>接着，你会看到 Google 把首页 HTML 返回了：&lt;/p>
&lt;pre>&lt;code>HTTP/1.0 200 OK
...（此处省略多行 HTTP 头）
...（此处省略正文）
&lt;/code>&lt;/pre>
&lt;h2 id="http10">HTTP/1.0&lt;/h2>
&lt;p>到了 1996 年，HTTP 1.0 版本就稳定而成熟了，也是如今浏览器广泛支持的最低版本 HTTP 协议。引入了返回码，引入了 header，引入了多字符集，也终于支持多行请求了。&lt;/p>
&lt;p>当然，它的问题也还有很多，支持的特性也远没有后来的 1.1 版本多样。比如，方法只支持 GET、HEAD、POST 这几个。但是，麻雀虽小五脏俱全，这是第一个具备广泛实际应用价值的协议版本。&lt;/p>
&lt;p>你一样可以用和前面类似的方法来亲自动手实践一下，不过，HTTP 1.0 因为支持多行文本的请求，单纯使用 telnet 已经无法很好地一次发送它们了，其中一个解决办法就是使用 &lt;a href="http://netcat.sourceforge.net/">netcat&lt;/a>。&lt;/p>
&lt;p>好，我们先手写一份 HTTP/1.0 的多行请求，并保存到一个文件 request.txt 中：&lt;/p>
&lt;pre>&lt;code>GET / HTTP/1.0
User-Agent: Mozilla/1.22 (compatible; MSIE 2.0; Windows 3.1)
Accept: text/html
&lt;/code>&lt;/pre>
&lt;p>（根据协议，无论请求还是响应，在 HTTP 的头部结束后，必须增加一个额外的换行回车，因此上述代码最后这个空行是必须的，如果是 POST 请求，那么通常在这个空行之后会有正文）&lt;/p>
&lt;p>你看上面的 User-Agent，我写入了一个&lt;a href="https://developers.whatismybrowser.com/useragents/parse/2868-internet-explorer-windows-trident">假的浏览器和操作系统版本&lt;/a>，假装我穿越来自 Window 3.1 的年代，并且用的是 IE 2.0，这样一来，我想不会有人比我更&amp;quot;老&amp;quot;了吧。&lt;/p>
&lt;p>好，接着用类似的方法，使用 netcat 来发送这个请求：&lt;/p>
&lt;pre>&lt;code>netcat www.google.com 80 &amp;lt; ~/Downloads/request.txt
&lt;/code>&lt;/pre>
&lt;p>一样从 Google 收到了成功的报文。&lt;/p>
&lt;p>不知这样的几次动手是否能给你一个启示：懂一点特定的协议，使用简单的命令行和文本编辑工具，我们就已经可以做很多事情了。比如上面这样改变 UA 头的办法，可以模拟不同的浏览器，就是用来分析浏览器适配（指根据不同浏览器的兼容性返回不同的页面数据）的常用方法。&lt;/p>
&lt;h2 id="http11">HTTP/1.1&lt;/h2>
&lt;p>1999 年，著名的 RFC2616，在 1.0 的基础上，大量帮助传输效率提升的特性被加入。&lt;/p>
&lt;p>你可能知道，从网络协议分层上看， TCP 协议在 HTTP 协议的下方（TCP 是在 OSI 7 层协议的第 4 层，而 HTTP 则是在最高的第 7 层应用层，因此，前者更加&amp;quot;底层&amp;quot;一点）。&lt;/p>
&lt;p>在 HTTP 1.0 版本时，每一组请求和响应的交互，都要完成一次 TCP 的连接和关闭操作，这在曾经的互联网资源比较贫瘠的时候并没有暴露出多大的问题，但随着互联网的迅速发展，这种通讯模式显然过于低效了。&lt;/p>
&lt;p>于是这个问题的解决方案&amp;mdash;&amp;mdash;HTTP 的长连接，就自然而然地出现了，它指的是打开一次 TCP 连接，可以被连续几次报文传输重用，这样一来，我们就不需要给每次请求和响应都创建专门的连接了：&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/2e/f9/2e5a9e7cdc1560967168e96c642517f9.jpg" alt="">（上图来自 &lt;a href="https://medium.com/platform-engineer/evolution-of-http-69cfe6531ba0">Evolution of HTTP &amp;mdash; HTTP/0.9, HTTP/1.0, HTTP/1.1, Keep-Alive, Upgrade, and HTTPS&lt;/a>）&lt;/p>
&lt;p>可以看到，&lt;strong>通过建立长连接，中间的几次 TCP 连接开始和结束的握手都省掉了。&lt;/strong>&lt;/p>
&lt;p>那好，我们还是使用 netcat，这次把版本号改成 1.1，同时打开长连接：&lt;/p>
&lt;pre>&lt;code>GET / HTTP/1.1
Host: www.google.com
User-Agent: Mozilla/1.22 (compatible; MSIE 2.0; Windows 3.1)
Connection: keep-alive
Accept: text/html
&lt;/code>&lt;/pre>
&lt;p>（别忘了上面那个空行）&lt;/p>
&lt;p>相信你也注意到了上面客户端要求开启长连接的 HTTP 头：&lt;/p>
&lt;pre>&lt;code>Connection: keep-alive
&lt;/code>&lt;/pre>
&lt;p>再按老办法运行：&lt;/p>
&lt;pre>&lt;code>netcat www.google.com 80 &amp;lt; ~/Downloads/request.txt
&lt;/code>&lt;/pre>
&lt;p>我们果然得到了 Google 的响应：&lt;/p>
&lt;pre>&lt;code>HTTP/1.1 200 OK
Date: ...
Expires: -1
Cache-Control: private, max-age=0
Content-Type: text/html; charset=ISO-8859-1
Transfer-Encoding: chunked
...（此处省略多行 HTTP 头）
127a
...（此处省略 HTML）
0
&lt;/code>&lt;/pre>
&lt;p>但是在响应中，值得注意的有两点：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>在 HTTP 头部，有这样一行：&lt;/p>
&lt;p>Transfer-Encoding: chunked&lt;/p>
&lt;/li>
&lt;li>
&lt;p>正文的内容是这样的：&lt;/p>
&lt;p>127a
&amp;hellip;
0&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>同时，之前我们见到过头部的 Content-Length 不见了。这是怎么回事呢？&lt;/p>
&lt;p>事实上，如果协议头中存在上述的 chunked 头，表示将采用分块传输编码，响应的消息将由若干个块分次传输，而不是一次传回。刚才的 127a，指的是接下去这一块的大小，在这些有意义的块传输完毕后，会紧跟上一个长度为 0 的块和一个空行，表示传输结束了，这也是最后的那个 0 的含义。&lt;/p>
&lt;p>值得注意的是，实际上在这个 0 之后，协议还允许放一些额外的信息，这部分会被称作&amp;quot;&lt;a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Trailer">Trailer&lt;/a>&amp;quot;，这个额外的信息可以是用来校验正确性的 checksum，可以是数字签名，或者传输完成的状态等等。&lt;/p>
&lt;p>在长连接开启的情况下，使用 Content-Length 还是 chunked 头，必须具备其中一种。&lt;strong>分块传输编码大大地提高了 HTTP 交互的灵活性&lt;/strong> ，服务端可以在还不知道最终将传递多少数据的时候，就可以一块一块将数据传回来。在 [第 03 讲] 中，你还会看到藉由分块传输，可以实现一些模拟服务端推送的技术，比如 &lt;a href="https://en.wikipedia.org/wiki/Comet_(programming)">Comet&lt;/a>。&lt;/p>
&lt;p>事实上 HTTP/1.1 还增加了很多其它的特性，比如更全面的方法，以及更全面的返回码，对指定客户端缓存策略的支持，对 content negotiation 的支持（即通过客户端请求的以 Accept 开头的头部来告知服务端它能接受的内容类型），等等。&lt;/p>
&lt;h2 id="http2">HTTP/2&lt;/h2>
&lt;p>现在最广泛使用的 HTTP 协议还是 1.1 ，但是 HTTP/2 已经提出，在保持兼容性的基础上，包含了这样几个重要改进：&lt;/p>
&lt;ul>
&lt;li>设计了一种机制，允许客户端来选择使用的 HTTP 版本，这个机制被命名为 ALPN；&lt;/li>
&lt;li>HTTP 头的压缩，在 HTTP/2 以前，HTTP 正文支持多种方式的压缩，但是 HTTP 头部却不能；&lt;/li>
&lt;li>多路复用，允许客户端同时在一个连接中同时传输多组请求响应的方法；&lt;/li>
&lt;li>服务端的 push 机制，比方说客户端去获取一个网页的时候，下载网页，分析网页内容，得知还需要一个 js 文件和一个 css 文件，于是再分别下载，而服务端的 push 机制可以提前就把这些资源推送到客户端，而不需要客户端来索取，从而节约网页加载总时间。&lt;/li>
&lt;/ul>
&lt;p>在 HTTP/2 之后，我们展望未来，HTTP/3 已经箭在弦上。如同前面的版本更新一样，依旧围绕传输效率这个协议核心来做进一步改进，其承载协议将从 TCP 转移到基于 UDP 的 &lt;a href="https://en.wikipedia.org/wiki/QUIC">QUIC&lt;/a> 上面来。&lt;/p>
&lt;p>最后，我想说的是，&lt;strong>HTTP 协议的进化史，恰恰是互联网进化史的一个绝佳缩影&lt;/strong>，从中你可以看到互联网发展的数个特质。比方说，长连接和分块传输很大程度上增强了 HTTP 交互模型上的灵活性，使得 B/S 架构下的消息即时推送成为可能。&lt;/p>
&lt;h2 id="总结思考">总结思考&lt;/h2>
&lt;p>今天我们了解了 HTTP 协议的进化史，并且用了动手操作的方法来帮助你理解内容，还分析了其中两个重要的特性，长连接和分块传输。希望经过今天的实践，除了知识本身的学习，你还能够&lt;strong>在快速的动手验证中，强化自己的主观认识，并将这种学习知识的方式培养成一种习惯，这是学习全栈技能的一大法宝&lt;/strong>。&lt;/p>
&lt;p>现在，让我们来进一步思考这样两个问题：&lt;/p>
&lt;ul>
&lt;li>文中介绍了分块传输的 HTTP 特性，你觉得它可以应用到哪些具体场景？&lt;/li>
&lt;li>如果让你去设计一个新的网络协议，你能否举例设计的过程中需要遵循哪些原则？&lt;/li>
&lt;/ul>
&lt;p>好，今天的分享就到这里，欢迎提出你的疑问，也期待你留言与我交流！&lt;/p>
&lt;h2 id="选修课堂抓一段-http-的包">选修课堂：抓一段 HTTP 的包&lt;/h2>
&lt;p>如果你对于使用 tcpdump 进行网络抓包这个技能已经了解了，就可以跳过下面的内容。反之，推荐你动动手。因为在学习任何网络协议的时候，网络抓包是一个非常基本的实践前置技能；而在实际定位问题的时候，也时不时需要抓包分析。这也是我在第一讲就放上这堂选修课的原因。&lt;/p>
&lt;p>俗话说，耳听为虚，眼见为实，下面让我们继续动手实践。你当然可以尝试抓访问某个网站的包，但也可以在本机自己启动一个 web 服务，抓一段 HTTP GET 请求的报文。&lt;/p>
&lt;p>利用 Python，在任意目录，一行命令就可以在端口 8080 上启动一个完备的 HTTP 服务（这大概是世界上最简单的启动一个 HTTP 服务的方式了）：&lt;/p>
&lt;pre>&lt;code>python -m SimpleHTTPServer 8080
&lt;/code>&lt;/pre>
&lt;p>启动成功后，你应该能看到：&lt;/p>
&lt;pre>&lt;code>Serving HTTP on 0.0.0.0 port 8080 ...
&lt;/code>&lt;/pre>
&lt;p>接着使用 tcpdump 来抓包，注意抓的是 loopback 的包（本地发送到本地），因此执行：&lt;/p>
&lt;pre>&lt;code>sudo tcpdump -i lo0 -v 'port 8080' -w http.cap
&lt;/code>&lt;/pre>
&lt;p>这里的 -i 参数表示指定 interface，而因为客户端和服务端都在本地，因此使用 lo0（我使用的是 Mac，在某些 Linux 操作系统下可能是 lo，具体可以通过 ifconfig 查看）指定 loopback 的接口，这里我们只想捕获发往 8080 端口的数据包，结果汇总成 http.cap 文件。&lt;/p>
&lt;p>打开浏览器敲入 &lt;a href="http://localhost:8080">http://localhost:8080&lt;/a> 并回车，应该能看到启动 HTTP 服务路径下的文件（夹）列表。这时候你也应该能看到类似下面这样的文字，标志着多少包被捕获，多少包被过滤掉了：&lt;/p>
&lt;pre>&lt;code>24 packets captured
232 packets received by filter
&lt;/code>&lt;/pre>
&lt;p>好，现在我们使用 CTRL + C 结束这个抓包过程。&lt;/p>
&lt;p>抓包后使用 &lt;a href="https://www.wireshark.org/">Wireshark&lt;/a> 打开该 http.cap 文件，在 filter 里面输入 http 以过滤掉别的我们不关心的数据包，我们应该能看到请求和响应至少两条数据。于是接下去的内容就是我们非常关心的了。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/2b/d8/2bdc949865ae703a08ffd528d44e3ad8.jpeg" alt="">&lt;/p>
&lt;p>如果你看到这里，我想请你再思考下，在不设置上面的 http filter 的时候，我们会看到比这多得多的报文，它们不是 HTTP 的请求响应所以才被过滤掉了，那么，它们都有什么呢？&lt;/p>
&lt;h2 id="扩展阅读">扩展阅读&lt;/h2>
&lt;ul>
&lt;li>【基础】如果你对 HTTP 还不熟悉的话，推荐你阅读一篇系统性介绍 HTTP 的教程，比如 &lt;a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP">MDN 的这篇教程&lt;/a>。&lt;/li>
&lt;li>【基础】&lt;a href="https://www.networkworld.com/article/3239677/the-osi-model-explained-how-to-understand-and-remember-the-7-layer-network-model.html">The OSI model explained: How to understand (and remember) the 7 layer network model&lt;/a>：如果你对网络的 OSI 7 层模型还不清楚的话，建议阅读。如果你想知道那些鼎鼎大名的网络协议在这个模型中的哪个位置，那么请从 &lt;a href="https://en.wikipedia.org/wiki/List_of_network_protocols_(OSI_model)">List of network protocols (OSI model)&lt;/a> 里面找。基于聚焦主题的关系，我们在这个专栏中不会详细介绍呈现层（Presentation Layer）之下的网络协议。&lt;/li>
&lt;li>HTTP &lt;a href="https://tools.ietf.org/html/rfc1945">1.0&lt;/a>、&lt;a href="https://tools.ietf.org/html/rfc2616">1.1&lt;/a> 和 &lt;a href="https://tools.ietf.org/html/rfc7540">2.0&lt;/a>：它们是 RFC 文档，看起来似乎枯燥乏味，通常我们不需要去仔细阅读它们，但是当我们想知道对协议的理解是否正确，它们是我们最终的参考依据。&lt;/li>
&lt;li>&lt;a href="http://www.ra.ethz.ch/cdstore/www8/data/2136/pdf/pd1.pdf">Key differences between HTTP 1.0 and HTTP 1.1&lt;/a>：文中总结了从 HTTP 1.0 到 1.1 的 9 大改进；而 &lt;a href="http://qnimate.com/post-series/http2-complete-tutorial/">HTTP/2 Complete Tutorial&lt;/a> 是一篇比较系统的 HTTP/2 的介绍。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/11/8b/1181246bbd51ce348d5729696d1dc28b.jpg" alt="unpreview">&lt;/p></description></item><item><title>极客专栏: 01丨使用了并发工具类库，线程安全就高枕无忧了吗？</title><link>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/java%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF100%E4%BE%8B/01%E4%B8%A8%E4%BD%BF%E7%94%A8%E4%BA%86%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB%E5%BA%93%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%B0%B1%E9%AB%98%E6%9E%95%E6%97%A0%E5%BF%A7%E4%BA%86%E5%90%97/</link><pubDate>Sun, 29 May 2022 00:00:00 +0000</pubDate><guid>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/java%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF100%E4%BE%8B/01%E4%B8%A8%E4%BD%BF%E7%94%A8%E4%BA%86%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB%E5%BA%93%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%B0%B1%E9%AB%98%E6%9E%95%E6%97%A0%E5%BF%A7%E4%BA%86%E5%90%97/</guid><description>
&lt;p>你好，我是朱晔。作为课程的第一讲，我今天要和你聊聊使用并发工具类库相关的话题。&lt;/p>
&lt;p>在代码审核讨论的时候，我们有时会听到有关线程安全和并发工具的一些片面的观点和结论，比如&amp;quot;把 HashMap 改为 ConcurrentHashMap，就可以解决并发问题了呀&amp;quot;&amp;ldquo;要不我们试试无锁的 CopyOnWriteArrayList 吧，性能更好&amp;rdquo;。事实上，这些说法都不太准确。&lt;/p>
&lt;p>的确，为了方便开发者进行多线程编程，现代编程语言会提供各种并发工具类。但如果我们没有充分了解它们的使用场景、解决的问题，以及最佳实践的话，盲目使用就可能会导致一些坑，小则损失性能，大则无法确保多线程情况下业务逻辑的正确性。&lt;/p>
&lt;p>我需要先说明下，这里的并发工具类是指用来解决多线程环境下并发问题的工具类库。一般而言并发工具包括同步器和容器两大类，业务代码中使用并发容器的情况会多一些，我今天分享的例子也会侧重并发容器。&lt;/p>
&lt;p>接下来，我们就看看在使用并发工具时，最常遇到哪些坑，以及如何解决、避免这些坑吧。&lt;/p>
&lt;h1 id="没有意识到线程重用导致用户信息错乱的-bug">没有意识到线程重用导致用户信息错乱的 Bug&lt;/h1>
&lt;p>之前有业务同学和我反馈，在生产上遇到一个诡异的问题，有时获取到的用户信息是别人的。查看代码后，我发现他使用了 ThreadLocal 来缓存获取到的用户信息。&lt;/p>
&lt;p>我们知道，ThreadLocal 适用于变量在线程间隔离，而在方法或类间共享的场景。如果用户信息的获取比较昂贵（比如从数据库查询用户信息），那么在 ThreadLocal 中缓存数据是比较合适的做法。但，这么做为什么会出现用户信息错乱的 Bug 呢？&lt;/p>
&lt;p>我们看一个具体的案例吧。&lt;/p>
&lt;p>使用 Spring Boot 创建一个 Web 应用程序，使用 ThreadLocal 存放一个 Integer 的值，来暂且代表需要在线程中保存的用户信息，这个值初始是 null。在业务逻辑中，我先从 ThreadLocal 获取一次值，然后把外部传入的参数设置到 ThreadLocal 中，来模拟从当前上下文获取到用户信息的逻辑，随后再获取一次值，最后输出两次获得的值和线程名称。&lt;/p>
&lt;pre tabindex="0">&lt;code>private ThreadLocal&amp;lt;Integer&amp;gt; currentUser = ThreadLocal.withInitial(() -&amp;gt; null);
@GetMapping(&amp;#34;wrong&amp;#34;)
public Map wrong(@RequestParam(&amp;#34;userId&amp;#34;) Integer userId) {
//设置用户信息之前先查询一次ThreadLocal中的用户信息
String before = Thread.currentThread().getName() + &amp;#34;:&amp;#34; + currentUser.get();
//设置用户信息到ThreadLocal
currentUser.set(userId);
//设置用户信息之后再查询一次ThreadLocal中的用户信息
String after = Thread.currentThread().getName() + &amp;#34;:&amp;#34; + currentUser.get();
//汇总输出两次查询结果
Map result = new HashMap();
result.put(&amp;#34;before&amp;#34;, before);
result.put(&amp;#34;after&amp;#34;, after);
return result;
}
&lt;/code>&lt;/pre>&lt;p>按理说，在设置用户信息之前第一次获取的值始终应该是 null，但我们要意识到，程序运行在 Tomcat 中，执行程序的线程是 Tomcat 的工作线程，而 Tomcat 的工作线程是基于线程池的。&lt;/p>
&lt;p>&lt;strong>顾名思义，线程池会重用固定的几个线程，一旦线程重用，那么很可能首次从 ThreadLocal 获取的值是之前其他用户的请求遗留的值。这时，ThreadLocal 中的用户信息就是其他用户的信息。&lt;/strong>&lt;/p>
&lt;p>为了更快地重现这个问题，我在配置文件中设置一下 Tomcat 的参数，把工作线程池最大线程数设置为 1，这样始终是同一个线程在处理请求：&lt;/p>
&lt;pre tabindex="0">&lt;code>server.tomcat.max-threads=1
&lt;/code>&lt;/pre>&lt;p>运行程序后先让用户 1 来请求接口，可以看到第一和第二次获取到用户 ID 分别是 null 和 1，符合预期：&lt;br>
&lt;img src="https://static001.geekbang.org/resource/image/4b/30/4b8f38415d03423132c7a3608ebe2430.png" alt="">&lt;/p>
&lt;p>随后用户 2 来请求接口，这次就出现了 Bug，第一和第二次获取到用户 ID 分别是 1 和 2，显然第一次获取到了用户 1 的信息，原因就是 Tomcat 的线程池重用了线程。从图中可以看到，两次请求的线程都是同一个线程：http-nio-8080-exec-1。&lt;br>
&lt;img src="https://static001.geekbang.org/resource/image/a9/db/a9ccd42716d807687b3acff9a0baf2db.png" alt="">&lt;/p>
&lt;p>这个例子告诉我们，在写业务代码时，首先要理解代码会跑在什么线程上：&lt;/p>
&lt;ul>
&lt;li>我们可能会抱怨学多线程没用，因为代码里没有开启使用多线程。但其实，可能只是我们没有意识到，在 Tomcat 这种 Web 服务器下跑的业务代码，本来就运行在一个多线程环境（否则接口也不可能支持这么高的并发），&lt;strong>并不能认为没有显式开启多线程就不会有线程安全问题&lt;/strong>。&lt;/li>
&lt;li>因为线程的创建比较昂贵，所以 Web 服务器往往会使用线程池来处理请求，这就意味着线程会被重用。这时，&lt;strong>使用类似 ThreadLocal 工具来存放一些数据时，需要特别注意在代码运行完后，显式地去清空设置的数据&lt;/strong>。如果在代码中使用了自定义的线程池，也同样会遇到这个问题。&lt;/li>
&lt;/ul>
&lt;p>理解了这个知识点后，我们修正这段代码的方案是，在代码的 finally 代码块中，显式清除 ThreadLocal 中的数据。这样一来，新的请求过来即使使用了之前的线程也不会获取到错误的用户信息了。修正后的代码如下：&lt;/p>
&lt;pre tabindex="0">&lt;code>@GetMapping(&amp;#34;right&amp;#34;)
public Map right(@RequestParam(&amp;#34;userId&amp;#34;) Integer userId) {
String before = Thread.currentThread().getName() + &amp;#34;:&amp;#34; + currentUser.get();
currentUser.set(userId);
try {
String after = Thread.currentThread().getName() + &amp;#34;:&amp;#34; + currentUser.get();
Map result = new HashMap();
result.put(&amp;#34;before&amp;#34;, before);
result.put(&amp;#34;after&amp;#34;, after);
return result;
} finally {
//在finally代码块中删除ThreadLocal中的数据，确保数据不串
currentUser.remove();
}
}
&lt;/code>&lt;/pre>&lt;p>重新运行程序可以验证，再也不会出现第一次查询用户信息查询到之前用户请求的 Bug：&lt;br>
&lt;img src="https://static001.geekbang.org/resource/image/0d/cc/0dfe40fca441b58d491fc799d120a7cc.png" alt="">&lt;/p>
&lt;p>ThreadLocal 是利用独占资源的方式，来解决线程安全问题，那如果我们确实需要有资源在线程之前共享，应该怎么办呢？这时，我们可能就需要用到线程安全的容器了。&lt;/p>
&lt;h1 id="使用了线程安全的并发工具并不代表解决了所有线程安全问题">使用了线程安全的并发工具，并不代表解决了所有线程安全问题&lt;/h1>
&lt;p>JDK 1.5 后推出的 ConcurrentHashMap，是一个高性能的线程安全的哈希表容器。&amp;ldquo;线程安全&amp;quot;这四个字特别容易让人误解，因为 &lt;strong>ConcurrentHashMap 只能保证提供的原子性读写操作是线程安全的。&lt;/strong>&lt;/p>
&lt;p>我在相当多的业务代码中看到过这个误区，比如下面这个场景。有一个含 900 个元素的 Map，现在再补充 100 个元素进去，这个补充操作由 10 个线程并发进行。开发人员误以为使用了 ConcurrentHashMap 就不会有线程安全问题，于是不加思索地写出了下面的代码：在每一个线程的代码逻辑中先通过 size 方法拿到当前元素数量，计算 ConcurrentHashMap 目前还需要补充多少元素，并在日志中输出了这个值，然后通过 putAll 方法把缺少的元素添加进去。&lt;/p>
&lt;p>为方便观察问题，我们输出了这个 Map 一开始和最后的元素个数。&lt;/p>
&lt;pre tabindex="0">&lt;code>//线程个数
private static int THREAD_COUNT = 10;
//总元素数量
private static int ITEM_COUNT = 1000;
//帮助方法，用来获得一个指定元素数量模拟数据的ConcurrentHashMap
private ConcurrentHashMap&amp;lt;String, Long&amp;gt; getData(int count) {
return LongStream.rangeClosed(1, count)
.boxed()
.collect(Collectors.toConcurrentMap(i -&amp;gt; UUID.randomUUID().toString(), Function.identity(),
(o1, o2) -&amp;gt; o1, ConcurrentHashMap::new));
}
@GetMapping(&amp;#34;wrong&amp;#34;)
public String wrong() throws InterruptedException {
ConcurrentHashMap&amp;lt;String, Long&amp;gt; concurrentHashMap = getData(ITEM_COUNT - 100);
//初始900个元素
log.info(&amp;#34;init size:{}&amp;#34;, concurrentHashMap.size());
ForkJoinPool forkJoinPool = new ForkJoinPool(THREAD_COUNT);
//使用线程池并发处理逻辑
forkJoinPool.execute(() -&amp;gt; IntStream.rangeClosed(1, 10).parallel().forEach(i -&amp;gt; {
//查询还需要补充多少个元素
int gap = ITEM_COUNT - concurrentHashMap.size();
log.info(&amp;#34;gap size:{}&amp;#34;, gap);
//补充元素
concurrentHashMap.putAll(getData(gap));
}));
//等待所有任务完成
forkJoinPool.shutdown();
forkJoinPool.awaitTermination(1, TimeUnit.HOURS);
//最后元素个数会是1000吗？
log.info(&amp;#34;finish size:{}&amp;#34;, concurrentHashMap.size());
return &amp;#34;OK&amp;#34;;
}
&lt;/code>&lt;/pre>&lt;p>访问接口后程序输出的日志内容如下：&lt;br>
&lt;img src="https://static001.geekbang.org/resource/image/2e/70/2eaf5cd1b910b2678aca15fee6144070.png" alt="">&lt;/p>
&lt;p>从日志中可以看到：&lt;/p>
&lt;ul>
&lt;li>初始大小 900 符合预期，还需要填充 100 个元素。&lt;/li>
&lt;li>worker1 线程查询到当前需要填充的元素为 36，竟然还不是 100 的倍数。&lt;/li>
&lt;li>worker13 线程查询到需要填充的元素数是负的，显然已经过度填充了。&lt;/li>
&lt;li>最后 HashMap 的总项目数是 1536，显然不符合填充满 1000 的预期。&lt;/li>
&lt;/ul>
&lt;p>针对这个场景，我们可以举一个形象的例子。ConcurrentHashMap 就像是一个大篮子，现在这个篮子里有 900 个桔子，我们期望把这个篮子装满 1000 个桔子，也就是再装 100 个桔子。有 10 个工人来干这件事儿，大家先后到岗后会计算还需要补多少个桔子进去，最后把桔子装入篮子。&lt;/p>
&lt;p>ConcurrentHashMap 这个篮子本身，可以确保多个工人在装东西进去时，不会相互影响干扰，但无法确保工人 A 看到还需要装 100 个桔子但是还未装的时候，工人 B 就看不到篮子中的桔子数量。更值得注意的是，你往这个篮子装 100 个桔子的操作不是原子性的，在别人看来可能会有一个瞬间篮子里有 964 个桔子，还需要补 36 个桔子。&lt;/p>
&lt;p>回到 ConcurrentHashMap，我们需要注意 &lt;strong>ConcurrentHashMap 对外提供的方法或能力的限制&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>使用了 ConcurrentHashMap，不代表对它的多个操作之间的状态是一致的，是没有其他线程在操作它的，如果需要确保需要手动加锁。&lt;/li>
&lt;li>诸如 size、isEmpty 和 containsValue 等聚合方法，在并发情况下可能会反映 ConcurrentHashMap 的中间状态。因此在并发情况下，这些方法的返回值只能用作参考，而不能用于流程控制。显然，利用 size 方法计算差异值，是一个流程控制。&lt;/li>
&lt;li>诸如 putAll 这样的聚合方法也不能确保原子性，在 putAll 的过程中去获取数据可能会获取到部分数据。&lt;/li>
&lt;/ul>
&lt;p>代码的修改方案很简单，整段逻辑加锁即可：&lt;/p>
&lt;pre tabindex="0">&lt;code>@GetMapping(&amp;#34;right&amp;#34;)
public String right() throws InterruptedException {
ConcurrentHashMap&amp;lt;String, Long&amp;gt; concurrentHashMap = getData(ITEM_COUNT - 100);
log.info(&amp;#34;init size:{}&amp;#34;, concurrentHashMap.size());
ForkJoinPool forkJoinPool = new ForkJoinPool(THREAD_COUNT);
forkJoinPool.execute(() -&amp;gt; IntStream.rangeClosed(1, 10).parallel().forEach(i -&amp;gt; {
//下面的这段复合逻辑需要锁一下这个ConcurrentHashMap
synchronized (concurrentHashMap) {
int gap = ITEM_COUNT - concurrentHashMap.size();
log.info(&amp;#34;gap size:{}&amp;#34;, gap);
concurrentHashMap.putAll(getData(gap));
}
}));
forkJoinPool.shutdown();
forkJoinPool.awaitTermination(1, TimeUnit.HOURS);
log.info(&amp;#34;finish size:{}&amp;#34;, concurrentHashMap.size());
return &amp;#34;OK&amp;#34;;
}
&lt;/code>&lt;/pre>&lt;p>重新调用接口，程序的日志输出结果符合预期：&lt;br>
&lt;img src="https://static001.geekbang.org/resource/image/11/b8/1151b5b87f27073725060b76c56d95b8.png" alt="">&lt;/p>
&lt;p>可以看到，只有一个线程查询到了需要补 100 个元素，其他 9 个线程查询到不需要补元素，最后 Map 大小为 1000。&lt;/p>
&lt;p>到了这里，你可能又要问了，使用 ConcurrentHashMap 全程加锁，还不如使用普通的 HashMap 呢。&lt;/p>
&lt;p>其实不完全是这样。&lt;/p>
&lt;p>ConcurrentHashMap 提供了一些原子性的简单复合逻辑方法，用好这些方法就可以发挥其威力。这就引申出代码中常见的另一个问题：在使用一些类库提供的高级工具类时，开发人员可能还是按照旧的方式去使用这些新类，因为没有使用其特性，所以无法发挥其威力。&lt;/p>
&lt;h1 id="没有充分了解并发工具的特性从而无法发挥其威力">没有充分了解并发工具的特性，从而无法发挥其威力&lt;/h1>
&lt;p>我们来看一个使用 Map 来统计 Key 出现次数的场景吧，这个逻辑在业务代码中非常常见。&lt;/p>
&lt;ul>
&lt;li>使用 ConcurrentHashMap 来统计，Key 的范围是 10。&lt;/li>
&lt;li>使用最多 10 个并发，循环操作 1000 万次，每次操作累加随机的 Key。&lt;/li>
&lt;li>如果 Key 不存在的话，首次设置值为 1。&lt;/li>
&lt;/ul>
&lt;p>代码如下：&lt;/p>
&lt;pre tabindex="0">&lt;code>//循环次数
private static int LOOP_COUNT = 10000000;
//线程数量
private static int THREAD_COUNT = 10;
//元素数量
private static int ITEM_COUNT = 1000;
private Map&amp;lt;String, Long&amp;gt; normaluse() throws InterruptedException {
ConcurrentHashMap&amp;lt;String, Long&amp;gt; freqs = new ConcurrentHashMap&amp;lt;&amp;gt;(ITEM_COUNT);
ForkJoinPool forkJoinPool = new ForkJoinPool(THREAD_COUNT);
forkJoinPool.execute(() -&amp;gt; IntStream.rangeClosed(1, LOOP_COUNT).parallel().forEach(i -&amp;gt; {
//获得一个随机的Key
String key = &amp;#34;item&amp;#34; + ThreadLocalRandom.current().nextInt(ITEM_COUNT);
synchronized (freqs) {
if (freqs.containsKey(key)) {
//Key存在则+1
freqs.put(key, freqs.get(key) + 1);
} else {
//Key不存在则初始化为1
freqs.put(key, 1L);
}
}
}
));
forkJoinPool.shutdown();
forkJoinPool.awaitTermination(1, TimeUnit.HOURS);
return freqs;
}
&lt;/code>&lt;/pre>&lt;p>我们吸取之前的教训，直接通过锁的方式锁住 Map，然后做判断、读取现在的累计值、加 1、保存累加后值的逻辑。这段代码在功能上没有问题，但无法充分发挥 ConcurrentHashMap 的威力，改进后的代码如下：&lt;/p>
&lt;pre tabindex="0">&lt;code>private Map&amp;lt;String, Long&amp;gt; gooduse() throws InterruptedException {
ConcurrentHashMap&amp;lt;String, LongAdder&amp;gt; freqs = new ConcurrentHashMap&amp;lt;&amp;gt;(ITEM_COUNT);
ForkJoinPool forkJoinPool = new ForkJoinPool(THREAD_COUNT);
forkJoinPool.execute(() -&amp;gt; IntStream.rangeClosed(1, LOOP_COUNT).parallel().forEach(i -&amp;gt; {
String key = &amp;#34;item&amp;#34; + ThreadLocalRandom.current().nextInt(ITEM_COUNT);
//利用computeIfAbsent()方法来实例化LongAdder，然后利用LongAdder来进行线程安全计数
freqs.computeIfAbsent(key, k -&amp;gt; new LongAdder()).increment();
}
));
forkJoinPool.shutdown();
forkJoinPool.awaitTermination(1, TimeUnit.HOURS);
//因为我们的Value是LongAdder而不是Long，所以需要做一次转换才能返回
return freqs.entrySet().stream()
.collect(Collectors.toMap(
e -&amp;gt; e.getKey(),
e -&amp;gt; e.getValue().longValue())
);
}
&lt;/code>&lt;/pre>&lt;p>在这段改进后的代码中，我们巧妙利用了下面两点：&lt;/p>
&lt;ul>
&lt;li>使用 ConcurrentHashMap 的原子性方法 computeIfAbsent 来做复合逻辑操作，判断 Key 是否存在 Value，如果不存在则把 Lambda 表达式运行后的结果放入 Map 作为 Value，也就是新创建一个 LongAdder 对象，最后返回 Value。&lt;/li>
&lt;li>由于 computeIfAbsent 方法返回的 Value 是 LongAdder，是一个线程安全的累加器，因此可以直接调用其 increment 方法进行累加。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>这样在确保线程安全的情况下达到极致性能，把之前 7 行代码替换为了 1 行。&lt;/strong>&lt;/p>
&lt;p>我们通过一个简单的测试比较一下修改前后两段代码的性能：&lt;/p>
&lt;pre tabindex="0">&lt;code>@GetMapping(&amp;#34;good&amp;#34;)
public String good() throws InterruptedException {
StopWatch stopWatch = new StopWatch();
stopWatch.start(&amp;#34;normaluse&amp;#34;);
Map&amp;lt;String, Long&amp;gt; normaluse = normaluse();
stopWatch.stop();
//校验元素数量
Assert.isTrue(normaluse.size() == ITEM_COUNT, &amp;#34;normaluse size error&amp;#34;);
//校验累计总数
Assert.isTrue(normaluse.entrySet().stream()
.mapToLong(item -&amp;gt; item.getValue()).reduce(0, Long::sum) == LOOP_COUNT
, &amp;#34;normaluse count error&amp;#34;);
stopWatch.start(&amp;#34;gooduse&amp;#34;);
Map&amp;lt;String, Long&amp;gt; gooduse = gooduse();
stopWatch.stop();
Assert.isTrue(gooduse.size() == ITEM_COUNT, &amp;#34;gooduse size error&amp;#34;);
Assert.isTrue(gooduse.entrySet().stream()
.mapToLong(item -&amp;gt; item.getValue())
.reduce(0, Long::sum) == LOOP_COUNT
, &amp;#34;gooduse count error&amp;#34;);
log.info(stopWatch.prettyPrint());
return &amp;#34;OK&amp;#34;;
}
&lt;/code>&lt;/pre>&lt;p>这段测试代码并无特殊之处，使用 StopWatch 来测试两段代码的性能，最后跟了一个断言判断 Map 中元素的个数以及所有 Value 的和，是否符合预期来校验代码的正确性。测试结果如下：&lt;br>
&lt;img src="https://static001.geekbang.org/resource/image/75/3a/751d484ecd8c3114c15588e7fff3263a.png" alt="">&lt;/p>
&lt;p>可以看到，&lt;strong>优化后的代码，相比使用锁来操作 ConcurrentHashMap 的方式，性能提升了 10 倍&lt;/strong>。&lt;/p>
&lt;p>你可能会问，computeIfAbsent 为什么如此高效呢？&lt;/p>
&lt;p>答案就在源码最核心的部分，也就是 Java 自带的 Unsafe 实现的 CAS。它在虚拟机层面确保了写入数据的原子性，比加锁的效率高得多：&lt;/p>
&lt;pre tabindex="0">&lt;code> static final &amp;lt;K,V&amp;gt; boolean casTabAt(Node&amp;lt;K,V&amp;gt;[] tab, int i,
Node&amp;lt;K,V&amp;gt; c, Node&amp;lt;K,V&amp;gt; v) {
return U.compareAndSetObject(tab, ((long)i &amp;lt;&amp;lt; ASHIFT) + ABASE, c, v);
}
&lt;/code>&lt;/pre>&lt;p>像 ConcurrentHashMap 这样的高级并发工具的确提供了一些高级 API，只有充分了解其特性才能最大化其威力，而不能因为其足够高级、酷炫盲目使用。&lt;/p>
&lt;h1 id="没有认清并发工具的使用场景因而导致性能问题">没有认清并发工具的使用场景，因而导致性能问题&lt;/h1>
&lt;p>除了 ConcurrentHashMap 这样通用的并发工具类之外，我们的工具包中还有些针对特殊场景实现的生面孔。一般来说，针对通用场景的通用解决方案，在所有场景下性能都还可以，属于&amp;quot;万金油&amp;rdquo;；而针对特殊场景的特殊实现，会有比通用解决方案更高的性能，但一定要在它针对的场景下使用，否则可能会产生性能问题甚至是 Bug。&lt;/p>
&lt;p>之前在排查一个生产性能问题时，我们发现一段简单的非数据库操作的业务逻辑，消耗了超出预期的时间，在修改数据时操作本地缓存比回写数据库慢许多。查看代码发现，开发同学使用了 CopyOnWriteArrayList 来缓存大量的数据，而数据变化又比较频繁。&lt;/p>
&lt;p>CopyOnWrite 是一个时髦的技术，不管是 Linux 还是 Redis 都会用到。&lt;strong>在 Java 中，CopyOnWriteArrayList 虽然是一个线程安全的 ArrayList，但因为其实现方式是，每次修改数据时都会复制一份数据出来，所以有明显的适用场景，即读多写少或者说希望无锁读的场景。&lt;/strong>&lt;/p>
&lt;p>如果我们要使用 CopyOnWriteArrayList，那一定是因为场景需要而不是因为足够酷炫。如果读写比例均衡或者有大量写操作的话，使用 CopyOnWriteArrayList 的性能会非常糟糕。&lt;/p>
&lt;p>我们写一段测试代码，来比较下使用 CopyOnWriteArrayList 和普通加锁方式 ArrayList 的读写性能吧。在这段代码中我们针对并发读和并发写分别写了一个测试方法，测试两者一定次数的写或读操作的耗时。&lt;/p>
&lt;pre tabindex="0">&lt;code>//测试并发写的性能
@GetMapping(&amp;#34;write&amp;#34;)
public Map testWrite() {
List&amp;lt;Integer&amp;gt; copyOnWriteArrayList = new CopyOnWriteArrayList&amp;lt;&amp;gt;();
List&amp;lt;Integer&amp;gt; synchronizedList = Collections.synchronizedList(new ArrayList&amp;lt;&amp;gt;());
StopWatch stopWatch = new StopWatch();
int loopCount = 100000;
stopWatch.start(&amp;#34;Write:copyOnWriteArrayList&amp;#34;);
//循环100000次并发往CopyOnWriteArrayList写入随机元素
IntStream.rangeClosed(1, loopCount).parallel().forEach(__ -&amp;gt; copyOnWriteArrayList.add(ThreadLocalRandom.current().nextInt(loopCount)));
stopWatch.stop();
stopWatch.start(&amp;#34;Write:synchronizedList&amp;#34;);
//循环100000次并发往加锁的ArrayList写入随机元素
IntStream.rangeClosed(1, loopCount).parallel().forEach(__ -&amp;gt; synchronizedList.add(ThreadLocalRandom.current().nextInt(loopCount)));
stopWatch.stop();
log.info(stopWatch.prettyPrint());
Map result = new HashMap();
result.put(&amp;#34;copyOnWriteArrayList&amp;#34;, copyOnWriteArrayList.size());
result.put(&amp;#34;synchronizedList&amp;#34;, synchronizedList.size());
return result;
}
//帮助方法用来填充List
private void addAll(List&amp;lt;Integer&amp;gt; list) {
list.addAll(IntStream.rangeClosed(1, 1000000).boxed().collect(Collectors.toList()));
}
//测试并发读的性能
@GetMapping(&amp;#34;read&amp;#34;)
public Map testRead() {
//创建两个测试对象
List&amp;lt;Integer&amp;gt; copyOnWriteArrayList = new CopyOnWriteArrayList&amp;lt;&amp;gt;();
List&amp;lt;Integer&amp;gt; synchronizedList = Collections.synchronizedList(new ArrayList&amp;lt;&amp;gt;());
//填充数据
addAll(copyOnWriteArrayList);
addAll(synchronizedList);
StopWatch stopWatch = new StopWatch();
int loopCount = 1000000;
int count = copyOnWriteArrayList.size();
stopWatch.start(&amp;#34;Read:copyOnWriteArrayList&amp;#34;);
//循环1000000次并发从CopyOnWriteArrayList随机查询元素
IntStream.rangeClosed(1, loopCount).parallel().forEach(__ -&amp;gt; copyOnWriteArrayList.get(ThreadLocalRandom.current().nextInt(count)));
stopWatch.stop();
stopWatch.start(&amp;#34;Read:synchronizedList&amp;#34;);
//循环1000000次并发从加锁的ArrayList随机查询元素
IntStream.range(0, loopCount).parallel().forEach(__ -&amp;gt; synchronizedList.get(ThreadLocalRandom.current().nextInt(count)));
stopWatch.stop();
log.info(stopWatch.prettyPrint());
Map result = new HashMap();
result.put(&amp;#34;copyOnWriteArrayList&amp;#34;, copyOnWriteArrayList.size());
result.put(&amp;#34;synchronizedList&amp;#34;, synchronizedList.size());
return result;
}
&lt;/code>&lt;/pre>&lt;p>运行程序可以看到，**大量写的场景（10 万次 add 操作），**&lt;strong>CopyOnWriteArray 几乎比同步的 ArrayList 慢一百倍&lt;/strong>：&lt;br>
&lt;img src="https://static001.geekbang.org/resource/image/97/b4/9789fe2019a1267b7883606b60e498b4.png" alt="">&lt;/p>
&lt;p>而在大量读的场景下（100 万次 get 操作），CopyOnWriteArray 又比同步的 ArrayList 快五倍以上：&lt;br>
&lt;img src="https://static001.geekbang.org/resource/image/30/36/30ba652fb3295c58b03f51de0a132436.png" alt="">&lt;/p>
&lt;p>你可能会问，为何在大量写的场景下，CopyOnWriteArrayList 会这么慢呢？&lt;/p>
&lt;p>答案就在源码中。以 add 方法为例，每次 add 时，都会用 Arrays.copyOf 创建一个新数组，频繁 add 时内存的申请释放消耗会很大：&lt;/p>
&lt;pre tabindex="0">&lt;code> /**
* Appends the specified element to the end of this list.
*
* @param e element to be appended to this list
* @return {@code true} (as specified by {@link Collection#add})
*/
public boolean add(E e) {
synchronized (lock) {
Object[] elements = getArray();
int len = elements.length;
Object[] newElements = Arrays.copyOf(elements, len + 1);
newElements[len] = e;
setArray(newElements);
return true;
}
}
&lt;/code>&lt;/pre>&lt;h1 id="重点回顾">重点回顾&lt;/h1>
&lt;p>今天，我主要与你分享了，开发人员使用并发工具来解决线程安全问题时容易犯的四类错。&lt;/p>
&lt;p>一是，只知道使用并发工具，但并不清楚当前线程的来龙去脉，解决多线程问题却不了解线程。比如，使用 ThreadLocal 来缓存数据，以为 ThreadLocal 在线程之间做了隔离不会有线程安全问题，没想到线程重用导致数据串了。请务必记得，在业务逻辑结束之前清理 ThreadLocal 中的数据。&lt;/p>
&lt;p>二是，误以为使用了并发工具就可以解决一切线程安全问题，期望通过把线程不安全的类替换为线程安全的类来一键解决问题。比如，认为使用了 ConcurrentHashMap 就可以解决线程安全问题，没对复合逻辑加锁导致业务逻辑错误。如果你希望在一整段业务逻辑中，对容器的操作都保持整体一致性的话，需要加锁处理。&lt;/p>
&lt;p>三是，没有充分了解并发工具的特性，还是按照老方式使用新工具导致无法发挥其性能。比如，使用了 ConcurrentHashMap，但没有充分利用其提供的基于 CAS 安全的方法，还是使用锁的方式来实现逻辑。你可以阅读一下ConcurrentHashMap 的文档，看一下相关原子性操作 API 是否可以满足业务需求，如果可以则优先考虑使用。&lt;/p>
&lt;p>四是，没有了解清楚工具的适用场景，在不合适的场景下使用了错误的工具导致性能更差。比如，没有理解 CopyOnWriteArrayList 的适用场景，把它用在了读写均衡或者大量写操作的场景下，导致性能问题。对于这种场景，你可以考虑是用普通的 List。&lt;/p>
&lt;p>其实，这四类坑之所以容易踩到，原因可以归结为，我们在使用并发工具的时候，并没有充分理解其可能存在的问题、适用场景等。所以最后，&lt;strong>我还要和你分享两点建议&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>一定要认真阅读官方文档（比如 Oracle JDK 文档）。充分阅读官方文档，理解工具的适用场景及其 API 的用法，并做一些小实验。了解之后再去使用，就可以避免大部分坑。&lt;/li>
&lt;li>如果你的代码运行在多线程环境下，那么就会有并发问题，并发问题不那么容易重现，可能需要使用压力测试模拟并发场景，来发现其中的 Bug 或性能问题。&lt;/li>
&lt;/ul>
&lt;p>今天用到的代码，我都放在了 GitHub 上，你可以点击这个链接查看。&lt;/p>
&lt;h1 id="思考与讨论">思考与讨论&lt;/h1>
&lt;ul>
&lt;li>今天我们多次用到了 ThreadLocalRandom，你觉得是否可以把它的实例设置到静态变量中，在多线程情况下重用呢？&lt;/li>
&lt;li>ConcurrentHashMap 还提供了 putIfAbsent 方法，你能否通过查阅JDK 文档，说说 computeIfAbsent 和 putIfAbsent 方法的区别？&lt;/li>
&lt;/ul>
&lt;p>你在使用并发工具时，还遇到过其他坑吗？我是朱晔，欢迎在评论区与我留言分享你的想法，也欢迎你把这篇文章分享给你的朋友或同事，一起交流。&lt;/p></description></item><item><title>极客专栏: 01丨可见性、原子性和有序性问题：并发编程Bug的源头</title><link>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/01%E4%B8%A8%E5%8F%AF%E8%A7%81%E6%80%A7%E5%8E%9F%E5%AD%90%E6%80%A7%E5%92%8C%E6%9C%89%E5%BA%8F%E6%80%A7%E9%97%AE%E9%A2%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8Bbug%E7%9A%84%E6%BA%90%E5%A4%B4/</link><pubDate>Sun, 29 May 2022 00:00:00 +0000</pubDate><guid>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/01%E4%B8%A8%E5%8F%AF%E8%A7%81%E6%80%A7%E5%8E%9F%E5%AD%90%E6%80%A7%E5%92%8C%E6%9C%89%E5%BA%8F%E6%80%A7%E9%97%AE%E9%A2%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8Bbug%E7%9A%84%E6%BA%90%E5%A4%B4/</guid><description>
&lt;p>如果你细心观察的话，你会发现，不管是哪一门编程语言，并发类的知识都是在高级篇里。换句话说，这块知识点其实对于程序员来说，是比较进阶的知识。我自己这么多年学习过来，也确实觉得并发是比较难的，因为它会涉及到很多的底层知识，比如若你对操作系统相关的知识一无所知的话，那去理解一些原理就会费些力气。这是我们整个专栏的第一篇文章，我说这些话的意思是如果你在中间遇到自己没想通的问题，可以去查阅资料，也可以在评论区找我，以保证你能够跟上学习进度。&lt;/p>
&lt;p>你我都知道，编写正确的并发程序是一件极困难的事情，并发程序的 Bug 往往会诡异地出现，然后又诡异地消失，很难重现，也很难追踪，很多时候都让人很抓狂。但要快速而又精准地解决&amp;quot;并发&amp;quot;类的疑难杂症，你就要理解这件事情的本质，追本溯源，深入分析这些 Bug 的源头在哪里。&lt;/p>
&lt;p>那为什么并发编程容易出问题呢？它是怎么出问题的？今天我们就重点聊聊这些 Bug 的源头。&lt;/p>
&lt;h2 id="并发程序幕后的故事">并发程序幕后的故事&lt;/h2>
&lt;p>这些年，我们的 CPU、内存、I/O 设备都在不断迭代，不断朝着更快的方向努力。但是，在这个快速发展的过程中，有一个&lt;strong>核心矛盾一直存在，就是这三者的速度差异&lt;/strong>。CPU 和内存的速度差异可以形象地描述为：CPU 是天上一天，内存是地上一年（假设 CPU 执行一条普通指令需要一天，那么 CPU 读写内存得等待一年的时间）。内存和 I/O 设备的速度差异就更大了，内存是天上一天，I/O 设备是地上十年。&lt;/p>
&lt;p>程序里大部分语句都要访问内存，有些还要访问 I/O，根据木桶理论（一只水桶能装多少水取决于它最短的那块木板），程序整体的性能取决于最慢的操作&amp;mdash;&amp;mdash;读写 I/O 设备，也就是说单方面提高 CPU 性能是无效的。&lt;/p>
&lt;p>为了合理利用 CPU 的高性能，平衡这三者的速度差异，计算机体系机构、操作系统、编译程序都做出了贡献，主要体现为：&lt;/p>
&lt;ol>
&lt;li>CPU 增加了缓存，以均衡与内存的速度差异；&lt;/li>
&lt;li>操作系统增加了进程、线程，以分时复用 CPU，进而均衡 CPU 与 I/O 设备的速度差异；&lt;/li>
&lt;li>编译程序优化指令执行次序，使得缓存能够得到更加合理地利用。&lt;/li>
&lt;/ol>
&lt;p>现在我们几乎所有的程序都默默地享受着这些成果，但是天下没有免费的午餐，并发程序很多诡异问题的根源也在这里。&lt;/p>
&lt;h2 id="源头之一缓存导致的可见性问题">源头之一：缓存导致的可见性问题&lt;/h2>
&lt;p>在单核时代，所有的线程都是在一颗 CPU 上执行，CPU 缓存与内存的数据一致性容易解决。因为所有线程都是操作同一个 CPU 的缓存，一个线程对缓存的写，对另外一个线程来说一定是可见的。例如在下面的图中，线程 A 和线程 B 都是操作同一个 CPU 里面的缓存，所以线程 A 更新了变量 V 的值，那么线程 B 之后再访问变量 V，得到的一定是 V 的最新值（线程 A 写过的值）。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/a0/da/a07e8182819e2b260ce85b2167d446da.png" alt="">
CPU 缓存与内存的关系图&lt;/p>
&lt;p>一个线程对共享变量的修改，另外一个线程能够立刻看到，我们称为&lt;strong>可见性&lt;/strong>。&lt;/p>
&lt;p>多核时代，每颗 CPU 都有自己的缓存，这时 CPU 缓存与内存的数据一致性就没那么容易解决了，当多个线程在不同的 CPU 上执行时，这些线程操作的是不同的 CPU 缓存。比如下图中，线程 A 操作的是 CPU-1 上的缓存，而线程 B 操作的是 CPU-2 上的缓存，很明显，这个时候线程 A 对变量 V 的操作对于线程 B 而言就不具备可见性了。这个就属于硬件程序员给软件程序员挖的&amp;quot;坑&amp;quot;。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/e2/ea/e2aa76928b2bc135e08e7590ca36e0ea.png" alt="">
多核 CPU 的缓存与内存关系图&lt;/p>
&lt;p>下面我们再用一段代码来验证一下多核场景下的可见性问题。下面的代码，每执行一次 add10K() 方法，都会循环 10000 次 count+=1 操作。在 calc() 方法中我们创建了两个线程，每个线程调用一次 add10K() 方法，我们来想一想执行 calc() 方法得到的结果应该是多少呢？&lt;/p>
&lt;pre>&lt;code>public class Test {
private long count = 0;
private void add10K() {
int idx = 0;
while(idx++ &amp;lt; 10000) {
count += 1;
}
}
public static long calc() {
final Test test = new Test();
// 创建两个线程，执行 add() 操作
Thread th1 = new Thread(()-&amp;gt;{
test.add10K();
});
Thread th2 = new Thread(()-&amp;gt;{
test.add10K();
});
// 启动两个线程
th1.start();
th2.start();
// 等待两个线程执行结束
th1.join();
th2.join();
return count;
}
}
&lt;/code>&lt;/pre>
&lt;p>直觉告诉我们应该是 20000，因为在单线程里调用两次 add10K() 方法，count 的值就是 20000，但实际上 calc() 的执行结果是个 10000 到 20000 之间的随机数。为什么呢？&lt;/p>
&lt;p>我们假设线程 A 和线程 B 同时开始执行，那么第一次都会将 count=0 读到各自的 CPU 缓存里，执行完 count+=1 之后，各自 CPU 缓存里的值都是 1，同时写入内存后，我们会发现内存中是 1，而不是我们期望的 2。之后由于各自的 CPU 缓存里都有了 count 的值，两个线程都是基于 CPU 缓存里的 count 值来计算，所以导致最终 count 的值都是小于 20000 的。这就是缓存的可见性问题。&lt;/p>
&lt;p>循环 10000 次 count+=1 操作如果改为循环 1 亿次，你会发现效果更明显，最终 count 的值接近 1 亿，而不是 2 亿。如果循环 10000 次，count 的值接近 20000，原因是两个线程不是同时启动的，有一个时差。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/ec/79/ec6743e74ccf9a3c6d6c819a41e52279.png" alt="">
变量 count 在 CPU 缓存和内存的分布图&lt;/p>
&lt;h2 id="源头之二线程切换带来的原子性问题">源头之二：线程切换带来的原子性问题&lt;/h2>
&lt;p>由于 IO 太慢，早期的操作系统就发明了多进程，即便在单核的 CPU 上我们也可以一边听着歌，一边写 Bug，这个就是多进程的功劳。&lt;/p>
&lt;p>操作系统允许某个进程执行一小段时间，例如 50 毫秒，过了 50 毫秒操作系统就会重新选择一个进程来执行（我们称为&amp;quot;任务切换&amp;quot;），这个 50 毫秒称为&amp;quot;&lt;strong>时间片&lt;/strong>&amp;quot;。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/25/fb/254b129b145d80e9bb74123d6e620efb.png" alt="">
线程切换示意图&lt;/p>
&lt;p>在一个时间片内，如果一个进程进行一个 IO 操作，例如读个文件，这个时候该进程可以把自己标记为&amp;quot;休眠状态&amp;quot;并出让 CPU 的使用权，待文件读进内存，操作系统会把这个休眠的进程唤醒，唤醒后的进程就有机会重新获得 CPU 的使用权了。&lt;/p>
&lt;p>这里的进程在等待 IO 时之所以会释放 CPU 使用权，是为了让 CPU 在这段等待时间里可以做别的事情，这样一来 CPU 的使用率就上来了；此外，如果这时有另外一个进程也读文件，读文件的操作就会排队，磁盘驱动在完成一个进程的读操作后，发现有排队的任务，就会立即启动下一个读操作，这样 IO 的使用率也上来了。&lt;/p>
&lt;p>是不是很简单的逻辑？但是，虽然看似简单，支持多进程分时复用在操作系统的发展史上却具有里程碑意义，Unix 就是因为解决了这个问题而名噪天下的。&lt;/p>
&lt;p>早期的操作系统基于进程来调度 CPU，不同进程间是不共享内存空间的，所以进程要做任务切换就要切换内存映射地址，而一个进程创建的所有线程，都是共享一个内存空间的，所以线程做任务切换成本就很低了。现代的操作系统都基于更轻量的线程来调度，现在我们提到的&amp;quot;任务切换&amp;quot;都是指&amp;quot;线程切换&amp;quot;。&lt;/p>
&lt;p>Java 并发程序都是基于多线程的，自然也会涉及到任务切换，也许你想不到，任务切换竟然也是并发编程里诡异 Bug 的源头之一。任务切换的时机大多数是在时间片结束的时候，我们现在基本都使用高级语言编程，高级语言里一条语句往往需要多条 CPU 指令完成，例如上面代码中的&lt;code>count += 1&lt;/code>，至少需要三条 CPU 指令。&lt;/p>
&lt;ul>
&lt;li>指令 1：首先，需要把变量 count 从内存加载到 CPU 的寄存器；&lt;/li>
&lt;li>指令 2：之后，在寄存器中执行 +1 操作；&lt;/li>
&lt;li>指令 3：最后，将结果写入内存（缓存机制导致可能写入的是 CPU 缓存而不是内存）。&lt;/li>
&lt;/ul>
&lt;p>操作系统做任务切换，可以发生在任何一条&lt;strong>CPU 指令&lt;/strong>执行完，是的，是 CPU 指令，而不是高级语言里的一条语句。对于上面的三条指令来说，我们假设 count=0，如果线程 A 在指令 1 执行完后做线程切换，线程 A 和线程 B 按照下图的序列执行，那么我们会发现两个线程都执行了 count+=1 的操作，但是得到的结果不是我们期望的 2，而是 1。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/33/63/33777c468872cb9a99b3cdc1ff597063.png" alt="">
非原子操作的执行路径示意图&lt;/p>
&lt;p>我们潜意识里面觉得 count+=1 这个操作是一个不可分割的整体，就像一个原子一样，线程的切换可以发生在 count+=1 之前，也可以发生在 count+=1 之后，但就是不会发生在中间。&lt;strong>我们把一个或者多个操作在 CPU 执行的过程中不被中断的特性称为原子性&lt;/strong>。CPU 能保证的原子操作是 CPU 指令级别的，而不是高级语言的操作符，这是违背我们直觉的地方。因此，很多时候我们需要在高级语言层面保证操作的原子性。&lt;/p>
&lt;h2 id="源头之三编译优化带来的有序性问题">源头之三：编译优化带来的有序性问题&lt;/h2>
&lt;p>那并发编程里还有没有其他有违直觉容易导致诡异 Bug 的技术呢？有的，就是有序性。顾名思义，有序性指的是程序按照代码的先后顺序执行。编译器为了优化性能，有时候会改变程序中语句的先后顺序，例如程序中：&amp;ldquo;a=6；b=7；&amp;ldquo;编译器优化后可能变成&amp;quot;b=7；a=6；&amp;quot;，在这个例子中，编译器调整了语句的顺序，但是不影响程序的最终结果。不过有时候编译器及解释器的优化可能导致意想不到的 Bug。&lt;/p>
&lt;p>在 Java 领域一个经典的案例就是利用双重检查创建单例对象，例如下面的代码：在获取实例 getInstance() 的方法中，我们首先判断 instance 是否为空，如果为空，则锁定 Singleton.class 并再次检查 instance 是否为空，如果还为空则创建 Singleton 的一个实例。&lt;/p>
&lt;pre>&lt;code>public class Singleton {
static Singleton instance;
static Singleton getInstance(){
if (instance == null) {
synchronized(Singleton.class) {
if (instance == null)
instance = new Singleton();
}
}
return instance;
}
}
&lt;/code>&lt;/pre>
&lt;p>假设有两个线程 A、B 同时调用 getInstance() 方法，他们会同时发现 &lt;code>instance == null&lt;/code> ，于是同时对 Singleton.class 加锁，此时 JVM 保证只有一个线程能够加锁成功（假设是线程 A），另外一个线程则会处于等待状态（假设是线程 B）；线程 A 会创建一个 Singleton 实例，之后释放锁，锁释放后，线程 B 被唤醒，线程 B 再次尝试加锁，此时是可以加锁成功的，加锁成功后，线程 B 检查 &lt;code>instance == null&lt;/code> 时会发现，已经创建过 Singleton 实例了，所以线程 B 不会再创建一个 Singleton 实例。&lt;/p>
&lt;p>这看上去一切都很完美，无懈可击，但实际上这个 getInstance() 方法并不完美。问题出在哪里呢？出在 new 操作上，我们以为的 new 操作应该是：&lt;/p>
&lt;ol>
&lt;li>分配一块内存 M；&lt;/li>
&lt;li>在内存 M 上初始化 Singleton 对象；&lt;/li>
&lt;li>然后 M 的地址赋值给 instance 变量。&lt;/li>
&lt;/ol>
&lt;p>但是实际上优化后的执行路径却是这样的：&lt;/p>
&lt;ol>
&lt;li>分配一块内存 M；&lt;/li>
&lt;li>将 M 的地址赋值给 instance 变量；&lt;/li>
&lt;li>最后在内存 M 上初始化 Singleton 对象。&lt;/li>
&lt;/ol>
&lt;p>优化后会导致什么问题呢？我们假设线程 A 先执行 getInstance() 方法，当执行完指令 2 时恰好发生了线程切换，切换到了线程 B 上；如果此时线程 B 也执行 getInstance() 方法，那么线程 B 在执行第一个判断时会发现 &lt;code>instance != null&lt;/code> ，所以直接返回 instance，而此时的 instance 是没有初始化过的，如果我们这个时候访问 instance 的成员变量就可能触发空指针异常。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/64/d8/64c955c65010aae3902ec918412827d8.png" alt="">
双重检查创建单例的异常执行路径&lt;/p>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>要写好并发程序，首先要知道并发程序的问题在哪里，只有确定了&amp;quot;靶子&amp;rdquo;，才有可能把问题解决，毕竟所有的解决方案都是针对问题的。并发程序经常出现的诡异问题看上去非常无厘头，但是深究的话，无外乎就是直觉欺骗了我们，&lt;strong>只要我们能够深刻理解可见性、原子性、有序性在并发场景下的原理，很多并发 Bug 都是可以理解、可以诊断的&lt;/strong>。&lt;/p>
&lt;p>在介绍可见性、原子性、有序性的时候，特意提到&lt;strong>缓存&lt;/strong> 导致的可见性问题，&lt;strong>线程切换&lt;/strong> 带来的原子性问题，&lt;strong>编译优化&lt;/strong> 带来的有序性问题，其实缓存、线程、编译优化的目的和我们写并发程序的目的是相同的，都是提高程序性能。但是技术在解决一个问题的同时，必然会带来另外一个问题，所以&lt;strong>在采用一项技术的同时，一定要清楚它带来的问题是什么，以及如何规避&lt;/strong>。&lt;/p>
&lt;p>我们这个专栏在讲解每项技术的时候，都会尽量将每项技术解决的问题以及产生的问题讲清楚，也希望你能够在这方面多思考、多总结。&lt;/p>
&lt;h2 id="课后思考">课后思考&lt;/h2>
&lt;p>常听人说，在 32 位的机器上对 long 型变量进行加减操作存在并发隐患，到底是不是这样呢？现在相信你一定能分析出来。&lt;/p>
&lt;p>欢迎在留言区与我分享你的想法，也欢迎你在留言区记录你的思考过程。感谢阅读，如果你觉得这篇文章对你有帮助的话，也欢迎把它分享给更多的朋友。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/cf/aa/cf393cd748a4f0e6451807c4b61843aa.jpg" alt="">&lt;/p></description></item><item><title>极客专栏: 01丨工作区和GOPATH</title><link>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/go-%E8%AF%AD%E8%A8%80%E6%A0%B8%E5%BF%83-36-%E8%AE%B2/01%E4%B8%A8%E5%B7%A5%E4%BD%9C%E5%8C%BA%E5%92%8Cgopath/</link><pubDate>Sun, 29 May 2022 00:00:00 +0000</pubDate><guid>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/go-%E8%AF%AD%E8%A8%80%E6%A0%B8%E5%BF%83-36-%E8%AE%B2/01%E4%B8%A8%E5%B7%A5%E4%BD%9C%E5%8C%BA%E5%92%8Cgopath/</guid><description>
&lt;h3 id="go-语言代码较多建议配合文章收听音频">【Go 语言代码较多，建议配合文章收听音频。】&lt;/h3>
&lt;p>你好，我是郝林。从今天开始，我将和你一起梳理 Go 语言的整个知识体系。&lt;/p>
&lt;p>在过去的几年里，我与广大爱好者一起见证了 Go 语言的崛起。&lt;/p>
&lt;p>从 Go 1.5 版本的自举（即用 Go 语言编写程序来实现 Go 语言自身），到 Go 1.7 版本的极速 GC（也称垃圾回收器），再到 2018 年 2 月发布的 Go 1.10 版本对其自带工具的全面升级，以及可预见的后续版本关键特性（比如用来做程序依赖管理的&lt;code>go mod&lt;/code>命令），这一切都令我们欢欣鼓舞。Go 语言在一步步走向辉煌的同时，显然已经成为软件工程师们最喜爱的编程语言之一。&lt;/p>
&lt;p>我开办这个专栏的主要目的，是要与你一起探索 Go 语言的奥秘，并帮助你在学习和实践的过程中获取更多。&lt;/p>
&lt;p>我假设本专栏的读者已经具备了一定的计算机基础，比如，你要知道操作系统是什么、环境变量怎么设置、怎样正确使用命令行，等等。&lt;/p>
&lt;p>当然了，如果你已经有了编程经验，尤其是一点点 Go 语言编程经验，那就更好了，毕竟我想教给你的，都是 Go 语言中非常核心的技术。&lt;/p>
&lt;p>如果你对 Go 语言中最基本的概念和语法还不够了解，那么可能需要在学习本专栏的过程中去查阅&lt;a href="https://golang.google.cn/ref/spec">Go 语言规范文档&lt;/a>，也可以把预习篇的基础知识图拿出来好好研究一下。&lt;/p>
&lt;p>最后，我来说一下专栏的讲述模式。我总会以一道 Go 语言的面试题开始，针对它进行解答，我会告诉你为什么我要关注这道题，这道题的背后隐藏着哪些知识，并且，我会对这部分的内容，进行相关的知识扩展。&lt;/p>
&lt;p>好了，准备就绪，我们一起开始。&lt;/p>
&lt;hr>
&lt;p>我们学习 Go 语言时，要做的第一件事，都是根据自己电脑的计算架构（比如，是 32 位的计算机还是 64 位的计算机）以及操作系统（比如，是 Windows 还是 Linux），从&lt;a href="https://golang.google.cn">Go 语言官网&lt;/a>下载对应的二进制包，也就是可以拿来即用的安装包。&lt;/p>
&lt;p>随后，我们会解压缩安装包、放置到某个目录、配置环境变量，并通过在命令行中输入&lt;code>go version&lt;/code>来验证是否安装成功。&lt;/p>
&lt;p>在这个过程中，我们还需要配置 3 个环境变量，也就是 GOROOT、GOPATH 和 GOBIN。这里我可以简单介绍一下。&lt;/p>
&lt;ul>
&lt;li>GOROOT：Go 语言安装根目录的路径，也就是 GO 语言的安装路径。&lt;/li>
&lt;li>GOPATH：若干工作区目录的路径。是我们自己定义的工作空间。&lt;/li>
&lt;li>GOBIN：GO 程序生成的可执行文件（executable file）的路径。&lt;/li>
&lt;/ul>
&lt;p>其中，GOPATH 背后的概念是最多的，也是最重要的。那么，&lt;strong>今天我们的面试问题是：你知道设置 GOPATH 有什么意义吗？&lt;/strong>&lt;/p>
&lt;p>关于这个问题，它的&lt;strong>典型回答&lt;/strong>是这样的：&lt;/p>
&lt;p>你可以把 GOPATH 简单理解成 Go 语言的工作目录，它的值是一个目录的路径，也可以是多个目录路径，每个目录都代表 Go 语言的一个工作区（workspace）。&lt;/p>
&lt;p>我们需要利于这些工作区，去放置 Go 语言的源码文件（source file），以及安装（install）后的归档文件（archive file，也就是以&amp;quot;.a&amp;quot;为扩展名的文件）和可执行文件（executable file）。&lt;/p>
&lt;p>事实上，由于 Go 语言项目在其生命周期内的所有操作（编码、依赖管理、构建、测试、安装等）基本上都是围绕着 GOPATH 和工作区进行的。所以，它的背后至少有 3 个知识点，分别是：&lt;/p>
&lt;p>&lt;strong>1. Go 语言源码的组织方式是怎样的；&lt;/strong>&lt;/p>
&lt;p>&lt;strong>2. 你是否了解源码安装后的结果（只有在安装后，Go 语言源码才能被我们或其他代码使用）；&lt;/strong>&lt;/p>
&lt;p>&lt;strong>3. 你是否理解构建和安装 Go 程序的过程（这在开发程序以及查找程序问题的时候都很有用，否则你很可能会走弯路）。&lt;/strong>&lt;/p>
&lt;p>下面我就重点来聊一聊这些内容。&lt;/p>
&lt;h2 id="知识扩展">知识扩展&lt;/h2>
&lt;ol>
&lt;li>Go 语言源码的组织方式&lt;/li>
&lt;/ol>
&lt;hr>
&lt;p>与许多编程语言一样，Go 语言的源码也是以代码包为基本组织单位的。在文件系统中，这些代码包其实是与目录一一对应的。由于目录可以有子目录，所以代码包也可以有子包。&lt;/p>
&lt;p>一个代码包中可以包含任意个以.go 为扩展名的源码文件，这些源码文件都需要被声明属于同一个代码包。&lt;/p>
&lt;p>代码包的名称一般会与源码文件所在的目录同名。如果不同名，那么在构建、安装的过程中会以代码包名称为准。&lt;/p>
&lt;p>每个代码包都会有导入路径。代码包的导入路径是其他代码在使用该包中的程序实体时，需要引入的路径。在实际使用程序实体之前，我们必须先导入其所在的代码包。具体的方式就是&lt;code>import&lt;/code>该代码包的导入路径。就像这样：&lt;/p>
&lt;pre>&lt;code>import &amp;quot;github.com/labstack/echo&amp;quot;
&lt;/code>&lt;/pre>
&lt;p>在工作区中，一个代码包的导入路径实际上就是从 src 子目录，到该包的实际存储位置的相对路径。&lt;/p>
&lt;p>所以说，Go 语言源码的组织方式就是以环境变量 GOPATH、工作区、src 目录和代码包为主线的。一般情况下，Go 语言的源码文件都需要被存放在环境变量 GOPATH 包含的某个工作区（目录）中的 src 目录下的某个代码包（目录）中。&lt;/p>
&lt;ol start="2">
&lt;li>了解源码安装后的结果&lt;/li>
&lt;/ol>
&lt;hr>
&lt;p>了解了 Go 语言源码的组织方式后，我们很有必要知道 Go 语言源码在安装后会产生怎样的结果。&lt;/p>
&lt;p>源码文件以及安装后的结果文件都会放到哪里呢？我们都知道，源码文件通常会被放在某个工作区的 src 子目录下。&lt;/p>
&lt;p>那么在安装后如果产生了归档文件（以&amp;quot;.a&amp;quot;为扩展名的文件），就会放进该工作区的 pkg 子目录；如果产生了可执行文件，就可能会放进该工作区的 bin 子目录。&lt;/p>
&lt;p>我再讲一下归档文件存放的具体位置和规则。&lt;/p>
&lt;p>源码文件会以代码包的形式组织起来，一个代码包其实就对应一个目录。安装某个代码包而产生的归档文件是与这个代码包同名的。&lt;/p>
&lt;p>放置它的相对目录就是该代码包的导入路径的直接父级。比如，一个已存在的代码包的导入路径是&lt;/p>
&lt;pre>&lt;code>github.com/labstack/echo，
&lt;/code>&lt;/pre>
&lt;p>那么执行命令&lt;/p>
&lt;pre>&lt;code>go install github.com/labstack/echo
&lt;/code>&lt;/pre>
&lt;p>生成的归档文件的相对目录就是 &lt;a href="http://github.com/labstack%EF%BC%8C">github.com/labstack，&lt;/a> 文件名为 echo.a。&lt;/p>
&lt;p>顺便说一下，上面这个代码包导入路径还有另外一层含义，那就是：该代码包的源码文件存在于 GitHub 网站的 labstack 组的代码仓库 echo 中。&lt;/p>
&lt;p>再说回来，归档文件的相对目录与 pkg 目录之间还有一级目录，叫做平台相关目录。平台相关目录的名称是由 build（也称&amp;quot;构建&amp;quot;）的目标操作系统、下划线和目标计算架构的代号组成的。&lt;/p>
&lt;p>比如，构建某个代码包时的目标操作系统是 Linux，目标计算架构是 64 位的，那么对应的平台相关目录就是 linux_amd64。&lt;/p>
&lt;p>因此，上述代码包的归档文件就会被放置在当前工作区的子目录 pkg/linux_amd64/github.com/labstack 中。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/2f/3c/2fdfb5620e072d864907870e61ae5f3c.png" alt="">&lt;br>
（GOPATH 与工作区）&lt;/p>
&lt;p>总之，你需要记住的是，某个工作区的 src 子目录下的源码文件在安装后一般会被放置到当前工作区的 pkg 子目录下对应的目录中，或者被直接放置到该工作区的 bin 子目录中。&lt;/p>
&lt;ol start="3">
&lt;li>理解构建和安装 Go 程序的过程&lt;/li>
&lt;/ol>
&lt;hr>
&lt;p>我们再来说说构建和安装 Go 程序的过程都是怎样的，以及它们的异同点。&lt;/p>
&lt;p>构建使用命令&lt;code>go build&lt;/code>，安装使用命令&lt;code>go install&lt;/code>。构建和安装代码包的时候都会执行编译、打包等操作，并且，这些操作生成的任何文件都会先被保存到某个临时的目录中。&lt;/p>
&lt;p>如果构建的是库源码文件，那么操作后产生的结果文件只会存在于临时目录中。这里的构建的主要意义在于检查和验证。&lt;/p>
&lt;p>如果构建的是命令源码文件，那么操作的结果文件会被搬运到源码文件所在的目录中。（这里讲到的两种源码文件我在&lt;a href="https://time.geekbang.org/column/article/13540?utm_source=weibo&amp;amp;utm_medium=xuxiaoping&amp;amp;utm_campaign=promotion&amp;amp;utm_content=columns">&amp;ldquo;预习篇&amp;quot;的基础知识图&lt;/a>中提到过，在后面的文章中我也会带你详细了解。）&lt;/p>
&lt;p>安装操作会先执行构建，然后还会进行链接操作，并且把结果文件搬运到指定目录。&lt;/p>
&lt;p>进一步说，如果安装的是库源码文件，那么结果文件会被搬运到它所在工作区的 pkg 目录下的某个子目录中。&lt;/p>
&lt;p>如果安装的是命令源码文件，那么结果文件会被搬运到它所在工作区的 bin 目录中，或者环境变量&lt;code>GOBIN&lt;/code>指向的目录中。&lt;/p>
&lt;p>这里你需要记住的是，构建和安装的不同之处，以及执行相应命令后得到的结果文件都会出现在哪里。&lt;/p>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>工作区和 GOPATH 的概念和含义是每个 Go 工程师都需要了解的。虽然它们都比较简单，但是说它们是 Go 程序开发的核心知识并不为过。&lt;/p>
&lt;p>然而，我在招聘面试的过程中仍然发现有人忽略掉了它们。Go 语言提供的很多工具都是在 GOPATH 和工作区的基础上运行的，比如上面提到的&lt;code>go build&lt;/code>、&lt;code>go install&lt;/code>和&lt;code>go get&lt;/code>，这三个命令也是我们最常用到的。&lt;/p>
&lt;h2 id="思考题">思考题&lt;/h2>
&lt;p>说到 Go 程序中的依赖管理，其实还有很多问题值得我们探索。我在这里留下两个问题供你进一步思考。&lt;/p>
&lt;ol>
&lt;li>Go 语言在多个工作区中查找依赖包的时候是以怎样的顺序进行的？&lt;/li>
&lt;li>如果在多个工作区中都存在导入路径相同的代码包会产生冲突吗？&lt;/li>
&lt;/ol>
&lt;p>这两个问题之间其实是有一些关联的。答案并不复杂，你做几个试验几乎就可以找到它了。你也可以看一下 Go 语言标准库中&lt;code>go build&lt;/code>包及其子包的源码。那里面的宝藏也很多，可以助你深刻理解 Go 程序的构建过程。&lt;/p>
&lt;hr>
&lt;h2 id="补充阅读">补充阅读&lt;/h2>
&lt;h2 id="go-build-命令一些可选项的用途和用法">go build 命令一些可选项的用途和用法&lt;/h2>
&lt;p>在运行&lt;code>go build&lt;/code>命令的时候，默认不会编译目标代码包所依赖的那些代码包。当然，如果被依赖的代码包的归档文件不存在，或者源码文件有了变化，那它还是会被编译。&lt;/p>
&lt;p>如果要强制编译它们，可以在执行命令的时候加入标记&lt;code>-a&lt;/code>。此时，不但目标代码包总是会被编译，它依赖的代码包也总会被编译，即使依赖的是标准库中的代码包也是如此。&lt;/p>
&lt;p>另外，如果不但要编译依赖的代码包，还要安装它们的归档文件，那么可以加入标记&lt;code>-i&lt;/code>。&lt;/p>
&lt;p>那么我们怎么确定哪些代码包被编译了呢？有两种方法。&lt;/p>
&lt;ol>
&lt;li>运行&lt;code>go build&lt;/code>命令时加入标记&lt;code>-x&lt;/code>，这样可以看到&lt;code>go build&lt;/code>命令具体都执行了哪些操作。另外也可以加入标记&lt;code>-n&lt;/code>，这样可以只查看具体操作而不执行它们。&lt;/li>
&lt;li>运行&lt;code>go build&lt;/code>命令时加入标记&lt;code>-v&lt;/code>，这样可以看到&lt;code>go build&lt;/code>命令编译的代码包的名称。它在与&lt;code>-a&lt;/code>标记搭配使用时很有用。&lt;/li>
&lt;/ol>
&lt;p>下面再说一说与 Go 源码的安装联系很紧密的一个命令：&lt;code>go get&lt;/code>。&lt;/p>
&lt;p>命令&lt;code>go get&lt;/code>会自动从一些主流公用代码仓库（比如 GitHub）下载目标代码包，并把它们安装到环境变量&lt;code>GOPATH&lt;/code>包含的第 1 工作区的相应目录中。如果存在环境变量&lt;code>GOBIN&lt;/code>，那么仅包含命令源码文件的代码包会被安装到&lt;code>GOBIN&lt;/code>指向的那个目录。&lt;/p>
&lt;p>最常用的几个标记有下面几种。&lt;/p>
&lt;ul>
&lt;li>&lt;code>-u&lt;/code>：下载并安装代码包，不论工作区中是否已存在它们。&lt;/li>
&lt;li>&lt;code>-d&lt;/code>：只下载代码包，不安装代码包。&lt;/li>
&lt;li>&lt;code>-fix&lt;/code>：在下载代码包后先运行一个用于根据当前 Go 语言版本修正代码的工具，然后再安装代码包。&lt;/li>
&lt;li>&lt;code>-t&lt;/code>：同时下载测试所需的代码包。&lt;/li>
&lt;li>&lt;code>-insecure&lt;/code>：允许通过非安全的网络协议下载和安装代码包。HTTP 就是这样的协议。&lt;/li>
&lt;/ul>
&lt;p>Go 语言官方提供的&lt;code>go get&lt;/code>命令是比较基础的，其中并没有提供依赖管理的功能。目前 GitHub 上有很多提供这类功能的第三方工具，比如&lt;code>glide&lt;/code>、&lt;code>gb&lt;/code>以及官方出品的&lt;code>dep&lt;/code>、&lt;code>vgo&lt;/code>等等，它们在内部大都会直接使用&lt;code>go get&lt;/code>。&lt;/p>
&lt;p>有时候，我们可能会出于某种目的变更存储源码的代码仓库或者代码包的相对路径。这时，为了让代码包的远程导入路径不受此类变更的影响，我们会使用自定义的代码包导入路径。&lt;/p>
&lt;p>对代码包的远程导入路径进行自定义的方法是：在该代码包中的库源码文件的包声明语句的右边加入导入注释，像这样：&lt;/p>
&lt;pre>&lt;code>package semaphore // import &amp;quot;golang.org/x/sync/semaphore&amp;quot;
&lt;/code>&lt;/pre>
&lt;p>这个代码包原本的完整导入路径是&lt;code>github.com/golang/sync/semaphore&lt;/code>。这与实际存储它的网络地址对应的。该代码包的源码实际存在 GitHub 网站的 golang 组的 sync 代码仓库的 semaphore 目录下。而加入导入注释之后，用以下命令即可下载并安装该代码包了：&lt;/p>
&lt;pre>&lt;code>go get golang.org/x/sync/semaphore
&lt;/code>&lt;/pre>
&lt;p>而 Go 语言官网 golang.org 下的路径 /x/sync/semaphore 并不是存放&lt;code>semaphore&lt;/code>包的真实地址。我们称之为代码包的自定义导入路径。&lt;/p>
&lt;p>不过，这还需要在 golang.org 这个域名背后的服务端程序上，添加一些支持才能使这条命令成功。&lt;/p>
&lt;p>关于自定义代码包导入路径的完整说明可以参看&lt;a href="https://github.com/hyper0x/go_command_tutorial/blob/master/0.3.md">这里&lt;/a>。&lt;/p>
&lt;p>好了，对于&lt;code>go build&lt;/code>命令和&lt;code>go get&lt;/code>命令的简短介绍就到这里。如果你想查阅更详细的文档，那么可以访问 Go 语言官方的&lt;a href="https://golang.google.cn/cmd/go">命令文档页面&lt;/a>，或者在命令行下输入诸如&lt;code>go help build&lt;/code>这类的命令。&lt;/p>
&lt;p>&lt;a href="https://github.com/hyper0x/Golang_Puzzlers">戳此查看 Go 语言专栏文章配套详细代码。&lt;/a>&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/35/48/358e4e8578a706598e18a7dfed3ed648.jpg" alt="">&lt;/p></description></item><item><title>极客专栏: 01丨核心原理：能否画张图解释下RPC的通信流程？</title><link>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/rpc%E5%AE%9E%E6%88%98%E4%B8%8E%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/01%E4%B8%A8%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E8%83%BD%E5%90%A6%E7%94%BB%E5%BC%A0%E5%9B%BE%E8%A7%A3%E9%87%8A%E4%B8%8Brpc%E7%9A%84%E9%80%9A%E4%BF%A1%E6%B5%81%E7%A8%8B/</link><pubDate>Sat, 28 May 2022 00:00:00 +0000</pubDate><guid>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/rpc%E5%AE%9E%E6%88%98%E4%B8%8E%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/01%E4%B8%A8%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E8%83%BD%E5%90%A6%E7%94%BB%E5%BC%A0%E5%9B%BE%E8%A7%A3%E9%87%8A%E4%B8%8Brpc%E7%9A%84%E9%80%9A%E4%BF%A1%E6%B5%81%E7%A8%8B/</guid><description>
&lt;p>你好，我是何小锋。只要你做过几年开发，那我相信 RPC 这个词你肯定是不陌生了。写专栏之前，我还特意查了下 RPC 的百度指数，发现这些年 RPC 的搜索趋势都是稳步上升的，这也侧面说明了这项技术正在逐步渗透到我们的日常开发中。作为专栏的第一讲，我想只围绕&amp;quot;RPC&amp;quot;这个词，和你聊聊它的定义，它要解决的问题，以及工作原理。&lt;/p>
&lt;p>在前些年，我面试工程师的时候，最喜欢问候选人一个问题，&amp;ldquo;你能否给我解释下 RPC 的通信流程&amp;rdquo;。这问题其实并不难，不过因为很多工程师平时都在用各种框架，他们可能并未停下来思考过框架的原理，所以，问完这问题，有的人就犹豫了，吱唔了半天也没说出所以然来。&lt;/p>
&lt;p>紧接着，我会引导他说，&amp;ldquo;你想想，如果没有 RPC 框架，那你要怎么调用另外一台服务器上的接口呢&amp;rdquo;。你看，这问题可深可浅，也特别考验候选人的基本功。如果你是候选人，你会怎么回答呢？今天我就来试着回答你这个问题。&lt;/p>
&lt;h1 id="什么是-rpc">什么是 RPC？&lt;/h1>
&lt;p>我知道你肯定不喜欢听概念，我也是这样，看书的时候一看到概念就直接略过。不过，到后来，我才发现，&amp;ldquo;定义&amp;quot;是一件多么伟大的事情。当我们能够用一句话把一个东西给定义出来的时候，侧面也说明你已经彻底理解这事了，不仅知道它要解决什么问题，还要知道它的边界。所以，你可以先停下来想想，什么是 RPC。&lt;/p>
&lt;p>RPC 的全称是 Remote Procedure Call，即远程过程调用。简单解读字面上的意思，远程肯定是指要跨机器而非本机，所以需要用到网络编程才能实现，但是不是只要通过网络通信访问到另一台机器的应用程序，就可以称之为 RPC 调用了？显然并不够。&lt;/p>
&lt;p>我理解的 RPC 是帮助我们屏蔽网络编程细节，实现调用远程方法就跟调用本地（同一个项目中的方法）一样的体验，我们不需要因为这个方法是远程调用就需要编写很多与业务无关的代码。&lt;/p>
&lt;p>这就好比建在小河上的桥一样连接着河的两岸，如果没有小桥，我们需要通过划船、绕道等其他方式才能到达对面，但是有了小桥之后，我们就能像在路面上一样行走到达对面，并且跟在路面上行走的体验没有区别。所以&lt;strong>我认为，RPC 的作用就是体现在这样两个方面：&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>屏蔽远程调用跟本地调用的区别，让我们感觉就是调用项目内的方法；&lt;/li>
&lt;li>隐藏底层网络通信的复杂性，让我们更专注于业务逻辑。&lt;/li>
&lt;/ul>
&lt;h1 id="rpc-通信流程">RPC 通信流程&lt;/h1>
&lt;p>理解了什么是 RPC，接下来我们讲下 RPC 框架的通信流程，方便我们进一步理解 RPC。&lt;/p>
&lt;p>如前面所讲，RPC 能帮助我们的应用透明地完成远程调用，发起调用请求的那一方叫做调用方，被调用的一方叫做服务提供方。为了实现这个的目标，我们就需要在 RPC 框架里面对整个通信细节进行封装，&lt;strong>那一个完整的 RPC 会涉及到哪些步骤呢？&lt;/strong>&lt;/p>
&lt;p>我们已经知道 RPC 是一个远程调用，那肯定就需要通过网络来传输数据，并且 RPC 常用于业务系统之间的数据交互，需要保证其可靠性，所以 RPC 一般默认采用 TCP 来传输。我们常用的 HTTP 协议也是建立在 TCP 之上的。&lt;/p>
&lt;p>网络传输的数据必须是二进制数据，但调用方请求的出入参数都是对象。对象是肯定没法直接在网络中传输的，需要提前把它转成可传输的二进制，并且要求转换算法是可逆的，这个过程我们一般叫做&amp;quot;序列化&amp;rdquo;。&lt;/p>
&lt;p>调用方持续地把请求参数序列化成二进制后，经过 TCP 传输给了服务提供方。服务提供方从 TCP 通道里面收到二进制数据，那如何知道一个请求的数据到哪里结束，是一个什么类型的请求呢？&lt;/p>
&lt;p>在这里我们可以想想高速公路，它上面有很多出口，为了让司机清楚地知道从哪里出去，管理部门会在路上建立很多指示牌，并在指示牌上标明下一个出口是哪里、还有多远。那回到数据包识别这个场景，我们是不是也可以建立一些&amp;quot;指示牌&amp;quot;，并在上面标明数据包的类型和长度，这样就可以正确的解析数据了。确实可以，并且我们把数据格式的约定内容叫做&amp;quot;协议&amp;quot;。大多数的协议会分成两部分，分别是数据头和消息体。数据头一般用于身份识别，包括协议标识、数据大小、请求类型、序列化类型等信息；消息体主要是请求的业务参数信息和扩展属性等。&lt;/p>
&lt;p>根据协议格式，服务提供方就可以正确地从二进制数据中分割出不同的请求来，同时根据请求类型和序列化类型，把二进制的消息体逆向还原成请求对象。这个过程叫作&amp;quot;反序列化&amp;quot;。&lt;/p>
&lt;p>服务提供方再根据反序列化出来的请求对象找到对应的实现类，完成真正的方法调用，然后把执行结果序列化后，回写到对应的 TCP 通道里面。调用方获取到应答的数据包后，再反序列化成应答对象，这样调用方就完成了一次 RPC 调用。&lt;/p>
&lt;p>&lt;strong>那上述几个流程就组成了一个完整的 RPC 吗？&lt;/strong>&lt;/p>
&lt;p>在我看来，还缺点东西。因为对于研发人员来说，这样做要掌握太多的 RPC 底层细节，需要手动写代码去构造请求、调用序列化，并进行网络调用，整个 API 非常不友好。&lt;/p>
&lt;p>那我们有什么办法来简化 API，屏蔽掉 RPC 细节，让使用方只需要关注业务接口，像调用本地一样来调用远程呢？&lt;/p>
&lt;p>如果你了解 Spring，一定对其 AOP 技术很佩服，其核心是采用动态代理的技术，通过字节码增强对方法进行拦截增强，以便于增加需要的额外处理逻辑。其实这个技术也可以应用到 RPC 场景来解决我们刚才面临的问题。&lt;/p>
&lt;p>由服务提供者给出业务接口声明，在调用方的程序里面，RPC 框架根据调用的服务接口提前生成动态代理实现类，并通过依赖注入等技术注入到声明了该接口的相关业务逻辑里面。该代理实现类会拦截所有的方法调用，在提供的方法处理逻辑里面完成一整套的远程调用，并把远程调用结果返回给调用方，这样调用方在调用远程方法的时候就获得了像调用本地接口一样的体验。&lt;/p>
&lt;p>到这里，一个简单版本的 RPC 框架就实现了。我把整个流程都画出来了，供你参考：&lt;br>
&lt;img src="https://static001.geekbang.org/resource/image/ac/fa/acf53138659f4982bbef02acdd30f1fa.jpg" alt="">&lt;/p>
&lt;h1 id="rpc-在架构中的位置">RPC 在架构中的位置&lt;/h1>
&lt;p>围绕 RPC 我们讲了这么多，那 RPC 在架构中究竟处于什么位置呢？&lt;/p>
&lt;p>如刚才所讲，RPC 是解决应用间通信的一种方式，而无论是在一个大型的分布式应用系统还是中小型系统中，应用架构最终都会从&amp;quot;单体&amp;quot;演进成&amp;quot;微服务化&amp;quot;，整个应用系统会被拆分为多个不同功能的应用，并将它们部署在不同的服务器中，而应用之间会通过 RPC 进行通信，可以说 RPC 对应的是整个分布式应用系统，就像是&amp;quot;经络&amp;quot;一样的存在。&lt;/p>
&lt;p>那么如果没有 RPC，我们现实中的开发过程是怎样的一个体验呢？&lt;/p>
&lt;p>所有的功能代码都会被我们堆砌在一个大项目中，开发过程中你可能要改一行代码，但改完后编译会花掉你 2 分钟，编译完想运行起来验证下结果可能要 5 分钟，是不是很酸爽？更难受的是在人数比较多的团队里面，多人协同开发的时候，如果团队其他人把接口定义改了，你连编译通过的机会都没有，系统直接报错，从而导致整个团队的开发效率都会非常低下。而且当我们准备要上线发版本的时候，QA 也很难评估这次的测试范围，为了保险起见我们只能把所有的功能进行回归测试，这样会导致我们上线新功能的整体周期都特别长。&lt;/p>
&lt;p>无论你是研发还是架构师，我相信这种系统架构我们肯定都不能接受，那怎么才能解决这个问题呢？&lt;/p>
&lt;p>我们首先都会想到可以采用&amp;quot;分而治之&amp;quot;的思想来进行拆分，但是拆分完的系统怎么保持跟未拆分前的调用方式一样呢？我们总不能因为架构升级，就把所有的代码都推倒重写一遍吧。&lt;/p>
&lt;p>**RPC 框架能够帮助我们解决系统拆分后的通信问题，并且能让我们像调用本地一样去调用远程方法。**利用 RPC 我们不仅可以很方便地将应用架构从&amp;quot;单体&amp;quot;演进成&amp;quot;微服务化&amp;quot;，而且还能解决实际开发过程中的效率低下、系统耦合等问题，这样可以使得我们的系统架构整体清晰、健壮，应用可运维度增强。&lt;/p>
&lt;p>当然 RPC 不仅可以用来解决通信问题，它还被用在了很多其他场景，比如：发 MQ、分布式缓存、数据库等。下图是我之前开发的一个应用架构图：&lt;br>
&lt;img src="https://static001.geekbang.org/resource/image/50/be/506e902e06e91663334672c29bfbc2be.jpg" alt="">&lt;/p>
&lt;p>在这个应用中，我使用了 MQ 来处理异步流程、Redis 缓存热点数据、MySQL 持久化数据，还有就是在系统中调用另外一个业务系统的接口，对我的应用来说这些都是属于 RPC 调用，而 MQ、MySQL 持久化的数据也会存在于一个分布式文件系统中，他们之间的调用也是需要用 RPC 来完成数据交互的。&lt;/p>
&lt;p>由此可见，RPC 确实是我们日常开发中经常接触的东西，只是被包装成了各种框架，导致我们很少意识到这就是 RPC，让 RPC 变成了我们最&amp;quot;熟悉的陌生人&amp;quot;。现在，回过头想想，我说 RPC 是整个应用系统的&amp;quot;经络&amp;quot;，这不为过吧？我们真的很有必要学好 RPC，不仅因为 RPC 是构建复杂系统的基石，还是提升自身认知的利器。&lt;/p>
&lt;h1 id="总结">总结&lt;/h1>
&lt;p>本讲我主要讲了下 RPC 的原理，RPC 就是提供一种透明调用机制，让使用者不必显式地区分本地调用和远程调用。RPC 虽然可以帮助开发者屏蔽远程调用跟本地调用的区别，但毕竟涉及到远程网络通信，所以这里还是有很多使用上的区别，比如：&lt;/p>
&lt;ul>
&lt;li>调用过程中超时了怎么处理业务？&lt;/li>
&lt;li>什么场景下最适合使用 RPC？&lt;/li>
&lt;li>什么时候才需要考虑开启压缩？&lt;/li>
&lt;/ul>
&lt;p>无论你是一个初级开发者还是高级开发者，RPC 都应该是你日常开发过程中绕不开的一个话题，所以作为软件开发者的我们，真的很有必要详细地了解 RPC 实现细节。只有这样，才能帮助我们更好地在日常工作中使用 RPC。&lt;/p>
&lt;h1 id="课后思考">课后思考&lt;/h1>
&lt;ul>
&lt;li>你应用中有哪些地方用到了 RPC？&lt;/li>
&lt;li>你认为，RPC 使用过程中需要注意哪些问题？&lt;/li>
&lt;/ul>
&lt;p>欢迎留言和我分享你的思考和疑惑，也欢迎你把文章分享给你的朋友，邀请他加入学习。我们下节课再见！&lt;/p></description></item><item><title>极客专栏: 01丨缺乏业务含义的命名：如何精准命名？</title><link>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E4%BB%A3%E7%A0%81%E4%B9%8B%E4%B8%91/01%E4%B8%A8%E7%BC%BA%E4%B9%8F%E4%B8%9A%E5%8A%A1%E5%90%AB%E4%B9%89%E7%9A%84%E5%91%BD%E5%90%8D%E5%A6%82%E4%BD%95%E7%B2%BE%E5%87%86%E5%91%BD%E5%90%8D/</link><pubDate>Sat, 28 May 2022 00:00:00 +0000</pubDate><guid>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E4%BB%A3%E7%A0%81%E4%B9%8B%E4%B8%91/01%E4%B8%A8%E7%BC%BA%E4%B9%8F%E4%B8%9A%E5%8A%A1%E5%90%AB%E4%B9%89%E7%9A%84%E5%91%BD%E5%90%8D%E5%A6%82%E4%BD%95%E7%B2%BE%E5%87%86%E5%91%BD%E5%90%8D/</guid><description>
&lt;p>你好，我是郑晔。&lt;/p>
&lt;p>讲写代码的书通常都会从命名开始讲，《程序设计实践》如此，《代码整洁之道》亦然。所以，我们这个讲代码坏味道的专栏，也遵循传统，从命名开始讲。&lt;/p>
&lt;p>不过，也许你会说：&amp;ldquo;我知道，命名不就是不能用 abcxyz 命名，名字要有意义嘛，这有什么好讲的。&amp;ldquo;然而，即便懂得了名字要有意义这个道理，很多程序员依然无法从命名的泥潭中挣脱出来。&lt;/p>
&lt;h1 id="不精准的命名">不精准的命名&lt;/h1>
&lt;p>我们先来看一段代码：&lt;/p>
&lt;pre tabindex="0">&lt;code>public void processChapter(long chapterId) {
Chapter chapter = this.repository.findByChapterId(chapterId);
if (chapter == null) {
throw new IllegalArgumentException(&amp;#34;Unknown chapter [&amp;#34; + chapterId + &amp;#34;]&amp;#34;);
}
chapter.setTranslationState(TranslationState.TRANSLATING);
this.repository.save(chapter);
}
&lt;/code>&lt;/pre>&lt;p>这是一段看上去还挺正常的代码，甚至以很多团队的标准来看，这段代码写得还不错。但如果我问你，这段代码是做什么的。你就需要调动全部注意力，去认真阅读这段代码，找出其中的逻辑。经过阅读我们发现，这段代码做的就是把一个章节的翻译状态改成翻译中。&lt;/p>
&lt;p>问题来了，为什么你需要阅读这段代码的细节，才能知道这段代码是做什么的？&lt;/p>
&lt;p>问题就出在函数名上。这个函数的名字叫 processChapter（处理章节），这个函数确实是在处理章节，但是，这个名字太过宽泛。如果说&amp;quot;将章节的翻译状态改成翻译中&amp;quot;叫做处理章节，那么&amp;quot;将章节的翻译状态改成翻译完&amp;quot;是不是也叫处理章节呢？&amp;ldquo;修改章节内容&amp;quot;是不是也叫处理章节呢？换句话说，如果各种场景都能够叫处理章节，那么处理章节就是一个过于宽泛的名字，没有错，但不精准。&lt;/p>
&lt;p>这就是一类典型的命名问题，从表面上看，这个名字是有含义的，但实际上，它并不能有效地反映这段代码的含义。如果说我在做的是一个信息处理系统，你根本无法判断，我做是一个电商平台，还是一个图书管理系统，从沟通的角度看，这就不是一个有效的沟通。要想理解它，你需要消耗大量认知成本，无论是时间，还是精力。&lt;/p>
&lt;p>&lt;strong>命名过于宽泛，不能精准描述，这是很多代码在命名上存在的严重问题，也是代码难以理解的根源所在&lt;/strong>。&lt;/p>
&lt;p>或许这么说你的印象还是不深刻，我们看看下面这些词是不是经常出现在你的代码里：data、info、flag、process、handle、build、maintain、manage、modify 等等。这些名字都属于典型的过于宽泛的名字，当这些名字出现在你的代码里，多半是写代码的人当时没有想好用什么名字，就开始写代码了。我相信，只要稍微仔细想想，类似的名字你一定还能想出不少来。&lt;/p>
&lt;p>回到前面那段代码上，如果它不叫&amp;quot;处理章节&amp;rdquo;，那应该叫什么呢？首先，&lt;strong>命名要能够描述出这段代码在做的事情&lt;/strong>。这段代码在做的事情就是&amp;quot;将章节修改为翻译中&amp;rdquo;。那是不是它就应该叫 changeChapterToTranlsating 呢？&lt;/p>
&lt;p>不可否认，相比于&amp;quot;处理章节&amp;rdquo;，changeChapterToTranlsating 这个名字已经进了一步，然而，它也不算是一个好名字，因为它更多的是在描述这段代码在做的细节。我们之所以要将一段代码封装起来，一个重要的原因就是，我们不想知道那么多的细节。如果把细节平铺开来，那本质上和直接阅读代码细节差别并不大。&lt;/p>
&lt;p>所以，&lt;strong>一个好的名字应该描述意图，而非细节。&lt;/strong>&lt;/p>
&lt;p>就这段代码而言， 我们为什么要把翻译状态修改成翻译中，这一定是有原因的，也就是意图。具体到这里的业务，我们把翻译状态修改成翻译中，是因为我们在这里开启了一个翻译的过程。所以，这段函数应该命名 startTranslation。&lt;/p>
&lt;pre tabindex="0">&lt;code>public void startTranslation(long chapterId) {
Chapter chapter = this.repository.findByChapterId(chapterId);
if (chapter == null) {
throw new IllegalArgumentException(&amp;#34;Unknown chapter [&amp;#34; + chapterId + &amp;#34;]&amp;#34;);
}
chapter.setTranslationState(TranslationState.TRANSLATING);
this.repository.save(chapter);
}
&lt;/code>&lt;/pre>&lt;h1 id="用技术术语命名">用技术术语命名&lt;/h1>
&lt;p>我们再来看一段代码：&lt;/p>
&lt;pre tabindex="0">&lt;code>List&amp;lt;Book&amp;gt; bookList = service.getBooks();
&lt;/code>&lt;/pre>&lt;p>可以说这是一段常见得不能再常见的代码了，但这段代码却隐藏另外一个典型得不能再典型的问题：&lt;strong>用技术术语命名。&lt;/strong>&lt;/p>
&lt;p>这个 bookList 变量之所以叫 bookList，原因就是它声明的类型是 List。这种命名在代码中几乎是随处可见的，比如 xxxMap、xxxSet。&lt;/p>
&lt;p>这是一种不费脑子的命名方式，但是，这种命名却会带来很多问题，因为它是一种基于实现细节的命名方式。&lt;/p>
&lt;p>我们都知道，编程有一个重要的原则是面向接口编程，这个原则从另外一个角度理解，就是不要面向实现编程，&lt;strong>因为接口是稳定的，而实现是易变的&lt;/strong>。虽然在大多数人的理解里，这个原则是针对类型的，但在命名上，我们也应该遵循同样的原则。为什么？我举个例子你就知道了。&lt;/p>
&lt;p>比如，如果我发现，我现在需要的是一个不重复的作品集合，也就是说，我需要把这个变量的类型从 List 改成 Set。变量类型你一定会改，但变量名你会改吗？这还真不一定，一旦出现遗忘，就会出现一个奇特的现象，一个叫 bookList 的变量，它的类型是一个 Set。这样，一个新的混淆就此产生了。&lt;/p>
&lt;p>那有什么更好的名字吗？我们需要一个更面向意图的名字。其实，我们在这段代码里真正要表达的是拿到了一堆书，所以，这个名字可以命名成 books。&lt;/p>
&lt;pre tabindex="0">&lt;code>List&amp;lt;Book&amp;gt; books = service.getBooks();
&lt;/code>&lt;/pre>&lt;p>也许你发现了，这个名字其实更简单，但从表意的程度上来说，它却是一个更有效的名字。&lt;/p>
&lt;p>虽然这里我们只是以变量为例说明了以技术术语命名存在的问题，事实上，**在实际的代码中，技术名词的出现，**&lt;strong>往往就代表着它缺少了一个应有的模型。&lt;/strong>&lt;/p>
&lt;p>比如，在业务代码里如果直接出现了 Redis：&lt;/p>
&lt;pre tabindex="0">&lt;code>public Book getByIsbn(String isbn) {
Book cachedBook = redisBookStore.get(isbn);
if (cachedBook != null) {
return cachedBook;
}
Book book = doGetByIsbn(isbn);
redisBookStore.put(isbn, book);
return book;
}
&lt;/code>&lt;/pre>&lt;p>通常来说，这里真正需要的是一个缓存。Redis 是缓存这个模型的一个实现：&lt;/p>
&lt;pre tabindex="0">&lt;code>public Book getByIsbn(String isbn) {
Book cachedBook = cache.get(isbn);
if (cachedBook != null) {
return cachedBook;
}
Book book = doGetByIsbn(isbn);
cache.put(isbn, book);
return book;
}
&lt;/code>&lt;/pre>&lt;p>再进一步，缓存这个概念其实也是一个技术术语，从某种意义上说，它也不应该出现在业务代码中。这方面做得比较好的是 Spring。使用 Spring 框架时，如果需要缓存，我们通常是加上一个 Annotation（注解）：&lt;/p>
&lt;pre tabindex="0">&lt;code>@Cacheable(&amp;#34;books&amp;#34;)
public Book getByIsbn(String isbn) {
...
}
&lt;/code>&lt;/pre>&lt;p>程序员之所以喜欢用技术名词去命名，一方面是因为，这是大家习惯的语言，另一方面也是因为程序员学习写代码，很大程度上是参考别人的代码，而行业里面优秀的代码常常是一些开源项目，而这些开源项目往往是技术类的项目。&lt;strong>在一个技术类的项目中，这些技术术语其实就是它的业务语言。但对于业务项目，这个说法就必须重新审视了。&lt;/strong>&lt;/p>
&lt;p>如果这个部分的代码确实就是处理一些技术，使用技术术语无可厚非，但如果是在处理业务，就要尽可能把技术术语隔离开来。&lt;/p>
&lt;h1 id="用业务语言写代码">用业务语言写代码&lt;/h1>
&lt;p>无论是不精准的命名也好，技术名词也罢，归根结底，体现的是同一个问题：对业务理解不到位。&lt;/p>
&lt;p>我在《10x 程序员工作法》专栏中曾经说过，&lt;strong>编写可维护的代码要使用业务语言&lt;/strong>。怎么才知道自己的命名是否用的是业务语言呢？一种简单的做法就是，把这个词讲给产品经理，看他知不知道是怎么回事。&lt;/p>
&lt;p>从团队的角度看，让每个人根据自己的理解来命名，确实就有可能出现千奇百怪的名字，所以，一个良好的团队实践是，&lt;strong>建立团队的词汇表&lt;/strong>，让团队成员有信息可以参考。&lt;/p>
&lt;p>团队对于业务有了共同理解，我们也许就可以发现一些更高级的坏味道，比如说下面这个函数声明：&lt;/p>
&lt;pre tabindex="0">&lt;code>public void approveChapter(long chapterId, long userId) {
...
}
&lt;/code>&lt;/pre>&lt;p>这个函数的意图是，确认章节内容审核通过。这里有一个问题，chapterId 是审核章节的 ID，这个没问题，但 userId 是什么呢？了解了一下背景，我们才知道，之所以这里要有一个 userId，是因为这里需要记录一下审核人的信息，这个 userId 就是审核人的 userId。&lt;/p>
&lt;p>你看，通过业务的分析，我们会发现，这个 userId 并不是一个好的命名，因为它还需要更多的解释，更好的命名是 reviewerUserId，之所以起这个名字，因为这个用户在这个场景下扮演的角色是审核人（Reviewer）。&lt;/p>
&lt;pre tabindex="0">&lt;code>public void approveChapter(long chapterId, long reviewerUserId) {
...
}
&lt;/code>&lt;/pre>&lt;p>从某种意义上来说，这个坏味道也是一种不精准的命名，但它不是那种一眼可见的坏味道，&lt;strong>而是需要在业务层面上再进行讨论&lt;/strong>，所以，它是一种更高级的坏味道。&lt;/p>
&lt;p>我初入职场的时候，有一次为一个名字陷入了沉思，一个工作经验丰富的同事对此的评价是：你开始进阶了。确实，能够意识到自己的命名有问题，是程序员进阶的第一步。&lt;/p>
&lt;h1 id="总结时刻">总结时刻&lt;/h1>
&lt;p>我们今天讲了两个典型的命名坏味道：&lt;/p>
&lt;ul>
&lt;li>不精准的命名；&lt;/li>
&lt;li>用技术术语命名。&lt;/li>
&lt;/ul>
&lt;p>命名是软件开发中两件难事之一（另一个难事是缓存失效），不好的命名本质上是增加我们的认知成本，同样也增加了后来人（包括我们自己）维护代码的成本。&lt;/p>
&lt;p>好的命名要体现出这段代码在做的事情，而无需展开代码了解其中的细节，这是最低的要求。再进一步，好的命名要准确地体现意图，而不是实现细节。更高的要求是，用业务语言写代码。&lt;/p>
&lt;p>至此，我们已经对命名有了一个更深入的认识。下一讲，我们来说说国外那些经典的讲编码的书都不曾覆盖到的一个话题：英文命名。&lt;/p>
&lt;p>如果今天的内容你只能记住一件事，那请记住：&lt;strong>好的命名，是体现业务含义的命名&lt;/strong>。&lt;br>
&lt;img src="https://static001.geekbang.org/resource/image/4e/66/4e725dfea2eeb16ef0f654813ca42066.jpg" alt="">&lt;/p>
&lt;h1 id="思考题">思考题&lt;/h1>
&lt;p>前面我们提到了一些代码中常见的不精准的命名所用的词汇，你还能想到哪些词呢？欢迎在留言区分享你的想法。也欢迎你把这节课分享给你身边对命名问题感到困惑的朋友。&lt;/p>
&lt;p>感谢阅读，我们下一讲再见！&lt;/p>
&lt;p>参考资料: 你的代码为谁而写？&lt;/p></description></item><item><title>极客专栏: 01丨课前热身丨这些需求给到你，你会怎么写代码？</title><link>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E4%BB%A3%E7%A0%81%E4%B9%8B%E4%B8%91/01%E4%B8%A8%E8%AF%BE%E5%89%8D%E7%83%AD%E8%BA%AB%E4%B8%A8%E8%BF%99%E4%BA%9B%E9%9C%80%E6%B1%82%E7%BB%99%E5%88%B0%E4%BD%A0%E4%BD%A0%E4%BC%9A%E6%80%8E%E4%B9%88%E5%86%99%E4%BB%A3%E7%A0%81/</link><pubDate>Sat, 28 May 2022 00:00:00 +0000</pubDate><guid>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E4%BB%A3%E7%A0%81%E4%B9%8B%E4%B8%91/01%E4%B8%A8%E8%AF%BE%E5%89%8D%E7%83%AD%E8%BA%AB%E4%B8%A8%E8%BF%99%E4%BA%9B%E9%9C%80%E6%B1%82%E7%BB%99%E5%88%B0%E4%BD%A0%E4%BD%A0%E4%BC%9A%E6%80%8E%E4%B9%88%E5%86%99%E4%BB%A3%E7%A0%81/</guid><description>
&lt;p>你好，我是郑晔。&lt;/p>
&lt;p>我在开篇词中提到，缺乏识别代码坏味道的感觉，这才让很多问题代码堂而皇之地留在了自己的眼皮底下。识别坏味道，单纯学理论是不够的，你得结合具体问题进行分析，所以我才在课程中加入了大量真实的代码案例，帮助你理解坏味道。当然，除此之外，你还要有足够多的练习。&lt;/p>
&lt;p>为了让你能够深度地参与到这个专栏的学习中，代码能力得到有效提升，我准备了一个课前热身的环节：大家一起来写代码。&lt;/p>
&lt;p>我们要编写一个待办事项管理的软件，你可以看我下面给出的需求，它是以&lt;strong>命令行应用&lt;/strong>的方式存在的。&lt;/p>
&lt;h1 id="第一阶段基本功能">第一阶段：基本功能&lt;/h1>
&lt;ul>
&lt;li>添加 Todo 项。&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>todo add &amp;lt;item&amp;gt;
1. &amp;lt;item&amp;gt;
Item &amp;lt;itemIndex&amp;gt; added
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>完成 Todo 项。&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>todo done &amp;lt;itemIndex&amp;gt;
Item &amp;lt;itemIndex&amp;gt; done.
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>查看 Todo 列表，缺省情况下，只列出未完成的 Todo 项。&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>todo list
1. &amp;lt;item1&amp;gt;
2. &amp;lt;item2&amp;gt;
Total: 2 items
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>使用 all 参数，查看所有的 Todo 项。&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>todo list --all
1. &amp;lt;item1&amp;gt;
2. &amp;lt;item2&amp;gt;
3. [Done] &amp;lt;item3&amp;gt;
Total: 3 items, 1 item done
&lt;/code>&lt;/pre>&lt;p>要求：&lt;/p>
&lt;ul>
&lt;li>Todo 项存储在本地文件中；&lt;/li>
&lt;li>Todo 项索引逐一递增。&lt;/li>
&lt;/ul>
&lt;h1 id="第二阶段支持多用户">第二阶段：支持多用户&lt;/h1>
&lt;ul>
&lt;li>用户登录。&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>todo login -u user
Password:
Login success!
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>用户退出。&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>todo logout
Logout success!
&lt;/code>&lt;/pre>&lt;p>要求：&lt;/p>
&lt;ul>
&lt;li>只能看到当前用户的 Todo 列表；&lt;/li>
&lt;li>同一个用户的 Todo 项索引逐一递增；&lt;/li>
&lt;li>当前用户信息存储在配置文件中 ~/.todo-config。&lt;/li>
&lt;/ul>
&lt;h1 id="第三阶段支持-todo-列表导入和导出">第三阶段：支持 Todo 列表导入和导出&lt;/h1>
&lt;ul>
&lt;li>Todo 列表导出。&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>todo export &amp;gt; todolist
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>Todo 列表导入。&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>todo import -f todolist
&lt;/code>&lt;/pre>&lt;h1 id="第四阶段支持数据库持久化">第四阶段：支持数据库持久化&lt;/h1>
&lt;p>在配置文件中，配置数据库连接信息。&lt;/p>
&lt;ul>
&lt;li>初始化数据库。&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>todo init
&lt;/code>&lt;/pre>&lt;p>要求：&lt;/p>
&lt;ul>
&lt;li>没有数据库的情况下，使用本地文件；&lt;/li>
&lt;li>在有数据库的情况下，使用数据库；&lt;/li>
&lt;li>在本地文件已经存在的情况，将本地信息导入到数据库中。&lt;/li>
&lt;/ul>
&lt;p>以上我给出的是最基本的需求，你可以根据自己的实际编码情况，适当补充一些细节，比如，相应的错误提示。&lt;/p>
&lt;p>你可以用自己最熟悉的程序设计语言、按照自己最习惯的方式编写代码，并在 Github 上以公开仓库的方式提交自己的代码，将仓库链接贴在这节课的留言区下，我会顺着链接找到你的仓库，去查看你写的代码。&lt;/p>
&lt;p>为了方便代码的阅读，请你按如下要求编写你的代码：&lt;/p>
&lt;ul>
&lt;li>在项目的 README 文件中，写出如何构建和执行你的应用；&lt;/li>
&lt;li>需求分成四个阶段，请你按顺序依次完成每个阶段的需求；&lt;/li>
&lt;li>每完成一个阶段的代码，创建一个 tag，tag 名称分别为 todo-phase-1、todo-phase-2、todo-phase-3、todo-phase-4。&lt;/li>
&lt;/ul>
&lt;p>之所以要把需求分阶段，主要是方便大家参与，即便你时间有限，只写第一个阶段的代码，依然是一个完整的需求。学过《10x 程序员工作法》的同学都知道，任务分解是一个重要的工作原则，分阶段需求其实就是一种需求层面上的任务分解。&lt;/p>
&lt;p>在专栏结束之前，我会专门制作一期加餐，点评大家的代码；同时，我也会选出代码写的最整洁的 3 位同学，送出价值149 元的华为智能体脂电子称。&lt;br>
&lt;img src="https://static001.geekbang.org/resource/image/5d/6b/5d6600a2769c6924d732d80eb365206b.jpg" alt="">&lt;/p>
&lt;p>欢迎加入这次编码的训练中，期待你在留言区分享你的代码。&lt;/p></description></item><item><title>极客专栏: 01丨Java代码是怎么运行的？</title><link>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E6%B7%B1%E5%85%A5%E6%8B%86%E8%A7%A3jvm%E8%99%9A%E6%8B%9F%E6%9C%BA/01%E4%B8%A8java%E4%BB%A3%E7%A0%81%E6%98%AF%E6%80%8E%E4%B9%88%E8%BF%90%E8%A1%8C%E7%9A%84/</link><pubDate>Fri, 27 May 2022 00:00:00 +0000</pubDate><guid>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E6%B7%B1%E5%85%A5%E6%8B%86%E8%A7%A3jvm%E8%99%9A%E6%8B%9F%E6%9C%BA/01%E4%B8%A8java%E4%BB%A3%E7%A0%81%E6%98%AF%E6%80%8E%E4%B9%88%E8%BF%90%E8%A1%8C%E7%9A%84/</guid><description>
&lt;p>我们学院的一位教授之前去美国开会，入境的时候海关官员就问他：既然你会计算机，那你说说你用的都是什么语言吧？&lt;/p>
&lt;p>教授随口就答了个 Java。海关一看是懂行的，也就放行了，边敲章还边说他们上学那会学的是 C+。我还特意去查了下，真有叫 C+ 的语言，但是这里海关官员应该指的是 C++。&lt;/p>
&lt;p>事后教授告诉我们，他当时差点就问海关，是否知道 Java 和 C++ 在运行方式上的区别。但是又担心海关官员拿他的问题来考别人，也就没问出口。那么，下次你去美国，不幸地被海关官员问这个问题，你懂得如何回答吗？&lt;/p>
&lt;p>作为一名 Java 程序员，你应该知道，Java 代码有很多种不同的运行方式。比如说可以在开发工具中运行，可以双击执行 jar 文件运行，也可以在命令行中运行，甚至可以在网页中运行。当然，这些执行方式都离不开 JRE，也就是 Java 运行时环境。&lt;/p>
&lt;p>实际上，JRE 仅包含运行 Java 程序的必需组件，包括 Java 虚拟机以及 Java 核心类库等。我们 Java 程序员经常接触到的 JDK（Java 开发工具包）同样包含了 JRE，并且还附带了一系列开发、诊断工具。&lt;/p>
&lt;p>然而，运行 C++ 代码则无需额外的运行时。我们往往把这些代码直接编译成 CPU 所能理解的代码格式，也就是机器码。&lt;/p>
&lt;p>比如下图的中间列，就是用 C 语言写的 Helloworld 程序的编译结果。可以看到，C 程序编译而成的机器码就是一个个的字节，它们是给机器读的。那么为了让开发人员也能够理解，我们可以用反汇编器将其转换成汇编代码（如下图的最右列所示）。&lt;/p>
&lt;pre>&lt;code>; 最左列是偏移；中间列是给机器读的机器码；最右列是给人读的汇编代码
0x00: 55 push rbp
0x01: 48 89 e5 mov rbp,rsp
0x04: 48 83 ec 10 sub rsp,0x10
0x08: 48 8d 3d 3b 00 00 00 lea rdi,[rip+0x3b]
; 加载 &amp;quot;Hello, World!\n&amp;quot;
0x0f: c7 45 fc 00 00 00 00 mov DWORD PTR [rbp-0x4],0x0
0x16: b0 00 mov al,0x0
0x18: e8 0d 00 00 00 call 0x12
; 调用 printf 方法
0x1d: 31 c9 xor ecx,ecx
0x1f: 89 45 f8 mov DWORD PTR [rbp-0x8],eax
0x22: 89 c8 mov eax,ecx
0x24: 48 83 c4 10 add rsp,0x10
0x28: 5d pop rbp
0x29: c3 ret
&lt;/code>&lt;/pre>
&lt;p>既然 C++ 的运行方式如此成熟，那么你有没有想过，为什么 Java 要在虚拟机中运行呢，Java 虚拟机具体又是怎样运行 Java 代码的呢，它的运行效率又如何呢？&lt;/p>
&lt;p>今天我便从这几个问题入手，和你探讨一下，Java 执行系统的主流实现以及设计决策。&lt;/p>
&lt;h2 id="为什么-java-要在虚拟机里运行">为什么 Java 要在虚拟机里运行？&lt;/h2>
&lt;p>Java 作为一门高级程序语言，它的语法非常复杂，抽象程度也很高。因此，直接在硬件上运行这种复杂的程序并不现实。所以呢，在运行 Java 程序之前，我们需要对其进行一番转换。&lt;/p>
&lt;p>这个转换具体是怎么操作的呢？当前的主流思路是这样子的，设计一个面向 Java 语言特性的虚拟机，并通过编译器将 Java 程序转换成该虚拟机所能识别的指令序列，也称 Java 字节码。这里顺便说一句，之所以这么取名，是因为 Java 字节码指令的操作码（opcode）被固定为一个字节。&lt;/p>
&lt;p>举例来说，下图的中间列，正是用 Java 写的 Helloworld 程序编译而成的字节码。可以看到，它与 C 版本的编译结果一样，都是由一个个字节组成的。&lt;/p>
&lt;p>并且，我们同样可以将其反汇编为人类可读的代码格式（如下图的最右列所示）。不同的是，Java 版本的编译结果相对精简一些。这是因为 Java 虚拟机相对于物理机而言，抽象程度更高。&lt;/p>
&lt;pre>&lt;code># 最左列是偏移；中间列是给虚拟机读的机器码；最右列是给人读的代码
0x00: b2 00 02 getstatic java.lang.System.out
0x03: 12 03 ldc &amp;quot;Hello, World!&amp;quot;
0x05: b6 00 04 invokevirtual java.io.PrintStream.println
0x08: b1 return
&lt;/code>&lt;/pre>
&lt;p>Java 虚拟机可以由硬件实现 [1]，但更为常见的是在各个现有平台（如 Windows_x64、Linux_aarch64）上提供软件实现。这么做的意义在于，一旦一个程序被转换成 Java 字节码，那么它便可以在不同平台上的虚拟机实现里运行。这也就是我们经常说的&amp;quot;一次编写，到处运行&amp;quot;。&lt;/p>
&lt;p>虚拟机的另外一个好处是它带来了一个托管环境（Managed Runtime）。这个托管环境能够代替我们处理一些代码中冗长而且容易出错的部分。其中最广为人知的当属自动内存管理与垃圾回收，这部分内容甚至催生了一波垃圾回收调优的业务。&lt;/p>
&lt;p>除此之外，托管环境还提供了诸如数组越界、动态类型、安全权限等等的动态检测，使我们免于书写这些无关业务逻辑的代码。&lt;/p>
&lt;h2 id="java-虚拟机具体是怎样运行-java-字节码的">Java 虚拟机具体是怎样运行 Java 字节码的？&lt;/h2>
&lt;p>下面我将以标准 JDK 中的 HotSpot 虚拟机为例，从虚拟机以及底层硬件两个角度，给你讲一讲 Java 虚拟机具体是怎么运行 Java 字节码的。&lt;/p>
&lt;p>从虚拟机视角来看，执行 Java 代码首先需要将它编译而成的 class 文件加载到 Java 虚拟机中。加载后的 Java 类会被存放于方法区（Method Area）中。实际运行时，虚拟机会执行方法区内的代码。&lt;/p>
&lt;p>如果你熟悉 X86 的话，你会发现这和段式内存管理中的代码段类似。而且，Java 虚拟机同样也在内存中划分出堆和栈来存储运行时数据。&lt;/p>
&lt;p>不同的是，Java 虚拟机会将栈细分为面向 Java 方法的 Java 方法栈，面向本地方法（用 C++ 写的 native 方法）的本地方法栈，以及存放各个线程执行位置的 PC 寄存器。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/ab/77/ab5c3523af08e0bf2f689c1d6033ef77.png" alt="">&lt;/p>
&lt;p>在运行过程中，每当调用进入一个 Java 方法，Java 虚拟机会在当前线程的 Java 方法栈中生成一个栈帧，用以存放局部变量以及字节码的操作数。这个栈帧的大小是提前计算好的，而且 Java 虚拟机不要求栈帧在内存空间里连续分布。&lt;/p>
&lt;p>当退出当前执行的方法时，不管是正常返回还是异常返回，Java 虚拟机均会弹出当前线程的当前栈帧，并将之舍弃。&lt;/p>
&lt;p>从硬件视角来看，Java 字节码无法直接执行。因此，Java 虚拟机需要将字节码翻译成机器码。&lt;/p>
&lt;p>在 HotSpot 里面，上述翻译过程有两种形式：第一种是解释执行，即逐条将字节码翻译成机器码并执行；第二种是即时编译（Just-In-Time compilation，JIT），即将一个方法中包含的所有字节码编译成机器码后再执行。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/5e/3b/5ee351091464de78eed75438b6f9183b.png" alt="">&lt;/p>
&lt;p>前者的优势在于无需等待编译，而后者的优势在于实际运行速度更快。HotSpot 默认采用混合模式，综合了解释执行和即时编译两者的优点。它会先解释执行字节码，而后将其中反复执行的热点代码，以方法为单位进行即时编译。&lt;/p>
&lt;h2 id="java-虚拟机的运行效率究竟是怎么样的">Java 虚拟机的运行效率究竟是怎么样的？&lt;/h2>
&lt;p>HotSpot 采用了多种技术来提升启动性能以及峰值性能，刚刚提到的即时编译便是其中最重要的技术之一。&lt;/p>
&lt;p>即时编译建立在程序符合二八定律的假设上，也就是百分之二十的代码占据了百分之八十的计算资源。&lt;/p>
&lt;p>对于占据大部分的不常用的代码，我们无需耗费时间将其编译成机器码，而是采取解释执行的方式运行；另一方面，对于仅占据小部分的热点代码，我们则可以将其编译成机器码，以达到理想的运行速度。&lt;/p>
&lt;p>理论上讲，即时编译后的 Java 程序的执行效率，是可能超过 C++ 程序的。这是因为与静态编译相比，即时编译拥有程序的运行时信息，并且能够根据这个信息做出相应的优化。&lt;/p>
&lt;p>举个例子，我们知道虚方法是用来实现面向对象语言多态性的。对于一个虚方法调用，尽管它有很多个目标方法，但在实际运行过程中它可能只调用其中的一个。&lt;/p>
&lt;p>这个信息便可以被即时编译器所利用，来规避虚方法调用的开销，从而达到比静态编译的 C++ 程序更高的性能。&lt;/p>
&lt;p>为了满足不同用户场景的需要，HotSpot 内置了多个即时编译器：C1、C2 和 Graal。Graal 是 Java 10 正式引入的实验性即时编译器，在专栏的第四部分我会详细介绍，这里暂不做讨论。&lt;/p>
&lt;p>之所以引入多个即时编译器，是为了在编译时间和生成代码的执行效率之间进行取舍。C1 又叫做 Client 编译器，面向的是对启动性能有要求的客户端 GUI 程序，采用的优化手段相对简单，因此编译时间较短。&lt;/p>
&lt;p>C2 又叫做 Server 编译器，面向的是对峰值性能有要求的服务器端程序，采用的优化手段相对复杂，因此编译时间较长，但同时生成代码的执行效率较高。&lt;/p>
&lt;p>从 Java 7 开始，HotSpot 默认采用分层编译的方式：热点方法首先会被 C1 编译，而后热点方法中的热点会进一步被 C2 编译。&lt;/p>
&lt;p>为了不干扰应用的正常运行，HotSpot 的即时编译是放在额外的编译线程中进行的。HotSpot 会根据 CPU 的数量设置编译线程的数目，并且按 1:2 的比例配置给 C1 及 C2 编译器。&lt;/p>
&lt;p>在计算资源充足的情况下，字节码的解释执行和即时编译可同时进行。编译完成后的机器码会在下次调用该方法时启用，以替换原本的解释执行。&lt;/p>
&lt;h2 id="总结与实践">总结与实践&lt;/h2>
&lt;p>今天我简单介绍了 Java 代码为何在虚拟机中运行，以及如何在虚拟机中运行。&lt;/p>
&lt;p>之所以要在虚拟机中运行，是因为它提供了可移植性。一旦 Java 代码被编译为 Java 字节码，便可以在不同平台上的 Java 虚拟机实现上运行。此外，虚拟机还提供了一个代码托管的环境，代替我们处理部分冗长而且容易出错的事务，例如内存管理。&lt;/p>
&lt;p>Java 虚拟机将运行时内存区域划分为五个部分，分别为方法区、堆、PC 寄存器、Java 方法栈和本地方法栈。Java 程序编译而成的 class 文件，需要先加载至方法区中，方能在 Java 虚拟机中运行。&lt;/p>
&lt;p>为了提高运行效率，标准 JDK 中的 HotSpot 虚拟机采用的是一种混合执行的策略。&lt;/p>
&lt;p>它会解释执行 Java 字节码，然后会将其中反复执行的热点代码，以方法为单位进行即时编译，翻译成机器码后直接运行在底层硬件之上。&lt;/p>
&lt;p>HotSpot 装载了多个不同的即时编译器，以便在编译时间和生成代码的执行效率之间做取舍。&lt;/p>
&lt;p>下面我给你留一个小作业，通过观察两个条件判断语句的运行结果，来思考 Java 语言和 Java 虚拟机看待 boolean 类型的方式是否不同。&lt;/p>
&lt;p>下载 asmtools.jar [2] ，并在命令行中运行下述指令（不包含提示符 $）：&lt;/p>
&lt;pre>&lt;code>$ echo '
public class Foo {
public static void main(String[] args) {
boolean flag = true;
if (flag) System.out.println(&amp;quot;Hello, Java!&amp;quot;);
if (flag == true) System.out.println(&amp;quot;Hello, JVM!&amp;quot;);
}
}' &amp;gt; Foo.java
$ javac Foo.java
$ java Foo
$ java -cp /path/to/asmtools.jar org.openjdk.asmtools.jdis.Main Foo.class &amp;gt; Foo.jasm.1
$ awk 'NR==1,/iconst_1/{sub(/iconst_1/, &amp;quot;iconst_2&amp;quot;)} 1' Foo.jasm.1 &amp;gt; Foo.jasm
$ java -cp /path/to/asmtools.jar org.openjdk.asmtools.jasm.Main Foo.jasm
$ java Foo
&lt;/code>&lt;/pre>
&lt;p>[1] : &lt;a href="https://en.wikipedia.org/wiki/Java_processor">https://en.wikipedia.org/wiki/Java_processor&lt;/a>&lt;br>
[2]: &lt;a href="https://wiki.openjdk.java.net/display/CodeTools/asmtools">https://wiki.openjdk.java.net/display/CodeTools/asmtools&lt;/a>&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/2a/d5/2a62e58cbdf56a5dc40748567d346fd5.jpg" alt="">&lt;/p></description></item><item><title>极客专栏: 01丨为什么要学习数据结构和算法？</title><link>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/01%E4%B8%A8%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%AD%A6%E4%B9%A0%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/</link><pubDate>Fri, 27 May 2022 00:00:00 +0000</pubDate><guid>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/01%E4%B8%A8%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%AD%A6%E4%B9%A0%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/</guid><description>
&lt;p>你是不是觉得数据结构和算法，跟操作系统、计算机网络一样，是脱离实际工作的知识？可能除了面试，这辈子也用不着？&lt;/p>
&lt;p>尽管计算机相关专业的同学在大学都学过这门课程，甚至很多培训机构也会培训这方面的知识，但是据我了解，很多程序员对数据结构和算法依旧一窍不通。还有一些人也只听说过数组、链表、快排这些最最基本的数据结构和算法，稍微复杂一点的就完全没概念。&lt;/p>
&lt;p>当然，也有很多人说，自己实际工作中根本用不到数据结构和算法。所以，就算不懂这块知识，只要 Java API、开发框架用得熟练，照样可以把代码写得&amp;quot;飞&amp;quot;起来。事实真的是这样吗？&lt;/p>
&lt;p>今天我们就来详细聊一聊，为什么要学习数据结构和算法。&lt;/p>
&lt;h2 id="想要通关大厂面试千万别让数据结构和算法拖了后腿">想要通关大厂面试，千万别让数据结构和算法拖了后腿&lt;/h2>
&lt;p>很多大公司，比如 BAT、Google、Facebook，面试的时候都喜欢考算法、让人现场写代码。有些人虽然技术不错，但每次去面试都会&amp;quot;跪&amp;quot;在算法上，很是可惜。那你有没有想过，为什么这些大公司都喜欢考算法呢？&lt;/p>
&lt;p>校招的时候，参加面试的学生通常没有实际项目经验，公司只能考察他们的基础知识是否牢固。社招就更不用说了，越是厉害的公司，越是注重考察数据结构与算法这类基础知识。相比短期能力，他们更看中你的长期潜力。&lt;/p>
&lt;p>你可能要说了，我不懂数据结构与算法，照样找到了好工作啊。那我是不是就不用学数据结构和算法呢？当然不是，你别忘了，&lt;strong>我们学任何知识都是为了&amp;quot;用&amp;quot;的，是为了解决实际工作问题的&lt;/strong>，学习数据结构和算法自然也不例外。&lt;/p>
&lt;h2 id="业务开发工程师你真的愿意做一辈子-crud-boy-吗">业务开发工程师，你真的愿意做一辈子 CRUD boy 吗？&lt;/h2>
&lt;p>如果你是一名业务开发工程师，你可能要说，我整天就是做数据库 CRUD（增删改查），哪里用得到数据结构和算法啊？&lt;/p>
&lt;p>是的，对于大部分业务开发来说，我们平时可能更多的是利用已经封装好的现成的接口、类库来堆砌、翻译业务逻辑，很少需要自己实现数据结构和算法。但是，&lt;strong>不需要自己实现，并不代表什么都不需要了解&lt;/strong>。&lt;/p>
&lt;p>如果不知道这些类库背后的原理，不懂得时间、空间复杂度分析，你如何能用好、用对它们？存储某个业务数据的时候，你如何知道应该用 ArrayList，还是 Linked List 呢？调用了某个函数之后，你又该如何评估代码的性能和资源的消耗呢？&lt;/p>
&lt;p>作为业务开发，我们会用到各种框架、中间件和底层系统，比如 Spring、RPC 框架、消息中间件、Redis 等等。&lt;strong>在这些基础框架中，一般都揉和了很多基础数据结构和算法的设计思想。&lt;/strong>&lt;/p>
&lt;p>比如，我们常用的 Key-Value 数据库 Redis 中，里面的有序集合是用什么数据结构来实现的呢？为什么要用跳表来实现呢？为什么不用二叉树呢？&lt;/p>
&lt;p>如果你能弄明白这些底层原理，你就能更好地使用它们。即便出现问题，也很容易就能定位。因此，&lt;strong>掌握数据结构和算法，不管对于阅读框架源码，还是理解其背后的设计思想，都是非常有用的。&lt;/strong>&lt;/p>
&lt;p>在平时的工作中，数据结构和算法的应用到处可见。我来举一个你非常熟悉的例子：如何实时地统计业务接口的 99% 响应时间？&lt;/p>
&lt;p>你可能最先想到，每次查询时，从小到大排序所有的响应时间，如果总共有 1200 个数据，那第 1188 个数据就是 99% 的响应时间。很显然，每次用这个方法查询的话都要排序，效率是非常低的。但是，如果你知道&amp;quot;堆&amp;quot;这个数据结构，用两个堆可以非常高效地解决这个问题。&lt;/p>
&lt;h2 id="基础架构研发工程师写出达到开源水平的框架才是你的目标">基础架构研发工程师，写出达到开源水平的框架才是你的目标！&lt;/h2>
&lt;p>现在互联网上的技术文章、架构分享、开源项目满天飞，照猫画虎做一套基础框架并不难。我就拿 RPC 框架举例。&lt;/p>
&lt;p>不同的公司、不同的人做出的 RPC 框架，架构设计思路都差不多，最后实现的功能也都差不多。但是有的人做出来的框架，Bug 很多、性能一般、扩展性也不好，只能在自己公司仅有的几个项目里面用一下。而有的人做的框架可以开源到 GitHub 上给很多人用，甚至被 Apache 收录。为什么会有这么大的差距呢？&lt;/p>
&lt;p>我觉得，高手之间的竞争其实就在细节。这些细节包括：你用的算法是不是够优化，数据存取的效率是不是够高，内存是不是够节省等等。这些累积起来，决定了一个框架是不是优秀。所以，如果你还不懂数据结构和算法，没听说过大 O 复杂度分析，不知道怎么分析代码的时间复杂度和空间复杂度，那肯定说不过去了，赶紧来补一补吧！&lt;/p>
&lt;h2 id="对编程还有追求不想被行业淘汰那就不要只会写凑合能用的代码">对编程还有追求？不想被行业淘汰？那就不要只会写凑合能用的代码！&lt;/h2>
&lt;p>何为编程能力强？是代码的可读性好、健壮？还是扩展性好？我觉得没法列，也列不全。但是，在我看来，&lt;strong>性能好坏起码是其中一个非常重要的评判标准&lt;/strong>。但是，如果你连代码的时间复杂度、空间复杂度都不知道怎么分析，怎么写出高性能的代码呢？&lt;/p>
&lt;p>你可能会说，我在小公司工作，用户量很少，需要处理的数据量也很少，开发中不需要考虑那么多性能的问题，完成功能就可以，用什么数据结构和算法，差别根本不大。但是你真的想&amp;quot;十年如一日&amp;quot;地做一样的工作吗？&lt;/p>
&lt;p>经常有人说，程序员 35 岁之后很容易陷入瓶颈，被行业淘汰，我觉得原因其实就在此。有的人写代码的时候，从来都不考虑非功能性的需求，只是完成功能，凑合能用就好；做事情的时候，也从来没有长远规划，只把眼前事情做好就满足了。&lt;/p>
&lt;p>我曾经面试过很多大龄候选人，简历能写十几页，经历的项目有几十个，但是细看下来，每个项目都是重复地堆砌业务逻辑而已，完全没有难度递进，看不出有能力提升。久而久之，十年的积累可能跟一年的积累没有任何区别。这样的人，怎么不会被行业淘汰呢？&lt;/p>
&lt;p>如果你在一家成熟的公司，或者 BAT 这样的大公司，面对的是千万级甚至亿级的用户，开发的是 TB、PB 级别数据的处理系统。性能几乎是开发过程中时刻都要考虑的问题。一个简单的 ArrayList、Linked List 的选择问题，就可能会产生成千上万倍的性能差别。这个时候，数据结构和算法的意义就完全凸显出来了。&lt;/p>
&lt;p>其实，我觉得，数据结构和算法这个东西，如果你不去学，可能真的这辈子都用不到，也感受不到它的好。但是一旦掌握，你就会常常被它的强大威力所折服。之前你可能需要费很大劲儿来优化的代码，需要花很多心思来设计的架构，用了数据结构和算法之后，很容易就可以解决了。&lt;/p>
&lt;h2 id="内容小结">内容小结&lt;/h2>
&lt;p>我们学习数据结构和算法，并不是为了死记硬背几个知识点。我们的目的是建立时间复杂度、空间复杂度意识，写出高质量的代码，能够设计基础架构，提升编程技能，训练逻辑思维，积攒人生经验，以此获得工作回报，实现你的价值，完善你的人生。&lt;/p>
&lt;p>所以，不管你是业务开发工程师，还是基础架构工程师；不管你是初入职场的初级工程师，还是工作多年的资深架构师，又或者是想转人工智能、区块链这些热门领域的程序员，数据结构与算法作为计算机的基础知识、核心知识，都是必须要掌握的。&lt;/p>
&lt;p>&lt;strong>掌握了数据结构与算法，你看待问题的深度，解决问题的角度就会完全不一样&lt;/strong>。因为这样的你，就像是站在巨人的肩膀上，拿着生存利器行走世界。数据结构与算法，会为你的编程之路，甚至人生之路打开一扇通往新世界的大门。&lt;/p>
&lt;h2 id="课后思考">课后思考&lt;/h2>
&lt;p>你为什么要学习数据结构和算法呢？在过去的软件开发中，数据结构和算法在哪些地方帮到了你？&lt;/p>
&lt;p>欢迎留言和我分享，我会第一时间给你反馈。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/8e/d3/8e603e3d795fc0ab2698f6f5eabf14d3.jpg" alt="">&lt;/p></description></item><item><title>极客专栏: 01丨基础架构：一条SQL查询语句是如何执行的？</title><link>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/mysql-%E5%AE%9E%E6%88%98-45-%E8%AE%B2/01%E4%B8%A8%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84%E4%B8%80%E6%9D%A1sql%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84/</link><pubDate>Fri, 27 May 2022 00:00:00 +0000</pubDate><guid>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/mysql-%E5%AE%9E%E6%88%98-45-%E8%AE%B2/01%E4%B8%A8%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84%E4%B8%80%E6%9D%A1sql%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84/</guid><description>
&lt;p>你好，我是林晓斌。&lt;/p>
&lt;p>这是专栏的第一篇文章，我想来跟你聊聊 MySQL 的基础架构。我们经常说，看一个事儿千万不要直接陷入细节里，你应该先鸟瞰其全貌，这样能够帮助你从高维度理解问题。同样，对于 MySQL 的学习也是这样。平时我们使用数据库，看到的通常都是一个整体。比如，你有个最简单的表，表里只有一个 ID 字段，在执行下面这个查询语句时：&lt;/p>
&lt;pre>&lt;code>mysql&amp;gt; select * from T where ID=10；
&lt;/code>&lt;/pre>
&lt;p>我们看到的只是输入一条语句，返回一个结果，却不知道这条语句在 MySQL 内部的执行过程。&lt;/p>
&lt;p>所以今天我想和你一起把 MySQL 拆解一下，看看里面都有哪些&amp;quot;零件&amp;quot;，希望借由这个拆解过程，让你对 MySQL 有更深入的理解。这样当我们碰到 MySQL 的一些异常或者问题时，就能够直戳本质，更为快速地定位并解决问题。&lt;/p>
&lt;p>下面我给出的是 MySQL 的基本架构示意图，从中你可以清楚地看到 SQL 语句在 MySQL 的各个功能模块中的执行过程。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/0d/d9/0d2070e8f84c4801adbfa03bda1f98d9.png" alt="">
MySQL 的逻辑架构图&lt;/p>
&lt;p>大体来说，MySQL 可以分为 Server 层和存储引擎层两部分。&lt;/p>
&lt;p>Server 层包括连接器、查询缓存、分析器、优化器、执行器等，涵盖 MySQL 的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。&lt;/p>
&lt;p>而存储引擎层负责数据的存储和提取。其架构模式是插件式的，支持 InnoDB、MyISAM、Memory 等多个存储引擎。现在最常用的存储引擎是 InnoDB，它从 MySQL 5.5.5 版本开始成为了默认存储引擎。&lt;/p>
&lt;p>也就是说，你执行 create table 建表的时候，如果不指定引擎类型，默认使用的就是 InnoDB。不过，你也可以通过指定存储引擎的类型来选择别的引擎，比如在 create table 语句中使用 engine=memory, 来指定使用内存引擎创建表。不同存储引擎的表数据存取方式不同，支持的功能也不同，在后面的文章中，我们会讨论到引擎的选择。&lt;/p>
&lt;p>从图中不难看出，不同的存储引擎共用一个&lt;strong>Server 层&lt;/strong>，也就是从连接器到执行器的部分。你可以先对每个组件的名字有个印象，接下来我会结合开头提到的那条 SQL 语句，带你走一遍整个执行流程，依次看下每个组件的作用。&lt;/p>
&lt;h1 id="连接器">连接器&lt;/h1>
&lt;p>第一步，你会先连接到这个数据库上，这时候接待你的就是连接器。连接器负责跟客户端建立连接、获取权限、维持和管理连接。连接命令一般是这么写的：&lt;/p>
&lt;pre>&lt;code>mysql -h$ip -P$port -u$user -p
&lt;/code>&lt;/pre>
&lt;p>输完命令之后，你就需要在交互对话里面输入密码。虽然密码也可以直接跟在 -p 后面写在命令行中，但这样可能会导致你的密码泄露。如果你连的是生产服务器，强烈建议你不要这么做。&lt;/p>
&lt;p>连接命令中的 mysql 是客户端工具，用来跟服务端建立连接。在完成经典的 TCP 握手后，连接器就要开始认证你的身份，这个时候用的就是你输入的用户名和密码。&lt;/p>
&lt;ul>
&lt;li>如果用户名或密码不对，你就会收到一个&amp;quot;Access denied for user&amp;quot;的错误，然后客户端程序结束执行。&lt;/li>
&lt;li>如果用户名密码认证通过，连接器会到权限表里面查出你拥有的权限。之后，这个连接里面的权限判断逻辑，都将依赖于此时读到的权限。&lt;/li>
&lt;/ul>
&lt;p>这就意味着，一个用户成功建立连接后，即使你用管理员账号对这个用户的权限做了修改，也不会影响已经存在连接的权限。修改完成后，只有再新建的连接才会使用新的权限设置。&lt;/p>
&lt;p>连接完成后，如果你没有后续的动作，这个连接就处于空闲状态，你可以在 show processlist 命令中看到它。文本中这个图是 show processlist 的结果，其中的 Command 列显示为&amp;quot;Sleep&amp;quot;的这一行，就表示现在系统里面有一个空闲连接。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/f2/ed/f2da4aa3a672d48ec05df97b9f992fed.png" alt="">&lt;br>
客户端如果太长时间没动静，连接器就会自动将它断开。这个时间是由参数 wait_timeout 控制的，默认值是 8 小时。&lt;/p>
&lt;p>如果在连接被断开之后，客户端再次发送请求的话，就会收到一个错误提醒： Lost connection to MySQL server during query。这时候如果你要继续，就需要重连，然后再执行请求了。&lt;/p>
&lt;p>数据库里面，长连接是指连接成功后，如果客户端持续有请求，则一直使用同一个连接。短连接则是指每次执行完很少的几次查询就断开连接，下次查询再重新建立一个。&lt;/p>
&lt;p>建立连接的过程通常是比较复杂的，所以我建议你在使用中要尽量减少建立连接的动作，也就是尽量使用长连接。&lt;/p>
&lt;p>但是全部使用长连接后，你可能会发现，有些时候 MySQL 占用内存涨得特别快，这是因为 MySQL 在执行过程中临时使用的内存是管理在连接对象里面的。这些资源会在连接断开的时候才释放。所以如果长连接累积下来，可能导致内存占用太大，被系统强行杀掉（OOM），从现象看就是 MySQL 异常重启了。&lt;/p>
&lt;p>怎么解决这个问题呢？你可以考虑以下两种方案。&lt;/p>
&lt;ol>
&lt;li>
&lt;p>定期断开长连接。使用一段时间，或者程序里面判断执行过一个占用内存的大查询后，断开连接，之后要查询再重连。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>如果你用的是 MySQL 5.7 或更新版本，可以在每次执行一个比较大的操作后，通过执行 mysql_reset_connection 来重新初始化连接资源。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h1 id="查询缓存">查询缓存&lt;/h1>
&lt;p>连接建立完成后，你就可以执行 select 语句了。执行逻辑就会来到第二步：查询缓存。&lt;/p>
&lt;p>MySQL 拿到一个查询请求后，会先到查询缓存看看，之前是不是执行过这条语句。之前执行过的语句及其结果可能会以 key-value 对的形式，被直接缓存在内存中。key 是查询的语句，value 是查询的结果。如果你的查询能够直接在这个缓存中找到 key，那么这个 value 就会被直接返回给客户端。&lt;/p>
&lt;p>如果语句不在查询缓存中，就会继续后面的执行阶段。执行完成后，执行结果会被存入查询缓存中。你可以看到，如果查询命中缓存，MySQL 不需要执行后面的复杂操作，就可以直接返回结果，这个效率会很高。&lt;/p>
&lt;p>&lt;strong>但是大多数情况下我会建议你不要使用查询缓存，为什么呢？因为查询缓存往往弊大于利。&lt;/strong>&lt;/p>
&lt;p>查询缓存的失效非常频繁，只要有对一个表的更新，这个表上所有的查询缓存都会被清空。因此很可能你费劲地把结果存起来，还没使用呢，就被一个更新全清空了。对于更新压力大的数据库来说，查询缓存的命中率会非常低。除非你的业务就是有一张静态表，很长时间才会更新一次。比如，一个系统配置表，那这张表上的查询才适合使用查询缓存。&lt;/p>
&lt;p>好在 MySQL 也提供了这种&amp;quot;按需使用&amp;quot;的方式。你可以将参数 query_cache_type 设置成 DEMAND，这样对于默认的 SQL 语句都不使用查询缓存。而对于你确定要使用查询缓存的语句，可以用 SQL_CACHE 显式指定，像下面这个语句一样：&lt;/p>
&lt;pre>&lt;code>mysql&amp;gt; select SQL_CACHE * from T where ID=10；
&lt;/code>&lt;/pre>
&lt;p>需要注意的是，MySQL 8.0 版本直接将查询缓存的整块功能删掉了，也就是说 8.0 开始彻底没有这个功能了。&lt;/p>
&lt;h1 id="分析器">分析器&lt;/h1>
&lt;p>如果没有命中查询缓存，就要开始真正执行语句了。首先，MySQL 需要知道你要做什么，因此需要对 SQL 语句做解析。&lt;/p>
&lt;p>分析器先会做&amp;quot;词法分析&amp;quot;。你输入的是由多个字符串和空格组成的一条 SQL 语句，MySQL 需要识别出里面的字符串分别是什么，代表什么。&lt;/p>
&lt;p>MySQL 从你输入的&amp;quot;select&amp;quot;这个关键字识别出来，这是一个查询语句。它也要把字符串&amp;quot;T&amp;quot;识别成&amp;quot;表名 T&amp;quot;，把字符串&amp;quot;ID&amp;quot;识别成&amp;quot;列 ID&amp;quot;。&lt;/p>
&lt;p>做完了这些识别以后，就要做&amp;quot;语法分析&amp;quot;。根据词法分析的结果，语法分析器会根据语法规则，判断你输入的这个 SQL 语句是否满足 MySQL 语法。&lt;/p>
&lt;p>如果你的语句不对，就会收到&amp;quot;You have an error in your SQL syntax&amp;quot;的错误提醒，比如下面这个语句 select 少打了开头的字母&amp;quot;s&amp;quot;。&lt;/p>
&lt;pre>&lt;code>mysql&amp;gt; elect * from t where ID=1;
ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near 'elect * from t where ID=1' at line 1
&lt;/code>&lt;/pre>
&lt;p>一般语法错误会提示第一个出现错误的位置，所以你要关注的是紧接&amp;quot;use near&amp;quot;的内容。&lt;/p>
&lt;h1 id="优化器">优化器&lt;/h1>
&lt;p>经过了分析器，MySQL 就知道你要做什么了。在开始执行之前，还要先经过优化器的处理。&lt;/p>
&lt;p>优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序。比如你执行下面这样的语句，这个语句是执行两个表的 join：&lt;/p>
&lt;pre>&lt;code>mysql&amp;gt; select * from t1 join t2 using(ID) where t1.c=10 and t2.d=20;
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>既可以先从表 t1 里面取出 c=10 的记录的 ID 值，再根据 ID 值关联到表 t2，再判断 t2 里面 d 的值是否等于 20。&lt;/li>
&lt;li>也可以先从表 t2 里面取出 d=20 的记录的 ID 值，再根据 ID 值关联到 t1，再判断 t1 里面 c 的值是否等于 10。&lt;/li>
&lt;/ul>
&lt;p>这两种执行方法的逻辑结果是一样的，但是执行的效率会有不同，而优化器的作用就是决定选择使用哪一个方案。&lt;/p>
&lt;p>优化器阶段完成后，这个语句的执行方案就确定下来了，然后进入执行器阶段。如果你还有一些疑问，比如优化器是怎么选择索引的，有没有可能选择错等等，没关系，我会在后面的文章中单独展开说明优化器的内容。&lt;/p>
&lt;h1 id="执行器">执行器&lt;/h1>
&lt;p>MySQL 通过分析器知道了你要做什么，通过优化器知道了该怎么做，于是就进入了执行器阶段，开始执行语句。&lt;/p>
&lt;p>开始执行的时候，要先判断一下你对这个表 T 有没有执行查询的权限，如果没有，就会返回没有权限的错误，如下所示 (在工程实现上，如果命中查询缓存，会在查询缓存返回结果的时候，做权限验证。查询也会在优化器之前调用 precheck 验证权限)。&lt;/p>
&lt;pre>&lt;code>mysql&amp;gt; select * from T where ID=10;
ERROR 1142 (42000): SELECT command denied to user 'b'@'localhost' for table 'T'
&lt;/code>&lt;/pre>
&lt;p>如果有权限，就打开表继续执行。打开表的时候，执行器就会根据表的引擎定义，去使用这个引擎提供的接口。&lt;/p>
&lt;p>比如我们这个例子中的表 T 中，ID 字段没有索引，那么执行器的执行流程是这样的：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>调用 InnoDB 引擎接口取这个表的第一行，判断 ID 值是不是 10，如果不是则跳过，如果是则将这行存在结果集中；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>调用引擎接口取&amp;quot;下一行&amp;quot;，重复相同的判断逻辑，直到取到这个表的最后一行。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>至此，这个语句就执行完成了。&lt;/p>
&lt;p>对于有索引的表，执行的逻辑也差不多。第一次调用的是&amp;quot;取满足条件的第一行&amp;quot;这个接口，之后循环取&amp;quot;满足条件的下一行&amp;quot;这个接口，这些接口都是引擎中已经定义好的。&lt;/p>
&lt;p>你会在数据库的慢查询日志中看到一个 rows_examined 的字段，表示这个语句执行过程中扫描了多少行。这个值就是在执行器每次调用引擎获取数据行的时候累加的。&lt;/p>
&lt;p>在有些场景下，执行器调用一次，在引擎内部则扫描了多行，因此**引擎扫描行数跟 rows_examined 并不是完全相同的。**我们后面会专门有一篇文章来讲存储引擎的内部机制，里面会有详细的说明。&lt;/p>
&lt;h1 id="小结">小结&lt;/h1>
&lt;p>今天我给你介绍了 MySQL 的逻辑架构，希望你对一个 SQL 语句完整执行流程的各个阶段有了一个初步的印象。由于篇幅的限制，我只是用一个查询的例子将各个环节过了一遍。如果你还对每个环节的展开细节存有疑问，也不用担心，后续在实战章节中我还会再提到它们。&lt;/p>
&lt;p>我给你留一个问题吧，如果表 T 中没有字段 k，而你执行了这个语句 select * from T where k=1, 那肯定是会报&amp;quot;不存在这个列&amp;quot;的错误： &amp;ldquo;Unknown column &amp;lsquo;k&amp;rsquo; in &amp;lsquo;where clause&amp;rsquo;&amp;quot;。你觉得这个错误是在我们上面提到的哪个阶段报出来的呢？&lt;/p>
&lt;p>感谢你的收听，欢迎你给我留言，也欢迎分享给更多的朋友一起阅读。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/ce/d9/ce7f4e35916ed1aa49206a53a0547bd9.jpg" alt="">&lt;/p></description></item><item><title>极客专栏: 01丨是什么推动了单体应用到微服务架构的演进？</title><link>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/springclouod%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/01%E4%B8%A8%E6%98%AF%E4%BB%80%E4%B9%88%E6%8E%A8%E5%8A%A8%E4%BA%86%E5%8D%95%E4%BD%93%E5%BA%94%E7%94%A8%E5%88%B0%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%9A%84%E6%BC%94%E8%BF%9B/</link><pubDate>Fri, 27 May 2022 00:00:00 +0000</pubDate><guid>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/springclouod%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/01%E4%B8%A8%E6%98%AF%E4%BB%80%E4%B9%88%E6%8E%A8%E5%8A%A8%E4%BA%86%E5%8D%95%E4%BD%93%E5%BA%94%E7%94%A8%E5%88%B0%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%9A%84%E6%BC%94%E8%BF%9B/</guid><description>
&lt;p>你好，我是姚秋辰。&lt;/p>
&lt;p>&amp;ldquo;微服务&amp;quot;是近些年在大型应用架构领域的一个热门话题，从实践领域来看，我们身边的一二线大厂也纷纷选择全面拥抱微服务。就拿国内 Java 系的一线大厂来说，如阿里系、美团点评、PDD 等，它们都将自己的核心业务系统构建在微服务架构之上。&lt;/p>
&lt;p>即便你是刚参加工作的萌新，也一定从铺天盖地的&amp;quot;微服务&amp;quot;相关信息流中了解到了这个名词的热度。谷歌搜索指数显示，自 2014 年起，微服务的搜索热度一路上升。&lt;br>
&lt;img src="https://static001.geekbang.org/resource/image/61/2a/61efecb5f468ab50c767804cc8ea172a.jpg?wh=2284x1213" alt="">&lt;br>
&amp;ldquo;微服务&amp;quot;的谷歌搜索指数&lt;/p>
&lt;p>其实，微服务并不是一个新兴的技术概念，很早之前它就已经进入了公众视野。&lt;/p>
&lt;p>早在 2012 年，一位叫做 Fred George 的技术专家就在一次大会上分享了自己的微服务落地经验，讲述他是如何带领团队将一个极度庞大的 J2EE 巨无霸程序，分解成 20 多个小服务的。作为微服务领域的先驱，他是这样描述微服务架构的：&lt;/p>
&lt;blockquote>
&lt;p>Micro Services Architecture - small, short lived services rather than SOA.&lt;/p>
&lt;/blockquote>
&lt;p>如果你在工作中没有接触过微服务架构的系统，那么此时一定非常蒙圈，不明白大佬所说的微服务架构到底是什么。没关系，就让我带你去回顾微服务的发展历史，了解微服务解决了什么痛点；然后我们一道来分析微服务架构的优势，让你明白为什么如今一线大厂会采用微服务架构。&lt;/p>
&lt;p>那么，我们就从微服务架构的前世今生聊起吧。&lt;/p>
&lt;h1 id="单体应用之殇">单体应用之殇&lt;/h1>
&lt;p>在互联网技术发展的早期阶段，我们采用&amp;quot;单体应用&amp;quot;的方式来构建网络系统。你没看错，即便是如今的各大老牌互联网大厂，在当年也是从单体应用小作坊成长起来的。&lt;/p>
&lt;p>以 Java 单体应用为例，我们将业务逻辑打包在一起，做成一个 WAR 包部署到 Tomcat、JBoss 之类的容器中，对外提供服务。业务上了一定规模之后，再通过集群化水平扩展的方式，将单体应用部署到一个集群中，承接更大的用户访问量。&lt;/p>
&lt;p>然而，随着业务复杂度的进一步提升，单体应用在生产力和高可用性层面就面临了巨大的挑战。我在参加工作之初做过近五年的单体应用开发，深知其中的痛处。&lt;/p>
&lt;p>我刚毕业的时候，参与了一个巨无霸的电商套件的开发，那是一个标准的单体应用。整个开发加测试团队有 100 多号人，所有人的代码都提交到一个主干分支，每次 merge 代码都要面对各种代码冲突，开发过程中&lt;strong>耗费了大量的沟通成本&lt;/strong>。不仅如此，由于庞大的业务体系都部署在一个 WAR 包中，每一次提交代码都要执行 3 个小时的回归测试，不出错还好，一旦出错就要回炉重造。周而复始执行这套繁重的流程，研发效率非常低下，完全&lt;strong>无法达到&amp;quot;快速迭代&amp;quot;的目的&lt;/strong>。&lt;/p>
&lt;p>在上线阶段我们也经常碰到各类问题。我参与的这个单体应用的发布周期是 2 个月一次（这在单体应用中已经算是很快的发布节奏了），每次发布一旦出现 Bug，&lt;strong>无法单独回滚&lt;/strong>这个小改动，我必须将整个发布里所有的功能全部回滚，待问题修复之后再重新发布。更可悲的是，整个 WAR 包的服务经常因为一个小 Bug 导致团灭，曾经有一次，我提交了一个&amp;quot;数据批量导入导出&amp;quot;的代码改动，把一个隐蔽 Bug 发布到了线上，业务持续运行一段时间之后，JVM 内存发生了泄露，导致集群各节点的 HEALTHCHECK 失败服务被重启，进而影响到了所有服务。&lt;/p>
&lt;p>上面这些问题是不是很让人头痛？想要解决它们，我们就要用到一句老话，叫&amp;quot;大事化小，小事化了&amp;rdquo;。&lt;/p>
&lt;p>在架构领域，我的经验是&amp;quot;一切看似大到无法解决的问题，都可以通过逐一拆解、各个击破的方式来解决&amp;rdquo;。在&amp;quot;单体应用&amp;quot;这个问题上，我们可以采取&amp;quot;微服务&amp;quot;化的方式，通过将这个巨无霸应用拆分成各个独立的小型微服务应用，分而治之！&lt;/p>
&lt;h1 id="微服务架构的优势">微服务架构的优势&lt;/h1>
&lt;p>微服务架构是在 SOA（面向服务架构）之上做的进一步扩展。在一线实践中，我们通过领域建模等理论将一个大型应用拆分成了更细粒度且边界清晰的服务模块。而且，每个微服务都能被独立测试、独立部署，并借助 Docker 和 CI/CD（持续集成环境）完成快速上线，不必像单体应用一样经历繁琐的 release 流程和漫长的发布窗口。&lt;/p>
&lt;p>每个微服务就像一个&amp;quot;麻雀虽小、五脏俱全&amp;quot;的小王国，&lt;strong>它拥有独立的代码库和数据库 Schema，通常由一个小规模的微服务技术团队全权负责，这个团队汇聚了产品、技术、架构等人员，采用 Scrum 之类的敏捷开发流程做快速迭代&lt;/strong>。基于此，微服务具备了&amp;quot;独立演进&amp;quot;能力。&lt;/p>
&lt;p>如果你对微服务拆分比较感兴趣，我推荐你去了解&amp;quot;领域建模&amp;quot;和&amp;quot;领域模型驱动（DDD）&amp;ldquo;的相关知识，后续我也会在这个课程中写一篇扩展阅读，跟你分享互联网公司常用的服务拆分规划理论：主链路规划。&lt;/p>
&lt;p>你现在肯定在好奇，为什么能独立开发部署的&amp;quot;微服务&amp;quot;可以解决单体应用的痛点呢？从我自己的经验来说，我认为微服务架构有这样几个天然的优势：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>快速迭代 + 快速回滚&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>细粒度的可独立部署的小型服务，再加上敏捷开发模式的加持，可以让你对产品功能实现快速迭代。在互联网公司中，微服务团队通常以周甚至 0.5 周为时间单位进行快速迭代。如果迭代过程中发现线上 Bug，也可以在最短的时间内做线上回滚，并且不会影响到其他应用的正常发布。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>资源利用大大提高&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>你可以将硬件等资源定向分配给需要用到资源的微服务，实现差异化的资源利用。在大厂的微服务体系中，我们会统计每个服务集群的线上压力水位，应用弹性计算技术在各个服务之间调配计算资源。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>大幅降低协作成本&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>代码库、数据库、编译打包从&amp;quot;共享&amp;quot;变为了&amp;quot;独享&amp;rdquo;，微服务团队也保持了小规模特战队的模式，进一步降低了组内组外的沟通协作成本。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>高可用&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>高可用是系统设计的第一目标，关于这一点，我想和你多介绍一些大厂微服务架构中的实践经验。通过这些介绍，让你对微服务化的必要性有更加深刻的认识。&lt;/p>
&lt;p>相比前牵一发而动全身的单体应用来说，我们可以通过很多技术手段对微服务施加个性化的保护措施，比如弹性机房水位调拨、流量整形、熔断降级。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>弹性机房水位调拨&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>弹性机房实现了计算资源的自动分配，这种弹性伸缩能力必须建立在微服务化的基础上。它可以根据每个微服务的重要程度（核心服务 vs 边缘业务）以及当前承接的用户访问压力，动态地将计算资源（如虚机、云存储）分配给需要资源的服务。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>流量整形&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>根据每个微服务承载能力的不同，控制外部流量抵达服务的速率。&amp;ldquo;限流&amp;quot;其实只是流量整形的一个场景，大型微服务的流量整形有很多种方式，比如匀速排队、流量预热、削峰填谷等等。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>熔断降级&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>在流量高峰的时候，我们可以对边缘服务做人工降级，把计算资源腾挪给核心应用，降低核心服务的访问压力。除了人工降级以外，我们还可以为每个服务设置自动降级和熔断指标，比如当调用失败率达到某个阈值之后，开启自动降级措施，降低对下游业务的访问压力。&lt;/p>
&lt;p>我们只有把应用微服务化之后，才能更好地使用上面这些技术手段对业务系统做精细力度的保护，从而实现高可用的目标。&lt;/p>
&lt;p>到这里，相信你已经对微服务架构有了更深一步的认识。不过，任何事物都有其两面性，微服务不光有好的一面，也有很多问题等着我们去解决。比如集群环境下的服务治理、数据一致性、以及高并发场景下的服务容错等等。不过呢，你大可放心，这些问题都不算事儿，在实战环节我会教你如何使用 Spring Cloud 组件将其一一攻破。下节课，我们正式开启 Spring Cloud 的大门。&lt;/p>
&lt;h1 id="总结">总结&lt;/h1>
&lt;p>今天我带你了解了微服务架构，我们将单体应用和微服务架构做了个比较，分析了单体应用无法适应互联网快速迭代的痛点，以及微服务架构是如何利用灵巧敏捷的小规模服务，很好地适应了互联网行业的快速迭代和高可用保障的要求。&lt;/p>
&lt;p>总结来说，微服务架构是通过应用领域模型等理论，将庞大的单体应用拆分为更细粒度的小型服务，每个服务都可以独立部署、测试和发布，加之敏捷开发的推广，使得微服务很好地迎合了如今互联网行业快速试错、快速迭代的节奏，同时也保证了系统的可用性。&lt;/p>
&lt;h1 id="思考题">思考题&lt;/h1>
&lt;p>你的公司是否也采用了微服务架构呢？你能从技术角度分享一下公司项目的技术选型方案吗？欢迎你和我分享，我在留言区等你。&lt;/p>
&lt;p>好啦，这节课就结束啦，也欢迎你把这节课分享给更多对 Spring Cloud 感兴趣的朋友。我是姚秋辰，我们下节课再见！&lt;/p></description></item><item><title>极客专栏: 01丨程序员如何用技术变现（上）</title><link>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E/01%E4%B8%A8%E7%A8%8B%E5%BA%8F%E5%91%98%E5%A6%82%E4%BD%95%E7%94%A8%E6%8A%80%E6%9C%AF%E5%8F%98%E7%8E%B0%E4%B8%8A/</link><pubDate>Fri, 27 May 2022 00:00:00 +0000</pubDate><guid>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E/01%E4%B8%A8%E7%A8%8B%E5%BA%8F%E5%91%98%E5%A6%82%E4%BD%95%E7%94%A8%E6%8A%80%E6%9C%AF%E5%8F%98%E7%8E%B0%E4%B8%8A/</guid><description>
&lt;p>程序员用自己的技术变现，其实是一件天经地义的事儿。写程序是一门&amp;quot;手艺活儿&amp;quot;，那么作为手艺人，程序员当然可以做到靠自己的手艺和技能养活自己。&lt;/p>
&lt;p>然而，现在很多手艺人程序员却说自己是&amp;quot;码农&amp;quot;，编码的农民工，在工作上被各种使唤，各种加班，累得像个牲口。在职业发展上各种迷茫和彷徨，完全看不到未来的希望，更别说可以成为一个手艺人用自己的技能变现了。&lt;/p>
&lt;p>从大学时代帮人打字挣点零花钱，到逐渐通过自己的技能帮助别人，由此获得相对丰厚的收入，我在很早就意识到，从事编程这个事可以做到，完全靠自己的手艺、不依赖任何人或公司去生活的。&lt;/p>
&lt;p>这对于程序员来说，本就应该是件天经地义的事，只是好像并不是所有的程序员都能意识到自己的价值。这里，我想结合我的一些经历来跟你聊聊。当然，我的经历有限，也不一定全对，只希望能给你一个参考。&lt;/p>
&lt;h1 id="学生时代">学生时代&lt;/h1>
&lt;p>我是 1994 年上的大学，计算机科学软件专业。在 1996 年上大二的时候，因为五笔学得好打字很快，我应征到教务处帮忙，把一些文档录入到电脑里。打了三个月的字，学校按照每千字 10 元，给了我 1000 元钱。&lt;/p>
&lt;p>由于我的五笔越打越快，还会用 CCED 和 WPS 排版，于是引起了别人的注意，叫我帮忙去他的打字工作室，一个月收入 400 元。我的大学是在昆明上的，这相当于那会当地收入的中上水平了。&lt;/p>
&lt;p>后来，1997 年的时候，我帮一个开公司的老师写一些 MIS 软件，用 Delphi 和 PowerBuilder 写一些办公自动化和酒店管理的软件。一年后，老师给了我 2000 元钱。&lt;/p>
&lt;p>因为动手能力比较强，当时系上的老师要干个什么事都让我帮忙。而且，因为当时的计算机人才太少太少了，所以一些社会上的人需要开发软件或是解决技术问题也都会到大学来。基本上老师们也都推荐给我。&lt;/p>
&lt;p>还记得 1997 年老师推荐一个人来找我，问我会不会做网页？5 个静态页，10000 元钱。当时学校没教怎样做网页，我去书店找书看，结果发现书店里一本讲 HTML 的书都没有，只好回绝说&amp;quot;不会做&amp;quot;。一年后，我才发现原来这事简单得要命。&lt;/p>
&lt;h1 id="初入职场">初入职场&lt;/h1>
&lt;p>到了 1998 年，我毕业参加工作，在工商银行网络科。由于可以拨号上网，于是我做了一个个人主页，那时超级流行个人主页或个人网站。我一边收集网上的一些知识，一边学着做些花哨的东西，比如网页上的菜单什么的。&lt;/p>
&lt;p>在 2000 年时，机缘巧合我的网站被《电脑报》的编辑看到了，他写来邮件约我投稿。我就写了一些如何在网页上做菜单之类的小技术文章，每个月写个两三篇，这样每个月就有 300 元左右的稿费，当时我的月工资是 600 元。&lt;/p>
&lt;p>现在通过文章标题还能找到一两篇，比如《&lt;a href="http://www.yesky.com/251/142751all.shtml">抽屉式菜单的设计&lt;/a>》，已经是乱码一堆了。&lt;/p>
&lt;p>大学时代被人请去做事的经历对我影响很大，甚至在潜意识里完全影响了我如何规划自己的人生。虽然当时我还说不清楚，只是一种强烈的感觉&amp;mdash;&amp;mdash;我完全可以靠自己的手艺、不依赖任何人或公司去生活。&lt;/p>
&lt;p>我想这种感觉，我现在可以说清楚了，这种潜意识就是&amp;mdash;&amp;mdash;&lt;strong>我完全没有必要通过打工听人安排而活着，而是反过来通过在公司工作提高自己的技能，让自己可以更为独立和自由地生活&lt;/strong>。&lt;/p>
&lt;p>因而，在工作当中，对于那些没什么技术含量的工作，我基本上就像是在学生时代那样交作业就好了。我想尽一切方法提高交作业的效率，比如，提高代码的重用度，能自动化的就自动化，和需求人员谈需求，简化掉需求，这样我就可以少干一些活了&amp;hellip;&amp;hellip;&lt;/p>
&lt;p>这样一来，&lt;strong>我就可以有更多的时间，去研究公司里外那些更为核心更有技术含量的技术了&lt;/strong>。&lt;/p>
&lt;p>在工作中，我总是能被别人和领导注意到，总是有比别人更多的时间去读书，去玩一些高技术含量的技术。当然，这种被&amp;quot;注意&amp;quot;，也不全然是一种好事。&lt;/p>
&lt;p>2002 年，我被外包到银行里做业务开发时，因为我完成项目的速度太快，所以，没事干，整天在用户那边看书，写别的代码练手，而被用户投诉&amp;quot;不务正业&amp;quot;。我当然对这样的投诉置之不理，还是我行我素，因为我的作业已交了，所以用户也就是说说罢了。&lt;/p>
&lt;p>同年，我到了一家新的很有技术含量的公司，他们在用 C 语言写一个可以把一堆 PC 机组成一个超级计算机，进行并行计算的公司项目。&lt;/p>
&lt;p>当我做完第一个项目时，有个公司里的牛人和我说，你用 Purify 测试一下你的代码有没有内存问题。Purify 是以前一个叫 Rational 的公司（后来被 IBM 收购）做的一个神器，有点像 Linux 开源的 Valgrind。&lt;/p>
&lt;p>用完以后，我觉得 Purify 太厉害了，于是把它的英文技术文档通读了一遍。经理看我很喜欢这个东西，就让我给公司里的人做个分享。我认真地准备了个 PPT，结果只来了一个 QA。&lt;/p>
&lt;p>我在一个大会议室就对着她一个人讲了一个半小时。这个 QA 对我说，&amp;ldquo;你的分享做得真好，条理性很强，也很清楚，我学到了很多东西&amp;rdquo;。&lt;/p>
&lt;p>有了这个正向反馈，我就把关于 Purify 的文章分享到了我的 CSDN 博客上，标题为《&lt;a href="http://blog.csdn.net/haoel/article/details/2900">C/C++ 内存问题检查利器&amp;mdash;Purify&lt;/a>》。可能因为这个软件是收费的，用的人不多，这篇文章的读者反响并不大。&lt;/p>
&lt;p>但是，2003 年的一天我很意外地接到了一个电话，是一个公司请我帮忙去给客户培训 Purify 这个软件。IBM 的培训太贵了，所以代理这个软件的公司为了成本问题，想找一个便宜的讲师。&lt;/p>
&lt;p>他们搜遍整个中国的互联网，只看到我的这篇文章，便通过 CSDN 找到我的联系方式，给我打了电话。最终，两天的培训价格税后一共 10000 元，而我当时的月薪只有 6000 元，还是税前。&lt;/p>
&lt;p>这件事儿让我在入行的时候就明白了一些道理。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>要去经历大多数人经历不到的，要把学习时间花在那些比较难的地方。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>要写文章就要写没有人写过的，或是别人写过，但我能写得更好的。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>更重要的是，技术和知识完全是可以变现的。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>现在回想一下，技术和知识变现这件事儿，在 15 年前我就明白了，哈哈。&lt;/p>
&lt;p>随后，我在 CSDN 博客上发表了很多文章，有谈 C 语言编程修养的文章，也有一些 makefile/gdb 手册性的文章，还有在工作中遇到的各种坑。&lt;/p>
&lt;p>因为我分享的东西比较系统，也是独一份，所以，搜索引擎自然是最优化的（最好的 SEO 就是独一份）。我的文章经常因为访问量大被推到 CSDN 首页。因此，引来了各种培训公司和出版社，还有一些别的公司主动发来的招聘，以及其他一些程序员想伙同创业的各种信息。&lt;/p>
&lt;p>紧接着我了解到，出书作者收入太低（作者的收入有两种：一种是稿费，一页 30 元；一种是版税，也就 5% 左右），而培训公司的投入产出比明显高很多后，于是我开始接一些培训的事（频率不高），一年有个七八次。当时需求比较强的培训主要是在这几个技术方面，C/C++/Java、Unix 系统编程、多层软件架构、软件测试、软件工程等。&lt;/p>
&lt;p>我喜欢做企业内训，还有一个主要原因是，可以走到内部去了解各个企业在做的事和他们遇到的技术痛点，以及身在其中的工程师的想法。这极大地增加了我对社会的了解和认识。而同时，让我这个原本不善表达的技术人员，在语言组织和表达方面有了极大的提升。&lt;/p>
&lt;p>其间也有一些软件开发的私活儿，但我基本全部拒绝了。最主要的原因是，这些软件开发基本上都是功能性的开发，我从中无法得到成长。而且后期会有很多维护工作，虽然一个小项目可以挣十几万，但为此花费的时间都是我人生中最宝贵的时光，得不偿失。&lt;/p>
&lt;p>&lt;strong>25~35 岁是每个人最宝贵的时光，应该用在刀刃上&lt;/strong>。&lt;/p>
&lt;h1 id="职业上升期">职业上升期&lt;/h1>
&lt;p>因为有了这些经历，我感受到了一个人知识和技能的价值。我开始把我的时间投在一些主流、高级和比较有挑战性的技术上，这可以让我保持两件事儿：一个是技术和技能的领先，二是对技术本质和趋势的敏感度。&lt;/p>
&lt;p>因此，我有强烈的意愿去前沿的公司经历和学习这些东西。比如，我在汤森路透学到了人员团队管理上的各种知识和技巧，而亚马逊是让我提升最快的公司。虽说，亚马逊也有很多不好的东西，但是它的一些理念，的确让我的思维方式和思考问题的角度有了质的飞跃。&lt;/p>
&lt;p>所以后来，我开始对外输出的不仅仅是技术了，还有一些技术价值观上的东西。&lt;/p>
&lt;p>而从亚马逊到阿里巴巴是我在互联网行业的工作经历，这两段经历让我对这两家看似类似但内部完全不同的成功大公司，有了更为全面的了解和看法。&lt;/p>
&lt;p>这两种完全不一样甚至有些矛盾的玩法让我时常在思考着，大脑里就像两个小人在扳手腕一样，这可能是我从小被灌输的&amp;quot;标准答案&amp;quot;的思维方式所致。其实，这个世界本来就没什么标准答案，或是说，一个题目本来就可以有若干个正确答案，而且这些&amp;quot;正确答案&amp;quot;还很矛盾。&lt;/p>
&lt;p>于是，在我把一些价值观和思考记录下来的同时，我自然又被很多人关注到了，还吸引很多不同的思路在其中交织讨论。而从另外一方面来说，这对我来说是一个很好地补充，无论别人骂我也好，教育我也罢，他们都对我有帮助，大大地丰富了我思考问题的角度。&lt;/p>
&lt;p>这些经历从质上改善了我的思考方式，让我思考技术问题的角度都随之有了一个比较大的转变。而这个转变让我有了更高的思维高度和更为开阔的视野。&lt;/p>
&lt;p>可能是因为我有一些&amp;quot;独特&amp;quot;的想法，而且经历比较丰富，基础也比较扎实，使得我对技术人的认识和理解会更为透彻和深入。所以，也有了一些小名气。来找我做咨询和帮助解决问题的人越来越多，而我也开始收费收得越来越贵了。这里需要注意的是，我完全是被动收费高的。&lt;/p>
&lt;p>因为父亲的身体原因，我没有办法全职，所以成了一个自由人。而也正因如此，我才得以有机会可以为更多公司解决技术问题。2015 年，有家公司的后端系统一推广就挂，性能有问题，请我去看。&lt;/p>
&lt;p>我花了两天时间跟他们的工程师一起简单处理了一下，直接在生产线上重构，性能翻了 10 倍。虽然这么做有点 low，但当时完全是为了救急。公司老板很高兴，觉得他投的几百万推广费用有救了，一下给了我 10 万元。我说不用这么多的，1 万元就好了，结果他说就是这么多。&lt;strong>我欣然接受了，当时心里有一种技术被尊重的感动&lt;/strong>。&lt;/p>
&lt;p>2016 年，某个公司需要做一个高并发方案，大概需要 2000 万 QPS，但是他们只能实现到 1200 万 QPS 左右。&lt;/p>
&lt;p>我花了两天时间做调研，分析性能原因，然后一天写了 700 多行代码。因为不想进入业务，所以我主要是优化了网络数据传输，让数据包尽量小，确保一个请求的响应在一个 MTU 内就传完。&lt;/p>
&lt;p>测试的时候，达到了 2500 万 QPS。于是老板给了我 20 万。&lt;/p>
&lt;p>这样的例子还有很多。上面的例子，我连钱都没谈就去做了，本来想着，也就最多 1 万元左右，没想到给我的酬劳大大超出了我的期望。&lt;/p>
&lt;p>这里，我想说的是，&lt;strong>并不是社会不尊重程序员，只要你能帮上大忙，就一定会赢得别人的尊重&lt;/strong>。&lt;/p>
&lt;p>所以，我和一些人开玩笑说，&lt;strong>我们可能都是在写一样的 for(int i=0; i&amp;lt;n; i++) 语句，但是，你写在那个地方一文不值，而我写在这个地方，这行代码就值 2000 元&lt;/strong>。不要误会，我只是想用这种&amp;quot;鲜明的对比方式&amp;quot;来加强我的观点。&lt;/p>
&lt;p>上面就是我这 20 年来的经历。相信这类经历你也有过，或者你正在经历中，欢迎你也分享一下自己的经历和心得。&lt;/p>
&lt;p>那么，怎样能让自己的技术被尊重？如何通过技术和技能赚钱？下一篇文章中，我将对此做一些总结，希望对你有帮助。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/fc/e9/fcc761001867c60f526665e237f831e9.jpg" alt="">&lt;/p></description></item><item><title>极客专栏: 01丨预习篇·小鲸鱼大事记（一）：初出茅庐</title><link>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90-kubernetes/01%E4%B8%A8%E9%A2%84%E4%B9%A0%E7%AF%87%E5%B0%8F%E9%B2%B8%E9%B1%BC%E5%A4%A7%E4%BA%8B%E8%AE%B0%E4%B8%80%E5%88%9D%E5%87%BA%E8%8C%85%E5%BA%90/</link><pubDate>Fri, 27 May 2022 00:00:00 +0000</pubDate><guid>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90-kubernetes/01%E4%B8%A8%E9%A2%84%E4%B9%A0%E7%AF%87%E5%B0%8F%E9%B2%B8%E9%B1%BC%E5%A4%A7%E4%BA%8B%E8%AE%B0%E4%B8%80%E5%88%9D%E5%87%BA%E8%8C%85%E5%BA%90/</guid><description>
&lt;p>你好，我是张磊。我今天分享的主题是：小鲸鱼大事记之初出茅庐。&lt;/p>
&lt;p>&lt;strong>如果我问你，现今最热门的服务器端技术是什么？想必你不假思索就能回答上来：当然是容器！可是，如果现在不是 2018 年而是 2013 年，你的回答还能这么斩钉截铁么？&lt;/strong>&lt;/p>
&lt;p>现在就让我们把时间拨回到五年前去看看吧。&lt;/p>
&lt;p>2013 年的后端技术领域，已经太久没有出现过令人兴奋的东西了。曾经被人们寄予厚望的云计算技术，也已经从当初虚无缥缈的概念蜕变成了实实在在的虚拟机和账单。而相比于的如日中天 AWS 和盛极一时的 OpenStack，以 Cloud Foundry 为代表的开源 PaaS 项目，却成为了当时云计算技术中的一股清流。&lt;/p>
&lt;p>这时，Cloud Foundry 项目已经基本度过了最艰难的概念普及和用户教育阶段，吸引了包括百度、京东、华为、IBM 等一大批国内外技术厂商，开启了以开源 PaaS 为核心构建平台层服务能力的变革。如果你有机会问问当时的云计算从业者们，他们十有八九都会告诉你：PaaS 的时代就要来了！&lt;/p>
&lt;p>这个说法其实一点儿没错，如果不是后来一个叫 Docker 的开源项目突然冒出来的话。&lt;/p>
&lt;p>事实上，当时还名叫 dotCloud 的 Docker 公司，也是这股 PaaS 热潮中的一份子。只不过相比于 Heroku、Pivotal、Red Hat 等 PaaS 弄潮儿们，dotCloud 公司实在是太微不足道了，而它的主打产品由于跟主流的 Cloud Foundry 社区脱节，长期以来也无人问津。眼看就要被如火如荼的 PaaS 风潮抛弃，dotCloud 公司却做出了这样一个决定：开源自己的容器项目 Docker。&lt;/p>
&lt;p>显然，这个决定在当时根本没人在乎。&lt;/p>
&lt;p>&amp;ldquo;容器&amp;quot;这个概念从来就不是什么新鲜的东西，也不是 Docker 公司发明的。即使在当时最热门的 PaaS 项目 Cloud Foundry 中，容器也只是其最底层、最没人关注的那一部分。说到这里，我正好以当时的事实标准 Cloud Foundry 为例，来解说一下 PaaS 技术。&lt;/p>
&lt;p>&lt;strong>PaaS 项目被大家接纳的一个主要原因，就是它提供了一种名叫&amp;quot;应用托管&amp;quot;的能力。&lt;/strong> 在当时，虚拟机和云计算已经是比较普遍的技术和服务了，那时主流用户的普遍用法，就是租一批 AWS 或者 OpenStack 的虚拟机，然后像以前管理物理服务器那样，用脚本或者手工的方式在这些机器上部署应用。&lt;/p>
&lt;p>当然，这个部署过程难免会碰到云端虚拟机和本地环境不一致的问题，所以当时的云计算服务，比的就是谁能更好地模拟本地服务器环境，能带来更好的&amp;quot;上云&amp;quot;体验。而 PaaS 开源项目的出现，就是当时解决这个问题的一个最佳方案。&lt;/p>
&lt;p>举个例子，虚拟机创建好之后，运维人员只需要在这些机器上部署一个 Cloud Foundry 项目，然后开发者只要执行一条命令就能把本地的应用部署到云上，这条命令就是：&lt;/p>
&lt;pre>&lt;code>$ cf push &amp;quot; 我的应用 &amp;quot;
&lt;/code>&lt;/pre>
&lt;p>是不是很神奇？&lt;/p>
&lt;p>事实上，&lt;strong>像 Cloud Foundry 这样的 PaaS 项目，最核心的组件就是一套应用的打包和分发机制。&lt;/strong> Cloud Foundry 为每种主流编程语言都定义了一种打包格式，而&amp;quot;cf push&amp;quot;的作用，基本上等同于用户把应用的可执行文件和启动脚本打进一个压缩包内，上传到云上 Cloud Foundry 的存储中。接着，Cloud Foundry 会通过调度器选择一个可以运行这个应用的虚拟机，然后通知这个机器上的 Agent 把应用压缩包下载下来启动。&lt;/p>
&lt;p>这时候关键来了，由于需要在一个虚拟机上启动很多个来自不同用户的应用，Cloud Foundry 会调用操作系统的 Cgroups 和 Namespace 机制为每一个应用单独创建一个称作&amp;quot;沙盒&amp;quot;的隔离环境，然后在&amp;quot;沙盒&amp;quot;中启动这些应用进程。这样，就实现了把多个用户的应用互不干涉地在虚拟机里批量地、自动地运行起来的目的。&lt;/p>
&lt;p>&lt;strong>这，正是 PaaS 项目最核心的能力。&lt;/strong> 而这些 Cloud Foundry 用来运行应用的隔离环境，或者说&amp;quot;沙盒&amp;rdquo;，就是所谓的&amp;quot;容器&amp;quot;。&lt;/p>
&lt;p>而 Docker 项目，实际上跟 Cloud Foundry 的容器并没有太大不同，所以在它发布后不久，Cloud Foundry 的首席产品经理 James Bayer 就在社区里做了一次详细对比，告诉用户 Docker 实际上只是一个同样使用 Cgroups 和 Namespace 实现的&amp;quot;沙盒&amp;quot;而已，没有什么特别的黑科技，也不需要特别关注。&lt;/p>
&lt;p>然而，短短几个月，Docker 项目就迅速崛起了。它的崛起速度如此之快，以至于 Cloud Foundry 以及所有的 PaaS 社区还没来得及成为它的竞争对手，就直接被宣告出局了。那时候，一位多年的 PaaS 从业者曾经如此感慨道：这简直就是一场&amp;quot;降维打击&amp;quot;啊。&lt;/p>
&lt;p>难道这一次，连闯荡多年的&amp;quot;老江湖&amp;quot;James Bayer 也看走眼了么？&lt;/p>
&lt;p>并没有。&lt;/p>
&lt;p>事实上，Docker 项目确实与 Cloud Foundry 的容器在大部分功能和实现原理上都是一样的，可偏偏就是这剩下的一小部分不一样的功能，成了 Docker 项目接下来&amp;quot;呼风唤雨&amp;quot;的不二法宝。&lt;/p>
&lt;p>&lt;strong>这个功能，就是 Docker 镜像。&lt;/strong>&lt;/p>
&lt;p>恐怕连 Docker 项目的作者 Solomon Hykes 自己当时都没想到，这个小小的创新，在短短几年内就如此迅速地改变了整个云计算领域的发展历程。&lt;/p>
&lt;p>我前面已经介绍过，PaaS 之所以能够帮助用户大规模部署应用到集群里，是因为它提供了一套应用打包的功能。可偏偏就是这个打包功能，却成了 PaaS 日后不断遭到用户诟病的一个&amp;quot;软肋&amp;quot;。&lt;/p>
&lt;p>出现这个问题的根本原因是，一旦用上了 PaaS，用户就必须为每种语言、每种框架，甚至每个版本的应用维护一个打好的包。这个打包过程，没有任何章法可循，更麻烦的是，明明在本地运行得好好的应用，却需要做很多修改和配置工作才能在 PaaS 里运行起来。而这些修改和配置，并没有什么经验可以借鉴，基本上得靠不断试错，直到你摸清楚了本地应用和远端 PaaS 匹配的&amp;quot;脾气&amp;quot;才能够搞定。&lt;/p>
&lt;p>最后结局就是，&amp;ldquo;cf push&amp;quot;确实是能一键部署了，但是为了实现这个一键部署，用户为每个应用打包的工作可谓一波三折，费尽心机。&lt;/p>
&lt;p>而&lt;strong>Docker 镜像解决的，恰恰就是打包这个根本性的问题。&lt;/strong> 所谓 Docker 镜像，其实就是一个压缩包。但是这个压缩包里的内容，比 PaaS 的应用可执行文件 + 启停脚本的组合就要丰富多了。实际上，大多数 Docker 镜像是直接由一个完整操作系统的所有文件和目录构成的，所以这个压缩包里的内容跟你本地开发和测试环境用的操作系统是完全一样的。&lt;/p>
&lt;p>这就有意思了：假设你的应用在本地运行时，能看见的环境是 CentOS 7.2 操作系统的所有文件和目录，那么只要用 CentOS 7.2 的 ISO 做一个压缩包，再把你的应用可执行文件也压缩进去，那么无论在哪里解压这个压缩包，都可以得到与你本地测试时一样的环境。当然，你的应用也在里面！&lt;/p>
&lt;p>这就是 Docker 镜像最厉害的地方：只要有这个压缩包在手，你就可以使用某种技术创建一个&amp;quot;沙盒&amp;rdquo;，在&amp;quot;沙盒&amp;quot;中解压这个压缩包，然后就可以运行你的程序了。&lt;/p>
&lt;p>更重要的是，这个压缩包包含了完整的操作系统文件和目录，也就是包含了这个应用运行所需要的所有依赖，所以你可以先用这个压缩包在本地进行开发和测试，完成之后，再把这个压缩包上传到云端运行。&lt;/p>
&lt;p>在这个过程中，你完全不需要进行任何配置或者修改，因为这个压缩包赋予了你一种极其宝贵的能力：本地环境和云端环境的高度一致！&lt;/p>
&lt;p>这，&lt;strong>正是 Docker 镜像的精髓。&lt;/strong>&lt;/p>
&lt;p>那么，有了 Docker 镜像这个利器，PaaS 里最核心的打包系统一下子就没了用武之地，最让用户抓狂的打包过程也随之消失了。相比之下，在当今的互联网里，Docker 镜像需要的操作系统文件和目录，可谓唾手可得。&lt;/p>
&lt;p>所以，你只需要提供一个下载好的操作系统文件与目录，然后使用它制作一个压缩包即可，这个命令就是：&lt;/p>
&lt;pre>&lt;code>$ docker build &amp;quot; 我的镜像 &amp;quot;
&lt;/code>&lt;/pre>
&lt;p>一旦镜像制作完成，用户就可以让 Docker 创建一个&amp;quot;沙盒&amp;quot;来解压这个镜像，然后在&amp;quot;沙盒&amp;quot;中运行自己的应用，这个命令就是：&lt;/p>
&lt;pre>&lt;code>$ docker run &amp;quot; 我的镜像 &amp;quot;
&lt;/code>&lt;/pre>
&lt;p>当然，docker run 创建的&amp;quot;沙盒&amp;quot;，也是使用 Cgroups 和 Namespace 机制创建出来的隔离环境。我会在后面的文章中，详细介绍这个机制的实现原理。&lt;/p>
&lt;p>所以，&lt;strong>Docker 项目给 PaaS 世界带来的&amp;quot;降维打击&amp;quot;，其实是提供了一种非常便利的打包机制。这种机制直接打包了应用运行所需要的整个操作系统，从而保证了本地环境和云端环境的高度一致，避免了用户通过&amp;quot;试错&amp;quot;来匹配两种不同运行环境之间差异的痛苦过程。&lt;/strong>&lt;/p>
&lt;p>而对于开发者们来说，在终于体验到了生产力解放所带来的痛快之后，他们自然选择了用脚投票，直接宣告了 PaaS 时代的结束。&lt;/p>
&lt;p>不过，Docker 项目固然解决了应用打包的难题，但正如前面所介绍的那样，它并不能代替 PaaS 完成大规模部署应用的职责。&lt;/p>
&lt;p>遗憾的是，考虑到 Docker 公司是一个与自己有潜在竞争关系的商业实体，再加上对 Docker 项目普及程度的错误判断，Cloud Foundry 项目并没有第一时间使用 Docker 作为自己的核心依赖，去替换自己那套饱受诟病的打包流程。&lt;/p>
&lt;p>反倒是一些机敏的创业公司，纷纷在第一时间推出了 Docker 容器集群管理的开源项目（比如 Deis 和 Flynn），它们一般称自己为 CaaS，即 Container-as-a-Service，用来跟&amp;quot;过时&amp;quot;的 PaaS 们划清界限。&lt;/p>
&lt;p>而在 2014 年底的 DockerCon 上，Docker 公司雄心勃勃地对外发布了自家研发的&amp;quot;Docker 原生&amp;quot;容器集群管理项目 Swarm，不仅将这波&amp;quot;CaaS&amp;quot;热推向了一个前所未有的高潮，更是寄托了整个 Docker 公司重新定义 PaaS 的宏伟愿望。&lt;/p>
&lt;p>在 2014 年的这段巅峰岁月里，Docker 公司离自己的理想真的只有一步之遥。&lt;/p>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>2013~2014 年，以 Cloud Foundry 为代表的 PaaS 项目，逐渐完成了教育用户和开拓市场的艰巨任务，也正是在这个将概念逐渐落地的过程中，应用&amp;quot;打包&amp;quot;困难这个问题，成了整个后端技术圈子的一块心病。&lt;/p>
&lt;p>Docker 项目的出现，则为这个根本性的问题提供了一个近乎完美的解决方案。这正是 Docker 项目刚刚开源不久，就能够带领一家原本默默无闻的 PaaS 创业公司脱颖而出，然后迅速占领了所有云计算领域头条的技术原因。&lt;/p>
&lt;p>而在成为了基础设施领域近十年难得一见的技术明星之后，dotCloud 公司则在 2013 年底大胆改名为 Docker 公司。不过，这个在当时就颇具争议的改名举动，也成为了日后容器技术圈风云变幻的一个关键伏笔。&lt;/p>
&lt;h2 id="思考题">思考题&lt;/h2>
&lt;p>你是否曾经研发过类似 PaaS 的项目？你碰到过应用打包的问题吗，又是如何解决的呢？&lt;/p>
&lt;p>感谢收听，欢迎你给我留言，也欢迎分享给更多的朋友一起阅读。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/47/55/47a6f3bf6b92d58512d5a2ed0a556f55.jpg" alt="">&lt;/p></description></item><item><title>极客专栏: 02丨“老周，我想知道”丨律师就在你身边（二）</title><link>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E7%99%BD%E8%AF%9D%E6%B3%95%E5%BE%8B/02%E4%B8%A8%E8%80%81%E5%91%A8%E6%88%91%E6%83%B3%E7%9F%A5%E9%81%93%E4%B8%A8%E5%BE%8B%E5%B8%88%E5%B0%B1%E5%9C%A8%E4%BD%A0%E8%BA%AB%E8%BE%B9%E4%BA%8C/</link><pubDate>Tue, 07 Jun 2022 00:00:00 +0000</pubDate><guid>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E7%99%BD%E8%AF%9D%E6%B3%95%E5%BE%8B/02%E4%B8%A8%E8%80%81%E5%91%A8%E6%88%91%E6%83%B3%E7%9F%A5%E9%81%93%E4%B8%A8%E5%BE%8B%E5%B8%88%E5%B0%B1%E5%9C%A8%E4%BD%A0%E8%BA%AB%E8%BE%B9%E4%BA%8C/</guid><description>
&lt;p>今天是我们&amp;quot;法律咨询&amp;quot;的第二期。我选取了专栏留言频次最高的十一个问题，并给出了相应的解答。接下来我们来看这些问答。&lt;/p>
&lt;p>&lt;strong>第一问：公司配备的电脑，上面能不能存我的个人数据呢？等到离职时，我是否可以删除电脑上的个人数据，像是照片这类？重装系统可以吗？&lt;/strong>&lt;/p>
&lt;p>老周答：如果公司没有特殊约定，在不影响工作的情况下，在公司配备的电脑上存储个人数据或照片，并没有什么问题，删除也是同样的道理。不过，想要重装系统的话，按照通常理解，需要经过你们公司的同意，并且要提前备份好重要数据。&lt;/p>
&lt;p>&lt;strong>第二问：下班时我忘了打卡，结果被公司算成了旷工，公司这样做是否违法呢？&lt;/strong>&lt;/p>
&lt;p>老周答：如果你能证明你确实上班了（比如照片、聊天记录等证据），只是忘记下班打卡了，那就不能算旷工。即使你的公司明确规定了，下班没打卡就算旷工，这在法律上也是不合理的规定，公司应该按照实际情况来执行。&lt;/p>
&lt;p>不过，记住一点，证明你确实上班，是你自己的责任，公司不需要为这个证据负责。&lt;/p>
&lt;p>&lt;strong>第三问：自己画画，自己开淘宝店来卖，算不算非法经营罪？&lt;/strong>&lt;/p>
&lt;p>老周答： 根据《电子商务法》第十条的规定，电子商务经营者应该依法办理市场主体登记。但是，下面两种行为不需要登记。&lt;/p>
&lt;ul>
&lt;li>个人销售自己生产的农副产品、家庭手工业产品。&lt;/li>
&lt;li>个人利用自己的技能，从事法律上规定的不用获得许可的便民劳务活动、零星小额交易活动。&lt;/li>
&lt;/ul>
&lt;p>因此，你这种行为不属于非法经营行为，更不构成非法经营罪。&lt;/p>
&lt;p>&lt;strong>第四问：实践中，往往是法不责众，三个人砸售楼处会被拘留，但是如果三百人砸售楼处呢？&lt;/strong>&lt;/p>
&lt;p>老周答：法不责众是一个社会上广为流传的谚语，但在法律规定中其实并不存在。法律面前人人平等，违法必究，才是基本法律原则。&lt;/p>
&lt;p>三人砸售楼处会被拘留，而三百人砸售楼处，至少领头人肯定会被拘留，其他的具体破坏者也同样会有惩罚。事实上，在群体事件中，个人很容易失去理智，失去主观判断，盲目跟风去做。但是，一旦行为过激或是直接造成重大损失、人身伤害，一样会受到法律的严惩。&lt;/p>
&lt;p>法不责众从来不是违法犯罪的保护伞，试图以此脱身，属于侥幸心理，现实结果往往会打脸。&lt;/p>
&lt;p>&lt;strong>第五问：公司给我交的社保，并有没有按实际工资的标准，以前的我并不知道这一点，所以合同里没写清楚也没在意，可是现在公司在裁员，裁员时我是不是可以要求公司给补上呢？&lt;/strong>&lt;/p>
&lt;p>老周答：缴纳社保应以实际工资为基数，这是法律的规定，不需要在合同里约定。即使合同里约定，按照低于实际工资的基数也是违法的，属于无效约定。&lt;/p>
&lt;p>一般来说，对于未缴部分，你可以要求公司进行补偿。另外，以前我也提到过的，2019 年 1 月 1 日起，社保将由税务机关统一征收，因为政策发生变化，具体要怎么处理还有待观察。&lt;/p>
&lt;p>&lt;strong>第六问：我和几个同事在一家公司工作 10 年以上了，一直没合同没社保。去年，老板把我们挪到另一家公司来管理，老板变成了新公司的股东，我们的工作内容也没有变化。那么，现在我们可以要求签无固定期限劳动合同了吗？如果老板不愿意签，我们又该怎么办呢？&lt;/strong>&lt;/p>
&lt;p>老周答：在公司连续工作 10 年以上，如果员工提出签订无固定期限劳动合同，公司应当同意并签订。&lt;/p>
&lt;p>你在公司工作了 10 年以上，虽然没有签订合同，但根据法律规定，用人单位自用工之日起满一年，还没有和劳动者签订书面劳动合同的话，就可以看作法律上的无固定期限劳动合同关系。&lt;/p>
&lt;p>所以，你们本身已经是无固定期限劳动合同关系。不过，老板给你们换公司的行为，还是要提高警惕。为了防止老板不认账，你最好尽早通过劳动合同，把以前的工作年限、工作关系都明确下来。&lt;/p>
&lt;p>&lt;strong>第七问：农民工没有签劳动合同，也没有交工伤保险，一旦发生工伤，应该怎么要求赔偿呢？&lt;/strong>&lt;/p>
&lt;p>老周答：工伤保险属于用人单位的法定义务，公司必须为建立劳动关系的员工进行缴纳。如果没有交保险的情况下，发生工伤事故，责任自然应该由公司承担。&lt;/p>
&lt;p>&lt;strong>第八问：代购算不算非法经营罪？&lt;/strong>&lt;/p>
&lt;p>老周答：这个问题，需要具体情况具体分析，不能一概而论。&lt;/p>
&lt;p>比如，你帮亲朋好友代购一些日常用品，不以营利为目的，也就不存在非法经营的问题，只涉及需不需要纳税的问题。&lt;/p>
&lt;p>但是，如果你代购的目的，本身就是为了营利，那就需要格外注意，也是需要依法报税的，否则就属于违法行为。而一旦达到一定的数额，就可能涉嫌走私普通货物罪，或者非法经营罪。&lt;/p>
&lt;p>&lt;strong>第九问：公司在 A 城，我的个人所得税也在 A 城缴纳。不过我的常住城市是 B 城，五险一金也被公司委托给了 B 城的人力资源机构代缴。另外，在入职时，公司跟我签了两份劳动合同，一个是本公司的，一个是人力资源机构的。这种情况下，如果我申请劳动仲裁，或者去法院起诉，应该去 A 城还是 B 城呢？&lt;/strong>&lt;/p>
&lt;p>老周答：公司这种行为其实是违法的，社保必须在本公司办理。你这种情况，本身应该在 A 城公司办理并缴纳社保。在人力资源机构办理的社保，不符合法律规定，属于虚假用工。&lt;/p>
&lt;p>所以，回到最重要的问题，如果想要申请劳动仲裁，或者起诉，自然应该在 A 城。&lt;/p>
&lt;p>&lt;strong>第十问：公司逼我签降薪协议，不签的话就要辞退我。我目前还不想辞职，如果先签下降薪协议的话，以后还能以公司这个行为为由，申请离职吗？如果可以的话，能拿到赔偿吗？&lt;/strong>&lt;/p>
&lt;p>老周答：公司这种行为显然不符合法律规定，属于违法辞退。这种所谓的降薪协议，通常也会约定很多对员工不利的内容。&lt;/p>
&lt;p>所以，如果你真的签了降薪协议，再想推翻就难了。以此为由，基本上也拿不到补偿。&lt;/p>
&lt;p>&lt;strong>第十一问：公司最近在讨论，给核心员工分一部分股权的事，形式是赠送股权。那什么是赠送股权呢？与公司签订股权协议，要注意什么呢？&lt;/strong>&lt;/p>
&lt;p>老周答：赠与股权，意思就是不需要支付对价，免费获得，通常是对公司有核心价值员工的一种激励措施。赠与股权也是股权转让的一种方式，需要公司其他股东同意。&lt;/p>
&lt;p>如果签订协议，一定要记得看赠与股权的附加条件，有很多赠与，名义上是赠与，其实加了很多的限制性条款，也规定了行权的具体条件，这一点需要特别注意。&lt;/p>
&lt;p>今天主要回答这十一个问题。那么，你还有什么疑惑想问我，或者有什么心得想要和我分享的吗？欢迎留言告诉我，也欢迎点击右下方的&amp;quot;请朋友读&amp;quot;，把今天所学分享给你的家人、朋友。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/cc/ff/cc229a6309f93017826a07452f3250ff.jpg" alt="">&lt;/p></description></item><item><title>极客专栏: 02丨为HTTP穿上盔甲：HTTPS</title><link>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E5%85%A8%E6%A0%88%E5%B7%A5%E7%A8%8B%E5%B8%88%E4%BF%AE%E7%82%BC%E6%8C%87%E5%8D%97/02%E4%B8%A8%E4%B8%BAhttp%E7%A9%BF%E4%B8%8A%E7%9B%94%E7%94%B2https/</link><pubDate>Tue, 07 Jun 2022 00:00:00 +0000</pubDate><guid>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E5%85%A8%E6%A0%88%E5%B7%A5%E7%A8%8B%E5%B8%88%E4%BF%AE%E7%82%BC%E6%8C%87%E5%8D%97/02%E4%B8%A8%E4%B8%BAhttp%E7%A9%BF%E4%B8%8A%E7%9B%94%E7%94%B2https/</guid><description>
&lt;p>你好，我是四火。&lt;/p>
&lt;p>在上一讲中，我介绍了互联网最重要的 HTTP 协议。可是随着互联网的发展，你会发现 HTTP 越来越无法满足复杂的需求，比如数据加密传输的安全性需求，再比如服务器消息即时推送的交互模式的需求，而这些不适性是由 HTTP 的基本特性所造成的。&lt;/p>
&lt;p>因此，我们需要在传统 HTTP 领域以外开疆拓土，这就包括要引入其它的网络协议，或增强、或填补 HTTP 协议所不擅长的空白领域，这也是今天这一讲和下一讲的核心内容。今天我们重点学习 SSL/TLS ，看看它是如何让 HTTP 传输变得安全可靠的。&lt;/p>
&lt;h2 id="httpssltls-和-https">HTTP，SSL/TLS 和 HTTPS&lt;/h2>
&lt;p>在一开始的时候，HTTP 的设计者并没有把专门的加密安全传输放进协议设计里面。因此单独使用 HTTP 进行明文的数据传输，一定存在着许多的安全问题。比方说，现在有一份数据需要使用 HTTP 协议从客户端 A 发送到服务端 B，而第三方 C 尝试来做点坏事，于是就可能产生如下四大类安全问题：&lt;/p>
&lt;ul>
&lt;li>Interception：拦截。传输的消息可以被中间人 C 截获，并泄露数据。&lt;/li>
&lt;li>Spoofing：伪装。A 和 B 都可能被 C 冒名顶替，因此消息传输变成了 C 发送到 B，或者 A 发送到 C。&lt;/li>
&lt;li>Falsification：篡改。C 改写了传输的消息，因此 B 收到了一条被篡改的消息而不知情。&lt;/li>
&lt;li>Repudiation：否认。这一类没有 C 什么事，而是由于 A 或 B 不安好心。A 把消息成功发送了，但之后 A 否认这件事发生过；或者 B 其实收到了消息，但是否认他收到过。&lt;/li>
&lt;/ul>
&lt;p>但是，与其重新设计一套安全传输方案，倒不如发挥一点拿来主义的精神，把已有的和成熟的安全协议直接拿过来套用，最好它位于呈现层（Presentation Layer），因此正好加塞在 HTTP 所在的应用层（Application Layer）下面，&lt;strong>这样这个过程对于 HTTP 本身透明，也不影响原本 HTTP 以下的协议（例如 TCP）&lt;/strong>。&lt;/p>
&lt;p>这个协议就是 SSL/TLS，它使得上面四大问题中，和传输本身密切相关的前三大问题都可以得到解决（第四个问题还需要引入数字签名来解决）。于是，HTTP 摇身一变成了 HTTPS：&lt;/p>
&lt;blockquote>
&lt;p>HTTP + SSL/TLS = HTTPS&lt;/p>
&lt;/blockquote>
&lt;p>这里涉及到的两个安全协议，SSL 和 TLS，下面简要说明下二者关系。&lt;/p>
&lt;p>SSL 指的是 Secure Socket Layer，而 TLS 指的是 Transport Layer Security，事实上，一开始只有 SSL，但是在 3.0 版本之后，SSL 被标准化并通过 &lt;a href="https://tools.ietf.org/html/rfc2246">RFC 2246&lt;/a> 以 SSL 为基础建立了 TLS 的第一个版本，因此可以简单地认为 SSL 和 TLS 是具备父子衍生关系的同一类安全协议。&lt;/p>
&lt;h2 id="动手捕获-tls-报文">动手捕获 TLS 报文&lt;/h2>
&lt;p>介绍了最基本的概念，我们再来看看 HTTPS 是怎样安全工作，让客户端和服务端相互信任的， TLS 连接又是怎样建立起来的。还记得上一讲的选修课堂吗？我们学了怎样抓包。今天我们就能让所学派上用场！自己动手，我们抓 TLS 连接握手的报文来分析。&lt;/p>
&lt;p>命令行执行抓包命令，指明要抓 &lt;a href="https://www.google.com">https://www.google.com&lt;/a> 的包（当然，你也可以使用其他 HTTPS 网站地址），注意 HTTPS 的默认端口是 443（-i 指定的 interface 可能因为不同的操作系统有所区别，在我的 Mac 上是 en0）：&lt;/p>
&lt;pre>&lt;code>sudo tcpdump -i en0 -v 'host www.google.com and port 443' -w https.cap
&lt;/code>&lt;/pre>
&lt;p>再新建一个命令行窗口，使用 curl 命令来访问 Google 主页：&lt;/p>
&lt;pre>&lt;code>curl https://www.google.com
&lt;/code>&lt;/pre>
&lt;p>于是在看到类似如下抓包后 CTRL + C 停止：&lt;/p>
&lt;pre>&lt;code>tcpdump: listening on en0, link-type EN10MB (Ethernet), capture size 262144 bytes
^C49 packets captured
719 packets received by filter
0 packets dropped by kernel
&lt;/code>&lt;/pre>
&lt;p>接着使用 Wireshark 打开刚才抓的 https.cap，在 filter 中输入 tls，得到如下请求和响应报文：&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/6a/3b/6a0269e1c2cdc7c768fc11c8bcc20e3b.jpg" alt="">&lt;/p>
&lt;p>可以看到，这里有五个重要的握手消息，在它们之后的所有消息都是用于承载实际数据的&amp;quot;Application Data&amp;quot;了。握手的过程略复杂，接下来我会尽可能用通俗的语言把最主要的流程讲清楚。&lt;/p>
&lt;h2 id="对称性和非对称性加密">对称性和非对称性加密&lt;/h2>
&lt;p>这里我先介绍两个概念，&amp;ldquo;对称性加密&amp;quot;和&amp;quot;非对称性加密&amp;rdquo;，这是学习后面内容的重要基础。&lt;/p>
&lt;p>对称性加密（Symmetric Cryptography），指的是加密和解密使用相同的密钥。这种方式相对简单，加密解密速度快，但是由于加密和解密需要使用相同的密钥，如何安全地传递密钥，往往成为一个难题。&lt;/p>
&lt;p>非对称性加密（Asymmetric Cryptography），指的是数据加密和解密需要使用不同的密钥。通常一个被称为公钥（Public Key），另一个被称为私钥（Private Key），二者一般同时生成，但是&lt;strong>公钥往往可以公开和传播，而私钥不能。经过公钥加密的数据，需要用私钥才能解密&lt;/strong>；反之亦然。这种方法较为复杂，且性能较差，好处就是由于加密和解密的密钥具有相对独立性，公钥可以放心地传播出去，不用担心安全性问题。&lt;/p>
&lt;blockquote>
&lt;p>原始数据 + 公钥 → 加密数据&lt;br>
加密数据 + 私钥 → 原始数据&lt;/p>
&lt;/blockquote>
&lt;h2 id="tls-连接建立原理">TLS 连接建立原理&lt;/h2>
&lt;p>有了上述基础，下面我们就可以结合图示，看看整个连接建立的握手过程了。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/94/63/941574c15cea2cc2d66c66ab492fea63.jpeg" alt="">&lt;/p>
&lt;p>&lt;strong>Step 1: Client Hello.&lt;/strong> 客户端很有礼貌，先向服务端打了个招呼，并携带以下信息：&lt;/p>
&lt;ul>
&lt;li>客户端产生的随机数 A；&lt;/li>
&lt;li>客户端支持的加密方法列表。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Step 2: Server Hello.&lt;/strong> 服务端也很有礼貌，向客户端回了个招呼：&lt;/p>
&lt;ul>
&lt;li>服务端产生的随机数 B；&lt;/li>
&lt;li>服务端根据客户端的支持情况确定出的加密方法组合（Cipher Suite）。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Step 3: Certificate, Server Key Exchange, Server Hello Done.&lt;/strong> 服务端在招呼之后也紧跟着告知：&lt;/p>
&lt;ul>
&lt;li>Certificate，证书信息，证书包含了服务端生成的公钥。这个公钥有什么用呢？别急，后面会说到。&lt;/li>
&lt;/ul>
&lt;p>客户端收到消息后，验证确认证书真实有效，那么这个证书里面的公钥也就是可信的了。&lt;/p>
&lt;p>接着客户端再生成一个随机数 C（Pre-master Secret），于是现在共有随机数 A、B 和 C，根据约好的加密方法组合，三者可生成新的密钥 X（Master Secret），而由 X 可继续生成真正用于后续数据进行加密和解密的对称密钥。因为它是在本次 TLS 会话中生成的，所以也被称为会话密钥（Session Secret）。简言之：&lt;/p>
&lt;blockquote>
&lt;p>客户端随机数 A + 服务端随机数 B + 客户端 Pre-master Secret C → 会话密钥&lt;/p>
&lt;/blockquote>
&lt;p>需要注意的是，实际这个 Pre-master Secret 的生成方法不是固定的，而会根据加密的具体算法不同而不同：&lt;/p>
&lt;ul>
&lt;li>上述我介绍的是传统 RSA 方式，即 Pre-master Secret 由客户端独立生成，加密后再通过 Client Key Exchange 发回服务端。&lt;/li>
&lt;li>还有一种是 &lt;a href="https://zh.wikipedia.org/wiki/%E6%A9%A2%E5%9C%93%E6%9B%B2%E7%B7%9A%E8%BF%AA%E8%8F%B2-%E8%B5%AB%E7%88%BE%E6%9B%BC%E9%87%91%E9%91%B0%E4%BA%A4%E6%8F%9B">ECDHE&lt;/a> 方式，这种方式下无论在客户端还是服务端，Pre-master Secret 需要通过 Client Key Exchange 和 Server Key Exchange 两者承载的参数联合生成。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Step 4: Client Key Exchange, Change Cipher Spec, Encrypted Handshake Message.&lt;/strong> 接着客户端告诉服务端：&lt;/p>
&lt;ul>
&lt;li>Client Key Exchange，本质上它就是上面说的这个 C，但使用了服务端通过证书发来的公钥加密；&lt;/li>
&lt;li>Change Cipher Spec，客户端同意正式启用约好的加密方法和密钥了，后面的数据传输全部都使用密钥 X 来加密；&lt;/li>
&lt;li>Encrypted Handshake Message，快速验证：这是客户端对于整个对话进行摘要并加密得到的串，如果经过服务端解密，和原串相等，就证明整个握手过程是成功的。&lt;/li>
&lt;/ul>
&lt;p>服务端收到消息后，用自己私钥解密上面的 Client Key Exchange，得到了 C，这样它和客户端一样，也得到了 A、B 和 C，继而到 X，以及最终的会话密钥。&lt;/p>
&lt;p>于是，客户端和服务端都得到了能够加密解密传输数据的对称密钥&amp;mdash;&amp;mdash;会话密钥。&lt;/p>
&lt;p>因此，我们可以看到：&lt;strong>TLS 是通过非对称加密技术来保证握手过程中的可靠性（公钥加密，私钥解密），再通过对称加密技术来保证数据传输过程中的可靠性的&lt;/strong>。&lt;/p>
&lt;p>这种通过较严格、较复杂的方式建立起消息交换渠道，再通过相对简单且性能更高的方式来实际完成主体的数据传输，并且前者具有长效性（即公钥和私钥相对稳定），后者具有一过性（密钥是临时生成的），这样的模式，我们还将在全栈的知识体系中，继续见到。&lt;/p>
&lt;p>&lt;strong>Step 5: Change Cipher Spec, Encrypted Handshake Message.&lt;/strong> 服务端最后也告知客户端：&lt;/p>
&lt;ul>
&lt;li>Change Cipher Spec，服务端也同意要正式启用约好的加密方法和密钥，后面的数据传输全部都使用 X 来加密。&lt;/li>
&lt;li>Encrypted Handshake Message，快速验证：这是服务端对于整个对话进行摘要并加密得到的串，如果经过客户端解密，和原串相等，就证明整个握手过程是成功的。&lt;/li>
&lt;/ul>
&lt;h2 id="总结思考">总结思考&lt;/h2>
&lt;p>今天我们了解了关于数据传输的四大类安全问题，了解了 HTTPS 和 SSL/TLS 的概念和它们之间的关系，还通过自己动手抓包的方式，详细学习了 TLS 连接建立的步骤。&lt;/p>
&lt;p>TLS 连接的步骤是今天的重点，也是比较难理解的部分，希望你能牢牢地掌握它。现在就来检验一下今天的学习成果吧！请你思考这样两个问题：&lt;/p>
&lt;ul>
&lt;li>有位程序员朋友注意到，自己在使用在线支付功能时，网站访问是使用 HTTPS 加密的，因此他觉得，支付的过程中是不可能出现安全问题的，你觉得这种想法对吗？&lt;/li>
&lt;li>在介绍 TLS/SSL 连接建立的过程当中，我提到了，握手过程是使用非对称加密实现的，而真正后续的数据传输部分却是由对称加密实现的。为什么要这么麻烦，全部都使用对称或非对称加密一种不好吗？&lt;/li>
&lt;/ul>
&lt;p>你能回答上面的问题吗？如果可以，我相信你已经理解了 HTTPS 安全机制建立的原理。&lt;/p>
&lt;h2 id="选修课堂证书有效验证的原理">选修课堂：证书有效验证的原理&lt;/h2>
&lt;p>在讲解&amp;quot;握手过程&amp;quot;的 step 3 时，我提到了客户端在收到服务端发送过来的证书时，需要校验证书的有效性。这个过程其实也是至关重要的，因为只有确认了证书的有效性，客户端才能放心地使用其中的公钥。如果你对它的理解比较模糊，那就一定要看看今天的选修课堂了。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/2e/a4/2e5095cb129d58b5bfa325c5e0d9b9a4.jpg" alt="">&lt;/p>
&lt;p>这就是我们抓包中，服务器发来的证书部分的截图。我们可以看到，这不是单个证书，而是一个证书链，包含了两个证书，每个证书都包含版本、发布机构、有效期、数字签名等基本内容，以及一个公钥。实际上，这两个服务端传回来的证书，和浏览器内置的根证书联合起来，组成了一个单向、完整的证书链：&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/1f/29/1f8d1f510e83084b2161d8e07b43b629.jpeg" alt="">&lt;/p>
&lt;p>上图中的第三行，就是携带着服务器公钥的证书，它是从证书发布机构（CA, Certificate Authority）申请得来的，也就是图中第二行的 GTS CA 1O1。证书在申请的时候，我们提到的服务器公钥就已经是该证书的一部分了，因此我们才说，如果证书是有效的，那么它携带的公钥就是有效的。&lt;/p>
&lt;p>在当时申请的时候，&lt;strong>证书发布机构对证书做摘要生成指纹，并使用它自己的私钥为该指纹加密，生成数字签名（Digital Signature），而这个数字签名也随证书一起发布&lt;/strong>。这个发布机构的私钥是它内部自己管理的，不会外泄。&lt;/p>
&lt;blockquote>
&lt;p>指纹 + 私钥 → 数字签名&lt;/p>
&lt;/blockquote>
&lt;p>验证过程则正好是发布过程的反向，即在客户端要对这个被检测证书做两件事：&lt;/p>
&lt;ul>
&lt;li>对它用指定算法进行摘要，得到指纹 P1；&lt;/li>
&lt;li>使用证书发布机构的公钥对它的数字签名进行解密，得到指纹 P2。&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>数字签名 + 公钥 → 指纹&lt;/p>
&lt;/blockquote>
&lt;p>如果 P1 和 P2 一致，就说明证书未被篡改过，也说明这个服务端发来的证书是真实有效的，而不是仿冒的。&lt;/p>
&lt;p>好，问题来了，证书发布机构使用非对称性加密和数字签名保证了证书的有效性，那么谁来保证证书发布机构的有效性？&lt;/p>
&lt;p>答案就是它的上一级证书发布机构。&lt;/p>
&lt;p>CA 是分级管理的，每一级 CA 都根据上述同样的原理，由它的上一级 CA 来加密证书和生成数字签名，来保证其真实性，从而形成一个单向的信任链。同时，标志着最高级别 CA 的根证书数量非常少，且一般在浏览器或操作系统安装的时候就被预置在里面了，因此它们是被我们完全信任的，这就使得真实性的鉴别递归有了最终出口。也就是说，递归自下而上验证的过程，如果一直正确，直至抵达了顶端&amp;mdash;&amp;mdash;浏览器内置的根证书，就说明服务端送过来的证书是安全有效的。&lt;/p>
&lt;p>总结一下今天选修课堂的内容。证书有效性的验证，需要使用依赖于证书发布机构的公钥去解密被检测证书的数字签名，如果顺利解密，并且得到的指纹和被检测证书做摘要得到的指纹一致，就说明证书真实有效。&lt;/p>
&lt;h2 id="扩展阅读">扩展阅读&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://howhttps.works/">HOW HTTPS WORKS&lt;/a>：漫画版介绍 HTTPS 前前后后，很有趣。&lt;/li>
&lt;li>&lt;a href="http://www.moserware.com/2009/06/first-few-milliseconds-of-https.html">The First Few Milliseconds of an HTTPS Connection&lt;/a>：如果你想深究你抓到的 TLS 连接建立的包中每一段报文的意思，这篇文章是一个很好的参考。&lt;/li>
&lt;li>文中介绍了两种生成 Pre-master Secret 的方法，其中第二种的方法是 Diffie&amp;ndash;Hellman 密钥交换的变种，这里蕴含的数学原理很有意思，如果你感兴趣，请参阅&lt;a href="https://zh.wikipedia.org/wiki/%E8%BF%AA%E8%8F%B2-%E8%B5%AB%E7%88%BE%E6%9B%BC%E5%AF%86%E9%91%B0%E4%BA%A4%E6%8F%9B#%E6%8F%8F%E8%BF%B0">维基百科链接&lt;/a>。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/11/8b/1181246bbd51ce348d5729696d1dc28b.jpg" alt="unpreview">&lt;/p></description></item><item><title>极客专栏: 02丨大厦基石：无生有，有生万物</title><link>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E8%AE%B8%E5%BC%8F%E4%BC%9F%E7%9A%84%E6%9E%B6%E6%9E%84%E8%AF%BE/02%E4%B8%A8%E5%A4%A7%E5%8E%A6%E5%9F%BA%E7%9F%B3%E6%97%A0%E7%94%9F%E6%9C%89%E6%9C%89%E7%94%9F%E4%B8%87%E7%89%A9/</link><pubDate>Tue, 07 Jun 2022 00:00:00 +0000</pubDate><guid>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E8%AE%B8%E5%BC%8F%E4%BC%9F%E7%9A%84%E6%9E%B6%E6%9E%84%E8%AF%BE/02%E4%B8%A8%E5%A4%A7%E5%8E%A6%E5%9F%BA%E7%9F%B3%E6%97%A0%E7%94%9F%E6%9C%89%E6%9C%89%E7%94%9F%E4%B8%87%E7%89%A9/</guid><description>
&lt;p>你好，我是七牛云许式伟。&lt;/p>
&lt;p>在上一篇中，我们把&amp;quot;构建一个应用程序&amp;quot;类比成&amp;quot;构建一座大厦&amp;quot;，并从宏观全局的视角剖析了应用程序这座大厦的构成。今天，我们将更加近距离地去解剖这座大厦的地基：冯·诺依曼体系结构。&lt;/p>
&lt;h2 id="解剖架构的关键点是什么">解剖架构的关键点是什么？&lt;/h2>
&lt;p>在解剖之前，我想和你先谈谈&amp;quot;解剖学&amp;quot;：&lt;strong>我们应该如何去分析架构设计中涉及的每一个零部件。换一句话说，当我们设计或分析一个零部件时，我们会关心哪些问题。&lt;/strong>&lt;/p>
&lt;p>**第一个问题，是需求。**这个零部件的作用是什么？它能被用来做哪些事情？（某种意义上来说更重要的是）它不会被用来做哪些事情？&lt;/p>
&lt;p>你可能会说，呀，这个问题很简单，既然我设计了这个零部件，自然知道它是用来干嘛的。但实质上这里真正艰难的是&amp;quot;为什么&amp;quot;：为何这个零件被设计成用来干这些事情的，而不是多干一点事情，或者为什么不是少干某些事情？&lt;/p>
&lt;p>**第二个问题，是规格。**这个零部件接口是什么样的？它如何与其他零件连接在一起的？&lt;/p>
&lt;p>规格是零部件的连接需求的抽象。符合规格的零部件可以有非常多种可能的实现方案，但是，一旦规格中某个条件不能满足了，它就无法正常完成与其他零件的连接，以达到预期的需求目标。&lt;/p>
&lt;p>规格的约束条件会非常多样化，可能是外观（比如形状和颜色），可能是交互方式（比如用键盘、鼠标，或者语音和触摸屏），也可能是质量（比如硬度、耐热性等等）。&lt;/p>
&lt;p>那么，冯·诺依曼体系结构的需求和规格又是什么样的呢？&lt;/p>
&lt;h2 id="为解决一切的问题而生">为&amp;quot;解决一切的问题&amp;quot;而生&lt;/h2>
&lt;p>冯·诺依曼体系结构不但是应用程序这座大厦的地基，同时也是整个信息科技的地基。&lt;/p>
&lt;p>&lt;strong>当我们去审视整个信息科技时，仅把它形容为一座大厦显得如此不贴切，甚至你也不能用&amp;quot;一个城市&amp;quot;去形容它，事实上，它更像是一个无中生有的全新世界：在其中，有个体、有族群、有生态，还有喜怒哀乐。&lt;/strong>&lt;/p>
&lt;p>冯·诺依曼体系结构的迷人之处在于，从需求来说，它想解决一切问题。解决一切可以用&amp;quot;计算&amp;quot;来解决的问题。&lt;/p>
&lt;p>&amp;ldquo;计算&amp;quot;的边界在哪里？今天我们还没有人能够真正说得清。计算能不能解决&amp;quot;智能&amp;quot;的问题？通过计算能力，计算机是否终有一天可以获得和人类一样的智能？&lt;/p>
&lt;p>今天人工智能热潮的兴起，证明对于这个问题我们很乐观：计算终将解决智能的问题。尽管我们不能确定什么时候能够达到，但是让人欣慰的是，我们一直在进步 &amp;mdash;&amp;mdash; 如果人类智能无法完成进一步的进化，那么我们就一直一直在前进，最终无限逼近甚至超越人类智能。&lt;/p>
&lt;p>甚至有科幻小说家设想（例如在 Google 的&amp;quot;AlphaGo&amp;quot;大热后，霍炬和西乔创作的漫画&amp;quot;BetaCat&amp;rdquo;），计算机演进出超过人类的智能是生物进化的一个自然演进路径，它将取代人类成为新的食物链顶端，并最终基于其悠久的生命力，去完成人类有限生命无法实现的星际航行之路。&lt;/p>
&lt;h2 id="冯诺依曼体系的规格">冯·诺依曼体系的规格&lt;/h2>
&lt;p>为了实现&amp;quot;解决一切可以用&amp;rsquo;计算&amp;rsquo;来解决的问题&amp;quot;这个目标，冯·诺依曼引入了三类基础零部件：&lt;/p>
&lt;ul>
&lt;li>中央处理器；&lt;/li>
&lt;li>存储；&lt;/li>
&lt;li>输入输出设备。&lt;/li>
&lt;/ul>
&lt;p>首先我们来看看存储。它负责存放计算涉及的相关数据，作为计算的输入参数和输出结果。&lt;/p>
&lt;p>我们日常见到的存储设备非常的多样化。比如：中央处理器自己内置的寄存器、内存、传统机械硬盘、USB 固态硬盘、光盘等等。&lt;/p>
&lt;p>从中央处理器的角度，存储可简单分为两类：一类是内置支持的存储，通过常规的处理器指令可直接访问，比如寄存器、内存、计算机主板的 ROM。一类是外置存储，它们属于输入输出设备。中央处理器本身并不能直接读写其中的数据。&lt;/p>
&lt;p>冯·诺依曼体系中涉及的&amp;quot;存储&amp;quot;，指的是中央处理器内置支持的存储。&lt;/p>
&lt;p>我们再来看看输入输出设备。它是计算机开放性的体现，大大拓展了计算机的能力。每个设备通过一个端口与中央处理器连接。通过这个端口地址，中央处理器可以和设备进行数据交换。数据交换涉及的数据格式由设备定义，中央处理器并不理解。&lt;/p>
&lt;p>但这并不影响设备的接入。设备数据交换的发起方（设备使用方）通常理解并可以解释所接收的数据含义。为了方便使用，设备厂商或操作系统厂商通常会提供设备相关的驱动程序，把设备数据交换的细节隐藏起来，设备的使用方只需要调用相关的接口函数就可以操作设备。&lt;/p>
&lt;p>最后我们来看看中央处理器。它负责程序（指令序列）的执行。指令序列在哪里？也存放在存储里面。计算机加电启动后，中央处理器从一个固定的存储地址开始执行。&lt;/p>
&lt;p>中央处理器支持的指令大体如下（我们在第一篇文章中也曾提到过）：&lt;/p>
&lt;ul>
&lt;li>计算类，也就是支持我们大家都熟知的各类数学运算，如加减乘除、sin/cos 等等；&lt;/li>
&lt;li>I/O 类，从存储读写数据，从输入输出设备读数据、写数据；&lt;/li>
&lt;li>指令跳转类，在满足特定条件下跳转到新的当前程序执行位置、调用自定义的函数。&lt;/li>
&lt;/ul>
&lt;p>和&amp;quot;解决一切可以用&amp;rsquo;计算&amp;rsquo;来解决的问题&amp;quot;这个伟大的目标相比，冯·诺依曼体系的三类零部件的规格设计显得如此精简。&lt;/p>
&lt;p>为什么这么简洁的规格设计，居然可以解决这么复杂的需求？&lt;/p>
&lt;h2 id="需求是怎么被满足的">需求是怎么被满足的？&lt;/h2>
&lt;p>我们来设想一下：假如今天让我们从零开始设计一个叫电脑的东西，我们的目标是&amp;quot;解决一切可以用&amp;rsquo;计算&amp;rsquo;来解决的问题&amp;quot;。&lt;/p>
&lt;p>对于这么含糊的需求，如果你是&amp;quot;电脑&amp;quot;这个产品的主架构师，你会如何应对？&lt;/p>
&lt;p>让我们来分析一下。&lt;/p>
&lt;p>一方面，需求的变化点在于，要解决的问题是五花八门包罗万象的。如何以某种稳定但可扩展的架构来支持这样的变化？而另一方面，需求的稳定之处在于，电脑的核心能力是固定的，怎么表达电脑的核心能力？&lt;/p>
&lt;p>电脑的核心能力是&amp;quot;计算&amp;quot;。什么是计算？计算就是对一个数据（输入）进行变换，变为另一个数据（输出）。在数学中我们把它叫&amp;quot;函数&amp;quot;。如下：&lt;/p>
&lt;blockquote>
&lt;p>y = F(x)&lt;/p>
&lt;/blockquote>
&lt;p>这里 x、y 是数据。它们可能只是一个简单的数值，也可能是文本、图片、视频，各种我们对现实问题进行参数化建模后的测量值，当然也可能是多个输入数据。但无论它的逻辑含义为何，物理上都可以以一段连续的字节内容来表达。用 Go 的语法表达就是：&lt;/p>
&lt;pre>&lt;code>func F(x []byte) (y []byte)
&lt;/code>&lt;/pre>
&lt;p>那么 x、y 物理上在哪里？思路推理到这里，&amp;ldquo;存储&amp;rdquo; 这个概念自然就产生了：存储，就是存放计算所要操作的数据的所在。&lt;/p>
&lt;p>下面的问题是：一个具体的计算（也就是 F 函数）怎么表达？&lt;/p>
&lt;p>这里的难点在于，F 对于电脑的架构师来说是未知的。那么，怎么设计一种系统架构让用户可以表达任意复杂的计算（函数）？&lt;/p>
&lt;p>逻辑上来看，无论多复杂的自定义函数，都可以通过下面这些元素的组合来定义：&lt;/p>
&lt;ul>
&lt;li>内置函数，比如整数或小数运算（加减乘除、sin/cos 等）；&lt;/li>
&lt;li>循环和条件分支；&lt;/li>
&lt;li>子函数（也是自定义函数）。&lt;/li>
&lt;/ul>
&lt;p>这样一来，对于任意的一个具体的计算（自定义函数）来说，都可以用一组指令序列来表达。&lt;/p>
&lt;p>那么函数 F 物理上在哪里？以指令序列形式存放在存储里面。所以，存储不只存放计算所要操作的数据，也存放&amp;quot;计算&amp;quot;本身。&lt;/p>
&lt;p>只是，存储里面存放的&amp;quot;计算&amp;quot;只是数据，需要有人理解并执行这些数据背后的计算行为，才变成真正意义的&amp;quot;计算&amp;quot;。这个执行者，就是中央处理器（CPU）。它支持很多计算指令，包括执行内置函数、循环和条件分支、执行子函数等。&lt;/p>
&lt;p>所以，有了中央处理器 + 存储，就可以支持任意复杂的&amp;quot;计算&amp;quot;了。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/cf/37/cf77b8fbe8a559cecbb264c390bc7337.png" alt="">&lt;/p>
&lt;p>只是如果电脑只有&amp;quot;中央处理器 + 存储&amp;quot;，那它就如同一个人只有头脑而没有四肢五官，尽管很可能很聪明，但是这种聪明无法展现出来，因为它没法和现实世界发生交互。&lt;/p>
&lt;p>交互，抽象来看就是输入和输出。对人来说，输入靠的是五官：眼睛看、耳朵听、鼻子闻、舌头尝，以及肌肤接触产生的触觉。输出靠语言（说话）和各种动作，如微笑、眨眼、皱眉、手势等等。&lt;/p>
&lt;p>对于电脑来说，输入输出的需求就更多了，不只是四肢五官，而可能是千肢万官。&lt;/p>
&lt;p>从输入需求来说，可能采集静态图像、声音、视频；也可能采集结构化数据，如 GPS 位置、脉搏、心电图、温度、湿度等；还可能是用户控制指令如键盘按键、鼠标、触摸屏动作等。&lt;/p>
&lt;p>从输出需求来说，可能是向屏幕输出信息；也可能是播放声音；还可能是执行某项动作，如交通灯开关、汽车马达转动、打印机打印等。&lt;/p>
&lt;p>但不管是什么样交互用途的器官（设备），我们要做的只是定义好统一的数据交换协议。这个数据交换机制，和网络上两台电脑通过互联网，需要通过某种数据交换协议进行通讯，需求上没有实质性的差别。&lt;/p>
&lt;p>也就是说，除了纯正的&amp;quot;计算&amp;quot;能力外，中央处理器还要有&amp;quot;数据交换&amp;quot;能力（或者叫 IO 能力）。最终，&lt;strong>电脑可以被看做由 &amp;ldquo;中央处理器 + 存储 + 一系列的输入输出设备&amp;rdquo;&lt;/strong> 构成。如下图：&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/28/a9/28ef9c0241c5c34abb85148453379fa9.png" alt="">&lt;/p>
&lt;p>尽管输入输出设备引入的最初灵感可能是来自于&amp;quot;交互&amp;quot;，但是当我们去审视输入输出设备到底是什么的时候，我们很自然发现，它能够做的不单单是交互。&lt;/p>
&lt;p>比如常见的外置存储如机械硬盘、光盘等，它们也是输入输出设备，但并不是用于交互，而是显著提升了电脑处理的数据体量。&lt;/p>
&lt;p>输入输出设备从根本上解决的问题是什么？&lt;/p>
&lt;p>是电脑无限可能的扩展能力。&lt;/p>
&lt;p>最重要的一点，输入输出设备和电脑是完全异构的。输入输出设备对电脑来说就只是实现了某项能力的黑盒子。&lt;/p>
&lt;p>这个黑盒子内部如何？没有规定。它可以只是一个原始的数字化的元器件，也可以是另一台冯·诺依曼架构的电脑，还可以是完全不同架构的电脑，比如 GPU 电脑、量子计算机。&lt;/p>
&lt;p>你可以发现，引入了输入输出设备的电脑，不再只能做狭义上的&amp;quot;计算&amp;quot;（也就是数学意义上的计算），如果我们把交互能力也看做一种计算能力的话，电脑理论上能够解决的&amp;quot;计算&amp;quot;问题变得无所不包。&lt;/p>
&lt;h2 id="架构思维上我们学习到什么">架构思维上我们学习到什么？&lt;/h2>
&lt;p>架构的第一步是需求分析。从需求分析角度来说，关键要抓住需求的稳定点和变化点。需求的稳定点，往往是系统的核心价值点；而需求的变化点，则往往需要相应去做开放性设计。&lt;/p>
&lt;p>对于&amp;quot;电脑&amp;quot;这个产品而言，需求的稳定点是电脑的&amp;quot;计算&amp;quot;能力。需求的变化点，一是用户&amp;quot;计算&amp;quot;需求的多样性，二是用户交互方式的多样性。&lt;/p>
&lt;p>电脑的&amp;quot;计算&amp;quot;能力，最终体现为中央处理器的指令集，这是需求相对稳定的部分。&lt;/p>
&lt;p>用户&amp;quot;计算&amp;quot;需求的多样性，最终是通过在存储中的指令序列实现。计算机加电启动后，中央处理器并不是按自己固有的&amp;quot;计算&amp;quot;过程进行，而是从一个固定的存储地址加载指令序列执行。&lt;/p>
&lt;p>通常，这个固定的存储地址指向计算机主板的 ROM 上的一段启动程序（BIOS）。这段启动程序通常包含以下这些内容。&lt;/p>
&lt;ul>
&lt;li>存储设备的驱动程序，用以识别常规的外置存储设备，比如硬盘、光驱、U 盘。&lt;/li>
&lt;li>基础外部设备的驱动程序，比如键盘、鼠标、显示器（显卡）。&lt;/li>
&lt;li>设备和启动配置的基础管理能力。&lt;/li>
&lt;li>在外置存储上执行程序的能力（中央处理器只支持在内存上执行程序，当然它也为在外置存储执行程序提供了一些支持，比如内存页缺失的中断处理）。&lt;/li>
&lt;li>将执行权转移到外置存储（第一次安装操作系统的时候可能是光驱甚至是网络存储，平常通常是硬盘）上的操作系统启动程序。这样，操作系统就开始干活了。&lt;/li>
&lt;/ul>
&lt;p>这样一来，&amp;ldquo;计算&amp;quot;需求的多样性只需要通过调整计算机主板上的 BIOS 程序，乃至外置存储中的操作系统启动程序就可以实现，而不必去修改中央处理器本身。&lt;/p>
&lt;p>用户交互方式的多样性，则通过定义外部设备与中央处理器的数据交换协议实现。&lt;/p>
&lt;p>当我们把所有的变化点从电脑的最核心部件中央处理器剥离后，中央处理器的需求变得极其稳定，可独立作为产品进行其核心价值的演进。&lt;/p>
&lt;h2 id="结语">结语&lt;/h2>
&lt;p>总结一下，今天，我们近距离地去解剖了整个信息世界地基：冯·诺依曼体系结构。&lt;/p>
&lt;p>冯·诺依曼体系结构的不凡之处在于，它想&amp;quot;解决一切可以用&amp;rsquo;计算&amp;rsquo;来解决的问题&amp;rdquo;。&lt;/p>
&lt;p>为了实现这个目标，冯·诺依曼引入了三类基础零部件：中央处理器、存储、输入输出设备。所有计算机都可以看做由 &amp;ldquo;中央处理器 + 存储 + 一系列的输入输出设备&amp;rdquo; 构成。&lt;/p>
&lt;p>为了方便理解，我在尝试用 Go 语言模拟来实现冯·诺依曼架构体系的电脑：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/qiniu/arch/tree/master/von">https://github.com/qiniu/arch/tree/master/von&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>如果你对此感兴趣，欢迎 fork 并对其进行修改迭代。&lt;/p>
&lt;p>如果你对今天的内容有什么思考与解读，欢迎给我留言，我们一起讨论。如果你觉得有所收获，也欢迎把文章分享给你的朋友。感谢你的收听，我们下期再见。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/43/00/43231f3789095eb4cdb38e67ff3d7900.jpg" alt="">&lt;/p></description></item><item><title>极客专栏: 02丨把错误关在笼子里的五道关卡</title><link>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E4%BB%A3%E7%A0%81%E7%B2%BE%E8%BF%9B%E4%B9%8B%E8%B7%AF/02%E4%B8%A8%E6%8A%8A%E9%94%99%E8%AF%AF%E5%85%B3%E5%9C%A8%E7%AC%BC%E5%AD%90%E9%87%8C%E7%9A%84%E4%BA%94%E9%81%93%E5%85%B3%E5%8D%A1/</link><pubDate>Tue, 07 Jun 2022 00:00:00 +0000</pubDate><guid>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E4%BB%A3%E7%A0%81%E7%B2%BE%E8%BF%9B%E4%B9%8B%E8%B7%AF/02%E4%B8%A8%E6%8A%8A%E9%94%99%E8%AF%AF%E5%85%B3%E5%9C%A8%E7%AC%BC%E5%AD%90%E9%87%8C%E7%9A%84%E4%BA%94%E9%81%93%E5%85%B3%E5%8D%A1/</guid><description>
&lt;p>上一讲中，我们一起讨论了什么是优秀的代码。简而言之，优秀的代码是经济、规范、安全的代码。在平时的工作中，我们要朝着这个方向努力，时常站在团队、流程、个人能力的角度去思考优秀代码。&lt;/p>
&lt;p>作为一名软件工程师，我们都想写出优秀的代码。可是，怎么才能编写出经济、规范、安全的代码呢？这是个大话题，相信你之前也有过思考。&lt;/p>
&lt;h2 id="无心的过失">无心的过失&lt;/h2>
&lt;p>开始之前，我先给你讲个曾经发生过的真实案例。2014 年 2 月，苹果公司的 iOS 和 OS X 操作系统爆出严重的安全漏洞，聪明的黑客们可以利用这一漏洞，伪装成可信网站或者服务，来拦截用户数据。而造成这一漏洞的原因，也让业界专家大跌眼镜。&lt;/p>
&lt;p>下面我用 C 语言的伪代码来给你简单描述下当时的漏洞情况。&lt;/p>
&lt;pre>&lt;code> if ((error = doSomething()) != 0)
goto fail;
goto fail;
if ((error= doMore()) != 0)
goto fail;
fail:
return error;
&lt;/code>&lt;/pre>
&lt;p>其实这段代码非常简单，它有两个判断语句，如果判断条件成立，那就执行&amp;quot;goto fail&amp;quot;语句，如果不成立，那就跳过判断语句继续执行。上面的&amp;quot;goto fail&amp;quot;语句，它的意思是略过它之后的所有语句，直接跳转到标有&amp;quot;fail&amp;quot;语句的地方，也就是第 6 行。&lt;/p>
&lt;p>我们来分析下，第一个判断条件（第一行和第二行），如果 error 不等于零，那就跳转到 fail 语句，这逻辑上没什么问题。而第三行，没有任何附加条件，就能直接跳转到 fail 语句，也就是说，它下面的代码永远也无法执行，这里是不是有问题？是的，漏洞就是出在这里。&lt;/p>
&lt;p>这一行多余的代码就是导致苹果操作系统那个安全漏洞的罪魁祸首。2014 年 2 月 21 日，苹果发布了相关的安全补丁，你随便一搜&amp;quot;GoTo Fail 漏洞&amp;quot;就能找到相关的细节，我这里不赘述了。&lt;/p>
&lt;p>我们每天仰慕的苹果操作系统出现这样&amp;quot;低级&amp;quot;的错误，你是不是有点惊讶？这么一个&amp;quot;简单&amp;quot;的错误，引发了一个非常严重的安全漏洞，是不是也有点出乎意料？上面的错误，简单看，就是复制的时候多复制了一行，或者因为时间关系，或者因为粗心大意，苹果的工程师硬是没检查出来。这在我们平时的工作中，也经常出现。&lt;/p>
&lt;p>这个具有重大杀伤力的 bug 是如此的&amp;quot;幼稚&amp;quot;，如此的&amp;quot;好玩&amp;quot;，如此的&amp;quot;萌萌哒&amp;quot;，以至于到现在，人们还可以买到印有&amp;quot;GoTo Fail&amp;quot;的 T 恤衫，更别提业界对于这个问题的兴趣了。有很多文章，专门研究这一个&amp;quot;低级&amp;quot;安全漏洞；甚至有人探讨这个&amp;quot;低级&amp;quot;错误对于计算机软件教育的积极影响。&lt;/p>
&lt;p>所有的危机都不应该被浪费，这一次也不例外。这些年，我也一直在思考&lt;strong>为什么我们会犯如此&amp;quot;低级&amp;quot;的错误&lt;/strong>？即使是在苹果这样的大公司。反过来再想，我们应该如何尽可能避免类似的错误呢？&lt;/p>
&lt;h2 id="人人都会犯错误">人人都会犯错误&lt;/h2>
&lt;p>没有人是完美的，人人都会犯错误。这应该是一个共识。这里面既有技术层面的因素，也有人类的行为模式的因素，也有现实环境的影响。我们在此不讨论人类进化和心智模式这样的严肃研究成果。但是，有两三个有意思的话题，我想和你聊聊。&lt;/p>
&lt;p>第一个比较普遍的观点是好的程序员不会写坏的代码，要不然，就是他还不足够优秀。我尊重这个观点背后代表的美好愿望，但是这个观点本身我很难认同。它一定程度上忽视了人类犯错误的复杂性，和影响因素的多样性。&lt;/p>
&lt;p>我认为，即使一个非常优秀的程序员，他主观上非常认真，能力又非常强，但他也会犯非常&amp;quot;低级&amp;quot;、&amp;ldquo;幼稚&amp;quot;的错误。所以，你不能因为苹果那个程序员，犯了那个非常低级的错误，就一棒子把他&amp;quot;打死&amp;rdquo;，认为他不是一个好的程序员。&lt;/p>
&lt;p>第二个更加普遍的观点是同样的错误不能犯第二次。作为一名程序员，我同样尊重这个观点背后代表的美好期望。但是，我想给这个观点加一点点限制。这个观点应该是我们对自身的期望和要求；对于他人，我们可以更宽容；&lt;strong>对于一个团队，我们首先要思考如何提供一种机制，&lt;/strong> &lt;strong>以减少此类错误的发生&lt;/strong>。如果强制要求他人错不过三，现实中，我们虽然发泄了怨气，但是往往错失了工作机制提升的机会。&lt;/p>
&lt;p>第三个深入人心的观点是一个人犯了错误并不可怕，怕的是不承认错误。同样的，我理解这个观点背后代表的美好诉求。这是一个深入人心的观点，具有深厚的群众基础，我万万不敢造次。在软件工程领域，我想，在犯错这件事情上，我们还是要再多一点对自己的谅解，以及对他人的宽容。错误并不可怕，你不必为此深深自责，更不应该责备他人。要不然，&lt;strong>一旦陷入自责和指责的漩涡，很多有建设意义的事情，我们可能没有意识去做；或者即使意识到了，也没法做，做不好&lt;/strong>。&lt;/p>
&lt;p>我这么说，你是不是开始有疑惑了：人人都会犯错误，还重复犯，还不能批评，这怎么能编写出优秀的代码呢？换句话说就是，&lt;strong>我们怎么样才会少犯错误呢？&lt;/strong>&lt;/p>
&lt;h2 id="把错误关在笼子里">把错误关在笼子里&lt;/h2>
&lt;p>人人都会犯错误，苹果的工程师也不例外。所以，&amp;ldquo;GoTo Fail&amp;quot;的&amp;quot;幼稚&amp;quot;漏洞，实在是在情理之中。可是，这样的漏洞是如何逃脱重重&amp;quot;监管&amp;rdquo;，出现在最终的发布产品中，这多多少少让我有点出乎意料。&lt;/p>
&lt;p>我们先来看看，这个错误是经过了怎样的&amp;quot;工序&amp;quot;，穿越了多少障碍，需要多少运气，最终才能被&amp;quot;发布&amp;quot;出来。&lt;/p>
&lt;p>我把这样的工序总结为&amp;quot;五道关卡&amp;quot;。&lt;/p>
&lt;p>&lt;strong>第一道关：程序员&lt;/strong>&lt;/p>
&lt;p>&lt;strong>提高程序员的修养，是一个永不过时的课题。从别人的失败和自己的失败中学习、积累、提高，是一个程序员成长的必修课&lt;/strong>。我知道，这是你和我一直都在努力做的事情。&lt;/p>
&lt;p>第三行的&amp;quot;GoTo Fail&amp;quot;，实在算得上&amp;quot;漏网之鱼&amp;quot;，才可以逃过哪怕最平凡的程序员的眼睛，堂而皇之地占据了宝贵的一行代码，并且狠狠地玩耍了一把。&lt;/p>
&lt;p>现在我们可以再回过来看看那段错误代码，如果是你写，你会怎么写呢？从你的角度来看，又有哪些细节可以帮助你避免类似的错误呢？这两个问题，你可以先停下来 1 分钟，想一想。&lt;/p>
&lt;p>在我看来，上面那段代码，起码有两个地方可以优化。如果那位程序员能够按照规范的方式写代码，那&amp;quot;GoTo Fail&amp;quot;的漏洞应该是很容易被发现。我们在遇到问题的时候，也应该尽量朝着规范以及可持续改进的角度去思考错误背后的原因，而非一味地自责。&lt;/p>
&lt;p>首先，&lt;strong>他应该正确使用缩进&lt;/strong>。你现在可以再看下我优化后的代码，是不是第三行的代码特别刺眼，是不是更容易被&amp;quot;逮住&amp;quot;？&lt;/p>
&lt;pre>&lt;code> if ((error = doSomething()) != 0)
goto fail;
goto fail;
if ((error= doMore()) != 0)
goto fail;
fail:
return error;
&lt;/code>&lt;/pre>
&lt;p>其次，&lt;strong>他应该使用大括号&lt;/strong>。使用大括号后，这个问题是不是就自动消失了？虽然，多余的这一行依然是多余的，但已经是没有多大危害的一行代码了。&lt;/p>
&lt;pre>&lt;code> if ((error = doSomething()) != 0) {
goto fail;
goto fail;
}
if ((error= doMore()) != 0) {
goto fail;
}
fail:
return error;
&lt;/code>&lt;/pre>
&lt;p>从上面这个例子里，不知道你有没有体会到，好的代码风格带来的好处呢？工作中，像苹果公司的那位程序员一样的错误，你应该没少遇到吧？那现在，你是不是可以思考如何从代码风格的角度来避免类似的错误呢？&lt;/p>
&lt;p>魔鬼藏于细节。很多时候， &lt;strong>优秀的代码源于我们对细节的热情和执着&lt;/strong> 。可能，你遇到的或者想到的问题，不是每一个都有完美的答案或者解决办法。但是，&lt;strong>如果你能够找到哪怕仅仅是一个小问题的一个小小的改进办法，都有可能会给你的代码质量带来巨大的提升和改变&lt;/strong>。&lt;/p>
&lt;p>当然，你可能还会说，我代码风格不错，但是那个问题就是没看到，这也是极有可能的事情。是这样，所以也就有了第二道工序：编译器。&lt;/p>
&lt;p>&lt;strong>第二道关：编译器&lt;/strong>&lt;/p>
&lt;p>编译器在代码质量方面，作为机器，恪尽职守，它可以帮助我们清除很多错误。还是以上面的漏洞代码为例子， 这一次其实编译器的防守并没有做好，因为它毫无察觉地漏过了多余的&amp;quot;GoTo Fail&amp;quot;。&lt;/p>
&lt;p>在 Java 语言里，对于无法访问的代码（第三行后的代码）， Java 编译器就会及时报告错误。而在 2014 年 2 月的 GCC 编译器里，并没有提供这样的功能。&lt;/p>
&lt;p>至今，GCC 社区对于无法访问代码的检查，还没有统一的意见 。然而，GCC 社区并没有完全浪费这个&amp;quot;GoTo Fail&amp;quot;的问题 。为解决类似问题，从 GCC 6 开始，GCC 社区为正确使用缩进提供了一个警告选项（ -Wmisleading-indentation ）。如果代码缩进格式没有正确使用，GCC 就会提供编译时警告。现在，如果我们启用并且注意到了 GCC 编译器的警告，犯类似错误的机会应该会大幅度地降低了。&lt;/p>
&lt;p>在这里，我要提醒你的是，对于编译器的警告，我们一定要非常警觉。能消除掉所有的警告，你就应该消除掉所有的警告。就算实在没有办法消除掉编译警告，那你也一定要搞清楚警告产生的原因，并确认编译警告不会产生任何后续问题。&lt;/p>
&lt;p>&lt;strong>第三道关：回归测试 （Regression Testing）&lt;/strong>&lt;/p>
&lt;p>一般地，软件测试会尽可能地覆盖&lt;strong>关键逻辑和负面清单&lt;/strong>，以确保关键功能能够正确执行，关键错误能够有效处理。一般情况下，无论是开发人员，还是测试人员，都要写很多测试代码，来测试软件是否达到预期的要求。&lt;/p>
&lt;p>另外，这些测试代码还有一个关键用途就是做回归测试 。如果有代码变更，我们可以用回归测试来检查这样的代码变更有没有使代码变得更坏。&lt;/p>
&lt;p>上述的&amp;quot;GoTo Fail&amp;quot;这样的代码变更，涉及到一个非常重要的负面检查点。遗憾的是，该检查点并没有包含在回归测试中；或者，在这个变更交付工程中，回归测试并没有被执行。&lt;/p>
&lt;p>软件测试没有办法覆盖所有的使用场景。但是，我们千万要覆盖关键逻辑和负面清单。一个没有良好回归测试的软件，很难保证代码变更的质量；也会使得代码变更充满不确定性，从而大幅地提高代码维护的成本。&lt;/p>
&lt;p>&lt;strong>第四道关：代码评审 （Code Review）&lt;/strong>&lt;/p>
&lt;p>&lt;strong>代码评审是一个有效的在软件研发过程中抵御人类缺陷的制度&lt;/strong>。通过更多的眼睛检查软件代码，被忽视的错误更容易被逮住，更好的设计和实现更容易浮现出来。&lt;/p>
&lt;p>那代码评审是怎么实现的呢？一般情况下，代码评审是通过阅读代码变更进行的。而代码变更一般通过某种形式的工具呈现出来。比如 OpenJDK 采用的&lt;a href="http://openjdk.java.net/guide/webrevHelp.html">Webrev&lt;/a> 。你可以访问&lt;a href="http://cr.openjdk.java.net/~xuelei/8171337/webrev.00/">我的一个代码评审使用的代码变更页面&lt;/a> ，感受下这种呈现方式。&lt;/p>
&lt;p>回到上面那个&amp;quot;GoTo Fail&amp;quot;的代码变更，看起来什么样子呢？下面是其中的一个代码变更版本示例：&lt;/p>
&lt;pre>&lt;code>if ((err = SSLHashSHA1.update(&amp;amp;hashCtx, &amp;amp;signedParams)) != 0)
goto fail;
+ goto fail;
if ((err = SSLHashSHA1.final(&amp;amp;hashCtx, &amp;amp;hashOut)) != 0)
goto fail;
&lt;/code>&lt;/pre>
&lt;p>添加的这行代码，还是相当刺眼的。多一些眼睛盯着这些代码，多一些形式展现这些变更，就会大幅度地降低问题藏匿的几率。&lt;/p>
&lt;p>上述的&amp;quot;GoTo Fail&amp;quot;这样的代码变更，怎么就逃过代码评审者的眼睛呢？我想说的是，评审者也是人，我们不能期望评审者能发现所有的问题。&lt;/p>
&lt;p>&lt;strong>第五道关：代码分析 （Code Analysis）&lt;/strong>&lt;/p>
&lt;p>静态代码分析（Static Code Analysis）是通过对源代码的检查来发现潜在问题的一种软件质量保障方式。有很多静态代码分析工具可以帮助你检查代码缺陷，比如说商业软件 Coverity，以及开源软件 FindBugs。你可以试试看，有哪些工具可以检测到这个&amp;quot;GoTo Fail&amp;quot;问题。&lt;/p>
&lt;p>代码覆盖率（Code Coverage）是一个反映测试覆盖程度的指标。它不仅仅量化测试的指标，也是一个检测代码缺陷的好工具。如果你的代码覆盖率测试实现了行覆盖（Line Coverage），这个&amp;quot;GoTo Fail&amp;quot;问题也很难闯过这一关。&lt;/p>
&lt;p>很显然，苹果的这一关也没有拦截住&amp;quot;GoTo Fail&amp;quot;。这样，&amp;ldquo;GoTo Fail&amp;quot;就像千里走单骑的关云长，闯过了五关（有些软件开发流程，也许会设置更多的关卡）。&lt;/p>
&lt;h2 id="代码制造的流水线">代码制造的流水线&lt;/h2>
&lt;p>我们分析了这重重关卡，我特别想传递的一个想法就是，&lt;strong>编写优秀的代码，不能仅仅依靠一个人的战斗&lt;/strong>。代码的优秀级别，依赖于每个关卡的优秀级别。高质量的代码，依赖于高质量的流水线。每道关卡都应该给程序员提供积极的反馈。这些反馈，在保障代码质量的同时，也能帮助程序员快速学习和成长。&lt;/p>
&lt;p>可是，即使我们设置了重重关卡，&amp;ldquo;GoTo Fail&amp;quot;依然&amp;quot;过关斩将&amp;rdquo;，一行代码一路恣意玩耍。这里面有关卡虚设的因素，也有我们粗心大意的因素。我们怎么样才能打造更好的关卡，或者设置更好的笼子？尤其是，&lt;strong>身为程序员，如何守好第一关？&lt;/strong>&lt;/p>
&lt;p>欢迎你在留言区说说自己的思考。下一讲，我们再接着聊这个话题。&lt;/p>
&lt;h2 id="一起来动手">一起来动手&lt;/h2>
&lt;p>下面的这段代码，有很多疏漏的地方。你看看自己读代码能发现多少问题？上面我们讨论的流程能够发现多少问题。不妨把讨论区看作代码评审区，看看在讨论区都有什么不同的发现。&lt;/p>
&lt;pre>&lt;code>package com.example;
import java.util.Collections;
import java.util.List;
import javax.net.ssl.SNIServerName;
class ServerNameSpec {
final List serverNames;
ServerNameSpec(List serverNames) {
this.serverNames = Collections.unmodifiableList(serverNames);
}
public void addServerName(SNIServerName serverName) {
serverNames.add(serverName);
}
public String toString() {
if (serverNames == null || serverNames.isEmpty())
return &amp;quot;&amp;lt;no server name indicator specified&amp;gt;&amp;quot;;
StringBuilder builder = new StringBuilder(512);
for (SNIServerName sn : serverNames) {
builder.append(sn.toString());
builder.append(&amp;quot;\n&amp;quot;);
}
return builder.toString();
}
}
&lt;/code>&lt;/pre>
&lt;p>你也可以把这篇文章分享给你的朋友或者同事，一起来讨论一下这道小小的练习题。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/5a/98/5a96a612403912b80de030e742e2e598.jpg" alt="">&lt;/p></description></item><item><title>极客专栏: 02丨Java内存模型：看Java如何解决可见性和有序性问题</title><link>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/02%E4%B8%A8java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E7%9C%8Bjava%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%8F%AF%E8%A7%81%E6%80%A7%E5%92%8C%E6%9C%89%E5%BA%8F%E6%80%A7%E9%97%AE%E9%A2%98/</link><pubDate>Sun, 29 May 2022 00:00:00 +0000</pubDate><guid>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/02%E4%B8%A8java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E7%9C%8Bjava%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%8F%AF%E8%A7%81%E6%80%A7%E5%92%8C%E6%9C%89%E5%BA%8F%E6%80%A7%E9%97%AE%E9%A2%98/</guid><description>
&lt;p>上一期我们讲到在并发场景中，因可见性、原子性、有序性导致的问题常常会违背我们的直觉，从而成为并发编程的 Bug 之源。这三者在编程领域属于共性问题，所有的编程语言都会遇到，Java 在诞生之初就支持多线程，自然也有针对这三者的技术方案，而且在编程语言领域处于领先地位。理解 Java 解决并发问题的解决方案，对于理解其他语言的解决方案有触类旁通的效果。&lt;/p>
&lt;p>那我们就先来聊聊如何解决其中的可见性和有序性导致的问题，这也就引出来了今天的主角&amp;mdash;&amp;mdash;&lt;strong>Java 内存模型&lt;/strong>。&lt;/p>
&lt;p>Java 内存模型这个概念，在职场的很多面试中都会考核到，是一个热门的考点，也是一个人并发水平的具体体现。原因是当并发程序出问题时，需要一行一行地检查代码，这个时候，只有掌握 Java 内存模型，才能慧眼如炬地发现问题。&lt;/p>
&lt;h2 id="什么是-java-内存模型">什么是 Java 内存模型？&lt;/h2>
&lt;p>你已经知道，导致可见性的原因是缓存，导致有序性的原因是编译优化，那解决可见性、有序性最直接的办法就是&lt;strong>禁用缓存和编译优化&lt;/strong>，但是这样问题虽然解决了，我们程序的性能可就堪忧了。&lt;/p>
&lt;p>合理的方案应该是&lt;strong>按需禁用缓存以及编译优化&lt;/strong>。那么，如何做到&amp;quot;按需禁用&amp;quot;呢？对于并发程序，何时禁用缓存以及编译优化只有程序员知道，那所谓&amp;quot;按需禁用&amp;quot;其实就是指按照程序员的要求来禁用。所以，为了解决可见性和有序性问题，只需要提供给程序员按需禁用缓存和编译优化的方法即可。&lt;/p>
&lt;p>Java 内存模型是个很复杂的规范，可以从不同的视角来解读，站在我们这些程序员的视角，本质上可以理解为，Java 内存模型规范了 JVM 如何提供按需禁用缓存和编译优化的方法。具体来说，这些方法包括 &lt;strong>volatile&lt;/strong> 、&lt;strong>synchronized&lt;/strong> 和 &lt;strong>final&lt;/strong> 三个关键字，以及六项 &lt;strong>Happens-Before 规则&lt;/strong>，这也正是本期的重点内容。&lt;/p>
&lt;h2 id="使用-volatile-的困惑">使用 volatile 的困惑&lt;/h2>
&lt;p>volatile 关键字并不是 Java 语言的特产，古老的 C 语言里也有，它最原始的意义就是禁用 CPU 缓存。&lt;/p>
&lt;p>例如，我们声明一个 volatile 变量 &lt;code>volatile int x = 0&lt;/code>，它表达的是：告诉编译器，对这个变量的读写，不能使用 CPU 缓存，必须从内存中读取或者写入。这个语义看上去相当明确，但是在实际使用的时候却会带来困惑。&lt;/p>
&lt;p>例如下面的示例代码，假设线程 A 执行 writer() 方法，按照 volatile 语义，会把变量 &amp;ldquo;v=true&amp;rdquo; 写入内存；假设线程 B 执行 reader() 方法，同样按照 volatile 语义，线程 B 会从内存中读取变量 v，如果线程 B 看到 &amp;ldquo;v == true&amp;rdquo; 时，那么线程 B 看到的变量 x 是多少呢？&lt;/p>
&lt;p>直觉上看，应该是 42，那实际应该是多少呢？这个要看 Java 的版本，如果在低于 1.5 版本上运行，x 可能是 42，也有可能是 0；如果在 1.5 以上的版本上运行，x 就是等于 42。&lt;/p>
&lt;pre>&lt;code>// 以下代码来源于【参考 1】
class VolatileExample {
int x = 0;
volatile boolean v = false;
public void writer() {
x = 42;
v = true;
}
public void reader() {
if (v == true) {
// 这里 x 会是多少呢？
}
}
}
&lt;/code>&lt;/pre>
&lt;p>分析一下，为什么 1.5 以前的版本会出现 x = 0 的情况呢？我相信你一定想到了，变量 x 可能被 CPU 缓存而导致可见性问题。这个问题在 1.5 版本已经被圆满解决了。Java 内存模型在 1.5 版本对 volatile 语义进行了增强。怎么增强的呢？答案是一项 Happens-Before 规则。&lt;/p>
&lt;h2 id="happens-before-规则">Happens-Before 规则&lt;/h2>
&lt;p>如何理解 Happens-Before 呢？如果望文生义（很多网文也都爱按字面意思翻译成&amp;quot;先行发生&amp;quot;），那就南辕北辙了，Happens-Before 并不是说前面一个操作发生在后续操作的前面，它真正要表达的是：&lt;strong>前面一个操作的结果对后续操作是可见的&lt;/strong>。就像有心灵感应的两个人，虽然远隔千里，一个人心之所想，另一个人都看得到。Happens-Before 规则就是要保证线程之间的这种&amp;quot;心灵感应&amp;quot;。所以比较正式的说法是：Happens-Before 约束了编译器的优化行为，虽允许编译器优化，但是要求编译器优化后一定遵守 Happens-Before 规则。&lt;/p>
&lt;p>Happens-Before 规则应该是 Java 内存模型里面最晦涩的内容了，和程序员相关的规则一共有如下六项，都是关于可见性的。&lt;/p>
&lt;p>恰好前面示例代码涉及到这六项规则中的前三项，为便于你理解，我也会分析上面的示例代码，来看看规则 1、2 和 3 到底该如何理解。至于其他三项，我也会结合其他例子作以说明。&lt;/p>
&lt;h3 id="1-程序的顺序性规则">1. 程序的顺序性规则&lt;/h3>
&lt;p>这条规则是指在一个线程中，按照程序顺序，前面的操作 Happens-Before 于后续的任意操作。这还是比较容易理解的，比如刚才那段示例代码，按照程序的顺序，第 6 行代码 &amp;ldquo;x = 42;&amp;rdquo; Happens-Before 于第 7 行代码 &amp;ldquo;v = true;&amp;quot;，这就是规则 1 的内容，也比较符合单线程里面的思维：程序前面对某个变量的修改一定是对后续操作可见的。&lt;/p>
&lt;p>（为方便你查看，我将那段示例代码在这儿再呈现一遍）&lt;/p>
&lt;pre>&lt;code>// 以下代码来源于【参考 1】
class VolatileExample {
int x = 0;
volatile boolean v = false;
public void writer() {
x = 42;
v = true;
}
public void reader() {
if (v == true) {
// 这里 x 会是多少呢？
}
}
}
&lt;/code>&lt;/pre>
&lt;h3 id="2-volatile-变量规则">2. volatile 变量规则&lt;/h3>
&lt;p>这条规则是指对一个 volatile 变量的写操作， Happens-Before 于后续对这个 volatile 变量的读操作。&lt;/p>
&lt;p>这个就有点费解了，对一个 volatile 变量的写操作相对于后续对这个 volatile 变量的读操作可见，这怎么看都是禁用缓存的意思啊，貌似和 1.5 版本以前的语义没有变化啊？如果单看这个规则，的确是这样，但是如果我们关联一下规则 3，就有点不一样的感觉了。&lt;/p>
&lt;h3 id="3-传递性">3. 传递性&lt;/h3>
&lt;p>这条规则是指如果 A Happens-Before B，且 B Happens-Before C，那么 A Happens-Before C。&lt;/p>
&lt;p>我们将规则 3 的传递性应用到我们的例子中，会发生什么呢？可以看下面这幅图：&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/b1/e1/b1fa541e98c74bc2a033d9ac5ae7fbe1.png" alt="">
示例代码中的传递性规则&lt;/p>
&lt;p>从图中，我们可以看到：&lt;/p>
&lt;ol>
&lt;li>&amp;ldquo;x=42&amp;rdquo; Happens-Before 写变量 &amp;ldquo;v=true&amp;rdquo; ，这是规则 1 的内容；&lt;/li>
&lt;li>写变量&amp;quot;v=true&amp;rdquo; Happens-Before 读变量 &amp;ldquo;v=true&amp;rdquo;，这是规则 2 的内容 。&lt;/li>
&lt;/ol>
&lt;p>再根据这个传递性规则，我们得到结果：&amp;ldquo;x=42&amp;rdquo; Happens-Before 读变量&amp;quot;v=true&amp;quot;。这意味着什么呢？&lt;/p>
&lt;p>如果线程 B 读到了&amp;quot;v=true&amp;quot;，那么线程 A 设置的&amp;quot;x=42&amp;quot;对线程 B 是可见的。也就是说，线程 B 能看到 &amp;ldquo;x == 42&amp;rdquo; ，有没有一种恍然大悟的感觉？这就是 1.5 版本对 volatile 语义的增强，这个增强意义重大，1.5 版本的并发工具包（java.util.concurrent）就是靠 volatile 语义来搞定可见性的，这个在后面的内容中会详细介绍。&lt;/p>
&lt;h3 id="4-管程中锁的规则">4. 管程中锁的规则&lt;/h3>
&lt;p>这条规则是指对一个锁的解锁 Happens-Before 于后续对这个锁的加锁。&lt;/p>
&lt;p>要理解这个规则，就首先要了解&amp;quot;管程指的是什么&amp;quot;。&lt;strong>管程&lt;/strong>是一种通用的同步原语，在 Java 中指的就是 synchronized，synchronized 是 Java 里对管程的实现。&lt;/p>
&lt;p>管程中的锁在 Java 里是隐式实现的，例如下面的代码，在进入同步块之前，会自动加锁，而在代码块执行完会自动释放锁，加锁以及释放锁都是编译器帮我们实现的。&lt;/p>
&lt;pre>&lt;code>synchronized (this) { // 此处自动加锁
// x 是共享变量, 初始值 =10
if (this.x &amp;lt; 12) {
this.x = 12;
}
} // 此处自动解锁
&lt;/code>&lt;/pre>
&lt;p>所以结合规则 4&amp;mdash;&amp;mdash;管程中锁的规则，可以这样理解：假设 x 的初始值是 10，线程 A 执行完代码块后 x 的值会变成 12（执行完自动释放锁），线程 B 进入代码块时，能够看到线程 A 对 x 的写操作，也就是线程 B 能够看到 x==12。这个也是符合我们直觉的，应该不难理解。&lt;/p>
&lt;h3 id="5-线程-start-规则">5. 线程 start() 规则&lt;/h3>
&lt;p>这条是关于线程启动的。它是指主线程 A 启动子线程 B 后，子线程 B 能够看到主线程在启动子线程 B 前的操作。&lt;/p>
&lt;p>换句话说就是，如果线程 A 调用线程 B 的 start() 方法（即在线程 A 中启动线程 B），那么该 start() 操作 Happens-Before 于线程 B 中的任意操作。具体可参考下面示例代码。&lt;/p>
&lt;pre>&lt;code>Thread B = new Thread(()-&amp;gt;{
// 主线程调用 B.start() 之前
// 所有对共享变量的修改，此处皆可见
// 此例中，var==77
});
// 此处对共享变量 var 修改
var = 77;
// 主线程启动子线程
B.start();
&lt;/code>&lt;/pre>
&lt;h3 id="6-线程-join-规则">6. 线程 join() 规则&lt;/h3>
&lt;p>这条是关于线程等待的。它是指主线程 A 等待子线程 B 完成（主线程 A 通过调用子线程 B 的 join() 方法实现），当子线程 B 完成后（主线程 A 中 join() 方法返回），主线程能够看到子线程的操作。当然所谓的&amp;quot;看到&amp;quot;，指的是对&lt;strong>共享变量&lt;/strong>的操作。&lt;/p>
&lt;p>换句话说就是，如果在线程 A 中，调用线程 B 的 join() 并成功返回，那么线程 B 中的任意操作 Happens-Before 于该 join() 操作的返回。具体可参考下面示例代码。&lt;/p>
&lt;pre>&lt;code>Thread B = new Thread(()-&amp;gt;{
// 此处对共享变量 var 修改
var = 66;
});
// 例如此处对共享变量修改，
// 则这个修改结果对线程 B 可见
// 主线程启动子线程
B.start();
B.join()
// 子线程所有对共享变量的修改
// 在主线程调用 B.join() 之后皆可见
// 此例中，var==66
&lt;/code>&lt;/pre>
&lt;h2 id="被我们忽视的-final">被我们忽视的 final&lt;/h2>
&lt;p>前面我们讲 volatile 为的是禁用缓存以及编译优化，我们再从另外一个方面来看，有没有办法告诉编译器优化得更好一点呢？这个可以有，就是&lt;strong>final 关键字&lt;/strong>。&lt;/p>
&lt;p>**final 修饰变量时，初衷是告诉编译器：这个变量生而不变，可以可劲儿优化。**Java 编译器在 1.5 以前的版本的确优化得很努力，以至于都优化错了。&lt;/p>
&lt;p>问题类似于上一期提到的利用双重检查方法创建单例，构造函数的错误重排导致线程可能看到 final 变量的值会变化。详细的案例可以参考&lt;a href="http://www.cs.umd.edu/~pugh/java/memoryModel/jsr-133-faq.html#finalWrong">这个文档&lt;/a>。&lt;/p>
&lt;p>当然了，在 1.5 以后 Java 内存模型对 final 类型变量的重排进行了约束。现在只要我们提供正确构造函数没有&amp;quot;逸出&amp;quot;，就不会出问题了。&lt;/p>
&lt;p>&amp;ldquo;逸出&amp;quot;有点抽象，我们还是举个例子吧，在下面例子中，在构造函数里面将 this 赋值给了全局变量 global.obj，这就是&amp;quot;逸出&amp;rdquo;，线程通过 global.obj 读取 x 是有可能读到 0 的。因此我们一定要避免&amp;quot;逸出&amp;quot;。&lt;/p>
&lt;pre>&lt;code>// 以下代码来源于【参考 1】
final int x;
// 错误的构造函数
public FinalFieldExample() {
x = 3;
y = 4;
// 此处就是讲 this 逸出，
global.obj = this;
}
&lt;/code>&lt;/pre>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>Java 的内存模型是并发编程领域的一次重要创新，之后 C++、C#、Golang 等高级语言都开始支持内存模型。Java 内存模型里面，最晦涩的部分就是 Happens-Before 规则了，Happens-Before 规则最初是在一篇叫做&lt;strong>Time, Clocks, and the Ordering of Events in a Distributed System&lt;/strong>的论文中提出来的，在这篇论文中，Happens-Before 的语义是一种因果关系。在现实世界里，如果 A 事件是导致 B 事件的起因，那么 A 事件一定是先于（Happens-Before）B 事件发生的，这个就是 Happens-Before 语义的现实理解。&lt;/p>
&lt;p>在 Java 语言里面，Happens-Before 的语义本质上是一种可见性，A Happens-Before B 意味着 A 事件对 B 事件来说是可见的，无论 A 事件和 B 事件是否发生在同一个线程里。例如 A 事件发生在线程 1 上，B 事件发生在线程 2 上，Happens-Before 规则保证线程 2 上也能看到 A 事件的发生。&lt;/p>
&lt;p>Java 内存模型主要分为两部分，一部分面向你我这种编写并发程序的应用开发人员，另一部分是面向 JVM 的实现人员的，我们可以重点关注前者，也就是和编写并发程序相关的部分，这部分内容的核心就是 Happens-Before 规则。相信经过本章的介绍，你应该对这部分内容已经有了深入的认识。&lt;/p>
&lt;h2 id="课后思考">课后思考&lt;/h2>
&lt;p>有一个共享变量 abc，在一个线程里设置了 abc 的值 &lt;code>abc=3&lt;/code>，你思考一下，有哪些办法可以让其他线程能够看到&lt;code>abc==3&lt;/code>？&lt;/p>
&lt;p>欢迎在留言区与我分享你的想法，也欢迎你在留言区记录你的思考过程。感谢阅读，如果你觉得这篇文章对你有帮助的话，也欢迎把它分享给更多的朋友。&lt;/p>
&lt;h2 id="参考">参考&lt;/h2>
&lt;ol>
&lt;li>&lt;a href="http://www.cs.umd.edu/~pugh/java/memoryModel/jsr-133-faq.html">JSR 133 (Java Memory Model) FAQ&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://ifeve.com/jmm-faq/">Java 内存模型 FAQ&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.cs.umd.edu/~pugh/java/memoryModel/jsr133.pdf">JSR-133: Java^TM^ Memory Model and Thread Specification&lt;/a>&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/cf/aa/cf393cd748a4f0e6451807c4b61843aa.jpg" alt="">&lt;/p></description></item><item><title>极客专栏: 02丨代码加锁：不要让“锁”事成为烦心事</title><link>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/java%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF100%E4%BE%8B/02%E4%B8%A8%E4%BB%A3%E7%A0%81%E5%8A%A0%E9%94%81%E4%B8%8D%E8%A6%81%E8%AE%A9%E9%94%81%E4%BA%8B%E6%88%90%E4%B8%BA%E7%83%A6%E5%BF%83%E4%BA%8B/</link><pubDate>Sun, 29 May 2022 00:00:00 +0000</pubDate><guid>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/java%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF100%E4%BE%8B/02%E4%B8%A8%E4%BB%A3%E7%A0%81%E5%8A%A0%E9%94%81%E4%B8%8D%E8%A6%81%E8%AE%A9%E9%94%81%E4%BA%8B%E6%88%90%E4%B8%BA%E7%83%A6%E5%BF%83%E4%BA%8B/</guid><description>
&lt;p>你好，我是朱晔。&lt;/p>
&lt;p>在上一讲中，我与你介绍了使用并发容器等工具解决线程安全的误区。今天，我们来看看解决线程安全问题的另一种重要手段&amp;mdash;&amp;mdash;锁，在使用上比较容易犯哪些错。&lt;/p>
&lt;p>我先和你分享一个有趣的案例吧。有一天，一位同学在群里说&amp;quot;见鬼了，疑似遇到了一个 JVM 的 Bug&amp;quot;，我们都很好奇是什么 Bug。&lt;/p>
&lt;p>于是，他贴出了这样一段代码：在一个类里有两个 int 类型的字段 a 和 b，有一个 add 方法循环 1 万次对 a 和 b 进行 ++ 操作，有另一个 compare 方法，同样循环 1 万次判断 a 是否小于 b，条件成立就打印 a 和 b 的值，并判断 a&amp;gt;b 是否成立。&lt;/p>
&lt;pre tabindex="0">&lt;code>@Slf4j
public class Interesting {
volatile int a = 1;
volatile int b = 1;
public void add() {
log.info(&amp;#34;add start&amp;#34;);
for (int i = 0; i &amp;lt; 10000; i++) {
a++;
b++;
}
log.info(&amp;#34;add done&amp;#34;);
}
public void compare() {
log.info(&amp;#34;compare start&amp;#34;);
for (int i = 0; i &amp;lt; 10000; i++) {
//a始终等于b吗？
if (a &amp;lt; b) {
log.info(&amp;#34;a:{},b:{},{}&amp;#34;, a, b, a &amp;gt; b);
//最后的a&amp;gt;b应该始终是false吗？
}
}
log.info(&amp;#34;compare done&amp;#34;);
}
}
&lt;/code>&lt;/pre>&lt;p>他起了两个线程来分别执行 add 和 compare 方法：&lt;/p>
&lt;pre tabindex="0">&lt;code>Interesting interesting = new Interesting();
new Thread(() -&amp;gt; interesting.add()).start();
new Thread(() -&amp;gt; interesting.compare()).start();
&lt;/code>&lt;/pre>&lt;p>按道理，a 和 b 同样进行累加操作，应该始终相等，compare 中的第一次判断应该始终不会成立，不会输出任何日志。但，执行代码后发现不但输出了日志，而且更诡异的是，compare 方法在判断 a&amp;lt;b 成立的情况下还输出了 a&amp;gt;b 也成立：&lt;br>
&lt;img src="https://static001.geekbang.org/resource/image/9e/1d/9ec61aada64ac6d38681dd199c0ee61d.png" alt="">&lt;/p>
&lt;p>群里一位同学看到这个问题笑了，说：&amp;ldquo;这哪是 JVM 的 Bug，分明是线程安全问题嘛。很明显，你这是在操作两个字段 a 和 b，有线程安全问题，应该为 add 方法加上锁，确保 a 和 b 的 ++ 是原子性的，就不会错乱了。&amp;ldquo;随后，他为 add 方法加上了锁：&lt;/p>
&lt;pre tabindex="0">&lt;code>public synchronized void add()
&lt;/code>&lt;/pre>&lt;p>但，加锁后问题并没有解决。&lt;/p>
&lt;p>我们来仔细想一下，为什么锁可以解决线程安全问题呢。因为只有一个线程可以拿到锁，所以加锁后的代码中的资源操作是线程安全的。但是，&lt;strong>这个案例中的 add 方法始终只有一个线程在操作，显然只为 add 方法加锁是没用的&lt;/strong>。&lt;/p>
&lt;p>之所以出现这种错乱，是因为两个线程是交错执行 add 和 compare 方法中的业务逻辑，而且这些业务逻辑不是原子性的：a++ 和 b++ 操作中可以穿插在 compare 方法的比较代码中；更需要注意的是，a&amp;lt;b 这种比较操作在字节码层面是加载 a、加载 b 和比较三步，代码虽然是一行但也不是原子性的。&lt;/p>
&lt;p>所以，正确的做法应该是，为 add 和 compare 都加上方法锁，确保 add 方法执行时，compare 无法读取 a 和 b：&lt;/p>
&lt;pre tabindex="0">&lt;code>public synchronized void add()
public synchronized void compare()
&lt;/code>&lt;/pre>&lt;p>所以，使用锁解决问题之前一定要理清楚，我们要保护的是什么逻辑，多线程执行的情况又是怎样的。&lt;/p>
&lt;h1 id="加锁前要清楚锁和被保护的对象是不是一个层面的">加锁前要清楚锁和被保护的对象是不是一个层面的&lt;/h1>
&lt;p>除了没有分析清线程、业务逻辑和锁三者之间的关系随意添加无效的方法锁外，还有一种比较常见的错误是，没有理清楚锁和要保护的对象是否是一个层面的。&lt;/p>
&lt;p>我们知道&lt;strong>静态字段属于类，类级别的锁才能保护；而非静态字段属于类实例，实例级别的锁就可以保护。&lt;/strong>&lt;/p>
&lt;p>先看看这段代码有什么问题：在类 Data 中定义了一个静态的 int 字段 counter 和一个非静态的 wrong 方法，实现 counter 字段的累加操作。&lt;/p>
&lt;pre tabindex="0">&lt;code>class Data {
@Getter
private static int counter = 0;
public static int reset() {
counter = 0;
return counter;
}
public synchronized void wrong() {
counter++;
}
}
&lt;/code>&lt;/pre>&lt;p>写一段代码测试下：&lt;/p>
&lt;pre tabindex="0">&lt;code>@GetMapping(&amp;#34;wrong&amp;#34;)
public int wrong(@RequestParam(value = &amp;#34;count&amp;#34;, defaultValue = &amp;#34;1000000&amp;#34;) int count) {
Data.reset();
//多线程循环一定次数调用Data类不同实例的wrong方法
IntStream.rangeClosed(1, count).parallel().forEach(i -&amp;gt; new Data().wrong());
return Data.getCounter();
}
&lt;/code>&lt;/pre>&lt;p>因为默认运行 100 万次，所以执行后应该输出 100 万，但页面输出的是 639242：&lt;br>
&lt;img src="https://static001.geekbang.org/resource/image/77/0b/777f520e9d0be89b66e814d3e7c1a30b.png" alt="">&lt;/p>
&lt;p>我们来分析下为什么会出现这个问题吧。&lt;/p>
&lt;p>在非静态的 wrong 方法上加锁，只能确保多个线程无法执行同一个实例的 wrong 方法，却不能保证不会执行不同实例的 wrong 方法。而静态的 counter 在多个实例中共享，所以必然会出现线程安全问题。&lt;/p>
&lt;p>理清思路后，修正方法就很清晰了：同样在类中定义一个 Object 类型的静态字段，在操作 counter 之前对这个字段加锁。&lt;/p>
&lt;pre tabindex="0">&lt;code>class Data {
@Getter
private static int counter = 0;
private static Object locker = new Object();
public void right() {
synchronized (locker) {
counter++;
}
}
}
&lt;/code>&lt;/pre>&lt;p>你可能要问了，把 wrong 方法定义为静态不就可以了，这个时候锁是类级别的。可以是可以，但我们不可能为了解决线程安全问题改变代码结构，把实例方法改为静态方法。&lt;/p>
&lt;p>感兴趣的同学还可以从字节码以及 JVM 的层面继续探索一下，代码块级别的 synchronized 和方法上标记 synchronized 关键字，在实现上有什么区别。&lt;/p>
&lt;h1 id="加锁要考虑锁的粒度和场景问题">加锁要考虑锁的粒度和场景问题&lt;/h1>
&lt;p>在方法上加 synchronized 关键字实现加锁确实简单，也因此我曾看到一些业务代码中几乎所有方法都加了 synchronized，但这种滥用 synchronized 的做法：&lt;/p>
&lt;ul>
&lt;li>一是，没必要。通常情况下 60% 的业务代码是三层架构，数据经过无状态的 Controller、Service、Repository 流转到数据库，没必要使用 synchronized 来保护什么数据。&lt;/li>
&lt;li>二是，可能会极大地降低性能。使用 Spring 框架时，默认情况下 Controller、Service、Repository 是单例的，加上 synchronized 会导致整个程序几乎就只能支持单线程，造成极大的性能问题。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>即使我们确实有一些共享资源需要保护，也要尽可能降低锁的粒度，仅对必要的代码块甚至是需要保护的资源本身加锁。&lt;/strong>&lt;/p>
&lt;p>比如，在业务代码中，有一个 ArrayList 因为会被多个线程操作而需要保护，又有一段比较耗时的操作（代码中的 slow 方法）不涉及线程安全问题，应该如何加锁呢？&lt;/p>
&lt;p>错误的做法是，给整段业务逻辑加锁，把 slow 方法和操作 ArrayList 的代码同时纳入 synchronized 代码块；更合适的做法是，把加锁的粒度降到最低，只在操作 ArrayList 的时候给这个 ArrayList 加锁。&lt;/p>
&lt;pre tabindex="0">&lt;code>private List&amp;lt;Integer&amp;gt; data = new ArrayList&amp;lt;&amp;gt;();
//不涉及共享资源的慢方法
private void slow() {
try {
TimeUnit.MILLISECONDS.sleep(10);
} catch (InterruptedException e) {
}
}
//错误的加锁方法
@GetMapping(&amp;#34;wrong&amp;#34;)
public int wrong() {
long begin = System.currentTimeMillis();
IntStream.rangeClosed(1, 1000).parallel().forEach(i -&amp;gt; {
//加锁粒度太粗了
synchronized (this) {
slow();
data.add(i);
}
});
log.info(&amp;#34;took:{}&amp;#34;, System.currentTimeMillis() - begin);
return data.size();
}
//正确的加锁方法
@GetMapping(&amp;#34;right&amp;#34;)
public int right() {
long begin = System.currentTimeMillis();
IntStream.rangeClosed(1, 1000).parallel().forEach(i -&amp;gt; {
slow();
//只对List加锁
synchronized (data) {
data.add(i);
}
});
log.info(&amp;#34;took:{}&amp;#34;, System.currentTimeMillis() - begin);
return data.size();
}
&lt;/code>&lt;/pre>&lt;p>执行这段代码，同样是 1000 次业务操作，正确加锁的版本耗时 1.4 秒，而对整个业务逻辑加锁的话耗时 11 秒。&lt;br>
&lt;img src="https://static001.geekbang.org/resource/image/1c/43/1cb278c010719ee00d988dbb2a42c543.png" alt="">&lt;/p>
&lt;p>&lt;strong>如果精细化考虑了锁应用范围后，性能还无法满足需求的话，我们就要考虑另一个维度的粒度问题了，即：区分读写场景以及资源的访问冲突，考虑使用悲观方式的锁还是乐观方式的锁。&lt;/strong>&lt;/p>
&lt;p>一般业务代码中，很少需要进一步考虑这两种更细粒度的锁，所以我只和你分享几个大概的结论，你可以根据自己的需求来考虑是否有必要进一步优化：&lt;/p>
&lt;ul>
&lt;li>对于读写比例差异明显的场景，考虑使用 ReentrantReadWriteLock 细化区分读写锁，来提高性能。&lt;/li>
&lt;li>如果你的 JDK 版本高于 1.8、共享资源的冲突概率也没那么大的话，考虑使用 StampedLock 的乐观读的特性，进一步提高性能。&lt;/li>
&lt;li>JDK 里 ReentrantLock 和 ReentrantReadWriteLock 都提供了公平锁的版本，在没有明确需求的情况下不要轻易开启公平锁特性，在任务很轻的情况下开启公平锁可能会让性能下降上百倍。&lt;/li>
&lt;/ul>
&lt;h1 id="多把锁要小心死锁问题">多把锁要小心死锁问题&lt;/h1>
&lt;p>刚才我们聊到锁的粒度够用就好，这就意味着我们的程序逻辑中有时会存在一些细粒度的锁。但一个业务逻辑如果涉及多把锁，容易产生死锁问题。&lt;/p>
&lt;p>之前我遇到过这样一个案例：下单操作需要锁定订单中多个商品的库存，拿到所有商品的锁之后进行下单扣减库存操作，全部操作完成之后释放所有的锁。代码上线后发现，下单失败概率很高，失败后需要用户重新下单，极大影响了用户体验，还影响到了销量。&lt;/p>
&lt;p>经排查发现是死锁引起的问题，背后原因是扣减库存的顺序不同，导致并发的情况下多个线程可能相互持有部分商品的锁，又等待其他线程释放另一部分商品的锁，于是出现了死锁问题。&lt;/p>
&lt;p>接下来，我们剖析一下核心的业务代码。&lt;/p>
&lt;p>首先，定义一个商品类型，包含商品名、库存剩余和商品的库存锁三个属性，每一种商品默认库存 1000 个；然后，初始化 10 个这样的商品对象来模拟商品清单：&lt;/p>
&lt;pre tabindex="0">&lt;code>@Data
@RequiredArgsConstructor
static class Item {
final String name; //商品名
int remaining = 1000; //库存剩余
@ToString.Exclude //ToString不包含这个字段
ReentrantLock lock = new ReentrantLock();
}
&lt;/code>&lt;/pre>&lt;p>随后，写一个方法模拟在购物车进行商品选购，每次从商品清单（items 字段）中随机选购三个商品（为了逻辑简单，我们不考虑每次选购多个同类商品的逻辑，购物车中不体现商品数量）：&lt;/p>
&lt;pre tabindex="0">&lt;code>private List&amp;lt;Item&amp;gt; createCart() {
return IntStream.rangeClosed(1, 3)
.mapToObj(i -&amp;gt; &amp;#34;item&amp;#34; + ThreadLocalRandom.current().nextInt(items.size()))
.map(name -&amp;gt; items.get(name)).collect(Collectors.toList());
}
&lt;/code>&lt;/pre>&lt;p>下单代码如下：先声明一个 List 来保存所有获得的锁，然后遍历购物车中的商品依次尝试获得商品的锁，最长等待 10 秒，获得全部锁之后再扣减库存；如果有无法获得锁的情况则解锁之前获得的所有锁，返回 false 下单失败。&lt;/p>
&lt;pre tabindex="0">&lt;code>private boolean createOrder(List&amp;lt;Item&amp;gt; order) {
//存放所有获得的锁
List&amp;lt;ReentrantLock&amp;gt; locks = new ArrayList&amp;lt;&amp;gt;();
for (Item item : order) {
try {
//获得锁10秒超时
if (item.lock.tryLock(10, TimeUnit.SECONDS)) {
locks.add(item.lock);
} else {
locks.forEach(ReentrantLock::unlock);
return false;
}
} catch (InterruptedException e) {
}
}
//锁全部拿到之后执行扣减库存业务逻辑
try {
order.forEach(item -&amp;gt; item.remaining--);
} finally {
locks.forEach(ReentrantLock::unlock);
}
return true;
}
&lt;/code>&lt;/pre>&lt;p>我们写一段代码测试这个下单操作。模拟在多线程情况下进行 100 次创建购物车和下单操作，最后通过日志输出成功的下单次数、总剩余的商品个数、100 次下单耗时，以及下单完成后的商品库存明细：&lt;/p>
&lt;pre tabindex="0">&lt;code>@GetMapping(&amp;#34;wrong&amp;#34;)
public long wrong() {
long begin = System.currentTimeMillis();
//并发进行100次下单操作，统计成功次数
long success = IntStream.rangeClosed(1, 100).parallel()
.mapToObj(i -&amp;gt; {
List&amp;lt;Item&amp;gt; cart = createCart();
return createOrder(cart);
})
.filter(result -&amp;gt; result)
.count();
log.info(&amp;#34;success:{} totalRemaining:{} took:{}ms items:{}&amp;#34;,
success,
items.entrySet().stream().map(item -&amp;gt; item.getValue().remaining).reduce(0, Integer::sum),
System.currentTimeMillis() - begin, items);
return success;
}
&lt;/code>&lt;/pre>&lt;p>运行程序，输出如下日志：&lt;br>
&lt;img src="https://static001.geekbang.org/resource/image/14/05/141a5ed915e08e50c0f6b066bea36e05.png" alt="">&lt;/p>
&lt;p>可以看到，100 次下单操作成功了 65 次，10 种商品总计 10000 件，库存总计为 9805，消耗了 195 件符合预期（65 次下单成功，每次下单包含三件商品），总耗时 50 秒。&lt;/p>
&lt;p>为什么会这样呢？&lt;/p>
&lt;p>使用 JDK 自带的 VisualVM 工具来跟踪一下，重新执行方法后不久就可以看到，线程 Tab 中提示了死锁问题，根据提示点击右侧线程 Dump 按钮进行线程抓取操作：&lt;br>
&lt;img src="https://static001.geekbang.org/resource/image/ff/ce/ff24ac10bd0635ef4bf5987038b622ce.png" alt="">&lt;/p>
&lt;p>查看抓取出的线程栈，在页面中部可以看到如下日志：&lt;br>
&lt;img src="https://static001.geekbang.org/resource/image/c3/42/c32cb32eb5433aae3b392738a80bca42.png" alt="">&lt;/p>
&lt;p>显然，&lt;strong>是出现了死锁，线程 4 在等待的一个锁被线程 3 持有，线程 3 在等待的另一把锁被线程 4 持有&lt;/strong>。&lt;/p>
&lt;p>那为什么会有死锁问题呢？&lt;/p>
&lt;p>我们仔细回忆一下购物车添加商品的逻辑，随机添加了三种商品，假设一个购物车中的商品是 item1 和 item2，另一个购物车中的商品是 item2 和 item1，一个线程先获取到了 item1 的锁，同时另一个线程获取到了 item2 的锁，然后两个线程接下来要分别获取 item2 和 item1 的锁，这个时候锁已经被对方获取了，只能相互等待一直到 10 秒超时。&lt;/p>
&lt;p>其实，避免死锁的方案很简单，&lt;strong>为购物车中的商品排一下序，让所有的线程一定是先获取 item1 的锁然后获取 item2 的锁，就不会有问题了&lt;/strong>。所以，我只需要修改一行代码，对 createCart 获得的购物车按照商品名进行排序即可：&lt;/p>
&lt;pre tabindex="0">&lt;code>@GetMapping(&amp;#34;right&amp;#34;)
public long right() {
...
.
long success = IntStream.rangeClosed(1, 100).parallel()
.mapToObj(i -&amp;gt; {
List&amp;lt;Item&amp;gt; cart = createCart().stream()
.sorted(Comparator.comparing(Item::getName))
.collect(Collectors.toList());
return createOrder(cart);
})
.filter(result -&amp;gt; result)
.count();
...
return success;
}
&lt;/code>&lt;/pre>&lt;p>测试一下 right 方法，不管执行多少次都是 100 次成功下单，而且性能相当高，达到了 3000 以上的 TPS：&lt;br>
&lt;img src="https://static001.geekbang.org/resource/image/a4/e4/a41d077eeecc8b922503409d13a465e4.png" alt="">&lt;/p>
&lt;p>这个案例中，虽然产生了死锁问题，但因为尝试获取锁的操作并不是无限阻塞的，所以没有造成永久死锁，之后的改进就是避免循环等待，通过对购物车的商品进行排序来实现有顺序的加锁，避免循环等待。&lt;/p>
&lt;h1 id="重点回顾">重点回顾&lt;/h1>
&lt;p>我们一起总结回顾下，使用锁来解决多线程情况下线程安全问题的坑吧。&lt;/p>
&lt;p>第一，使用 synchronized 加锁虽然简单，但我们首先要弄清楚共享资源是类还是实例级别的、会被哪些线程操作，synchronized 关联的锁对象或方法又是什么范围的。&lt;/p>
&lt;p>第二，加锁尽可能要考虑粒度和场景，锁保护的代码意味着无法进行多线程操作。对于 Web 类型的天然多线程项目，对方法进行大范围加锁会显著降级并发能力，要考虑尽可能地只为必要的代码块加锁，降低锁的粒度；而对于要求超高性能的业务，还要细化考虑锁的读写场景，以及悲观优先还是乐观优先，尽可能针对明确场景精细化加锁方案，可以在适当的场景下考虑使用 ReentrantReadWriteLock、StampedLock 等高级的锁工具类。&lt;/p>
&lt;p>第三，业务逻辑中有多把锁时要考虑死锁问题，通常的规避方案是，避免无限等待和循环等待。&lt;/p>
&lt;p>此外，&lt;strong>如果业务逻辑中锁的实现比较复杂的话，要仔细看看加锁和释放是否配对，是否有遗漏释放或重复释放的可能性；并且要考虑锁自动超时释放了，而业务逻辑却还在进行的情况下，如果别的线线程或进程拿到了相同的锁，可能会导致重复执行&lt;/strong>。&lt;/p>
&lt;p>为演示方便，今天的案例是在 Controller 的逻辑中开新的线程或使用线程池进行并发模拟，我们当然可以意识到哪些对象是并发操作的。但对于 Web 应用程序的天然多线程场景，你可能更容易忽略这点，并且也可能因为误用锁降低应用整体的吞吐。&lt;strong>如果你的业务代码涉及复杂的锁操作，强烈建议 Mock 相关外部接口或数据库操作后对应用代码进行压测，通过压测排除锁误用带来的性能问题和死锁问题&lt;/strong>。&lt;/p>
&lt;p>今天用到的代码，我都放在了 GitHub 上，你可以点击这个链接查看。&lt;/p>
&lt;h1 id="思考与讨论">思考与讨论&lt;/h1>
&lt;ul>
&lt;li>本文开头的例子里，变量 a、b 都使用了 volatile 关键字，你知道原因吗？我之前遇到过这样一个坑：我们开启了一个线程无限循环来跑一些任务，有一个 bool 类型的变量来控制循环的退出，默认为 true 代表执行，一段时间后主线程将这个变量设置为了 false。如果这个变量不是 volatile 修饰的，子线程可以退出吗？你能否解释其中的原因呢？&lt;/li>
&lt;li>文末我们又提了两个坑，一是加锁和释放没有配对的问题，二是锁自动释放导致的重复逻辑执行的问题。你有什么方法来发现和解决这两种问题吗？&lt;/li>
&lt;/ul>
&lt;p>在使用锁的过程中，你还遇到过其他坑吗？我是朱晔，欢迎在评论区与我留言分享你的想法，也欢迎你把这篇文章分享给你的朋友或同事，一起交流。&lt;/p></description></item><item><title>极客专栏: 02丨命令源码文件</title><link>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/go-%E8%AF%AD%E8%A8%80%E6%A0%B8%E5%BF%83-36-%E8%AE%B2/02%E4%B8%A8%E5%91%BD%E4%BB%A4%E6%BA%90%E7%A0%81%E6%96%87%E4%BB%B6/</link><pubDate>Sun, 29 May 2022 00:00:00 +0000</pubDate><guid>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/go-%E8%AF%AD%E8%A8%80%E6%A0%B8%E5%BF%83-36-%E8%AE%B2/02%E4%B8%A8%E5%91%BD%E4%BB%A4%E6%BA%90%E7%A0%81%E6%96%87%E4%BB%B6/</guid><description>
&lt;p>我们已经知道，环境变量 GOPATH 指向的是一个或多个工作区，每个工作区中都会有以代码包为基本组织形式的源码文件。&lt;/p>
&lt;p>&lt;strong>这里的源码文件又分为三种，即：命令源码文件、库源码文件和测试源码文件，它们都有着不同的用途和编写规则。（&lt;/strong> 我在&lt;a href="https://time.geekbang.org/column/article/13540?utm_source=weibo&amp;amp;utm_medium=xuxiaoping&amp;amp;utm_campaign=promotion&amp;amp;utm_content=columns">&amp;ldquo;预习篇&amp;quot;的基础知识图&lt;/a>介绍过这三种文件的基本情况。）&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/9d/cb/9d08647d238e21e7184d60c0afe5afcb.png" alt="">&lt;/p>
&lt;p>（长按保存大图查看）&lt;/p>
&lt;p>今天，我们就沿着&lt;strong>命令源码文件&lt;/strong>的知识点，展开更深层级的学习。&lt;/p>
&lt;hr>
&lt;p>一旦开始学习用编程语言编写程序，我们就一定希望在编码的过程中及时地得到反馈，只有这样才能清楚对错。实际上，我们的有效学习和进步，都是通过不断地接受反馈和执行修正实现的。&lt;/p>
&lt;p>对于 Go 语言学习者来说，你在学习阶段中，也一定会经常编写可以直接运行的程序。这样的程序肯定会涉及命令源码文件的编写，而且，命令源码文件也可以很方便地用&lt;code>go run&lt;/code>命令启动。&lt;/p>
&lt;p>那么，&lt;strong>我今天的问题就是：命令源码文件的用途是什么，怎样编写它？&lt;/strong>&lt;/p>
&lt;p>这里，我给出你一个&lt;strong>参考的回答&lt;/strong>：命令源码文件是程序的运行入口，是每个可独立运行的程序必须拥有的。我们可以通过构建或安装，生成与其对应的可执行文件，后者一般会与该命令源码文件的直接父目录同名。&lt;/p>
&lt;p>&lt;strong>如果一个源码文件声明属于&lt;code>main&lt;/code>包，并且包含一个无参数声明且无结果声明的&lt;code>main&lt;/code>函数，那么它就是命令源码文件。&lt;/strong> 就像下面这段代码：&lt;/p>
&lt;pre>&lt;code>package main
import &amp;quot;fmt&amp;quot;
func main() {
fmt.Println(&amp;quot;Hello, world!&amp;quot;)
}
&lt;/code>&lt;/pre>
&lt;p>如果你把这段代码存成 demo1.go 文件，那么运行&lt;code>go run demo1.go&lt;/code>命令后就会在屏幕（标准输出）中看到&lt;code>Hello, world!&lt;/code>&lt;/p>
&lt;blockquote>
&lt;p>当需要模块化编程时，我们往往会将代码拆分到多个文件，甚至拆分到不同的代码包中。但无论怎样，对于一个独立的程序来说，命令源码文件永远只会也只能有一个。如果有与命令源码文件同包的源码文件，那么它们也应该声明属于&lt;code>main&lt;/code>包。&lt;/p>
&lt;/blockquote>
&lt;h2 id="问题解析">问题解析&lt;/h2>
&lt;p>命令源码文件如此重要，以至于它毫无疑问地成为了我们学习 Go 语言的第一助手。不过，只会打印&lt;code>Hello, world&lt;/code>是远远不够的，咱们千万不要成为&amp;quot;Hello, world&amp;quot;党。既然决定学习 Go 语言，你就应该从每一个知识点深入下去。&lt;/p>
&lt;p>无论是 Linux 还是 Windows，如果你用过命令行（command line）的话，肯定就会知道几乎所有命令（command）都是可以接收参数（argument）的。通过构建或安装命令源码文件，生成的可执行文件就可以被视为&amp;quot;命令&amp;rdquo;，既然是命令，那么就应该具备接收参数的能力。&lt;/p>
&lt;p>下面，我就带你深入了解一下与命令参数的接收和解析有关的一系列问题。&lt;/p>
&lt;h2 id="知识精讲">知识精讲&lt;/h2>
&lt;h3 id="1-命令源码文件怎样接收参数">1. 命令源码文件怎样接收参数&lt;/h3>
&lt;p>我们先看一段不完整的代码：&lt;/p>
&lt;pre>&lt;code>package main
import (
// 需在此处添加代码。[1]
&amp;quot;fmt&amp;quot;
)
var name string
func init() {
// 需在此处添加代码。[2]
}
func main() {
// 需在此处添加代码。[3]
fmt.Printf(&amp;quot;Hello, %s!\n&amp;quot;, name)
}
&lt;/code>&lt;/pre>
&lt;p>&lt;strong>如果邀请你帮助我，在注释处添加相应的代码，并让程序实现&amp;quot;根据运行程序时给定的参数问候某人&amp;quot;的功能，你会打算怎样做？&lt;/strong>&lt;/p>
&lt;p>如果你知道做法，请现在就动手实现它。如果不知道也不要着急，咱们一起来搞定。&lt;/p>
&lt;p>首先，Go 语言标准库中有一个代码包专门用于接收和解析命令参数。这个代码包的名字叫&lt;code>flag&lt;/code>。&lt;/p>
&lt;p>我之前说过，如果想要在代码中使用某个包中的程序实体，那么应该先导入这个包。因此，我们需要在&lt;code>[1]&lt;/code>处添加代码&lt;code>&amp;quot;flag&amp;quot;&lt;/code>。注意，这里应该在代码包导入路径的前后加上英文半角的引号。如此一来，上述代码导入了&lt;code>flag&lt;/code>和&lt;code>fmt&lt;/code>这两个包。&lt;/p>
&lt;p>其次，人名肯定是由字符串代表的。所以我们要在&lt;code>[2]&lt;/code>处添加调用&lt;code>flag&lt;/code>包的&lt;code>StringVar&lt;/code>函数的代码。就像这样：&lt;/p>
&lt;pre>&lt;code>flag.StringVar(&amp;amp;name, &amp;quot;name&amp;quot;, &amp;quot;everyone&amp;quot;, &amp;quot;The greeting object.&amp;quot;)
&lt;/code>&lt;/pre>
&lt;p>函数&lt;code>flag.StringVar&lt;/code>接受 4 个参数。&lt;/p>
&lt;p>第 1 个参数是用于存储该命令参数值的地址，具体到这里就是在前面声明的变量&lt;code>name&lt;/code>的地址了，由表达式&lt;code>&amp;amp;name&lt;/code>表示。&lt;/p>
&lt;p>第 2 个参数是为了指定该命令参数的名称，这里是&lt;code>name&lt;/code>。&lt;/p>
&lt;p>第 3 个参数是为了指定在未追加该命令参数时的默认值，这里是&lt;code>everyone&lt;/code>。&lt;/p>
&lt;p>至于第 4 个函数参数，即是该命令参数的简短说明了，这在打印命令说明时会用到。&lt;/p>
&lt;p>顺便说一下，还有一个与&lt;code>flag.StringVar&lt;/code>函数类似的函数，叫&lt;code>flag.String&lt;/code>。这两个函数的区别是，后者会直接返回一个已经分配好的用于存储命令参数值的地址。如果使用它的话，我们就需要把&lt;/p>
&lt;pre>&lt;code>var name string
&lt;/code>&lt;/pre>
&lt;p>改为&lt;/p>
&lt;pre>&lt;code>var name = flag.String(&amp;quot;name&amp;quot;, &amp;quot;everyone&amp;quot;, &amp;quot;The greeting object.&amp;quot;)
&lt;/code>&lt;/pre>
&lt;p>所以，如果我们使用&lt;code>flag.String&lt;/code>函数就需要改动原有的代码。这样并不符合上述问题的要求。&lt;/p>
&lt;p>再说最后一个填空。我们需要在&lt;code>[3]&lt;/code>处添加代码&lt;code>flag.Parse()&lt;/code>。函数&lt;code>flag.Parse&lt;/code>用于真正解析命令参数，并把它们的值赋给相应的变量。&lt;/p>
&lt;p>对该函数的调用必须在所有命令参数存储载体的声明（这里是对变量&lt;code>name&lt;/code>的声明）和设置（这里是在&lt;code>[2]&lt;/code>处对&lt;code>flag.StringVar&lt;/code>函数的调用）之后，并且在读取任何命令参数值之前进行。&lt;/p>
&lt;p>正因为如此，我们最好把&lt;code>flag.Parse()&lt;/code>放在&lt;code>main&lt;/code>函数的函数体的第一行。&lt;/p>
&lt;h3 id="2-怎样在运行命令源码文件的时候传入参数又怎样查看参数的使用说明">2. 怎样在运行命令源码文件的时候传入参数，又怎样查看参数的使用说明&lt;/h3>
&lt;p>如果我们把上述代码存成名为 demo2.go 的文件，那么运行如下命令就可以为参数&lt;code>name&lt;/code>传值：&lt;/p>
&lt;pre>&lt;code>go run demo2.go -name=&amp;quot;Robert&amp;quot;
&lt;/code>&lt;/pre>
&lt;p>运行后，打印到标准输出（stdout）的内容会是：&lt;/p>
&lt;pre>&lt;code>Hello, Robert!
&lt;/code>&lt;/pre>
&lt;p>另外，如果想查看该命令源码文件的参数说明，可以这样做：&lt;/p>
&lt;pre>&lt;code>$ go run demo2.go --help
&lt;/code>&lt;/pre>
&lt;p>其中的&lt;code>$&lt;/code>表示我们是在命令提示符后运行&lt;code>go run&lt;/code>命令的。运行后输出的内容会类似：&lt;/p>
&lt;pre>&lt;code>Usage of /var/folders/ts/7lg_tl_x2gd_k1lm5g_48c7w0000gn/T/go-build155438482/b001/exe/demo2:
-name string
The greeting object. (default &amp;quot;everyone&amp;quot;)
exit status 2
&lt;/code>&lt;/pre>
&lt;p>你可能不明白下面这段输出代码的意思。&lt;/p>
&lt;pre>&lt;code>/var/folders/ts/7lg_tl_x2gd_k1lm5g_48c7w0000gn/T/go-build155438482/b001/exe/demo2
&lt;/code>&lt;/pre>
&lt;p>这其实是&lt;code>go run&lt;/code>命令构建上述命令源码文件时临时生成的可执行文件的完整路径。&lt;/p>
&lt;p>如果我们先构建这个命令源码文件再运行生成的可执行文件，像这样：&lt;/p>
&lt;pre>&lt;code>$ go build demo2.go
$ ./demo2 --help
&lt;/code>&lt;/pre>
&lt;p>那么输出就会是&lt;/p>
&lt;pre>&lt;code>Usage of ./demo2:
-name string
The greeting object. (default &amp;quot;everyone&amp;quot;)
&lt;/code>&lt;/pre>
&lt;h3 id="3-怎样自定义命令源码文件的参数使用说明">3. 怎样自定义命令源码文件的参数使用说明&lt;/h3>
&lt;p>这有很多种方式，最简单的一种方式就是对变量&lt;code>flag.Usage&lt;/code>重新赋值。&lt;code>flag.Usage&lt;/code>的类型是&lt;code>func()&lt;/code>，即一种无参数声明且无结果声明的函数类型。&lt;/p>
&lt;p>&lt;code>flag.Usage&lt;/code>变量在声明时就已经被赋值了，所以我们才能够在运行命令&lt;code>go run demo2.go --help&lt;/code>时看到正确的结果。&lt;/p>
&lt;p>注意，对&lt;code>flag.Usage&lt;/code>的赋值必须在调用&lt;code>flag.Parse&lt;/code>函数之前。&lt;/p>
&lt;p>现在，我们把 demo2.go 另存为 demo3.go，然后在&lt;code>main&lt;/code>函数体的开始处加入如下代码。&lt;/p>
&lt;pre>&lt;code>flag.Usage = func() {
fmt.Fprintf(os.Stderr, &amp;quot;Usage of %s:\n&amp;quot;, &amp;quot;question&amp;quot;)
flag.PrintDefaults()
}
&lt;/code>&lt;/pre>
&lt;p>那么当运行&lt;/p>
&lt;pre>&lt;code>$ go run demo3.go --help
&lt;/code>&lt;/pre>
&lt;p>后，就会看到&lt;/p>
&lt;pre>&lt;code>Usage of question:
-name string
The greeting object. (default &amp;quot;everyone&amp;quot;)
exit status 2
&lt;/code>&lt;/pre>
&lt;p>现在再深入一层，我们在调用&lt;code>flag&lt;/code>包中的一些函数（比如&lt;code>StringVar&lt;/code>、&lt;code>Parse&lt;/code>等等）的时候，实际上是在调用&lt;code>flag.CommandLine&lt;/code>变量的对应方法。&lt;/p>
&lt;p>&lt;code>flag.CommandLine&lt;/code>相当于默认情况下的命令参数容器。所以，通过对&lt;code>flag.CommandLine&lt;/code>重新赋值，我们可以更深层次地定制当前命令源码文件的参数使用说明。&lt;/p>
&lt;p>现在我们把&lt;code>main&lt;/code>函数体中的那条对&lt;code>flag.Usage&lt;/code>变量的赋值语句注销掉，然后在&lt;code>init&lt;/code>函数体的开始处添加如下代码：&lt;/p>
&lt;pre>&lt;code>flag.CommandLine = flag.NewFlagSet(&amp;quot;&amp;quot;, flag.ExitOnError)
flag.CommandLine.Usage = func() {
fmt.Fprintf(os.Stderr, &amp;quot;Usage of %s:\n&amp;quot;, &amp;quot;question&amp;quot;)
flag.PrintDefaults()
}
&lt;/code>&lt;/pre>
&lt;p>再运行命令&lt;code>go run demo3.go --help&lt;/code>后，其输出会与上一次的输出的一致。不过后面这种定制的方法更加灵活。比如，当我们把为&lt;code>flag.CommandLine&lt;/code>赋值的那条语句改为&lt;/p>
&lt;pre>&lt;code>flag.CommandLine = flag.NewFlagSet(&amp;quot;&amp;quot;, flag.PanicOnError)
&lt;/code>&lt;/pre>
&lt;p>后，再运行&lt;code>go run demo3.go --help&lt;/code>命令就会产生另一种输出效果。这是由于我们在这里传给&lt;code>flag.NewFlagSet&lt;/code>函数的第二个参数值是&lt;code>flag.PanicOnError&lt;/code>。&lt;code>flag.PanicOnError&lt;/code>和&lt;code>flag.ExitOnError&lt;/code>都是预定义在&lt;code>flag&lt;/code>包中的常量。&lt;/p>
&lt;p>&lt;code>flag.ExitOnError&lt;/code>的含义是，告诉命令参数容器，当命令后跟&lt;code>--help&lt;/code>或者参数设置的不正确的时候，在打印命令参数使用说明后以状态码&lt;code>2&lt;/code>结束当前程序。&lt;/p>
&lt;p>状态码&lt;code>2&lt;/code>代表用户错误地使用了命令，而&lt;code>flag.PanicOnError&lt;/code>与之的区别是在最后抛出&amp;quot;运行时恐慌（panic）&amp;quot;。&lt;/p>
&lt;p>上述两种情况都会在我们调用&lt;code>flag.Parse&lt;/code>函数时被触发。顺便提一句，&amp;ldquo;运行时恐慌&amp;quot;是 Go 程序错误处理方面的概念。关于它的抛出和恢复方法，我在本专栏的后续部分中会讲到。&lt;/p>
&lt;p>下面再进一步，我们索性不用全局的&lt;code>flag.CommandLine&lt;/code>变量，转而自己创建一个私有的命令参数容器。我们在函数外再添加一个变量声明：&lt;/p>
&lt;pre>&lt;code>var cmdLine = flag.NewFlagSet(&amp;quot;question&amp;quot;, flag.ExitOnError)
&lt;/code>&lt;/pre>
&lt;p>然后，我们把对&lt;code>flag.StringVar&lt;/code>的调用替换为对&lt;code>cmdLine.StringVar&lt;/code>调用，再把&lt;code>flag.Parse()&lt;/code>替换为&lt;code>cmdLine.Parse(os.Args[1:])&lt;/code>。&lt;/p>
&lt;p>其中的&lt;code>os.Args[1:]&lt;/code>指的就是我们给定的那些命令参数。这样做就完全脱离了&lt;code>flag.CommandLine&lt;/code>。&lt;code>*flag.FlagSet&lt;/code>类型的变量&lt;code>cmdLine&lt;/code>拥有很多有意思的方法。你可以去探索一下。我就不在这里一一讲述了。&lt;/p>
&lt;p>这样做的好处依然是更灵活地定制命令参数容器。但更重要的是，你的定制完全不会影响到那个全局变量&lt;code>flag.CommandLine&lt;/code>。&lt;/p>
&lt;p>&lt;strong>总结&lt;/strong>&lt;/p>
&lt;p>恭喜你！你现在已经走出了 Go 语言编程的第一步。你可以用 Go 编写命令，并可以让它们像众多操作系统命令那样被使用，甚至可以把它们嵌入到各种脚本中。&lt;/p>
&lt;p>虽然我为你讲解了命令源码文件的基本编写方法，并且也谈到了为了让它接受参数而需要做的各种准备工作，但这并不是全部。&lt;/p>
&lt;p>别担心，我在后面会经常提到它的。另外，如果你想详细了解&lt;code>flag&lt;/code>包的用法，可以到&lt;a href="https://golang.google.cn/pkg/flag/">这个网址&lt;/a>查看文档。或者直接使用&lt;code>godoc&lt;/code>命令在本地启动一个 Go 语言文档服务器。怎样使用&lt;code>godoc&lt;/code>命令？你可以参看&lt;a href="https://github.com/hyper0x/go_command_tutorial/blob/master/0.5.md">这里&lt;/a>。&lt;/p>
&lt;h2 id="思考题">思考题&lt;/h2>
&lt;p>我们已经见识过为命令源码文件传入字符串类型的参数值的方法，那还可以传入别的吗？这就是今天我留下的思考题。&lt;/p>
&lt;ol>
&lt;li>默认情况下，我们可以让命令源码文件接受哪些类型的参数值？&lt;/li>
&lt;li>我们可以把自定义的数据类型作为参数值的类型吗？如果可以，怎样做？&lt;/li>
&lt;/ol>
&lt;p>你可以通过查阅文档获得第一个问题的答案。记住，快速查看和理解文档是一项必备的技能。&lt;/p>
&lt;p>至于第二个问题，你回答起来可能会有些困难，因为这涉及了另一个问题：&amp;ldquo;怎样声明自己的数据类型？&amp;ldquo;这个问题我在专栏的后续部分中也会讲到。如果是这样，我希望你记下它和这里说的另一问题，并在能解决后者之后再来回答前者。&lt;/p>
&lt;p>&lt;a href="https://github.com/hyper0x/Golang_Puzzlers">戳此查看 Go 语言专栏文章配套详细代码。&lt;/a>&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/35/48/358e4e8578a706598e18a7dfed3ed648.jpg" alt="">&lt;/p></description></item><item><title>极客专栏: 02丨乱用英语：站在中国人的视角来看英文命名</title><link>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E4%BB%A3%E7%A0%81%E4%B9%8B%E4%B8%91/02%E4%B8%A8%E4%B9%B1%E7%94%A8%E8%8B%B1%E8%AF%AD%E7%AB%99%E5%9C%A8%E4%B8%AD%E5%9B%BD%E4%BA%BA%E7%9A%84%E8%A7%86%E8%A7%92%E6%9D%A5%E7%9C%8B%E8%8B%B1%E6%96%87%E5%91%BD%E5%90%8D/</link><pubDate>Sat, 28 May 2022 00:00:00 +0000</pubDate><guid>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E4%BB%A3%E7%A0%81%E4%B9%8B%E4%B8%91/02%E4%B8%A8%E4%B9%B1%E7%94%A8%E8%8B%B1%E8%AF%AD%E7%AB%99%E5%9C%A8%E4%B8%AD%E5%9B%BD%E4%BA%BA%E7%9A%84%E8%A7%86%E8%A7%92%E6%9D%A5%E7%9C%8B%E8%8B%B1%E6%96%87%E5%91%BD%E5%90%8D/</guid><description>
&lt;p>你好，我是郑晔。&lt;/p>
&lt;p>上一讲，我们讲了两种常见的命名的坏味道，这一讲的话题还是命名，只不过，这个主题是国外那些经典编程书籍所不曾涵盖的话题：英语命名。&lt;/p>
&lt;p>现在主流的程序设计语言都是以英语为基础的，且不说欧美人设计的各种语言，就连日本人设计的 Ruby、巴西人设计的 Lua，各种语法采用的也全都是英语。所以，想要成为一个优秀的程序员，会用英语写代码是必要的。&lt;/p>
&lt;p>这里并不是说，程序员的英语一定要多好，但&lt;strong>最低限度的要求是写出来的代码要像是在用英语表达&lt;/strong>。&lt;/p>
&lt;p>或许你听说过，甚至接触过国内的一些程序员用汉语拼音写代码，这就是一种典型的坏味道。鉴于现在的一些程序设计语言已经支持了 UTF-8 的编码格式，用汉语拼音写代码，还不如用汉字直接写代码。&lt;/p>
&lt;p>当然，这个坏味道实在是太低级了，我就不在这里深入讨论了。让我们来看看还有哪些可能会不经意间忽略的坏味道。&lt;/p>
&lt;h1 id="违反语法规则的命名">违反语法规则的命名&lt;/h1>
&lt;p>我们来看一段代码：&lt;/p>
&lt;pre tabindex="0">&lt;code>public void completedTranslate(final List&amp;lt;ChapterId&amp;gt; chapterIds) {
List&amp;lt;Chapter&amp;gt; chapters = repository.findByChapterIdIn(chapterIds);
chapters.forEach(Chapter::completedTranslate);
repository.saveAll(chapters);
}
&lt;/code>&lt;/pre>&lt;p>初看之下，这段代码写得还不错，它要做的是将一些章节的信息标记为翻译完成。似乎函数名也能反映这个意思，但仔细一看你就会发现问题。&lt;/p>
&lt;p>因为 completedTranslate 并不是一个正常的英语函数名。从这个名字你能看出，作者想表达的是&amp;quot;完成翻译&amp;quot;，因为是已经翻译完了，所以，他用了完成时的 completed，而翻译是 translate。这个函数名就成了 completedTranslate。由此，你可以看到，作者已经很用心了，但遗憾的是，这个名字还是起错了。&lt;/p>
&lt;p>一般来说，常见的命名规则是：&lt;strong>类名是一个名词，表示一个对象，而方法名则是一个动词，或者是动宾短语，表示一个动作&lt;/strong>。&lt;/p>
&lt;p>以此为标准衡量这个名字，completedTranslate 并不是一个有效的动宾结构。如果把这个名字改成动宾结构，只要把&amp;quot;完成&amp;quot;译为 complete，&amp;ldquo;翻译&amp;quot;用成它的名词形式 translation 就可以了。所以，这个函数名可以改成 completeTranslation：&lt;/p>
&lt;pre tabindex="0">&lt;code>public void completeTranslation(final List&amp;lt;ChapterId&amp;gt; chapterIds) {
List&amp;lt;Chapter&amp;gt; chapters = repository.findByChapterIdIn(chapterIds);
chapters.forEach(Chapter::completeTranslation);
repository.saveAll(chapters);
}
&lt;/code>&lt;/pre>&lt;p>这并不是一个复杂的坏味道，但这种坏味道在代码中却时常可以见到，比如，一个函数名是 retranslation，其表达的意图是重新翻译，&lt;strong>但作为函数名，它应该是一个动词&lt;/strong>，所以，正确的命名应该是 retranslate。&lt;/p>
&lt;p>其实，只要你懂得最基本的命名要求，知道最基本的英语规则，就完全能够发现这里的坏味道。比如，判断函数名里的动词是不是动词，宾语是不是一个名词？这并不需要英语有多么好。自己实在拿不准的时候，你就把这个词放到字典网站中查一下，确保别用错词性就好。&lt;/p>
&lt;p>对于大多数国内程序员来说，字典网站是我们的好朋友，是我们在写程序过程中不可或缺的一个好伙伴。不过，有些人使用字典网站也会很随意。&lt;/p>
&lt;h1 id="不准确的英语词汇">不准确的英语词汇&lt;/h1>
&lt;p>有一次，我们要实现一个章节审核的功能，一个同事先定义出了审核的状态：&lt;/p>
&lt;pre tabindex="0">&lt;code>public enum ChapterAuditStatus {
PENDING,
APPROVED,
REJECTED;
}
&lt;/code>&lt;/pre>&lt;p>你觉得这段代码有问题吗？如果看不出来，一点都不奇怪。如果你用审核作为关键字去字典网站上搜索，确实会得到 audit 这个词。所以，审核状态写成 AuditStatus 简直是再正常不过的事情了。&lt;/p>
&lt;p>然而，看到这个词的时候，我的第一反应就是这个词好像不太对。因为之前我实现了一个作品审核的功能，不过我写的定义是这样的：&lt;/p>
&lt;pre tabindex="0">&lt;code>public enum BookReviewStatus {
PENDING,
APPROVED,
REJECTED;
}
&lt;/code>&lt;/pre>&lt;p>抛开前缀不看，同样是审核，一个用了 audit，一个用了 review。这显然是一种不一致。本着代码一致性的考虑，我希望这两个定义应该采用同样的词汇。&lt;/p>
&lt;p>于是，我把 audit 和 review 同时放到了搜索引擎里查了一下。原来，audit 会有更官方的味道，更合适的翻译应该是审计，而 review 则有更多核查的意思，二者相比，review 更适合这里的场景。于是，章节的审核状态也统一使用了 review：&lt;/p>
&lt;pre tabindex="0">&lt;code>public enum ChapterReviewStatus {
PENDING,
APPROVED,
REJECTED;
}
&lt;/code>&lt;/pre>&lt;p>相比之下，这个坏味道是一个高级的坏味道，英语单词用得不准确。但这个问题确实是国内程序员不得不面对的一个尴尬的问题，我们的英语可能没有那么好，体会不到不同单词之间的差异。&lt;/p>
&lt;p>很多人习惯的做法就是把中文的词扔到字典网站，然后从诸多返回的结果中找一个自己看着顺眼的，而这也往往是很多问题出现的根源。这样写出来的程序看起来就像一个外国人在说中文，虽然你知道他在说的意思，但总觉得哪里怪怪的。&lt;/p>
&lt;p>**在这种情况下，****最好的解决方案还是建立起一个业务词汇表，千万不要臆想。**一般情况下，我们都可以去和业务方谈，共同确定一个词汇表，包含业务术语的中英文表达。这样在写代码的时候，你就可以参考这个词汇表给变量和函数命名。&lt;/p>
&lt;p>下面是一个词汇表的示例，从这个词汇表中你不难看出：一方面，词汇表给出的都是业务术语，同时也给出了在特定业务场景下的含义；另一方面，它也给出了相应的英文，省得你费劲心思去思考。当你遇到了一个词汇表中没有的术语怎么办呢？那就需要找出这个术语相应的解释，然后，补充到术语表里。&lt;br>
&lt;img src="https://static001.geekbang.org/resource/image/97/1e/976b74fd075d49cf27e198f38bdcec1e.jpg" alt="">&lt;/p>
&lt;p>建立词汇表的另一个关键点就是，&lt;strong>用集体智慧，而非个体智慧&lt;/strong>。你一个人的英语可能没那么好，但一群人总会找出一个合适的说法。我在《软件设计之美》里讲到领域驱动设计时，曾经讲过通用语言，其实，业务词汇表也应该是构建通用语言的一部分成果。&lt;/p>
&lt;h1 id="英语单词的拼写错误">英语单词的拼写错误&lt;/h1>
&lt;p>我再给你看一段曾经让我迷惑不已的代码：&lt;/p>
&lt;pre tabindex="0">&lt;code>public class QuerySort {
private final SortBy sortBy;
private final SortFiled sortFiled;
...
}
&lt;/code>&lt;/pre>&lt;p>初看这段代码时，我还想表扬代码的作者，他知道把查询的排序做一个封装，比起那些把字符串传来传去的做法要好很多。&lt;/p>
&lt;p>但仔细看一下代码，我脑子里就冒出了一系列问号。sortFiled 是啥？排序文件吗？为啥用的还是过去式？归档？&lt;/p>
&lt;p>被这段代码搞晕的我只好打开提交历史，找出这段代码的作者，向他求教。&lt;/p>
&lt;blockquote>
&lt;p>我：这个字段是啥意思？
同事：这是排序的字段啊。
我：排序的字段？
同事：你看，这个查询排序类有两个字段，一个是排序的方式，升序还是降序，另一个就是排序的字段。
我：字段这个单词是这么拼吗？
同事：不是吗？哦！是 field，拼错了，拼错了。&lt;/p>
&lt;/blockquote>
&lt;p>你看，是他把单词拼错了。&lt;/p>
&lt;p>其实，偶尔的拼写错误是不可避免的，这就像我们写文章的时候，出现错别字也是难免的。之所以要在这个专栏中把拼写错误作为一种独立的坏味道，是因为在很多国内程序员写的程序中，见到的拼写错误比例是偏高的。&lt;/p>
&lt;p>在这个故事里面，我都已经当面指出了问题，这个同事甚至都没有第一时间意识到自己的拼写是错误的，这其实说明了一种尴尬的现状：&lt;strong>很多程序员对英语的感觉并没有那么强。&lt;/strong>&lt;/p>
&lt;p>事实上，这个同事不止一次在代码里出现拼写错误了，一些拼写错误是很直白的，一眼就能看出来，所以，通常在代码评审的时候就能发现问题。这次的拼写错误刚好形成了另外一个有含义的单词，所以，我也被困住了。&lt;/p>
&lt;p>对今天的程序员来说，工具已经很进步了，&lt;strong>像 IntelliJ IDEA 这样的 IDE 甚至可以给你提示代码里有拼写错误（typo）&lt;/strong>，不少支持插件的工具也都有自己的拼写检查插件，比如Visual Studio Code 就有自己的拼写检查插件。在这些工具的帮助之下，我们只要稍微注意一下，就可以修正很多这样低级的错误。&lt;/p>
&lt;p>这一讲的内容几乎是完全针对国内程序员的。对于国外程序员来说，他们几乎不会犯这些错误。英语是程序员无论如何也绕不过去的一关，越是想成为优秀程序员，越要对英语有良好的感觉。当然，这里并不强求所有人的英语都能达到多好的程度，至少看到一些明显违反英语规则的代码，自己应该有能力看出来。&lt;/p>
&lt;p>英语和程序设计语言其实是一样的，想用好，唯有多多练习。我自己的英语水平也算不上多好，但我读过很多技术文档，也看了很多开源的代码。之前因为参加开源项目和在外企工作的经历，也写过很多的英语邮件和文档，逐渐对程序中的英语有了感觉。&lt;/p>
&lt;p>有些人注意到，我的开源项目 Moco 的文档是用英语写的，这其实是我强迫自己练习的结果。如果说英语是一门全功能的程序设计语言，那么程序中用到的英语就是一门 DSL（领域特定语言）。相比起完全掌握好英语，掌握程序中用到的英语就要简单一些了。&lt;/p>
&lt;h1 id="总结时刻">总结时刻&lt;/h1>
&lt;p>今天我们讲了几个英语使用不当造成的坏味道：&lt;/p>
&lt;ul>
&lt;li>违反语法规则的命名；&lt;/li>
&lt;li>不准确的英语词汇；&lt;/li>
&lt;li>英语单词的拼写错误。&lt;/li>
&lt;/ul>
&lt;p>这是国内程序员因为语言关系而造成的坏味道，英语是目前软件开发行业的通用语言，一个程序员要想写好程序，要对程序中用到的英语有一个基本的感觉，能够发现代码中的这些坏味道。&lt;/p>
&lt;p>其实，还有一些常见的与语言相关的坏味道，因为比较初级，我只放在这里给你提个醒，比如：&lt;/p>
&lt;ul>
&lt;li>使用拼音进行命名；&lt;/li>
&lt;li>使用不恰当的单词简写（比如，多个单词的首字母，或者写单词其中的一部分）。&lt;/li>
&lt;/ul>
&lt;p>我们还讨论了如何从实践层面上更好地规避这些坏味道：&lt;/p>
&lt;ul>
&lt;li>制定代码规范，比如，类名要用名词，函数名要用动词或动宾短语；&lt;/li>
&lt;li>要建立团队的词汇表（是的，我们在上一讲也提到了）；&lt;/li>
&lt;li>要经常进行代码评审。&lt;/li>
&lt;/ul>
&lt;p>命名之所以如此重要，因为它是一切代码的基础。就像写文章一样，一个错别字满天飞的文章，很难让人相信它会是一篇好的文章，所以，命名的重要性是如何强调都不为过的。&lt;/p>
&lt;p>如果今天的内容你只能记住一件事，那请记住：&lt;strong>编写符合英语语法规则的代码。&lt;/strong>&lt;br>
&lt;img src="https://static001.geekbang.org/resource/image/55/7b/556d83849b603cd145f1a1bbfa17567b.jpg" alt="">&lt;/p>
&lt;h1 id="思考题">思考题&lt;/h1>
&lt;p>我们在这一讲里讲到了程序员和英语之间的关系，我想请你分享一下，你在工作中与英语的关系，无论是遇到的问题，或是自我提升的经验，都行。欢迎在留言区分享你的经验，也欢迎你把这节课的内容分享给团队的小伙伴，大家一起精进&amp;quot;英语命名&amp;rdquo;。&lt;/p>
&lt;p>感谢阅读，我们下一讲再见！&lt;/p>
&lt;p>参考资料 :&lt;/p>
&lt;p>领域驱动设计：如何从零开始设计一个软件？&lt;/p>
&lt;p>动词：英语宇宙的中心&lt;/p></description></item><item><title>极客专栏: 02丨协议：怎么设计可扩展且向后兼容的协议？</title><link>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/rpc%E5%AE%9E%E6%88%98%E4%B8%8E%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/02%E4%B8%A8%E5%8D%8F%E8%AE%AE%E6%80%8E%E4%B9%88%E8%AE%BE%E8%AE%A1%E5%8F%AF%E6%89%A9%E5%B1%95%E4%B8%94%E5%90%91%E5%90%8E%E5%85%BC%E5%AE%B9%E7%9A%84%E5%8D%8F%E8%AE%AE/</link><pubDate>Sat, 28 May 2022 00:00:00 +0000</pubDate><guid>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/rpc%E5%AE%9E%E6%88%98%E4%B8%8E%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/02%E4%B8%A8%E5%8D%8F%E8%AE%AE%E6%80%8E%E4%B9%88%E8%AE%BE%E8%AE%A1%E5%8F%AF%E6%89%A9%E5%B1%95%E4%B8%94%E5%90%91%E5%90%8E%E5%85%BC%E5%AE%B9%E7%9A%84%E5%8D%8F%E8%AE%AE/</guid><description>
&lt;p>你好，我是何小锋。上一讲我分享了 RPC 原理，其核心是让我们像调用本地一样调用远程，帮助我们的应用层屏蔽远程调用的复杂性，使得我们可以更加方便地构建分布式系统。总结起来，其实就一个关键字：透明化。&lt;/p>
&lt;p>接着上一讲的内容，我们再来聊聊 RPC 协议。&lt;/p>
&lt;p>一提到协议，你最先想到的可能是 TCP 协议、UDP 协议等等，这些网络传输协议的实现在我看来有点晦涩难懂。虽然在 RPC 中我们也会用到这些协议，但这些协议更多的是对我们上层应用是透明的，我们 RPC 在使用过程中并不太需要关注他们的细节。那我今天要讲的 RPC 协议到底是什么呢？&lt;/p>
&lt;p>可能我举个例子，你立马就明白了。HTTP 协议是不是很熟悉（本讲里面所说的 HTTP 默认都是 1.X）？ 这应该是我们日常工作中用得最频繁的协议了，每天打开浏览器浏览的网页就是使用的 HTTP 协议。那 HTTP 协议跟 RPC 协议又有什么关系呢？看起来他俩好像不搭边，但他们有一个共性就是都属于应用层协议。&lt;/p>
&lt;p>所以**我们今天要讲的 RPC 协议就是围绕应用层协议展开的。**我们可以先了解下 HTTP 协议，我们先看看它的协议格式是什么样子的。回想一下我们在浏览器里面输入一个 URL 会发生什么？抛开 DNS 解析暂且不谈，浏览器收到命令后会封装一个请求，并把请求发送到 DNS 解析出来的 IP 上，通过抓包工具我们可以抓到请求的数据包，如下图所示：&lt;br>
&lt;img src="https://static001.geekbang.org/resource/image/5c/99/5ca698cbdc61b8e8b090773406b3ab99.jpg" alt="">&lt;/p>
&lt;h1 id="协议的作用">协议的作用&lt;/h1>
&lt;p>看完 HTTP 协议之后，你可能会有一个疑问，我们为什么需要协议这个东西呢？没有协议就不能通信吗？&lt;/p>
&lt;p>我们知道只有二进制才能在网络中传输，所以 RPC 请求在发送到网络中之前，他需要把方法调用的请求参数转成二进制；转成二进制后，写入本地 Socket 中，然后被网卡发送到网络设备中。&lt;/p>
&lt;p>但在传输过程中，RPC 并不会把请求参数的所有二进制数据整体一下子发送到对端机器上，中间可能会拆分成好几个数据包，也可能会合并其他请求的数据包（合并的前提是同一个 TCP 连接上的数据），至于怎么拆分合并，这其中的细节会涉及到系统参数配置和 TCP 窗口大小。对于服务提供方应用来说，他会从 TCP 通道里面收到很多的二进制数据，那这时候怎么识别出哪些二进制是第一个请求的呢？&lt;/p>
&lt;p>这就好比让你读一篇没有标点符号的文章，你要怎么识别出每一句话到哪里结束呢？很简单啊，我们加上标点，完成断句就好了。&lt;/p>
&lt;p>同理在 RPC 传输数据的时候，为了能准确地&amp;quot;断句&amp;quot;，我们也必须在应用发送请求的数据包里面加入&amp;quot;句号&amp;quot;，这样才能帮我们的接收方应用从数据流里面分割出正确的数据。这个数据包里面的句号就是消息的边界，用于标示请求数据的结束位置。举个具体例子，调用方发送 AB、CD、EF 3 个消息，如果没有边界的话，接收端就可能收到 ABCDEF 或者 ABC、DEF 这样的消息，这就会导致接收的语义跟发送的时候不一致了。&lt;/p>
&lt;p>所以呢，为了避免语义不一致的事情发生，我们就需要在发送请求的时候设定一个边界，然后在收到请求的时候按照这个设定的边界进行数据分割。这个边界语义的表达，就是我们所说的协议。&lt;/p>
&lt;h1 id="如何设计协议">如何设计协议？&lt;/h1>
&lt;p>理解了协议的作用，我们再来看看在 RPC 里面是怎么设计协议的。可能你会问：&amp;ldquo;前面你不是说了 HTTP 协议跟 RPC 都属于应用层协议，那有了现成的 HTTP 协议，为啥不直接用，还要为 RPC 设计私有协议呢？&amp;rdquo;&lt;/p>
&lt;p>这还要从 RPC 的作用说起，相对于 HTTP 的用处，RPC 更多的是负责应用间的通信，所以性能要求相对更高。但 HTTP 协议的数据包大小相对请求数据本身要大很多，又需要加入很多无用的内容，比如换行符号、回车符等；还有一个更重要的原因是，HTTP 协议属于无状态协议，客户端无法对请求和响应进行关联，每次请求都需要重新建立连接，响应完成后再关闭连接。因此，对于要求高性能的 RPC 来说，HTTP 协议基本很难满足需求，所以 RPC 会选择设计更紧凑的私有协议。&lt;/p>
&lt;p>&lt;strong>那怎么设计一个私有 RPC 协议呢？&lt;/strong>&lt;/p>
&lt;p>在设计协议前，我们先梳理下要完成 RPC 通信的时候，在协议里面需要放哪些内容。&lt;/p>
&lt;p>首先要想到的就是我们前面说的消息边界了，但 RPC 每次发请求发的大小都是不固定的，所以我们的协议必须能让接收方正确地读出不定长的内容。我们可以先固定一个长度（比如 4 个字节）用来保存整个请求数据大小，这样收到数据的时候，我们先读取固定长度的位置里面的值，值的大小就代表协议体的长度，接着再根据值的大小来读取协议体的数据，整个协议可以设计成这样：&lt;br>
&lt;img src="https://static001.geekbang.org/resource/image/de/67/debcb69ad381d9d86d13dcc7c72b0967.jpg" alt="">&lt;br>
不定长协议&lt;/p>
&lt;p>但上面这种协议，只实现了正确的断句效果，在 RPC 里面还行不通。因为对于服务提供方来说，他是不知道这个协议体里面的二进制数据是通过哪种序列化方式生成的。如果不能知道调用方用的序列化方式，即使服务提供方还原出了正确的语义，也并不能把二进制还原成对象，那服务提供方收到这个数据后也就不能完成调用了。因此我们需要把序列化方式单独拿出来，类似协议长度一样用固定的长度存放，这些需要固定长度存放的参数我们可以统称为&amp;quot;协议头&amp;quot;，这样整个协议就会拆分成两部分：协议头和协议体。&lt;/p>
&lt;p>在协议头里面，我们除了会放协议长度、序列化方式，还会放一些像协议标示、消息 ID、消息类型这样的参数，而协议体一般只放请求接口方法、请求的业务参数值和一些扩展属性。这样一个完整的 RPC 协议大概就出来了，协议头是由一堆固定的长度参数组成，而协议体是根据请求接口和参数构造的，长度属于可变的，具体协议如下图所示：&lt;br>
&lt;img src="https://static001.geekbang.org/resource/image/ac/2b/ac5f5236d972608fdb24c6eefce7e82b.jpg" alt="">&lt;br>
定长协议&lt;/p>
&lt;h1 id="可扩展的协议">可扩展的协议&lt;/h1>
&lt;p>刚才讲的协议属于定长协议头，那也就是说往后就不能再往协议头里加新参数了，如果加参数就会导致线上兼容问题。举个具体例子，假设你设计了一个 88Bit 的协议头，其中协议长度占用 32bit，然后你为了加入新功能，在协议头里面加了 2bit，并且放到协议头的最后。升级后的应用，会用新的协议发出请求，然而没有升级的应用收到的请求后，还是按照 88bit 读取协议头，新加的 2 个 bit 会当作协议体前 2 个 bit 数据读出来，但原本的协议体最后 2 个 bit 会被丢弃了，这样就会导致协议体的数据是错的。&lt;/p>
&lt;p>可能你会想：&amp;ldquo;那我把参数加在不定长的协议体里面行不行？而且刚才你也说了，协议体里面会放一些扩展属性。&amp;rdquo;&lt;/p>
&lt;p>没错，协议体里面是可以加新的参数，但这里有一个关键点，就是协议体里面的内容都是经过序列化出来的，也就是说你要获取到你参数的值，就必须把整个协议体里面的数据经过反序列化出来。但在某些场景下，这样做的代价有点高啊！&lt;/p>
&lt;p>比如说，服务提供方收到一个过期请求，这个过期是说服务提供方收到的这个请求的时间大于调用方发送的时间和配置的超时时间，既然已经过期，就没有必要接着处理，直接返回一个超时就好了。那要实现这个功能，就要在协议里面传递这个配置的超时时间，那如果之前协议里面没有加超时时间参数的话，我们现在把这个超时时间加到协议体里面是不是就有点重了呢？显然，会加重 CPU 的消耗。&lt;/p>
&lt;p>所以为了保证能平滑地升级改造前后的协议，我们有必要设计一种支持可扩展的协议。其关键在于让协议头支持可扩展，扩展后协议头的长度就不能定长了。那要实现读取不定长的协议头里面的内容，在这之前肯定需要一个固定的地方读取长度，所以我们需要一个固定的写入协议头的长度。整体协议就变成了三部分内容：固定部分、协议头内容、协议体内容，前两部分我们还是可以统称为&amp;quot;协议头&amp;quot;，具体协议如下：&lt;br>
&lt;img src="https://static001.geekbang.org/resource/image/2a/72/2a202f980458baca9fc50c53275c6772.jpg" alt="">&lt;br>
可扩展协议&lt;/p>
&lt;p>最后，我想说，**设计一个简单的 RPC 协议并不难，难的就是怎么去设计一个可&amp;quot;升级&amp;quot;的协议。**不仅要让我们在扩展新特性的时候能做到向下兼容，而且要尽可能地减少资源损耗，所以我们协议的结构不仅要支持协议体的扩展，还要做到协议头也能扩展。上述这种设计方法来源于我多年的线上经验，可以说做好扩展性是至关重要的，期待这个协议模版能帮你避掉一些坑。&lt;/p>
&lt;h1 id="总结">总结&lt;/h1>
&lt;p>我们人类区别于其他动物的一个很大原因，就是我们能够通过语言去沟通，用文字去沉淀文明，从而让我们能站在巨人的肩膀上成长，但为了保证我们记录的文字能够被其他人理解，我们必须通过符号去实现断句，否则就可能导致文字的意义被曲解，甚至闹出笑话。&lt;/p>
&lt;p>在 RPC 里面，协议的作用就类似于文字中的符号，作为应用拆解请求消息的边界，保证二进制数据经过网络传输后，还能被正确地还原语义，避免调用方跟被调用方之间的&amp;quot;鸡同鸭讲&amp;quot;。&lt;/p>
&lt;p>但我们在设计协议的时候，也不能只单纯考虑满足目前功能，还应该从更高的层次出发。就好比我们设计系统架构一样，我们需要保证设计出来的系统能够能很好地扩展，支持新增功能。&lt;/p>
&lt;h1 id="课后思考">课后思考&lt;/h1>
&lt;p>好了，今天的内容就到这里，最后留一道思考题。今天我们讨论过 RPC 不直接用 HTTP 协议的一个原因是无法实现请求跟响应关联，每次请求都需要重新建立连接，响应完成后再关闭连接，所以我们要设计私有协议。那么在 RPC 里面，我们是怎么实现请求跟响应关联的呢？&lt;/p>
&lt;p>欢迎留言和我分享你的思考，也欢迎你把文章分享给你的朋友，邀请他加入学习。我们下节课再见！&lt;/p></description></item><item><title>极客专栏: 02丨Java的基本类型</title><link>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E6%B7%B1%E5%85%A5%E6%8B%86%E8%A7%A3jvm%E8%99%9A%E6%8B%9F%E6%9C%BA/02%E4%B8%A8java%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/</link><pubDate>Fri, 27 May 2022 00:00:00 +0000</pubDate><guid>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E6%B7%B1%E5%85%A5%E6%8B%86%E8%A7%A3jvm%E8%99%9A%E6%8B%9F%E6%9C%BA/02%E4%B8%A8java%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/</guid><description>
&lt;p>如果你了解面向对象语言的发展史，那你可能听说过 Smalltalk 这门语言。它的影响力之大，以至于之后诞生的面向对象语言，或多或少都借鉴了它的设计和实现。&lt;/p>
&lt;p>在 Smalltalk 中，所有的值都是对象。因此，许多人认为它是一门纯粹的面向对象语言。&lt;/p>
&lt;p>Java 则不同，它引进了八个基本类型，来支持数值计算。Java 这么做的原因主要是工程上的考虑，因为使用基本类型能够在执行效率以及内存使用两方面提升软件性能。&lt;/p>
&lt;p>今天，我们就来了解一下基本类型在 Java 虚拟机中的实现。&lt;/p>
&lt;pre>&lt;code>public class Foo {
public static void main(String[] args) {
boolean 吃过饭没 = 2; // 直接编译的话 javac 会报错
if (吃过饭没) System.out.println(&amp;quot; 吃了 &amp;quot;);
if (true == 吃过饭没) System.out.println(&amp;quot; 真吃了 &amp;quot;);
}
}
&lt;/code>&lt;/pre>
&lt;p>在上一篇结尾的小作业里，我构造了这么一段代码，它将一个 boolean 类型的局部变量赋值为 2。为了方便记忆，我们给这个变量起个名字，就叫&amp;quot;吃过饭没&amp;quot;。&lt;/p>
&lt;p>赋值语句后边我设置了两个看似一样的 if 语句。第一个 if 语句，也就是直接判断&amp;quot;吃过饭没&amp;quot;，在它成立的情况下，代码会打印&amp;quot;吃了&amp;quot;。&lt;/p>
&lt;p>第二个 if 语句，也就是判断&amp;quot;吃过饭没&amp;quot;和 true 是否相等，在它成立的情况下，代码会打印&amp;quot;真吃了&amp;quot;。&lt;/p>
&lt;p>当然，直接编译这段代码，编译器是会报错的。所以，我迂回了一下，采用一个 Java 字节码的汇编工具，直接对字节码进行更改。&lt;/p>
&lt;p>那么问题就来了：当一个 boolean 变量的值是 2 时，它究竟是 true 还是 false 呢？&lt;/p>
&lt;p>如果你跑过这段代码，你会发现，问虚拟机&amp;quot;吃过饭没&amp;quot;，它会回答&amp;quot;吃了&amp;quot;，而问虚拟机&amp;quot;真（==）吃过饭没&amp;quot;，虚拟机则不会回答&amp;quot;真吃了&amp;quot;。&lt;/p>
&lt;p>那么虚拟机到底吃过没，下面我们来一起分析一下这背后的细节。&lt;/p>
&lt;h2 id="java-虚拟机的-boolean-类型">Java 虚拟机的 boolean 类型&lt;/h2>
&lt;p>首先，我们来看看 Java 语言规范以及 Java 虚拟机规范是怎么定义 boolean 类型的。&lt;/p>
&lt;p>在 Java 语言规范中，boolean 类型的值只有两种可能，它们分别用符号&amp;quot;true&amp;quot;和&amp;quot;false&amp;quot;来表示。显然，这两个符号是不能被虚拟机直接使用的。&lt;/p>
&lt;p>在 Java 虚拟机规范中，boolean 类型则被映射成 int 类型。具体来说，&amp;ldquo;true&amp;quot;被映射为整数 1，而&amp;quot;false&amp;quot;被映射为整数 0。这个编码规则约束了 Java 字节码的具体实现。&lt;/p>
&lt;p>举个例子，对于存储 boolean 数组的字节码，Java 虚拟机需保证实际存入的值是整数 1 或者 0。&lt;/p>
&lt;p>Java 虚拟机规范同时也要求 Java 编译器遵守这个编码规则，并且用整数相关的字节码来实现逻辑运算，以及基于 boolean 类型的条件跳转。这样一来，在编译而成的 class 文件中，除了字段和传入参数外，基本看不出 boolean 类型的痕迹了。&lt;/p>
&lt;pre>&lt;code># Foo.main 编译后的字节码
0: iconst_2 // 我们用 AsmTools 更改了这一指令
1: istore_1
2: iload_1
3: ifeq 14 // 第一个 if 语句，即操作数栈上数值为 0 时跳转
6: getstatic java.lang.System.out
9: ldc &amp;quot; 吃了 &amp;quot;
11: invokevirtual java.io.PrintStream.println
14: iload_1
15: iconst_1
16: if_icmpne 27 // 第二个 if 语句，即操作数栈上两个数值不相同时跳转
19: getstatic java.lang.System.out
22: ldc &amp;quot; 真吃了 &amp;quot;
24: invokevirtual java.io.PrintStream.println
27: return
&lt;/code>&lt;/pre>
&lt;p>在前面的例子中，第一个 if 语句会被编译成条件跳转字节码 ifeq，翻译成人话就是说，如果局部变量&amp;quot;吃过饭没&amp;quot;的值为 0，那么跳过打印&amp;quot;吃了&amp;quot;的语句。&lt;/p>
&lt;p>而第二个 if 语句则会被编译成条件跳转字节码 if_icmpne，也就是说，如果局部变量的值和整数 1 不相等，那么跳过打印&amp;quot;真吃了&amp;quot;的语句。&lt;/p>
&lt;p>可以看到，Java 编译器的确遵守了相同的编码规则。当然，这个约束很容易绕开。除了我们小作业中用到的汇编工具 AsmTools 外，还有许多可以修改字节码的 Java 库，比如说 ASM &lt;a href="https://asm.ow2.io/">[1]&lt;/a>等。&lt;/p>
&lt;p>对于 Java 虚拟机来说，它看到的 boolean 类型，早已被映射为整数类型。因此，将原本声明为 boolean 类型的局部变量，赋值为除了 0、1 之外的整数值，在 Java 虚拟机看来是&amp;quot;合法&amp;quot;的。&lt;/p>
&lt;p>在我们的例子中，经过编译器编译之后，Java 虚拟机看到的不是在问&amp;quot;吃过饭没&amp;rdquo;，而是在问&amp;quot;吃过几碗饭&amp;quot;。也就是说，第一个 if 语句变成：你不会一碗饭都没吃吧。第二个 if 语句则变成：你吃过一碗饭了吗。&lt;/p>
&lt;p>如果我们约定俗成，每人每顿只吃一碗，那么第二个 if 语句还是有意义的。但如果我们打破常规，吃了两碗，那么较真的 Java 虚拟机就会将第二个 if 语句判定为假了。&lt;/p>
&lt;h2 id="java-的基本类型">Java 的基本类型&lt;/h2>
&lt;p>除了上面提到的 boolean 类型外，Java 的基本类型还包括整数类型 byte、short、char、int 和 long，以及浮点类型 float 和 double。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/77/45/77dfb788a8ad5877e77fc28ed2d51745.png" alt="">&lt;/p>
&lt;p>Java 的基本类型都有对应的值域和默认值。可以看到，byte、short、int、long、float 以及 double 的值域依次扩大，而且前面的值域被后面的值域所包含。因此，从前面的基本类型转换至后面的基本类型，无需强制转换。另外一点值得注意的是，尽管他们的默认值看起来不一样，但在内存中都是 0。&lt;/p>
&lt;p>在这些基本类型中，boolean 和 char 是唯二的无符号类型。在不考虑违反规范的情况下，boolean 类型的取值范围是 0 或者 1。char 类型的取值范围则是 [0, 65535]。通常我们可以认定 char 类型的值为非负数。这种特性十分有用，比如说作为数组索引等。&lt;/p>
&lt;p>在前面的例子中，我们能够将整数 2 存储到一个声明为 boolean 类型的局部变量中。那么，声明为 byte、char 以及 short 的局部变量，是否也能够存储超出它们取值范围的数值呢？&lt;/p>
&lt;p>答案是可以的。而且，这些超出取值范围的数值同样会带来一些麻烦。比如说，声明为 char 类型的局部变量实际上有可能为负数。当然，在正常使用 Java 编译器的情况下，生成的字节码会遵守 Java 虚拟机规范对编译器的约束，因此你无须过分担心局部变量会超出它们的取值范围。&lt;/p>
&lt;p>Java 的浮点类型采用 IEEE 754 浮点数格式。以 float 为例，浮点类型通常有两个 0，+0.0F 以及 -0.0F。&lt;/p>
&lt;p>前者在 Java 里是 0，后者是符号位为 1、其他位均为 0 的浮点数，在内存中等同于十六进制整数 0x8000000（即 -0.0F 可通过 Float.intBitsToFloat(0x8000000) 求得）。尽管它们的内存数值不同，但是在 Java 中 +0.0F == -0.0F 会返回真。&lt;/p>
&lt;p>在有了 +0.0F 和 -0.0F 这两个定义后，我们便可以定义浮点数中的正无穷及负无穷。正无穷就是任意正浮点数（不包括 +0.0F）除以 +0.0F 得到的值，而负无穷是任意正浮点数除以 -0.0F 得到的值。在 Java 中，正无穷和负无穷是有确切的值，在内存中分别等同于十六进制整数 0x7F800000 和 0xFF800000。&lt;/p>
&lt;p>你也许会好奇，既然整数 0x7F800000 等同于正无穷，那么 0x7F800001 又对应什么浮点数呢？&lt;/p>
&lt;p>这个数字对应的浮点数是 NaN（Not-a-Number）。&lt;/p>
&lt;p>不仅如此，[0x7F800001, 0x7FFFFFFF] 和 [0xFF800001, 0xFFFFFFFF] 对应的都是 NaN。当然，一般我们计算得出的 NaN，比如说通过 +0.0F/+0.0F，在内存中应为 0x7FC00000。这个数值，我们称之为标准的 NaN，而其他的我们称之为不标准的 NaN。&lt;/p>
&lt;p>NaN 有一个有趣的特性：除了&amp;quot;!=&amp;ldquo;始终返回 true 之外，所有其他比较结果都会返回 false。&lt;/p>
&lt;p>举例来说，&amp;ldquo;NaN&amp;lt;1.0F&amp;quot;返回 false，而&amp;quot;NaN&amp;gt;=1.0F&amp;quot;同样返回 false。对于任意浮点数 f，不管它是 0 还是 NaN，&amp;ldquo;f!=NaN&amp;quot;始终会返回 true，而&amp;quot;f==NaN&amp;quot;始终会返回 false。&lt;/p>
&lt;p>因此，我们在程序里做浮点数比较的时候，需要考虑上述特性。在本专栏的第二部分，我会介绍这个特性给向量化比较带来什么麻烦。&lt;/p>
&lt;h2 id="java-基本类型的大小">Java 基本类型的大小&lt;/h2>
&lt;p>在第一篇中我曾经提到，Java 虚拟机每调用一个 Java 方法，便会创建一个栈帧。为了方便理解，这里我只讨论供解释器使用的解释栈帧（interpreted frame）。&lt;/p>
&lt;p>这种栈帧有两个主要的组成部分，分别是局部变量区，以及字节码的操作数栈。这里的局部变量是广义的，除了普遍意义下的局部变量之外，它还包含实例方法的&amp;quot;this 指针&amp;quot;以及方法所接收的参数。&lt;/p>
&lt;p>在 Java 虚拟机规范中，局部变量区等价于一个数组，并且可以用正整数来索引。除了 long、double 值需要用两个数组单元来存储之外，其他基本类型以及引用类型的值均占用一个数组单元。&lt;/p>
&lt;p>也就是说，boolean、byte、char、short 这四种类型，在栈上占用的空间和 int 是一样的，和引用类型也是一样的。因此，在 32 位的 HotSpot 中，这些类型在栈上将占用 4 个字节；而在 64 位的 HotSpot 中，他们将占 8 个字节。&lt;/p>
&lt;p>当然，这种情况仅存在于局部变量，而并不会出现在存储于堆中的字段或者数组元素上。对于 byte、char 以及 short 这三种类型的字段或者数组单元，它们在堆上占用的空间分别为一字节、两字节，以及两字节，也就是说，跟这些类型的值域相吻合。&lt;/p>
&lt;p>因此，当我们将一个 int 类型的值，存储到这些类型的字段或数组时，相当于做了一次隐式的掩码操作。举例来说，当我们把 0xFFFFFFFF（-1）存储到一个声明为 char 类型的字段里时，由于该字段仅占两字节，所以高两位的字节便会被截取掉，最终存入&amp;rdquo;\uFFFF&amp;rdquo;。&lt;/p>
&lt;p>boolean 字段和 boolean 数组则比较特殊。在 HotSpot 中，boolean 字段占用一字节，而 boolean 数组则直接用 byte 数组来实现。为了保证堆中的 boolean 值是合法的，HotSpot 在存储时显式地进行掩码操作，也就是说，只取最后一位的值存入 boolean 字段或数组中。&lt;/p>
&lt;p>讲完了存储，现在我来讲讲加载。Java 虚拟机的算数运算几乎全部依赖于操作数栈。也就是说，我们需要将堆中的 boolean、byte、char 以及 short 加载到操作数栈上，而后将栈上的值当成 int 类型来运算。&lt;/p>
&lt;p>对于 boolean、char 这两个无符号类型来说，加载伴随着零扩展。举个例子，char 的大小为两个字节。在加载时 char 的值会被复制到 int 类型的低二字节，而高二字节则会用 0 来填充。&lt;/p>
&lt;p>对于 byte、short 这两个类型来说，加载伴随着符号扩展。举个例子，short 的大小为两个字节。在加载时 short 的值同样会被复制到 int 类型的低二字节。如果该 short 值为非负数，即最高位为 0，那么该 int 类型的值的高二字节会用 0 来填充，否则用 1 来填充。&lt;/p>
&lt;h2 id="总结与实践">总结与实践&lt;/h2>
&lt;p>今天我介绍了 Java 里的基本类型。&lt;/p>
&lt;p>其中，boolean 类型在 Java 虚拟机中被映射为整数类型：&amp;ldquo;true&amp;quot;被映射为 1，而&amp;quot;false&amp;quot;被映射为 0。Java 代码中的逻辑运算以及条件跳转，都是用整数相关的字节码来实现的。&lt;/p>
&lt;p>除 boolean 类型之外，Java 还有另外 7 个基本类型。它们拥有不同的值域，但默认值在内存中均为 0。这些基本类型之中，浮点类型比较特殊。基于它的运算或比较，需要考虑 +0.0F、-0.0F 以及 NaN 的情况。&lt;/p>
&lt;p>除 long 和 double 外，其他基本类型与引用类型在解释执行的方法栈帧中占用的大小是一致的，但它们在堆中占用的大小确不同。在将 boolean、byte、char 以及 short 的值存入字段或者数组单元时，Java 虚拟机会进行掩码操作。在读取时，Java 虚拟机则会将其扩展为 int 类型。&lt;/p>
&lt;p>今天的动手环节，你可以观测一下，将 boolean 类型的值存入字段中时，Java 虚拟机所做的掩码操作。&lt;/p>
&lt;p>你可以将下面代码中 boolValue = true 里的 true 换为 2 或者 3，看看打印结果与你的猜测是否相符合。&lt;/p>
&lt;p>熟悉 Unsafe 的同学，可以使用 Unsafe.putBoolean 和 Unsafe.putByte 方法，看看还会不会做掩码操作。&lt;/p>
&lt;pre>&lt;code>public class Foo {
static boolean boolValue;
public static void main(String[] args) {
boolValue = true; // 将这个 true 替换为 2 或者 3，再看看打印结果
if (boolValue) System.out.println(&amp;quot;Hello, Java!&amp;quot;);
if (boolValue == true) System.out.println(&amp;quot;Hello, JVM!&amp;quot;);
}
}
&lt;/code>&lt;/pre>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/2a/d5/2a62e58cbdf56a5dc40748567d346fd5.jpg" alt="">&lt;/p></description></item><item><title>极客专栏: 02丨如何抓住重点，系统高效地学习数据结构与算法？</title><link>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/02%E4%B8%A8%E5%A6%82%E4%BD%95%E6%8A%93%E4%BD%8F%E9%87%8D%E7%82%B9%E7%B3%BB%E7%BB%9F%E9%AB%98%E6%95%88%E5%9C%B0%E5%AD%A6%E4%B9%A0%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</link><pubDate>Fri, 27 May 2022 00:00:00 +0000</pubDate><guid>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/02%E4%B8%A8%E5%A6%82%E4%BD%95%E6%8A%93%E4%BD%8F%E9%87%8D%E7%82%B9%E7%B3%BB%E7%BB%9F%E9%AB%98%E6%95%88%E5%9C%B0%E5%AD%A6%E4%B9%A0%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</guid><description>
&lt;p>你是否曾跟我一样，因为看不懂数据结构和算法，而一度怀疑是自己太笨？实际上，很多人在第一次接触这门课时，都会有这种感觉，觉得数据结构和算法很抽象，晦涩难懂，宛如天书。正是这个原因，让很多初学者对这门课望而却步。&lt;/p>
&lt;p>我个人觉得，其实真正的原因是你&lt;strong>没有找到好的学习方法&lt;/strong> ，&lt;strong>没有抓住学习的重点&lt;/strong>。实际上，数据结构和算法的东西并不多，常用的、基础的知识点更是屈指可数。只要掌握了正确的学习方法，学起来并没有看上去那么难，更不需要什么高智商、厚底子。&lt;/p>
&lt;p>还记得大学里每次考前老师都要划重点吗？今天，我就给你划划我们这门课的重点，再告诉你一些我总结的学习小窍门。相信有了这些之后，你学起来就会有的放矢、事半功倍了。&lt;/p>
&lt;h2 id="什么是数据结构什么是算法">什么是数据结构？什么是算法？&lt;/h2>
&lt;p>大部分数据结构和算法教材，在开篇都会给这两个概念下一个明确的定义。但是，这些定义都很抽象，对理解这两个概念并没有实质性的帮助，反倒会让你陷入死抠定义的误区。毕竟，我们现在学习，并不是为了考试，所以，概念背得再牢，不会用也就没什么用。&lt;/p>
&lt;p>&lt;strong>虽然我们说没必要深挖严格的定义，但是这并不等于不需要理解概念。&lt;/strong> 下面我就从广义和狭义两个层面，来帮你理解数据结构与算法这两个概念。&lt;/p>
&lt;p>从广义上讲，数据结构就是指一组数据的存储结构。算法就是操作数据的一组方法。&lt;/p>
&lt;p>图书馆储藏书籍你肯定见过吧？为了方便查找，图书管理员一般会将书籍分门别类进行&amp;quot;存储&amp;quot;。按照一定规律编号，就是书籍这种&amp;quot;数据&amp;quot;的存储结构。&lt;/p>
&lt;p>那我们如何来查找一本书呢？有很多种办法，你当然可以一本一本地找，也可以先根据书籍类别的编号，是人文，还是科学、计算机，来定位书架，然后再依次查找。笼统地说，这些查找方法都是算法。&lt;/p>
&lt;p>从狭义上讲，也就是我们专栏要讲的，是指某些著名的数据结构和算法，比如队列、栈、堆、二分查找、动态规划等。这些都是前人智慧的结晶，我们可以直接拿来用。我们要讲的这些经典数据结构和算法，都是前人从很多实际操作场景中抽象出来的，经过非常多的求证和检验，可以高效地帮助我们解决很多实际的开发问题。&lt;/p>
&lt;p>那数据结构和算法有什么关系呢？为什么大部分书都把这两个东西放到一块儿来讲呢？&lt;/p>
&lt;p>这是因为，数据结构和算法是相辅相成的。&lt;strong>数据结构是为算法服务的，算法要作用在特定的数据结构之上。&lt;/strong> 因此，我们无法孤立数据结构来讲算法，也无法孤立算法来讲数据结构。&lt;/p>
&lt;p>比如，因为数组具有随机访问的特点，常用的二分查找算法需要用数组来存储数据。但如果我们选择链表这种数据结构，二分查找算法就无法工作了，因为链表并不支持随机访问。&lt;/p>
&lt;p>数据结构是静态的，它只是组织数据的一种方式。如果不在它的基础上操作、构建算法，孤立存在的数据结构就是没用的。&lt;/p>
&lt;p>现在你对数据结构与算法是不是有了比较清晰的理解了呢？有了这些储备，下面我们来看看，究竟该怎么学数据结构与算法。&lt;/p>
&lt;h2 id="学习这个专栏需要什么基础">学习这个专栏需要什么基础？&lt;/h2>
&lt;p>看到数据结构和算法里的&amp;quot;算法&amp;quot;两个字，很多人就会联想到&amp;quot;数学&amp;quot;，觉得算法会涉及到很多深奥的数学知识。那我数学基础不是很好，学起来会不会很吃力啊？&lt;/p>
&lt;p>数据结构和算法课程确实会涉及一些数学方面的推理、证明，尤其是在分析某个算法的时间、空间复杂度的时候，但是这个你完全不需要担心。&lt;/p>
&lt;p>这个专栏不会像《算法导论》那样，里面有非常复杂的数学证明和推理。我会由浅入深，从概念到应用，一点一点给你解释清楚。你只要有高中数学水平，就完全可以学习。&lt;/p>
&lt;p>当然，我希望你最好有些编程基础，如果有项目经验就更好了。这样我给你讲数据结构和算法如何提高效率、如何节省存储空间，你就会有很直观的感受。因为，对于每个概念和实现过程，我都会从实际场景出发，不仅教你&amp;quot;&lt;strong>是什么&lt;/strong> &amp;ldquo;，还会教你&amp;rdquo;&lt;strong>为什么&lt;/strong> &amp;ldquo;，并且告诉你遇到同类型问题应该&amp;rdquo;&lt;strong>怎么做&lt;/strong>&amp;quot;。&lt;/p>
&lt;h2 id="学习的重点在什么地方">学习的重点在什么地方？&lt;/h2>
&lt;p>提到数据结构和算法，很多人就很头疼，因为这里面的内容实在是太多了。这里，我就帮你梳理一下，应该先学什么，后学什么。你可以对照看看，你属于哪个阶段，然后有针对地进行学习。&lt;/p>
&lt;p>想要学习数据结构与算法，&lt;strong>首先要掌握一个数据结构与算法中最重要的概念&amp;mdash;&amp;mdash;复杂度分析。&lt;/strong>&lt;/p>
&lt;p>这个概念究竟有多重要呢？可以这么说，它几乎占了数据结构和算法这门课的半壁江山，是数据结构和算法学习的精髓。&lt;/p>
&lt;p>数据结构和算法解决的是如何更省、更快地存储和处理数据的问题，因此，我们就需要一个考量效率和资源消耗的方法，这就是复杂度分析方法。所以，如果你只掌握了数据结构和算法的特点、用法，但是没有学会复杂度分析，那就相当于只知道操作口诀，而没掌握心法。只有把心法了然于胸，才能做到无招胜有招！&lt;/p>
&lt;p>所以，复杂度分析这个内容，我会用很大篇幅给你讲透。你也一定要花大力气来啃，必须要拿下，并且要搞得非常熟练。否则，后面的数据结构和算法也很难学好。&lt;/p>
&lt;p>搞定复杂度分析，下面就要进入&lt;strong>数据结构与算法的正文内容&lt;/strong>了。&lt;/p>
&lt;p>为了让你对数据结构和算法能有个全面的认识，我画了一张图，里面几乎涵盖了所有数据结构和算法书籍中都会讲到的知识点。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/91/a7/913e0ababe43a2d57267df5c5f0832a7.jpg" alt="">&lt;br>
（图谱内容较多，建议长按保存后浏览）&lt;/p>
&lt;p>但是，作为初学者，或者一个非算法工程师来说，你并不需要掌握图里面的所有知识点。很多高级的数据结构与算法，比如二分图、最大流等，这些在我们平常的开发中很少会用到。所以，你暂时可以不用看。我还是那句话，咱们学习要学会找重点。如果不分重点地学习，眉毛胡子一把抓，学起来肯定会比较吃力。&lt;/p>
&lt;p>所以，结合我自己的学习心得，还有这些年的面试、开发经验，我总结了&lt;strong>20 个最常用的、最基础&lt;/strong> 数据结构与算法，&lt;strong>不管是应付面试还是工作需要，只要集中精力逐一攻克这 20 个知识点就足够了。&lt;/strong>&lt;/p>
&lt;p>这里面有 10 个数据结构：数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、Trie 树；10 个算法：递归、排序、二分查找、搜索、哈希算法、贪心算法、分治算法、回溯算法、动态规划、字符串匹配算法。&lt;/p>
&lt;p>掌握了这些基础的数据结构和算法，再学更加复杂的数据结构和算法，就会非常容易、非常快。&lt;/p>
&lt;p>在学习数据结构和算法的过程中，你也要注意，不要只是死记硬背，不要为了学习而学习，而是&lt;strong>要学习它的&amp;quot;来历&amp;quot;&amp;ldquo;自身的特点&amp;quot;&amp;ldquo;适合解决的问题&amp;quot;以及&amp;quot;实际的应用场景&amp;rdquo;&lt;/strong>。对于每一种数据结构或算法，我都会从这几个方面进行详细讲解。只要你掌握了我每节课里讲的内容，就能在开发中灵活应用。&lt;/p>
&lt;p>学习数据结构和算法的过程，是非常好的思维训练的过程，所以，千万不要被动地记忆，要多辩证地思考，多问为什么。如果你一直这么坚持做，你会发现，等你学完之后，写代码的时候就会不由自主地考虑到很多性能方面的事情，时间复杂度、空间复杂度非常高的垃圾代码出现的次数就会越来越少。你的编程内功就真正得到了修炼。&lt;/p>
&lt;h2 id="一些可以让你事半功倍的学习技巧">一些可以让你事半功倍的学习技巧&lt;/h2>
&lt;p>前面我给你划了学习的重点，也讲了学习这门课需要具备的基础。作为一个过来人，现在我就给你分享一下，专栏学习的一些技巧。掌握了这些技巧，可以让你化被动为主动，学起来更加轻松，更加有动力！&lt;/p>
&lt;h3 id="1-边学边练适度刷题">1. 边学边练，适度刷题&lt;/h3>
&lt;p>&amp;ldquo;边学边练&amp;quot;这一招非常有用。建议你每周花 1～2 个小时的时间，集中把这周的三节内容涉及的数据结构和算法，全都自己写出来，用代码实现一遍。这样一定会比单纯地看或者听的效果要好很多！&lt;/p>
&lt;p>有面试需求的同学，可能会问了，那我还要不要去刷题呢？&lt;/p>
&lt;p>我个人的观点是&lt;strong>可以&amp;quot;适度&amp;quot;刷题，但一定不要浪费太多时间在刷题上&lt;/strong> 。我们&lt;strong>学习的目的还是掌握，然后应用&lt;/strong>。除非你要面试 Google、Facebook 这样的公司，它们的算法题目非常非常难，必须大量刷题，才能在短期内提升应试正确率。如果是应对国内公司的技术面试，即便是 BAT 这样的公司，你只要彻底掌握这个专栏的内容，就足以应对。&lt;/p>
&lt;h3 id="2-多问多思考多互动">2. 多问、多思考、多互动&lt;/h3>
&lt;p>&lt;strong>学习最好的方法是，找到几个人一起学习，一块儿讨论切磋，有问题及时寻求老师答疑。&lt;/strong> 但是，离开大学之后，既没有同学也没有老师，这个条件就比较难具备了。&lt;/p>
&lt;p>不过，这也就是咱们专栏学习的优势。专栏里有很多跟你一样的学习者。你可以多在留言区写下自己的疑问、思考和总结，也可以经常看看别人的留言，和他们进行互动。&lt;/p>
&lt;p>除此之外，如果你有疑问，你可以随时在留言区给我留言，我只要有空就会及时回复你。你不要担心问的问题太小白。因为我初学的时候，也常常会被一些小白问题困扰。不懂一点都不丢人，只要你勇敢提出来，我们一起解决了就可以了。&lt;/p>
&lt;p>我也会力争每节课都最大限度地给你讲透，帮你扫除知识盲点，而你要做的就是，避免一知半解，要想尽一切办法去搞懂我讲的所有内容。&lt;/p>
&lt;h3 id="3-打怪升级学习法">3. 打怪升级学习法&lt;/h3>
&lt;p>&lt;strong>学习的过程中，我们碰到最大的问题就是，坚持不下来。&lt;/strong> 是的，很多基础课程学起来都非常枯燥。为此，我自己总结了一套&amp;quot;打怪升级学习法&amp;rdquo;。&lt;/p>
&lt;p>游戏你肯定玩过吧？为什么很多看起来非常简单又没有乐趣的游戏，你会玩得不亦乐乎呢？这是因为，当你努力打到一定级别之后，每天看着自己的经验值、战斗力在慢慢提高，那种每天都在一点一点成长的成就感就不由自主地产生了。&lt;/p>
&lt;p>所以，&lt;strong>我们在枯燥的学习过程中，也可以给自己设立一个切实可行的目标&lt;/strong>，就像打怪升级一样。&lt;/p>
&lt;p>比如，针对这个专栏，你就可以设立这样一个目标：每节课后的思考题都认真思考，并且回复到留言区。当你看到很多人给你点赞之后，你就会为了每次都能发一个漂亮的留言，而更加认真地学习。&lt;/p>
&lt;p>当然，还有很多其他的目标，比如，每节课后都写一篇学习笔记或者学习心得；或者你还可以每节课都找一下我讲得不对、不合理的地方&amp;hellip;&amp;hellip;诸如此类，你可以总结一个适合你的&amp;quot;打怪升级攻略&amp;rdquo;。&lt;/p>
&lt;p>如果你能这样学习一段时间，不仅能收获到知识，你还会有意想不到的成就感。因为，这其实帮你改掉了一点学习的坏习惯。这个习惯一旦改掉了，你的人生也会变得不一样。&lt;/p>
&lt;h3 id="4-知识需要沉淀不要想试图一下子掌握所有">4. 知识需要沉淀，不要想试图一下子掌握所有&lt;/h3>
&lt;p>在学习的过程中，一定会碰到&amp;quot;拦路虎&amp;quot;。如果哪个知识点没有怎么学懂，不要着急，这是正常的。因为，想听一遍、看一遍就把所有知识掌握，这肯定是不可能的。&lt;strong>学习&lt;strong>&lt;strong>知识的&lt;/strong>&lt;/strong>过程是反复迭代、不断沉淀的过程。&lt;/strong>&lt;/p>
&lt;p>如果碰到&amp;quot;拦路虎&amp;quot;，你可以尽情地在留言区问我，也可以先沉淀一下，过几天再重新学一遍。所谓，书读百遍其义自见，我觉得是很有道理的！&lt;/p>
&lt;p>我讲的这些学习方法，不仅仅针对咱们这一个课程的学习，其实完全适用任何知识的学习过程。你可以通过这个专栏的学习，实践一下这些方法。如果效果不错，再推广到之后的学习过程中。&lt;/p>
&lt;h2 id="内容小结">内容小结&lt;/h2>
&lt;p>今天，我带你划了划数据结构和算法的学习重点，复杂度分析，以及 10 个数据结构和 10 个算法。&lt;/p>
&lt;p>这些内容是我根据平时的学习和工作、面试经验积累，精心筛选出来的。只要掌握这些内容，应付日常的面试、工作，基本不会有问题。&lt;/p>
&lt;p>除此之外，我还给你分享了我总结的一些学习技巧，比如边学边练、多问、多思考，还有两个比较通用的学习方法，打怪升级法和沉淀法。掌握了这些学习技巧，可以让你学习过程中事半功倍。所以，你一定要好好实践哦！&lt;/p>
&lt;h2 id="课后思考">课后思考&lt;/h2>
&lt;p>今天的内容是一个准备课，从下节开始，我们就要正式开始学习精心筛选出的这 20 个数据结构和算法了。所以，今天给你布置一个任务，对照我上面讲的&amp;quot;打怪升级学习法&amp;quot;，请思考一下你自己学习这个专栏的方法，让我们一起在留言区立下 Flag，相互鼓励！&lt;/p>
&lt;p>另外，你在之前学习数据结构和算法的过程中，遇到过什么样的困难或者疑惑吗？&lt;/p>
&lt;p>欢迎留言和我分享，我会第一时间给你反馈。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/8e/d3/8e603e3d795fc0ab2698f6f5eabf14d3.jpg" alt="">&lt;/p></description></item><item><title>极客专栏: 02丨微服务全家桶：走进SpringCloud的世界</title><link>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/springclouod%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/02%E4%B8%A8%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%85%A8%E5%AE%B6%E6%A1%B6%E8%B5%B0%E8%BF%9Bspringcloud%E7%9A%84%E4%B8%96%E7%95%8C/</link><pubDate>Fri, 27 May 2022 00:00:00 +0000</pubDate><guid>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/springclouod%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/02%E4%B8%A8%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%85%A8%E5%AE%B6%E6%A1%B6%E8%B5%B0%E8%BF%9Bspringcloud%E7%9A%84%E4%B8%96%E7%95%8C/</guid><description>
&lt;p>你好，我是姚秋辰。&lt;/p>
&lt;p>上一节课，我向你介绍了微服务架构的特点和优势。今天我就来带你了解 Spring Cloud 框架，看一看被称为微服务全家桶的 Spring Cloud 提供了哪些强大的工具。&lt;/p>
&lt;p>通过今天的学习，你将会了解 Spring Cloud 框架的功能定位，以及它和 Spring Boot 之间的关系。除此之外，我还会详细讲解 Spring Cloud 的发展历史，并介绍 Netflix 和 Alibaba 两大核心组件库，以及 Spring Cloud 的版本更新策略。这样一来，你就对 Spring Cloud 框架有了一个全面的认识。&lt;/p>
&lt;p>那我首先来带你了解一下什么是 Spring Cloud。&lt;/p>
&lt;h1 id="大话-spring-cloud">大话 Spring Cloud&lt;/h1>
&lt;p>Spring Cloud 可谓出身名门，它由 Spring 开源社区主导孵化的，专门为了解决微服务架构难题而诞生的一款微&amp;quot;微服务全家桶&amp;quot;框架。难能可贵的是，Spring Cloud 走了一条博采众家之长的道路，除了 Spring 开源社区的研发力量以外，它还吸纳了很多业界一线互联网大厂的开源组件为己用，将这些经过大厂真实业务锤炼的组件孵化成为了 Spring Cloud 组件的一部分。&lt;/p>
&lt;p>我们通过 Spring 社区发布的一张简化的架构图来看一下 Spring Cloud 的技能加点。&lt;br>
&lt;img src="https://static001.geekbang.org/resource/image/50/36/50dc50b943a1d68e1b9682f573e51736.jpg?wh=2000x1194" alt="">&lt;br>
Spring社区发布的一张简化的架构图&lt;/p>
&lt;p>在上面这幅图中，我们可以看到有几个 Spring Boot Apps 的应用集群，这就是经过拆分后的微服务。Spring Cloud 和 Spring Boot 达成了一种默契的配合：Spring Boot 主内，通过自动装配和各种开箱即用的特性，搞定了数据层访问、RESTful 接口、日志组件、内置容器等等基础功能，让开发人员不费吹灰之力就可以搭建起一个应用；Spring Cloud 主外，在应用集群之外提供了各种分布式系统的支持特性，帮助你轻松实现负载均衡、熔断降级、配置管理等诸多微服务领域的功能。&lt;/p>
&lt;p>从 Spring Boot 和 Spring Cloud 的分工中我们可以看出，Spring Boot 忙活的是底层的柴米油盐酱醋茶，Spring Boot 后勤保障做得好，才能让 Spring Cloud 毫无顾虑地投身于微服务的星辰大海，两者合二为一完整构建了微服务领域的全家桶解决方案。&lt;/p>
&lt;p>到这里，相信你已经可以理解 Spring Boot 和 Spring Cloud 的侧重点，以及 Spring Cloud 的功能定位。那么接下来，让我带你去了解一下 Spring Cloud 内部都有哪些重要组件。&lt;/p>
&lt;h1 id="spring-cloud-组件库的朝代更替">Spring Cloud 组件库的朝代更替&lt;/h1>
&lt;p>在我们开始了解 Spring Cloud 组件库之前，我得先介绍在 Spring Cloud 历史上举足轻重的两家公司 Netflix 和 Alibaba，以及它们的恩怨情仇。这两家公司分别为开源社区贡献了 Spring Cloud Netflix 组件库和 Spring Cloud Alibaba 组件库。&lt;/p>
&lt;p>说起 Netflix 可能你并不知道，但提起《纸牌屋》你一定看过或者听过，这部高分美剧就是由这家我们俗称&amp;quot;奈飞&amp;quot;的公司出品的。Netflix 是一家美国的流媒体巨头，它靠着自己强大的技术实力，开发沉淀了一系列优秀的组件，这些组件经历了 Netflix 线上庞大业务规模的考验，功能特性和稳定性过硬。如 Eureka 服务注册中心、Ribbon 负载均衡器、Hystrix 服务容错组件等。后来发生的故事可能你已经猜到了，Netflix 将这些组件贡献给了 Spring 开源社区，构成了 Netflix 组件库。可以这么说，在 Spring Cloud 的早期阶段，是 Netflix 打下了的半壁江山。&lt;/p>
&lt;p>Netflix 和 Spring Cloud 度过了蜜月期之后，矛盾就逐渐发生了。先是 Eureka 2.0 开源计划的搁浅，而后 Netflix 宣布 Hystrix 进入维护状态，Eureka 和 Hystrix 这两款 Netflix 组件库的明星项目停止了新功能的研发，Spring 社区不得不开始思考替代方案，在后续的新版本中走向了&amp;quot;去 Netflix 化&amp;quot;。以至于 Netflix 的网关组件 Zuul 2.0 历经几次跳票千呼万唤始出来后，Spring Cloud 社区已经不打算集成 Zuul 2.0，而是掏出了自己的 Gateway 网关。在最新版本的 Spring Cloud 中，Netflix 的踪迹已经逐渐消散，只有 Eureka 组件形单影只待在 Netflix 组件库中，回忆着昔日的辉煌。&lt;/p>
&lt;p>Spring Cloud Alibaba 是由 Alibaba 贡献的组件库，随着阿里在开源路线上的持续投入，近几年阿里系在开源领域的声音非常响亮。&lt;strong>Spring Cloud Alibaba 凝聚了阿里系在电商领域超高并发经验的重量级组件，保持了旺盛的更新活力，成为了 Spring Cloud 社区的一股新生代力量，逐渐取代了旧王 Netflix 的江湖地位&lt;/strong>。Spring Cloud Alibaba 组件秉承了&amp;quot;大而全&amp;quot;的特点，就像一个大中台应用一般包罗万象，在功能特性的丰富程度上做到了应有尽有，待我们学到 Spring Cloud 章节后你就能体会到了。这也是本课程选择 Spring Cloud Alibaba 组件的一个重要原因。&lt;/p>
&lt;h1 id="spring-cloud-全家桶组件库">Spring Cloud 全家桶组件库&lt;/h1>
&lt;p>我整理归纳了一个表格，将 Spring Cloud 中的核心组件库根据功能点做了分类，让你对每个特性功能的可选组件一目了然，&lt;strong>其中红色加粗的，是我们在课程实战环节将要集成的组件&lt;/strong>，你可以参考一下。&lt;br>
&lt;img src="https://static001.geekbang.org/resource/image/68/d2/6802f52d2fc50af6cfc02cf561a99bd2.jpg?wh=2000x1332" alt="">&lt;/p>
&lt;p>上面表格中列出的是业务开发过程中的常用功能性组件，除了这些以外，Spring Cloud 官方还提供了很多可扩展组件，比如用来支持构建集群的 Spring Cloud Cluster、提供安全特性支持的 Spring Cloud Security、云原生的流处理数据管道 Spring Cloud Data Flow 等等，你可以在这个Spring Cloud 官方文档中找到完整的列表。&lt;/p>
&lt;p>如果你想了解 Spring Cloud Alibaba 组件的更多细节，我推荐你阅读 spring-cloud-alibaba 的官方 GitHub 首页或者开源社区文档。&lt;/p>
&lt;p>到这里，我们对 Spring Cloud 的核心组件库有了一个比较全面的了解，接下来，我带你去了解一下 Spring Cloud 的版本更新策略。&lt;/p>
&lt;h1 id="spring-cloud-版本更新策略">Spring Cloud 版本更新策略&lt;/h1>
&lt;p>大部分开源项目以数字版本进行更新迭代，Spring Cloud 在诞生之初就别出心裁使用了字母序列，以字母 A 开头，按顺序使用字母表中的字母标识重大迭代发布的大版本号。&lt;/p>
&lt;p>我整理了一个表格，包含了 Spring Cloud 编年史各个版本的代号以及 Release 版的发布时间，我们来感受一下 Spring Cloud 的更新节奏：&lt;br>
&lt;img src="https://static001.geekbang.org/resource/image/bd/7d/bddab8d6db40951fd5e9c1af0e06807d.jpg?wh=2000x1077" alt="">&lt;/p>
&lt;p>从上面的表格中我们可以看出，&lt;strong>Spring Cloud 自 2015 年发布之始就保持了极其旺盛的生命力&lt;/strong>，&lt;strong>早期版本每半年就有一个大的版本号迭代&lt;/strong>，即便发展至今，也保持着几乎一年一升版的快速更新节奏。正是由于开源社区的持续输出，以及像 Alibaba 这类大型公司的助力，才有了今天微服务领域最为完善的 Spring Cloud 全家桶组件库。&lt;/p>
&lt;p>我们看完了 Spring Cloud 的大版本迭代更新策略，在大版本发布之前，还要经历很多小版本的迭代，接下来我带你了解一下 Spring Cloud 的小版本更新策略。如果你不清楚这里面的门道，很容易就会误用非稳定版本。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>SNAPSHOT 版本&lt;/strong>：正在开发中的快照版本，例如 2021.0.0-SNAPSHOT，快照版代表当前分支最新的代码进度，也是更新最为频繁的小版本类型，不推荐在线上正式环境使用；&lt;/li>
&lt;li>&lt;strong>Milestone 版本&lt;/strong>：在大版本正式发布前的里程碑版本，例如 2021.0.0-M1，M1 代表当前大版本的第一个里程碑版本，M2 代表第二个迭代里程碑，以此类推。在正式版本发布之前要经历多个里程碑的迭代，像 Spring Cloud Finchley 版足足经历了 9 个 M 版本之后，才过渡到了 RC 版。同样地，我也不推荐你在正式项目中使用 Milestone 版本；&lt;/li>
&lt;li>&lt;strong>Release Candidate 版本&lt;/strong>：这就是我们俗称的 RC 版，例如 2021.0.0-RC1。当一个版本迭代到 RC 版的时候，意味着离正式发布已经不远了。但是你要注意，RC 版是发布前的候选版本，走到这一步通常已经没有新的功能开发，RC 主要目的是开放出来让大家试用并尽量修复严重 Bug。&lt;/li>
&lt;li>&lt;strong>Release 版&lt;/strong>：稳定的正式发布版，比如 2020.0.1。你可以在自己的线上业务中放心使用 Release 稳定版。&lt;/li>
&lt;/ul>
&lt;p>到这里，我们就完整了解了 Spring Cloud 的发展历史、核心组件库、版本更新策略。现在，我们来回顾一下这节课的重点内容。&lt;/p>
&lt;h1 id="总结">总结&lt;/h1>
&lt;p>今天我带你了解了 Spring Cloud 框架的定位和它的核心组件库。以史为镜，我们了解了 Netflix 组件库和 Alibaba 组件库朝代更替的背景故事，以帮助我们在做技术选型的时候尽可能避开已经进入&amp;quot;维护状态&amp;quot;的组件。&lt;/p>
&lt;p>此外，我想再和你分享一些新旧工具应用的经验。我周围很多的技术人员在做项目的时候容易进入一个误区，那就是&amp;quot;为新而新&amp;quot;，什么意思呢？每当一个新版本出来的时候，他们就迫不及待地把自己的业务升级到最新版本，盲目追新，殊不知这样做很容易翻车。作为一名老司机，我推荐你这样做：&lt;strong>当你心仪的框架有重大版本更新时，我还是建议你先按兵不动，等大版本做了一两次迭代之后，明显的 Bug 修复得七七八八了，再应用到自己的项目中也不迟&lt;/strong>。&lt;/p>
&lt;h1 id="思考题">思考题&lt;/h1>
&lt;p>当你考虑给自己的项目做底层技术框架升版的时候，你会基于哪些因素做出&amp;quot;升级版本&amp;quot;的决定呢？欢迎你与我交流讨论，我在留言区等你。&lt;/p>
&lt;p>好啦，这节课就结束啦。也欢迎你把这节课分享给更多对 Spring Cloud 感兴趣的朋友。我是姚秋辰，我们下节课再见！&lt;/p></description></item><item><title>极客专栏: 02丨日志系统：一条SQL更新语句是如何执行的？</title><link>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/mysql-%E5%AE%9E%E6%88%98-45-%E8%AE%B2/02%E4%B8%A8%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F%E4%B8%80%E6%9D%A1sql%E6%9B%B4%E6%96%B0%E8%AF%AD%E5%8F%A5%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84/</link><pubDate>Fri, 27 May 2022 00:00:00 +0000</pubDate><guid>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/mysql-%E5%AE%9E%E6%88%98-45-%E8%AE%B2/02%E4%B8%A8%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F%E4%B8%80%E6%9D%A1sql%E6%9B%B4%E6%96%B0%E8%AF%AD%E5%8F%A5%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84/</guid><description>
&lt;p>前面我们系统了解了一个查询语句的执行流程，并介绍了执行过程中涉及的处理模块。相信你还记得，一条查询语句的执行过程一般是经过连接器、分析器、优化器、执行器等功能模块，最后到达存储引擎。&lt;/p>
&lt;p>那么，一条更新语句的执行流程又是怎样的呢？&lt;/p>
&lt;p>之前你可能经常听 DBA 同事说，MySQL 可以恢复到半个月内任意一秒的状态，惊叹的同时，你是不是心中也会不免会好奇，这是怎样做到的呢？&lt;/p>
&lt;p>我们还是从一个表的一条更新语句说起，下面是这个表的创建语句，这个表有一个主键 ID 和一个整型字段 c：&lt;/p>
&lt;pre>&lt;code>mysql&amp;gt; create table T(ID int primary key, c int);
&lt;/code>&lt;/pre>
&lt;p>如果要将 ID=2 这一行的值加 1，SQL 语句就会这么写：&lt;/p>
&lt;pre>&lt;code>mysql&amp;gt; update T set c=c+1 where ID=2;
&lt;/code>&lt;/pre>
&lt;p>前面我有跟你介绍过 SQL 语句基本的执行链路，这里我再把那张图拿过来，你也可以先简单看看这个图回顾下。首先，可以确定的说，查询语句的那一套流程，更新语句也是同样会走一遍。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/0d/d9/0d2070e8f84c4801adbfa03bda1f98d9.png" alt="">
MySQL 的逻辑架构图&lt;/p>
&lt;p>你执行语句前要先连接数据库，这是连接器的工作。&lt;/p>
&lt;p>前面我们说过，在一个表上有更新的时候，跟这个表有关的查询缓存会失效，所以这条语句就会把表 T 上所有缓存结果都清空。这也就是我们一般不建议使用查询缓存的原因。&lt;/p>
&lt;p>接下来，分析器会通过词法和语法解析知道这是一条更新语句。优化器决定要使用 ID 这个索引。然后，执行器负责具体执行，找到这一行，然后更新。&lt;/p>
&lt;p>与查询流程不一样的是，更新流程还涉及两个重要的日志模块，它们正是我们今天要讨论的主角：redo log（重做日志）和 binlog（归档日志）。如果接触 MySQL，那这两个词肯定是绕不过的，我后面的内容里也会不断地和你强调。不过话说回来，redo log 和 binlog 在设计上有很多有意思的地方，这些设计思路也可以用到你自己的程序里。&lt;/p>
&lt;h1 id="重要的日志模块redo-log">重要的日志模块：redo log&lt;/h1>
&lt;p>不知道你还记不记得《孔乙己》这篇文章，酒店掌柜有一个粉板，专门用来记录客人的赊账记录。如果赊账的人不多，那么他可以把顾客名和账目写在板上。但如果赊账的人多了，粉板总会有记不下的时候，这个时候掌柜一定还有一个专门记录赊账的账本。&lt;/p>
&lt;p>如果有人要赊账或者还账的话，掌柜一般有两种做法：&lt;/p>
&lt;ul>
&lt;li>一种做法是直接把账本翻出来，把这次赊的账加上去或者扣除掉；&lt;/li>
&lt;li>另一种做法是先在粉板上记下这次的账，等打烊以后再把账本翻出来核算。&lt;/li>
&lt;/ul>
&lt;p>在生意红火柜台很忙时，掌柜一定会选择后者，因为前者操作实在是太麻烦了。首先，你得找到这个人的赊账总额那条记录。你想想，密密麻麻几十页，掌柜要找到那个名字，可能还得带上老花镜慢慢找，找到之后再拿出算盘计算，最后再将结果写回到账本上。&lt;/p>
&lt;p>这整个过程想想都麻烦。相比之下，还是先在粉板上记一下方便。你想想，如果掌柜没有粉板的帮助，每次记账都得翻账本，效率是不是低得让人难以忍受？&lt;/p>
&lt;p>同样，在 MySQL 里也有这个问题，如果每一次的更新操作都需要写进磁盘，然后磁盘也要找到对应的那条记录，然后再更新，整个过程 IO 成本、查找成本都很高。为了解决这个问题，MySQL 的设计者就用了类似酒店掌柜粉板的思路来提升更新效率。&lt;/p>
&lt;p>而粉板和账本配合的整个过程，其实就是 MySQL 里经常说到的 WAL 技术，WAL 的全称是 Write-Ahead Logging，它的关键点就是先写日志，再写磁盘，也就是先写粉板，等不忙的时候再写账本。&lt;/p>
&lt;p>具体来说，当有一条记录需要更新的时候，InnoDB 引擎就会先把记录写到 redo log（粉板）里面，并更新内存，这个时候更新就算完成了。同时，InnoDB 引擎会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做，这就像打烊以后掌柜做的事。&lt;/p>
&lt;p>如果今天赊账的不多，掌柜可以等打烊后再整理。但如果某天赊账的特别多，粉板写满了，又怎么办呢？这个时候掌柜只好放下手中的活儿，把粉板中的一部分赊账记录更新到账本中，然后把这些记录从粉板上擦掉，为记新账腾出空间。&lt;/p>
&lt;p>与此类似，InnoDB 的 redo log 是固定大小的，比如可以配置为一组 4 个文件，每个文件的大小是 1GB，那么这块&amp;quot;粉板&amp;quot;总共就可以记录 4GB 的操作。从头开始写，写到末尾就又回到开头循环写，如下面这个图所示。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/16/a7/16a7950217b3f0f4ed02db5db59562a7.png" alt="">&lt;/p>
&lt;p>write pos 是当前记录的位置，一边写一边后移，写到第 3 号文件末尾后就回到 0 号文件开头。checkpoint 是当前要擦除的位置，也是往后推移并且循环的，擦除记录前要把记录更新到数据文件。&lt;/p>
&lt;p>write pos 和 checkpoint 之间的是&amp;quot;粉板&amp;quot;上还空着的部分，可以用来记录新的操作。如果 write pos 追上 checkpoint，表示&amp;quot;粉板&amp;quot;满了，这时候不能再执行新的更新，得停下来先擦掉一些记录，把 checkpoint 推进一下。&lt;/p>
&lt;p>有了 redo log，InnoDB 就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为&lt;strong>crash-safe&lt;/strong>。&lt;/p>
&lt;p>要理解 crash-safe 这个概念，可以想想我们前面赊账记录的例子。只要赊账记录记在了粉板上或写在了账本上，之后即使掌柜忘记了，比如突然停业几天，恢复生意后依然可以通过账本和粉板上的数据明确赊账账目。&lt;/p>
&lt;h1 id="重要的日志模块binlog">重要的日志模块：binlog&lt;/h1>
&lt;p>前面我们讲过，MySQL 整体来看，其实就有两块：一块是 Server 层，它主要做的是 MySQL 功能层面的事情；还有一块是引擎层，负责存储相关的具体事宜。上面我们聊到的粉板 redo log 是 InnoDB 引擎特有的日志，而 Server 层也有自己的日志，称为 binlog（归档日志）。&lt;/p>
&lt;p>我想你肯定会问，为什么会有两份日志呢？&lt;/p>
&lt;p>因为最开始 MySQL 里并没有 InnoDB 引擎。MySQL 自带的引擎是 MyISAM，但是 MyISAM 没有 crash-safe 的能力，binlog 日志只能用于归档。而 InnoDB 是另一个公司以插件形式引入 MySQL 的，既然只依靠 binlog 是没有 crash-safe 能力的，所以 InnoDB 使用另外一套日志系统&amp;mdash;&amp;mdash;也就是 redo log 来实现 crash-safe 能力。&lt;/p>
&lt;p>这两种日志有以下三点不同。&lt;/p>
&lt;ol>
&lt;li>
&lt;p>redo log 是 InnoDB 引擎特有的；binlog 是 MySQL 的 Server 层实现的，所有引擎都可以使用。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>redo log 是物理日志，记录的是&amp;quot;在某个数据页上做了什么修改&amp;quot;；binlog 是逻辑日志，记录的是这个语句的原始逻辑，比如&amp;quot;给 ID=2 这一行的 c 字段加 1 &amp;ldquo;。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>redo log 是循环写的，空间固定会用完；binlog 是可以追加写入的。&amp;ldquo;追加写&amp;quot;是指 binlog 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>有了对这两个日志的概念性理解，我们再来看执行器和 InnoDB 引擎在执行这个简单的 update 语句时的内部流程。&lt;/p>
&lt;ol>
&lt;li>
&lt;p>执行器先找引擎取 ID=2 这一行。ID 是主键，引擎直接用树搜索找到这一行。如果 ID=2 这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>执行器拿到引擎给的行数据，把这个值加上 1，比如原来是 N，现在就是 N+1，得到新的一行数据，再调用引擎接口写入这行新数据。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>引擎将这行新数据更新到内存中，同时将这个更新操作记录到 redo log 里面，此时 redo log 处于 prepare 状态。然后告知执行器执行完成了，随时可以提交事务。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>执行器生成这个操作的 binlog，并把 binlog 写入磁盘。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>执行器调用引擎的提交事务接口，引擎把刚刚写入的 redo log 改成提交（commit）状态，更新完成。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>这里我给出这个 update 语句的执行流程图，图中浅色框表示是在 InnoDB 内部执行的，深色框表示是在执行器中执行的。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/2e/be/2e5bff4910ec189fe1ee6e2ecc7b4bbe.png" alt="">
update 语句执行流程&lt;/p>
&lt;p>你可能注意到了，最后三步看上去有点&amp;quot;绕&amp;rdquo;，将 redo log 的写入拆成了两个步骤：prepare 和 commit，这就是&amp;quot;两阶段提交&amp;rdquo;。&lt;/p>
&lt;h1 id="两阶段提交">两阶段提交&lt;/h1>
&lt;p>为什么必须有&amp;quot;两阶段提交&amp;quot;呢？这是为了让两份日志之间的逻辑一致。要说明这个问题，我们得从文章开头的那个问题说起：&lt;strong>怎样让数据库恢复到半个月内任意一秒的状态？&lt;/strong>&lt;/p>
&lt;p>前面我们说过了，binlog 会记录所有的逻辑操作，并且是采用&amp;quot;追加写&amp;quot;的形式。如果你的 DBA 承诺说半个月内可以恢复，那么备份系统中一定会保存最近半个月的所有 binlog，同时系统会定期做整库备份。这里的&amp;quot;定期&amp;quot;取决于系统的重要性，可以是一天一备，也可以是一周一备。&lt;/p>
&lt;p>当需要恢复到指定的某一秒时，比如某天下午两点发现中午十二点有一次误删表，需要找回数据，那你可以这么做：&lt;/p>
&lt;ul>
&lt;li>首先，找到最近的一次全量备份，如果你运气好，可能就是昨天晚上的一个备份，从这个备份恢复到临时库；&lt;/li>
&lt;li>然后，从备份的时间点开始，将备份的 binlog 依次取出来，重放到中午误删表之前的那个时刻。&lt;/li>
&lt;/ul>
&lt;p>这样你的临时库就跟误删之前的线上库一样了，然后你可以把表数据从临时库取出来，按需要恢复到线上库去。&lt;/p>
&lt;p>好了，说完了数据恢复过程，我们回来说说，为什么日志需要&amp;quot;两阶段提交&amp;quot;。这里不妨用反证法来进行解释。&lt;/p>
&lt;p>由于 redo log 和 binlog 是两个独立的逻辑，如果不用两阶段提交，要么就是先写完 redo log 再写 binlog，或者采用反过来的顺序。我们看看这两种方式会有什么问题。&lt;/p>
&lt;p>仍然用前面的 update 语句来做例子。假设当前 ID=2 的行，字段 c 的值是 0，再假设执行 update 语句过程中在写完第一个日志后，第二个日志还没有写完期间发生了 crash，会出现什么情况呢？&lt;/p>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>先写 redo log 后写 binlog&lt;/strong> 。假设在 redo log 写完，binlog 还没有写完的时候，MySQL 进程异常重启。由于我们前面说过的，redo log 写完之后，系统即使崩溃，仍然能够把数据恢复回来，所以恢复后这一行 c 的值是 1。&lt;br>
但是由于 binlog 没写完就 crash 了，这时候 binlog 里面就没有记录这个语句。因此，之后备份日志的时候，存起来的 binlog 里面就没有这条语句。&lt;br>
然后你会发现，如果需要用这个 binlog 来恢复临时库的话，由于这个语句的 binlog 丢失，这个临时库就会少了这一次更新，恢复出来的这一行 c 的值就是 0，与原库的值不同。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>先写 binlog 后写 redo log&lt;/strong>。如果在 binlog 写完之后 crash，由于 redo log 还没写，崩溃恢复以后这个事务无效，所以这一行 c 的值是 0。但是 binlog 里面已经记录了&amp;quot;把 c 从 0 改成 1&amp;quot;这个日志。所以，在之后用 binlog 来恢复的时候就多了一个事务出来，恢复出来的这一行 c 的值就是 1，与原库的值不同。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>可以看到，如果不使用&amp;quot;两阶段提交&amp;quot;，那么数据库的状态就有可能和用它的日志恢复出来的库的状态不一致。&lt;/p>
&lt;p>你可能会说，这个概率是不是很低，平时也没有什么动不动就需要恢复临时库的场景呀？&lt;/p>
&lt;p>其实不是的，不只是误操作后需要用这个过程来恢复数据。当你需要扩容的时候，也就是需要再多搭建一些备库来增加系统的读能力的时候，现在常见的做法也是用全量备份加上应用 binlog 来实现的，这个&amp;quot;不一致&amp;quot;就会导致你的线上出现主从数据库不一致的情况。&lt;/p>
&lt;p>简单说，redo log 和 binlog 都可以用于表示事务的提交状态，而两阶段提交就是让这两个状态保持逻辑上的一致。&lt;/p>
&lt;h1 id="小结">小结&lt;/h1>
&lt;p>今天，我介绍了 MySQL 里面最重要的两个日志，即物理日志 redo log 和逻辑日志 binlog。&lt;/p>
&lt;p>redo log 用于保证 crash-safe 能力。innodb_flush_log_at_trx_commit 这个参数设置成 1 的时候，表示每次事务的 redo log 都直接持久化到磁盘。这个参数我建议你设置成 1，这样可以保证 MySQL 异常重启之后数据不丢失。&lt;/p>
&lt;p>sync_binlog 这个参数设置成 1 的时候，表示每次事务的 binlog 都持久化到磁盘。这个参数我也建议你设置成 1，这样可以保证 MySQL 异常重启之后 binlog 不丢失。&lt;/p>
&lt;p>我还跟你介绍了与 MySQL 日志系统密切相关的&amp;quot;两阶段提交&amp;quot;。两阶段提交是跨系统维持数据逻辑一致性时常用的一个方案，即使你不做数据库内核开发，日常开发中也有可能会用到。&lt;/p>
&lt;p>文章的最后，我给你留一个思考题吧。前面我说到定期全量备份的周期&amp;quot;取决于系统重要性，有的是一天一备，有的是一周一备&amp;quot;。那么在什么场景下，一天一备会比一周一备更有优势呢？或者说，它影响了这个数据库系统的哪个指标？&lt;/p>
&lt;p>你可以把你的思考和观点写在留言区里，我会在下一篇文章的末尾给出我的答案。&lt;/p>
&lt;p>感谢你的收听，也欢迎你把这篇文章分享给更多的朋友一起阅读。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/ce/d9/ce7f4e35916ed1aa49206a53a0547bd9.jpg" alt="">&lt;/p></description></item><item><title>极客专栏: 02丨程序员如何用技术变现（下）</title><link>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E/02%E4%B8%A8%E7%A8%8B%E5%BA%8F%E5%91%98%E5%A6%82%E4%BD%95%E7%94%A8%E6%8A%80%E6%9C%AF%E5%8F%98%E7%8E%B0%E4%B8%8B/</link><pubDate>Fri, 27 May 2022 00:00:00 +0000</pubDate><guid>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E/02%E4%B8%A8%E7%A8%8B%E5%BA%8F%E5%91%98%E5%A6%82%E4%BD%95%E7%94%A8%E6%8A%80%E6%9C%AF%E5%8F%98%E7%8E%B0%E4%B8%8B/</guid><description>
&lt;p>我不算是聪明的人，经历也不算特别成功，但一步一步走来，我认为，我能做到的，你一定也能做到，而且应该还能做得比我更好。&lt;/p>
&lt;h1 id="如何让自己的技能变现">如何让自己的技能变现&lt;/h1>
&lt;p>还是那句话，本质上来说，程序员是个手艺人，有手艺的人就能做出别人做不出来的东西，而付费也是一件很自然的事了。那么，这个问题就变成如何让自己的&amp;quot;手艺&amp;quot;更为值钱的问题了。&lt;/p>
&lt;p>第一，&lt;strong>千里之行，积于跬步&lt;/strong>。任何一件成功的大事，都是通过一个一个的小成功达到的。所以，你得确保你有一个一个的小成功。&lt;/p>
&lt;p>具体说来，首先，你得让自己身边的人有求于你，或是向别人推荐你。这就需要你能够掌握大多数人不能掌握的技能或技术，需要你更多地学习，并要有更多的别人没有的经验和经历。&lt;/p>
&lt;p>一旦你身边的人开始有求于你，或是向别人推荐你，你就会被外部的人注意到，于是其他人就会付费来获取你的帮助。而一旦你的帮忙对别人来说有效果，那就会产生效益，无论是经济效益还是社会效益，都会为你开拓更大的空间。&lt;/p>
&lt;p>你也会因为这样的正向反馈而鼓励自己去学习和钻研更多的东西，从而得到一个正向的循环。而且这个正向循环，一旦开始就停不下来了。&lt;/p>
&lt;p>第二，&lt;strong>关注有价值的东西&lt;/strong>。什么是有价值的东西？价值其实是受供需关系影响的，供大于求，就没什么价值，供不应求，就有价值。这意味着你不仅要看到市场，还要看到技术的趋势，能够分辨出什么是主流技术，什么是过渡式的技术。当你比别人有更好的嗅觉时，你就能启动得更快，也就比别人有先发优势。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>关于市场需求&lt;/strong>。你要看清市场，就需要看看各个公司都在做什么，他们的难题是什么。简单来说，现在的每家公司无论大小都缺人。但是真的缺人吗？中国是人口大国，从不缺少写代码搬砖的人，真正缺的其实是有能力能够解决技术难题的人，能够提高团队人效的人。所以，从这些方面思考，你会知道哪些技能才是真正的&amp;quot;供不应求&amp;quot;，这样可以让你更有价值。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>关于技术趋势&lt;/strong>。要看清技术趋势，你需要了解历史，就像一个球运动一样，你要知道这个球未来运动的地方，是需要观察球的已经完成运动的轨迹才知道的。因此，了解技术发展轨迹是一件很重要的事。要看一个新的技术是否顺应技术发展趋势，你需要将一些老技术的本质吃得很透。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>因此，在学习技术的过程一定要多问自己两个问题：&amp;ldquo;一，这个技术解决什么问题？为什么别的同类技术做不到？二，为什么是这样解决的？有没有更好的方式？&amp;ldquo;另外，还有一个简单的判断方法，如果一个新的技术顺应技术发展趋势，那么在这个新的技术出现时，后面一定会有大型的商业公司支持，这类公司支持得越多，就说明你越需要关注。&lt;/p>
&lt;p>第三，&lt;strong>找到能体现价值的地方&lt;/strong> 。&lt;strong>在一家高速发展的公司中，技术人员的价值可以达到最大化&lt;/strong>。&lt;/p>
&lt;p>试想，在一家大公司中，技术架构和业务已经定型，基本上没有什么太多的事可以做的。而且对于已经发展起来的大公司来说，往往稳定的重要性超过了创新。此外，大公司的高级技术人员很多，多你一个不多，少你一个不少，所以你的价值很难被体现出来。&lt;/p>
&lt;p>而刚起步的公司，业务还没有跑顺，公司的主要精力会放在业务拓展上，这个时候也不太需要高精尖的技术，所以，技术人员的价值也体现不出来。&lt;/p>
&lt;p>只有那些在高速发展的公司，技术人员的价值才能被最大化地体现出来。比较好的成长路径是，先进入大公司学习大公司的技术和成功的经验方法，然后再找到高速成长的公司，这样你就可以实现自己更多的价值。当然，这里并不排除在大公司中找到高速发展的业务。&lt;/p>
&lt;p>第四，&lt;strong>动手能力很重要&lt;/strong>。成为一个手艺人，动手能力是很重要的，因为在解决任何一个具体问题的时候，有没有动手能力就成为了关键。这也是我一直在写代码的原因，代码里全是细节，细节是魔鬼，只有了解了细节，你才能提出更好或是更靠谱、可以落地的解决方案。而不是一些笼统和模糊的东西。这太重要了。&lt;/p>
&lt;p>第五，&lt;strong>关注技术付费点&lt;/strong> 。技术付费点基本体现在两个地方，&lt;strong>一个是，能帮别人&amp;quot;挣钱&amp;quot;的地方；另一个是，能帮别人&amp;quot;省钱&amp;quot;的地方&lt;/strong>。也就是说，能够帮助别人更流畅地挣钱，或是能够帮助别人提高效率，能节省更多的成本，越直接越好。而且这个技术或解决方案最好还是大多数人做不到的。&lt;/p>
&lt;p>第六，&lt;strong>提升自己的能力和经历&lt;/strong>。付费的前提是信任，只有你提升自己的能力和经历后，别人才会对你有一定的信任，才会觉得你靠谱，才会给你机会。而这个信任需要用你的能力和经历来填补。比如，你是一个很知名的开源软件的核心开发人员，或是你是某知名公司核心项目的核心开发人员，等等。&lt;/p>
&lt;p>第七，&lt;strong>找到有价值的信息源&lt;/strong>。信息社会，如果你比别人有更好的信息源，那么你就可以比别人成长得更快。对于技术人员来说，我们知道，几乎所有的技术都源自西方世界，所以，你应该走到信息的源头去。&lt;/p>
&lt;p>如果你的信息来自朋友圈、微博、知乎、百度或是今日头条，那么我觉得你完蛋了。因为这些渠道有价值的信息不多，有营养的可能只有 1%，而为了这 1%，你需要读完 99% 的信息，太不划算了。&lt;/p>
&lt;p>那么如何找到这些信息源呢？用好 Google 就是一个关键，比如你在 Google 搜索引擎里输入&amp;quot;XXX Best Practice&amp;rdquo;，或是&amp;quot;Best programming resource&amp;rdquo;&amp;hellip;&amp;hellip;你就会找到很多。而用好这个更好的信息源需要你的英文能力，因此不断提升英文能力很关键。&lt;/p>
&lt;p>第八，&lt;strong>输出观点和价值观&lt;/strong>。真正伟大的公司或是产品都是要输出价值观的。只有输出了更先进的价值观，才会获得真正的影响力。但是，你要能输出观点和价值观，并不是一件容易的事，这需要你的积累和经历，而不是一朝之功。因此，如果想要让你的技能变现，这本质上是一个厚积薄发的过程。&lt;/p>
&lt;p>第九，&lt;strong>朋友圈很重要&lt;/strong>。一个人的朋友圈很重要，你在什么样的朋友圈，就会被什么样的朋友圈所影响。如果你的朋友圈比较优质，那么给你介绍过来的事儿和活儿也会好一些。&lt;/p>
&lt;p>优质的朋友圈基本上都有这样的特性。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>这些人都比较有想法、有观点，经验也比较丰富；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>这些人涉猎的面比较广；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>这些人都有或多或少的成功；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>这些人都是喜欢折腾喜欢搞事的人；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>这些人都对现状有些不满，并想做一些改变；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>这些人都有一定的影响力。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>最后有个关键的问题是，物以类聚，人以群分。如果你不做到这些，你怎么能进入到这样的朋友圈呢？&lt;/p>
&lt;p>总之，就一句话，&lt;strong>会挣钱的人一定是会投资的人&lt;/strong> 。我一直认为，&lt;strong>最宝贵的财富并不是钱，而是你的时间，时间比钱更宝贵，因为钱你不用还在那里，而时间你不用就浪费掉了。你把你的时间投资在哪些地方，就意味着你未来会走什么样的路。所以，利用好你的时间，投到一些有意义的地方吧&lt;/strong>。&lt;/p>
&lt;p>我的经历有限，只能看到这些，还希望大家一起来讨论，分享你的经验和心得，也让我可以学习和提高。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/fc/e9/fcc761001867c60f526665e237f831e9.jpg" alt="">&lt;/p></description></item><item><title>极客专栏: 02丨预习篇·小鲸鱼大事记（二）：崭露头角</title><link>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90-kubernetes/02%E4%B8%A8%E9%A2%84%E4%B9%A0%E7%AF%87%E5%B0%8F%E9%B2%B8%E9%B1%BC%E5%A4%A7%E4%BA%8B%E8%AE%B0%E4%BA%8C%E5%B4%AD%E9%9C%B2%E5%A4%B4%E8%A7%92/</link><pubDate>Fri, 27 May 2022 00:00:00 +0000</pubDate><guid>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90-kubernetes/02%E4%B8%A8%E9%A2%84%E4%B9%A0%E7%AF%87%E5%B0%8F%E9%B2%B8%E9%B1%BC%E5%A4%A7%E4%BA%8B%E8%AE%B0%E4%BA%8C%E5%B4%AD%E9%9C%B2%E5%A4%B4%E8%A7%92/</guid><description>
&lt;p>你好，我是张磊。我今天分享的主题是：小鲸鱼大事记之崭露头角。&lt;/p>
&lt;p>在上一篇文章中，我说到，伴随着 PaaS 概念的逐步普及，以 Cloud Foundry 为代表的经典 PaaS 项目，开始进入基础设施领域的视野，平台化和 PaaS 化成了这个生态中的一个最为重要的进化趋势。&lt;/p>
&lt;p>就在对开源 PaaS 项目落地的不断尝试中，这个领域的从业者们发现了 PaaS 中最为棘手也最亟待解决的一个问题：究竟如何给应用打包？&lt;/p>
&lt;p>遗憾的是，无论是 Cloud Foundry、OpenShift，还是 Clodify，面对这个问题都没能给出一个完美的答案，反而在竞争中走向了碎片化的歧途。&lt;/p>
&lt;p>而就在这时，一个并不引人瞩目的 PaaS 创业公司 dotCloud，却选择了开源自家的一个容器项目 Docker。更出人意料的是，&lt;strong>就是这样一个普通到不能再普通的技术，却开启了一个名为&amp;quot;Docker&amp;quot;的全新时代。&lt;/strong>&lt;/p>
&lt;p>你可能会有疑问，Docker 项目的崛起，是不是偶然呢？&lt;/p>
&lt;p>事实上，&lt;strong>这个以&amp;quot;鲸鱼&amp;quot;为注册商标的技术创业公司，最重要的战略之一就是：坚持把&amp;quot;开发者&amp;quot;群体放在至高无上的位置。&lt;/strong>&lt;/p>
&lt;p>相比于其他正在企业级市场里厮杀得头破血流的经典 PaaS 项目们，Docker 项目的推广策略从一开始就呈现出一副&amp;quot;憨态可掬&amp;quot;的亲人姿态，把每一位后端技术人员（而不是他们的老板）作为主要的传播对象。&lt;/p>
&lt;p>简洁的 UI，有趣的 demo，&amp;ldquo;1 分钟部署一个 WordPress 网站&amp;quot;&amp;ldquo;3 分钟部署一个 Nginx 集群&amp;rdquo;，这种同开发者之间与生俱来的亲近关系，使 Docker 项目迅速成为了全世界 Meetup 上最受欢迎的一颗新星。&lt;/p>
&lt;p>在过去的很长一段时间里，相较于前端和互联网技术社区，服务器端技术社区一直是一个相对沉闷而小众的圈子。在这里，从事 Linux 内核开发的极客们自带&amp;quot;不合群&amp;quot;的&amp;quot;光环&amp;rdquo;，后端开发者们啃着多年不变的 TCP/IP 发着牢骚，运维更是天生注定的幕后英雄。&lt;/p>
&lt;p>而 Docker 项目，却给后端开发者提供了走向聚光灯的机会。就比如 Cgroups 和 Namespace 这种已经存在多年却很少被人们关心的特性，在 2014 年和 2015 年竟然频繁入选各大技术会议的分享议题，就因为听众们想要知道 Docker 这个东西到底是怎么一回事儿。&lt;/p>
&lt;p>&lt;strong>而 Docker 项目之所以能取得如此高的关注，一方面正如前面我所说的那样，它解决了应用打包和发布这一困扰运维人员多年的技术难题；而另一方面，就是因为它第一次把一个纯后端的技术概念，通过非常友好的设计和封装，交到了最广大的开发者群体手里。&lt;/strong>&lt;/p>
&lt;p>在这种独特的氛围烘托下，你不需要精通 TCP/IP，也无需深谙 Linux 内核原理，哪怕只是一个前端或者网站的 PHP 工程师，都会对如何把自己的代码打包成一个随处可以运行的 Docker 镜像充满好奇和兴趣。&lt;/p>
&lt;p>这种受众群体的变革，正是 Docker 这样一个后端开源项目取得巨大成功的关键。这也是经典 PaaS 项目想做却没有做好的一件事情：PaaS 的最终用户和受益者，一定是为这个 PaaS 编写应用的开发者们，而在 Docker 项目开源之前，PaaS 与开发者之间的关系却从未如此紧密过。&lt;/p>
&lt;p>&lt;strong>解决了应用打包这个根本性的问题，同开发者与生俱来的的亲密关系，再加上 PaaS 概念已经深入人心的完美契机，成为 Docker 这个技术上看似平淡无奇的项目一举走红的重要原因。&lt;/strong>&lt;/p>
&lt;p>一时之间，&amp;ldquo;容器化&amp;quot;取代&amp;quot;PaaS 化&amp;quot;成为了基础设施领域最炙手可热的关键词，一个以&amp;quot;容器&amp;quot;为中心的、全新的云计算市场，正呼之欲出。而作为这个生态的一手缔造者，此时的 dotCloud 公司突然宣布将公司名称改为&amp;quot;Docker&amp;rdquo;。&lt;/p>
&lt;p>这个举动，在当时颇受质疑。在大家印象中，Docker 只是一个开源项目的名字。可是现在，这个单词却成了 Docker 公司的注册商标，任何人在商业活动中使用这个单词，以及鲸鱼的 Logo，都会立刻受到法律警告。&lt;/p>
&lt;p>那么，Docker 公司这个举动到底卖的什么药？这个问题，我不妨后面再做解读，因为相较于这件&amp;quot;小事儿&amp;quot;，Docker 公司在 2014 年发布 Swarm 项目才是真正的&amp;quot;大事儿&amp;quot;。&lt;/p>
&lt;p>那么，Docker 公司为什么一定要发布 Swarm 项目呢？&lt;/p>
&lt;p>通过我对 Docker 项目崛起背后原因的分析，你应该能发现这样一个有意思的事实：虽然通过&amp;quot;容器&amp;quot;这个概念完成了对经典 PaaS 项目的&amp;quot;降维打击&amp;quot;，但是 Docker 项目和 Docker 公司，兜兜转转了一年多，却还是回到了 PaaS 项目原本深耕了多年的那个战场：&lt;strong>如何让开发者把应用部署在我的项目上。&lt;/strong>&lt;/p>
&lt;p>没错，Docker 项目从发布之初就全面发力，从技术、社区、商业、市场全方位争取到的开发者群体，实际上是为此后吸引整个生态到自家&amp;quot;PaaS&amp;quot;上的一个铺垫。&lt;strong>只不过这时，&amp;ldquo;PaaS&amp;quot;的定义已经全然不是 Cloud Foundry 描述的那个样子，而是变成了一套以 Docker 容器为技术核心，以 Docker 镜像为打包标准的、全新的&amp;quot;容器化&amp;quot;思路。&lt;/strong>&lt;/p>
&lt;p>&lt;strong>这，正是 Docker 项目从一开始悉心运作&amp;quot;容器化&amp;quot;理念和经营整个 Docker 生态的主要目的。&lt;/strong>&lt;/p>
&lt;p>而 Swarm 项目，正是接下来承接 Docker 公司所有这些努力的关键所在。&lt;/p>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>今天，我着重介绍了 Docker 项目在短时间内迅速崛起的三个重要原因：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>Docker 镜像通过技术手段解决了 PaaS 的根本性问题；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Docker 容器同开发者之间有着与生俱来的密切关系；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>PaaS 概念已经深入人心的完美契机。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>崭露头角的 Docker 公司，也终于能够以一个更加强硬的姿态来面对这个曾经无比强势，但现在却完全不知所措的云计算市场。而 2014 年底的 DockerCon 欧洲峰会，则正式拉开了 Docker 公司扩张的序幕。&lt;/p>
&lt;h2 id="思考题">思考题&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>你是否认同 dotCloud 公司改名并开启扩张道路的战略选择？&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Docker 公司凭借&amp;quot;开源&amp;quot;和&amp;quot;开发者社群&amp;quot;这两个关键词完成崛起的过程，对你和你所在的团队有什么启发？&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>感谢收听，欢迎你给我留言，也欢迎分享给更多的朋友一起阅读。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/47/55/47a6f3bf6b92d58512d5a2ed0a556f55.jpg" alt="">&lt;/p></description></item><item><title>极客专栏: 03丨“老周，我想知道”丨律师就在你身边（三）</title><link>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E7%99%BD%E8%AF%9D%E6%B3%95%E5%BE%8B/03%E4%B8%A8%E8%80%81%E5%91%A8%E6%88%91%E6%83%B3%E7%9F%A5%E9%81%93%E4%B8%A8%E5%BE%8B%E5%B8%88%E5%B0%B1%E5%9C%A8%E4%BD%A0%E8%BA%AB%E8%BE%B9%E4%B8%89/</link><pubDate>Tue, 07 Jun 2022 00:00:00 +0000</pubDate><guid>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E7%99%BD%E8%AF%9D%E6%B3%95%E5%BE%8B/03%E4%B8%A8%E8%80%81%E5%91%A8%E6%88%91%E6%83%B3%E7%9F%A5%E9%81%93%E4%B8%A8%E5%BE%8B%E5%B8%88%E5%B0%B1%E5%9C%A8%E4%BD%A0%E8%BA%AB%E8%BE%B9%E4%B8%89/</guid><description>
&lt;p>今天是我们&amp;quot;法律咨询&amp;quot;的第三期。这次，我同样选取了专栏留言频次较高的十二个问题，给你做了相应的解答。接下来我们来看这些问答。&lt;/p>
&lt;p>&lt;strong>第一问：对于一些公司不指名道姓，但是打擦边球的做法，应该怎么看呢？类似于，我发布一个 APP 叫做&amp;quot;极客某间&amp;quot;，这类行为。&lt;/strong>&lt;/p>
&lt;p>老周答：这种事情其实主要看的是行为的界限，如果你的做法，以假乱真到了让别人以为你就是&amp;quot;极客时间&amp;quot;的产品，或者属于&amp;quot;极客时间&amp;quot;，那可能就涉及到侵权问题了。&lt;/p>
&lt;p>关于知识产权的内容，我们在文章中也有说明，现在国家已经加大了对知识产权的保护力度，同时也加大了惩处力度。&lt;/p>
&lt;p>因此，这种做法非常不可取。一旦你真的这么做了，哪怕后期在运营上投入再大的成本，来抹平此事，只要先前已经存在侵权行为，随时可能让你的所有投入付诸东流，最终一无所有。&lt;/p>
&lt;p>另外，在职场的人际关系也是如此。如果你含沙射影地侮辱、谩骂某个同事或领导，同样可能侵犯他人的名誉权。不要小看名誉权侵权问题，除了要负民事责任外，你很有可能因为这个违法行为，被公司依法辞退。&lt;/p>
&lt;p>&lt;strong>第二问：如果一些公司或产品的负面消息属实，我可以发布或者转发吗？比如说，我买了某个品牌的矿泉水，在没开封前，就发现了水里有虫子。这种情况下，我拍照上传照片，并且转发微博，还引起了大量关注的话，该怎么算呢？&lt;/strong>&lt;/p>
&lt;p>老周答：首先要注意的是，虽然我们在新闻或微博上经常见到这类例子，但大部分都是编造虚假信息，或者故意夸大后果。所以，还是那句话，转发需谨慎。&lt;/p>
&lt;p>当然，如果你买的商品确实有安全或者质量问题，比如说里面有虫子这种情况，那客观陈述并且借助社交工具等公开发布，并不会涉及侵权问题。&lt;/p>
&lt;p>不过千万要注意，客观陈述。如果有添油加醋的描述，可能就是侵权了。另外，还要注意的是，警惕冒牌，不要&amp;quot;冤枉好人&amp;quot;，毕竟，现在的&amp;quot;冒牌某水&amp;quot;还是很多的。&lt;/p>
&lt;p>&lt;strong>第三问：我以前买车是通过丰田旗下的丰田金融公司贷的款，机动车登记证书也抵押在了丰田金融。今年还清了贷款，可在我办理解除抵押手续时，业务员突然要收 100 元解除手续费。因为急着办手续，我没多想就给了钱，回家后越想越觉得不对劲儿，这笔钱没开发票，甚至连收据都没有。请问，这笔钱合理吗？&lt;/strong>&lt;/p>
&lt;p>老周答：不合理。合理收取任何费用的前提，都是提前约定好，或者经过协商后双方同意。否则，你都可以拒绝。&lt;/p>
&lt;p>&lt;strong>第四问：我和某位朋友借了一笔钱并打了欠条，在还款时，需要对方归还欠条吗？如果对方说欠条丢了，该怎么办呢？&lt;/strong>&lt;/p>
&lt;p>老周答：首先要注意，还款时自然需要对方归还欠条。&lt;/p>
&lt;p>不过，如果欠条真的丢了，那你的还款操作，尽量应该通过银行转账的方式进行，并且备注清楚这笔钱的用途，最好不要现金还款。这样，哪怕对方未归还欠条，一旦发生纠纷，你还有银行的转账记录做证明。&lt;/p>
&lt;p>另外，如果欠条丢失，你还可以要求对方写个&amp;quot;说明&amp;quot;，证明欠条已经丢失并且已经作废，你欠他的钱都已经还清楚了。&lt;/p>
&lt;p>&lt;strong>第五问：我的劳动合同还没有到期，公司也没有破产，可是在我没有犯错的情况下，公司无缘无故辞退我。如果我等 30 天以后再走，能有 2N 赔偿吗？&lt;/strong>&lt;/p>
&lt;p>老周答：公司这种行为属于违法辞退，你自然可以要求 2N 赔偿。而且，只要是违法辞退的情况，不管你什么时候离开，都不影响你主张你的合法权益，也就是获得 2N 赔偿。&lt;/p>
&lt;p>&lt;strong>第六问：在职期间，公司并没有给我们安排体检。有一天，我突然发病，医生说是三高并发症，并且以后必须长期服药、定期检查。请问，这算是工伤吗？&lt;/strong>&lt;/p>
&lt;p>老周答：不算工伤。首先你要清楚一点，给员工体检并不是公司的法定义务，所以这一点公司并没有过错。&lt;/p>
&lt;p>另外，&amp;ldquo;三高&amp;quot;不属于工伤的职业病范畴，在工伤篇我们讲过，连胃病、颈椎病这些也都不属于职业病。同时，你也不能证明自己的&amp;quot;三高&amp;rdquo;，是在工作场所因为工作原因造成的。&lt;/p>
&lt;p>综合来看，这个不能认定为工伤，还是要自己多爱惜身体，定期锻炼，定期体检。&lt;/p>
&lt;p>&lt;strong>第七问：借款凭证上，借款人只用在最后地方手写签字，就可以生效吗？他要是不认，非说这是伪造呢？&lt;/strong>&lt;/p>
&lt;p>老周答：一般情况下，不管借款人在最后地方签字，或者借款人全部书写借款凭证，都不影响法律效力。如果借款人矢口否认，认为他的签名是伪造的，你们可以通过司法鉴定来鉴别。&lt;/p>
&lt;p>另外一点，也是我多次强调的地方。不管是还钱，还是借钱给别人时，尽量用银行转账的方式，这样再配合你们的借款凭证，就比较保险了。&lt;/p>
&lt;p>&lt;strong>第八问：朋友租房，本身约定的是房东来出物业费，但是房东却要求安保费和小区卫生费由租客来出，请问这样合法吗？&lt;/strong>&lt;/p>
&lt;p>老周答：通常情况下，物业管理费本身包括了保安费和卫生费。所以，这可能是房东为了多收点钱，而单独开设的名义。事实上，除非你们的签订的租房合同里特殊约定过，物业费不包括安保费和卫生费，其他情况下，租客都可以拒绝支付。&lt;/p>
&lt;p>试想，物业费里，如果连卫生费都不包括，那还要物业做什么呢？另外，租客也可以去物业管理公司，咨询清楚具体的物业费情况，以便有理有据和房东交涉。&lt;/p>
&lt;p>&lt;strong>第九问：我在新单位已经入职七个月了，并且通过了六个月试用期，但转正申请一直被领导搁置着，还没有正是批下来，其他都正常。法律上讲，我过了试用期了吗？如果现在被裁，是按正式员工待遇，还是未通过试用期的待遇来赔偿呢？&lt;/strong>&lt;/p>
&lt;p>老周答：你的试用期已满，只要你还继续在这家公司工作，就说明试用期已经结束了，已经进入正式合同的期限。不管公司找什么理由，都不能你通过了试用期的事实，公司应按正式员工对待。如果公司强行辞退，那就属于违法辞退行为，你可以获得正式员工该有的赔偿。&lt;/p>
&lt;p>&lt;strong>第十问：公司经理在微信上告诉我，让我递交辞呈自己走人，同时，公司还拖欠报销工资，这个该如何处理？&lt;/strong>&lt;/p>
&lt;p>老周答：首先，就辞退一事，你应该让公司出具书面合同解除劳动关系，证明是公司主动要求解除，而不是你主动辞职，这是两个完全不同的概念。&lt;/p>
&lt;p>至于拖欠报销款项，应该和工资以及经济补偿金等，一起向公司索要。&lt;/p>
&lt;p>&lt;strong>第十一问：我已经签过无固定期限劳动合同，这种情况下，公司可以裁掉我吗？&lt;/strong>&lt;/p>
&lt;p>老周答：这种情况下的裁员，属于公司违法解除。如果你同意的话，公司需要向你支付经济赔偿金；如果你不同意解除劳动关系，那么劳动合同就继续进行，公司不能强行解除。&lt;/p>
&lt;p>&lt;strong>第十二问：在正常上下班时间，驾驶私家车前往公司途中，发生了交通事故，并且本人要负次要责任，这种情况算工伤吗？&lt;/strong>&lt;/p>
&lt;p>老周答：工伤一文中讲过，上下班途中发生交通事故，如果负主要责任，那就不属于工伤；如果不负责任，或者只负次要责任，应当被认定为工伤。所以这种情况可以算工伤。&lt;/p>
&lt;p>今天主要回答这些问题。那么，你还有什么疑惑想问我，或者有什么心得想要和我分享的吗？欢迎留言告诉我，也欢迎点击右下方的&amp;quot;请朋友读&amp;quot;，把今天所学分享给你的家人、朋友。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/cc/ff/cc229a6309f93017826a07452f3250ff.jpg" alt="">&lt;/p></description></item></channel></rss>