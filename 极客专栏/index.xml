<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>技术文章摘抄 – 极客专栏</title><link>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/</link><description>Recent content in 极客专栏 on 技术文章摘抄</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Fri, 08 Jul 2022 00:00:00 +0000</lastBuildDate><atom:link href="/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/index.xml" rel="self" type="application/rss+xml"/><item><title>极客专栏: 00丨导读丨如何学习这个专栏？</title><link>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E5%85%A8%E6%A0%88%E5%B7%A5%E7%A8%8B%E5%B8%88%E4%BF%AE%E7%82%BC%E6%8C%87%E5%8D%97/00%E4%B8%A8%E5%AF%BC%E8%AF%BB%E4%B8%A8%E5%A6%82%E4%BD%95%E5%AD%A6%E4%B9%A0%E8%BF%99%E4%B8%AA%E4%B8%93%E6%A0%8F/</link><pubDate>Tue, 07 Jun 2022 00:00:00 +0000</pubDate><guid>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E5%85%A8%E6%A0%88%E5%B7%A5%E7%A8%8B%E5%B8%88%E4%BF%AE%E7%82%BC%E6%8C%87%E5%8D%97/00%E4%B8%A8%E5%AF%BC%E8%AF%BB%E4%B8%A8%E5%A6%82%E4%BD%95%E5%AD%A6%E4%B9%A0%E8%BF%99%E4%B8%AA%E4%B8%93%E6%A0%8F/</guid><description>
&lt;p>你好，欢迎来到&amp;quot;全栈工程师修炼指南&amp;quot;，我是专栏编辑王冬青，很高兴认识你。&lt;/p>
&lt;p>这个专栏我们邀请了西雅图 Oracle 首席软件工程师四火，历时半年打磨完成。为了帮助你更好地了解专栏的内容设计，收获更好的学习效果，我们特别提供了这篇导读，希望你能在这里找到学习这个专栏的最佳姿势。&lt;/p>
&lt;h2 id="课程设计">课程设计&lt;/h2>
&lt;p>本专栏围绕基于 Web 的全栈技术进行展开，主要包括&amp;quot;网络协议和 Web 接口、服务端 MVC、前端技术、数据持久化、最佳实践和专题&amp;quot;。&lt;/p>
&lt;h3 id="1-学习目标">1. 学习目标&lt;/h3>
&lt;p>学完之后，你可以对基于 Web 的全栈技术有一个系统的认识，深度掌握全栈工程师必备技能，理解技术本质，而不仅仅是停留在技术配置和使用的表象，能够将作者交付的知识复用到自己的实际进阶中去。另外，你还可以将零散的知识点联结成一棵全栈技能树，培养&amp;quot;全栈思维&amp;quot;。&lt;/p>
&lt;h3 id="2-内容优势">2. 内容优势&lt;/h3>
&lt;p>专栏内容可以帮助你在入门或者进阶全栈的道路上，梳理出一条高效的学习路径，并掌握这条路径上有代表性的技术。&lt;/p>
&lt;p>目前市面上针对单一 、具体技术的教程有很多，但我们独辟蹊径，以系统的全栈技术关系树为基石，重点关注核心技术栈主流技术之间的关联和演进，介绍这些技术间的权衡，探究它们的本质，结合实践、沉淀知识、带动思考。&lt;/p>
&lt;h3 id="3-特色板块">3. 特色板块&lt;/h3>
&lt;p>**热点答疑：**基于内容性质，我们在前五章的最后一讲都设置了热点答疑，目的就是综合你的留言反馈进行分享，定位是较为开放式的，不局限于每一讲中的问题解答。关于&amp;quot;全栈工程师&amp;quot;这一职位，除了某一特定技术点，如果你有更感兴趣的内容，也可以在留言区中告知我们，这个专栏是可以有一些外延性质的话题分享的，比如已定的 《06 | 特别放送：北美大厂如何招聘全栈工程师？》，希望能帮助你拓展技术视野，你可以对照北美大厂的招聘标准和流程重新界定下自己所处的位置，进而有针对性地进行学习。&lt;/p>
&lt;p>**总结思考：**鉴于这个专栏的总结和思考是有强关联的，所以我们合并到了一起，总结主要就是回顾这一讲所学的内容，很好理解了。要特别说明下思考题部分，每一讲的末尾我们会设置两道思考题，一道难度较低，另一道难度略有升级，你可以根据自己的学习程度和本身积累在留言区中分享答案，作者会有针对性地进行回复。当然了，如果可以，十分鼓励你两道都解答一下，对于消化理解所学的知识内容，培养自己的全栈思维很有帮助。&lt;/p>
&lt;p>**选修课堂：**这是一个全新的板块，如果我们将总结思考之前的内容，定位为必修，那么选修课堂的功能就一目了然了。这部分的内容你可以结合自身情况，选择性阅读，它们是与该讲主题强相关的知识，但不会影响必修部分的学习，它们可能该讲中某一步骤的实践过程，帮助你强化认识，也可能是某一重要知识点的详细讲解，帮助你查漏补缺。同时，这个板块是根据每一讲的主题进行考虑的，对于无需增设选修课堂的主题，总结思考之后会直接进入&amp;quot;扩展阅读&amp;quot;板块。&lt;/p>
&lt;p>**扩展阅读：**同上，也是一个全新的板块，每一讲作者都精心准备了一组链接，大致 3~5 篇，每个链接都有文字说明。出于对质量的考虑，这里有部分是英文资料，这里要再强调一下，英文能力也是软件工程师进阶的必备能力之一，这一点作者在学习路径中已经谈过了，但修炼英文非朝夕之事，你也不必过于担心，同等质量下作者会优先选择中文资料进行推荐，如果理解上有困难，还可以借助一些翻译软件，遇到难点，也可以在留言区中与作者探讨。&lt;/p>
&lt;p>这些资料有自己的定位，不是&amp;quot;有了更好、没有也行&amp;quot;的可有可无的内容，而是可以帮助你进一步展开学习的重要资料。考虑到每个人的基础不同，它们有的是简单的教程，也有的是技术背景介绍，还有某一技术长项和短处的拓展分析等等。&lt;/p>
&lt;p>值得注意的是，少数资料前会标有【基础】字样，这表示该内容涉及的知识点较为基础，如果你对该讲的理解有困难，可以去这样的链接中找找答案。另外，这些资料中没有大厚书，并不是说它们不好，而是作者希望每一讲的内容，你都能在有限的时间内完成阅读、思考、练习和拓展这样的一个闭环。&lt;/p>
&lt;h2 id="学习攻略">学习攻略&lt;/h2>
&lt;p>除了介绍课程设计之外，我还为你准备了六大攻略，都是针对这个专栏的学习方法，帮助你提升学习效率和收获感。&lt;/p>
&lt;h3 id="攻略一利用好特色板块">攻略一：利用好特色板块&lt;/h3>
&lt;p>鉴于全栈工程师的学习性质，这个专栏我们开创了不少特色板块，每个板块的作用在上面我都做了详细说明。请你一定要结合自身情况利用好它们，尽可能不要错过&amp;quot;选修课堂&amp;quot;和&amp;quot;扩展阅读&amp;quot;，它们是可以帮助你快速提升，且拓展你知识版图的内容。&lt;/p>
&lt;h3 id="攻略二勤于动手实践">攻略二：勤于动手实践&lt;/h3>
&lt;p>全栈所包含的知识点非常多，最好的记忆方式就是实践，亲身操作一遍，你会打开一扇新世界的大门&amp;mdash;&amp;mdash;原来全栈并没有那么难。跟着作者文章中分享的小案例亲自做一做，跑一跑代码，自己验证下结论，这是个很高效的学习方法，我十分鼓励你这样做。&lt;/p>
&lt;p>不过也正因为这些案例，我推荐你首选文字 + 音频这样的学习方式，只听音频的话，对于这个专栏来说，理解上会有一定难度。&lt;/p>
&lt;h3 id="攻略三在联想和比较中学习">攻略三：在联想和比较中学习&lt;/h3>
&lt;p>基于全栈知识树庞大和繁杂的特点，它的学习方法会有所不同，它需要你多去尝试比较同类技术，并且将所学理论和工作中实际应用的技术、遇到的问题结合起来。它需要你掌握隐藏在具体技术背后的通用&amp;quot;套路&amp;quot;，联结不同技术，使之成为一个健壮的知识网格，真正将技术的理解落实到本质上去。&lt;/p>
&lt;h3 id="攻略四充分利用留言区">攻略四：充分利用留言区&lt;/h3>
&lt;p>留言区最直观的作用就是完成思考题，每一讲的思考题都是作者精选的，如果你能解答，并分享出来，得到作者和其他同学的肯定，相信你已经对该讲的内容有了深度的认识了，通过这样的方式对所学进行自我检验，是个非常高效的方法。&lt;/p>
&lt;p>除此之外，你还可以在这里进行学习总结、强化输出，提出问题、解决困惑，回复他人留言、发起互动，从&amp;quot;消费者&amp;quot;角色升级到&amp;quot;生产者&amp;quot;角色。&lt;/p>
&lt;p>如果你在留言区中写下的增量信息够硬核，还有机会让作者精选出来，在该章的最后一讲&amp;quot;热点答疑&amp;quot;中做深度讲解。&lt;/p>
&lt;h3 id="攻略五善于分享">攻略五：善于分享&lt;/h3>
&lt;p>极客时间平台提供了很多分享功能。比如，看到硬核知识点、金句或深有感触的内容，你可以长按做划线笔记，点击分享就可以生成精美的知识卡片，将所学随手记录或分享出去。如果你希望分享整篇文章，或者邀请你的朋友一起打卡学习，还可以点击文稿右上角的&amp;quot;请朋友读&amp;quot;，把这门课推荐给朋友。&lt;/p>
&lt;p>这里的分享更像是一种知识交换，给予越多，收获自然也就越多，期待在这个过程中，你的知识体系也能得到锤炼。&lt;/p>
&lt;h3 id="攻略六有计划地学习">攻略六：有计划地学习&lt;/h3>
&lt;p>这个专栏的更新频率为每周一、三、五，共计 40 讲，更新时间 14 周，你可以跟着作者的更新频率进行学习。一篇文章发布后你有两天的学习时间，你可以一天学习每讲的必修内容，一天学习选修课堂和扩展阅读，当然了，你也可以根据自身情况，自己制定合理的学习计划。&lt;/p>
&lt;p>修炼全栈，横向对比技术，纵向挖掘技术，再串联知识，形成一个知识体系，这本身并不是一件容易的事儿。在有作者引导的基础上，希望你能充分调动自身内驱力，将学习坚持下去，期待在最后的《全栈回顾》中见到你的打卡哦～&lt;/p>
&lt;p>最后，祝你学以致用、实现进阶。加油！&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/11/8b/1181246bbd51ce348d5729696d1dc28b.jpg" alt="unpreview">&lt;/p></description></item><item><title>极客专栏: 00丨开篇词 _ 一个态度两个步骤，成为容器实战高手</title><link>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E5%AE%B9%E5%99%A8%E9%AB%98%E6%89%8B%E5%AE%9E%E6%88%98%E8%AF%BE/00%E4%B8%A8%E5%BC%80%E7%AF%87%E8%AF%8D-_-%E4%B8%80%E4%B8%AA%E6%80%81%E5%BA%A6%E4%B8%A4%E4%B8%AA%E6%AD%A5%E9%AA%A4%E6%88%90%E4%B8%BA%E5%AE%B9%E5%99%A8%E5%AE%9E%E6%88%98%E9%AB%98%E6%89%8B/</link><pubDate>Fri, 08 Jul 2022 00:00:00 +0000</pubDate><guid>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E5%AE%B9%E5%99%A8%E9%AB%98%E6%89%8B%E5%AE%9E%E6%88%98%E8%AF%BE/00%E4%B8%A8%E5%BC%80%E7%AF%87%E8%AF%8D-_-%E4%B8%80%E4%B8%AA%E6%80%81%E5%BA%A6%E4%B8%A4%E4%B8%AA%E6%AD%A5%E9%AA%A4%E6%88%90%E4%B8%BA%E5%AE%B9%E5%99%A8%E5%AE%9E%E6%88%98%E9%AB%98%E6%89%8B/</guid><description>
&lt;p>你好，我是李程远，欢迎你加入我的极客时间专栏。从今天开始，我想和你聊一聊，怎么解决容器里的各种问题。&lt;/p>
&lt;p>先来介绍一下我自己吧。我毕业于浙江大学计算机系，第一份工作是开发基于 Xen 的 Linux 虚拟机，接下来的十几年，我的工作始终围绕着 Linux 系统。&lt;/p>
&lt;p>在 2013 年，我加入 eBay，从事云平台方面的工作，最先接触的是 OpenStack 云平台。&lt;/p>
&lt;p>一直到了 2015 年的时候，我们的团队开始做 Kubernetes，要用 Kubernetes 来管理 eBay 整个云平台。我们需要迁移所有 eBay 的应用程序，把它们从原来的物理机或者虚拟机迁移到容器的环境里。&lt;/p>
&lt;p>在 Kubernetes 具体落地的过程中，我们碰到了形形色色的容器问题。&lt;/p>
&lt;p>首先，我们都知道，容器是一种轻量级的隔离技术。而轻量级隔离造成了一些&lt;strong>行为模式&lt;/strong>的不同，比如原来运行在虚拟机里的 CPU 监控程序，移到容器之后，再用原来的算法计算容器 CPU 使用率就不适用了。&lt;/p>
&lt;p>然后呢，从&lt;strong>隔离程度&lt;/strong>这个方面考虑，CPU、memory、IO （disk and network）真的能做到精确隔离吗？&lt;/p>
&lt;p>其实还是有问题的，比如想让多个用户容器运行在一个节点上，我们就需要保证，每个容器的磁盘容量在一定的限额范围内，还而且需要合理分配磁盘读写性能。&lt;/p>
&lt;p>第三个方面，就是**处理性能敏感的应用。**容器技术的引入，会带来新的开销，那么肯定会影响性能。&lt;/p>
&lt;p>比如说，原来运行在物理机上、有极高性能要求的程序，在迁移到容器后，我们还需要对容器网络做优化，对 Cgroup 做优化。只有做了这样的优化，我们才能保证迁移过来的程序，当它们运行在容器里的时候，性能差异控制在 2% 以内（当时做迁移的标准）。&lt;/p>
&lt;p>另外，如果涉及高内存使用的应用，我们做迁移的时候，还要考虑 PageCache、Swap，还有 HugePage 等等问题，在叠加了 Cgroup 之后，会带来新的变化。&lt;/p>
&lt;p>综合来看，我们遇到的问题有的很简单，看一下源代码，写个测试代码验证一下，一两个小时就可以搞定。但有的问题却很复杂，我们需要尝试不同的测试，反复查看各种源代码，陆陆续续花费一两个月的时间解决。&lt;/p>
&lt;p>通过 5 年的不断努力，我和我的团队逐渐把 eBay 所有的业务都迁移到了容器中。现在，我们的云平台上运行着百万个容器。&lt;/p>
&lt;h1 id="怎么理解容器的知识体系">怎么理解容器的知识体系？&lt;/h1>
&lt;p>可以说，从我接触容器知识到能够得心应手地解决各种容器问题，这个过程还真是有点磕磕绊绊。&lt;/p>
&lt;p>一开始，我被各种各样的问题所淹没，觉得容器的内容太复杂了，没有一个系统性的解决方法。我只能是见招拆招，一个个解决，就这样，随着我解决的问题越来越多，我也开始思考，是不是有一些规律性的东西。&lt;/p>
&lt;p>容器问题虽然有很多类型，既有基本功能问题，也有性能问题，还有不少稳定性问题。但大部分问题，&lt;strong>最终都会归结到 Linux 操作系统上。&lt;/strong>&lt;/p>
&lt;p>比如，容器里进程被 OOM Kill 了，这个 OOM Killer 就是 Linux 里常见的内存保护机制；容器的进程引起平均负载增高，而平均负载也是在 Linux 里被反复讨论的概念；还有，容器使用的 OverlayFS 系统，看上去和 Linux 常用的 XFS、Ext4 系统不同，但是它也是 Linux 内核维护的一种文件系统。&lt;/p>
&lt;p>我们都知道，Linux 操作系统不外乎是**进程管理、内存管理、文件系统、网络协议栈，再加上一些安全管理。**这样一梳理，容器的问题就都可以投射到 Linux 操作系统这些模块上了，是不是一下子感觉清晰了很多？&lt;/p>
&lt;p>当然了，容器还有自己的特殊性，Linux 内核原来的特性加上 Namespace 和 Cgroups 会带来的变化。&lt;/p>
&lt;p>所以，我们在对应到每个模块上分析问题的时候，还需要考虑到 Namespace 和 Cgroups。这两个概念是容器技术的基石，我们课程中要讨论的容器相关问题，多少都会和 Namespace 或者 Cgroups 相关。&lt;/p>
&lt;p>总之就是一句话，&lt;strong>我们可以结合 Linux 操作系统的主要模块，把容器的知识结构系统地串联起来，同时看到 Namespace 和 Cgroups 带来的特殊性。&lt;/strong>&lt;br>
&lt;img src="https://static001.geekbang.org/resource/image/e0/21/e033032867a9cff7d399871c604ae921.jpeg" alt="">&lt;/p>
&lt;h1 id="怎么解决容器问题">怎么解决容器问题？&lt;/h1>
&lt;p>心中有了容器的知识体系，我们也就能在容器实践中解决具体的问题了。结合我自己这么多年的经历，我总结了一条经验，&lt;strong>解决容器问题需要一个态度 + 两个步骤。&lt;/strong>&lt;/p>
&lt;p>在解决容器问题的过程中，我们常见的误区就是浅尝辄止，不去挖掘问题的根本原因。我之前也碰到过这种情况，接下来我就拿一个具体的例子来说明。&lt;/p>
&lt;p>有一次团队一位同学问我，怎么让 Kubernetes 节点上的容器，从内部触发自己的容器重启啊？&lt;/p>
&lt;p>我试了一下，在容器中把第 1 号进程杀了，然后容器退出，Kubernetes 自动地把容器带回来，就能实现类似的自动重启功能了，同事试了也可以，认为问题解决了，也挺开心的。我也没有多想，以为自己找到方法了。&lt;/p>
&lt;p>后来又有一个同事和我说，这样做没有效果啊。我这才发现问题没那么简单，是我想当然了。&lt;/p>
&lt;p>所以，我又花时间理了理 Linux 信号的基本知识，trace 了一下内核代码，终于让我找到了真正的原因，那就是对于发送给 1 号进程的信号，内核会根据不同的类型、不同的注册状态，采取不同的处理方式。&lt;/p>
&lt;p>你看，这是一个挺简单的问题，就是 kill 一下容器里的 1 号进程。你或许也遇到过，如果你也和我开始时的态度一样，就很可能会错过找到真正答案的机会。这就是我说的，解决容器问题时我们需要的一个态度：不要浅尝辄止，要刨根问底。&lt;/p>
&lt;p>态度有了，那如果我们在线上碰到了更加复杂的问题，又该怎么解决呢？这就需要两个步骤了。&lt;/p>
&lt;p>我们的第一步，就是&lt;strong>化繁为简，重现问题。&lt;/strong>&lt;/p>
&lt;p>想要做到这一点，倒推回去，还是需要我们对基本的概念足够了解。只有对每个模块的概念都很清晰，我们才能对复杂问题做拆分。&lt;/p>
&lt;p>能够对问题做拆分是不是就够了呢？其实还不够，我自己有一个判断标准，就是还要能够写模拟程序，看是否可以用最简单的程序来重现问题。&lt;strong>如果我们能用简单的代码程序重现问题，那么问题也就解决了一半。&lt;/strong>&lt;/p>
&lt;p>接下来我们还需要进行第二步，就是想办法&lt;strong>把黑盒系统变成白盒系统。&lt;/strong>&lt;/p>
&lt;p>我在前面提到过，容器的问题大多都会归结到 Linux 系统上。Linux 系统从内核、库函数以及服务程序上看，虽然都是开源的，但是它运行在生产环境的时候，几乎就是一个黑盒。&lt;/p>
&lt;p>之所以说系统是黑盒，一方面是因为这个系统太庞大，太复杂了；另一方面，在实际运行的时候，只有很少的 log 会记录运行的过程和参数。所以，在出问题的时候，我们无法知道问题对应的代码，我们也不可能在生产环境中随心所欲地加 debug log。&lt;/p>
&lt;p>因此，我们就需要想点办法把它变成白盒，才能去排查和解决问题。具体怎么做呢？这里需要我们熟练地掌握调试工具，这样才能把某些函数变成&amp;quot;白盒&amp;quot;，从而找到复杂问题的根本原因，再对症下药。&lt;/p>
&lt;p>这里我想提醒你的是，我们熟练掌握工具有个重要前提，就是从全局上去掌握 Linux 系统以及容器，回归到底层原理去看问题。可以说，你把基础概念吃透了，练好了&amp;quot;内功心法&amp;quot;，有了这个底子，工具运用是水到渠成的事儿。&lt;/p>
&lt;h1 id="我是怎么设计这门课的">我是怎么设计这门课的？&lt;/h1>
&lt;p>讲到这里，估计你会有个问题，这&amp;quot;一个态度两个步骤&amp;quot;很好理解啊，我也了解到了，但是怎么才能真正地掌握这些知识、拥有解决问题的思路呢？&lt;/p>
&lt;p>这就是我们这门课想要实现的目标了，那就是带你走进一个个具体的案例中，体验解决问题的全过程，在实战中习得知识和技能。&lt;/p>
&lt;p>所以，在这门课程里，我会把零散的知识点体系化，按照类似操作系统的模块划分，为你讲述我所理解的容器。&lt;/p>
&lt;p>我们将一起学习容器进程、容器内存、容器存储、 容器网络、容器安全这几部分内容。在每一节课中，我们都会解决一个实际问题或者研究一个现象。围绕这个问题，我会为你讲解相关的知识点，并带着你结合实际的操作做理解，最终解决问题或者解释现象。&lt;/p>
&lt;p>我们要实现两个学习目标。&lt;/p>
&lt;p>&lt;strong>第一，系统掌握容器核心点：Namespace 和 Cgroups。&lt;/strong>&lt;/p>
&lt;p>&lt;strong>第二，理解 Namespace 和 Cgroups 对 Linux 原来模块的影响，看看它们是如何影响一些传统操作系统的行为。&lt;/strong>&lt;/p>
&lt;p>比如 Memory Cgroup，对 Pagecache 和 Swap 空间有怎样的影响；再比如在 proc 文件系统下，我们的网络参数应用了 Network Namespace 之后，需要如何重新设置等等。&lt;/p>
&lt;p>当我们一起把容器知识的框架搭建起来，把里面的核心概念、底层逻辑掌握之后，你其实就可以解决容器的大部分问题了。但是，我知道，你一定还有个问题，那就是工具呢？不讲了吗？我真的可以水到渠成吗？&lt;/p>
&lt;p>不要着急，这里我要做个特别说明，课程结束后，我会给你做一个专题加餐。目前，我是这么设计的，我选择了一个真实案例，就是在生产环境中容器网络延时不稳定的问题。&lt;/p>
&lt;p>在这个案例中，我们会用到 &lt;strong>perf，ftrace，bcc/ebpf 这几个 Linux 调试工具&lt;/strong>，了解它们的原理，熟悉它们在调试问题的不同阶段所发挥的作用，然后用这些工具一起来解决现实场景中复杂的容器问题。&lt;/p>
&lt;p>为什么一定要把这个专题放到课程结束后呢？因为我需要给你留一段消化吸收的时间，这里我安排了一个月时间。&lt;/p>
&lt;p>希望你能利用这一个月，把整个课程的内容复习一遍，把基本功打扎实，你才能在专题学习里彻底掌握这几个工具，遇到类似问题时也能有清晰的解决思路，这样这个专题的学习效率也才能更高。&lt;/p>
&lt;p>之所以一定要这么安排，也是想跟你表达我的一个观点，就是工具很重要，但是工具不是最重要的。&lt;/p>
&lt;p>所有学习，我们一定是先掌握知识体系，一定不能陷入唯工具论的思维框架里。我知道，这样的安排似乎只是我的一家之言，但这恰恰就是我想通过这门课交付给你的，因为这些真的是我自己的经验之谈，是我的受益点。这么学看似慢了，但其实只有这样，我们走的才是捷径。&lt;br>
&lt;img src="https://static001.geekbang.org/resource/image/36/2a/36ee722764e0c3a7e1aba7999b26b52a.jpg" alt="">&lt;/p>
&lt;p>好了，介绍完了课程设计和学习目标，还有一件事特别重要，我要特别提醒下。&lt;/p>
&lt;p>在这个容器课程中，每一讲里都会有一些小例子，所以需要&lt;strong>你有一台安装有 Linux 的机器，或者用 VirtualBox 安装一个虚拟机来跑 Linux。Linux 的版本建议是 CentOS 8 或者是 Ubuntu 20.04。&lt;/strong>&lt;/p>
&lt;p>希望你提前做好准备，这样在学习的过程中，你就能跟着我的讲解进行一些实际的操作，对容器知识也会有更加深刻的印象。&lt;/p>
&lt;p>你还可以拉上身边的小伙伴，组团来学习这门课程，共同学习、互相鼓励的氛围会让你的学习体验更好。另外，有什么想法或者疑问，你都可以通过留言区和我交流、互动。&lt;/p>
&lt;p>最后，我想和你说，&lt;strong>容器是一个很好的技术窗口，它可以帮助你在这个瞬息万变的计算机世界里看到后面那些&amp;quot;不变&amp;quot;的技术，只有掌握好那些&amp;quot;不变&amp;quot;的技术，你才可以更加从容地去接受技术的瞬息万变。&lt;/strong>&lt;/p>
&lt;p>我希望，这个专栏能帮你打开容器这扇窗，让你看到更精彩的风景，建立起你自己的容器知识体系。从今天开始，跟着我一起搞懂容器，提升实力，吃透原理，在技术之路上一起前进吧！&lt;/p></description></item><item><title>极客专栏: 00丨开篇词｜我们为什么要学Vim？</title><link>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/vim-%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/00%E4%B8%A8%E5%BC%80%E7%AF%87%E8%AF%8D%E6%88%91%E4%BB%AC%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%AD%A6vim/</link><pubDate>Fri, 08 Jul 2022 00:00:00 +0000</pubDate><guid>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/vim-%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/00%E4%B8%A8%E5%BC%80%E7%AF%87%E8%AF%8D%E6%88%91%E4%BB%AC%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%AD%A6vim/</guid><description>
&lt;p>你好，我是吴咏炜。&lt;/p>
&lt;p>今年 2 月，我在极客时间的第一门课程《现代 C++ 实战 30 讲》结课了。现在，我给你带来了一个全新的课程，《Vim 实用技巧必知必会》。&lt;/p>
&lt;p>这两门课虽然主题不同，但我准备它们的初衷却是完全一样的。我在 C++ 课程里分享过，我特别喜欢 Larry Wall（拉里 · 沃尔）所说的程序员的三大美德：懒惰，急切，傲慢（laziness, impatience, hubris）。正是这些美德，驱动我们不断地追求效率和极致，而 Vim 就恰恰是这样一个效率利器。我想通过接下来的课程，和你一起享受 Vim 带来的技术乐趣。&lt;/p>
&lt;h1 id="vim-的前世今生">Vim 的&amp;quot;前世今生&amp;quot;&lt;/h1>
&lt;p>说到 Vim，就不能不谈一下 vi；要说 vi，那跟 Unix 就有着千丝万缕的联系。万物起源总有那么点故事，我们这个课程的主题也不例外。这个故事可以讲上很长时间，不过，今天不是故事会时间，我只会花几分钟给你快速梳理一下这段历史，带你了解 Vim 的&amp;quot;前世&amp;quot;，也就能更好地理解它的&amp;quot;今生&amp;quot;。&lt;/p>
&lt;p>故事的开头是在 1975 年秋天，Unix 诞生之后的第六年。Ken Thompson（肯 · 汤普逊）来到了加利福尼亚大学伯克利分校，开始了为期一年的访问教授生活。当然，他也带上了最新版本的 Unix 的补丁。根据传说，由于贝尔实验室律师们的阻挠，他不能直接把补丁给其他人，而只能把装有补丁的磁带&amp;quot;丢&amp;quot;在某个地方，然后由别人&amp;quot;正好&amp;quot;捡到&amp;hellip;&amp;hellip;Unix 就以这种&amp;quot;地下&amp;quot;的传播方式流传开了。&lt;/p>
&lt;p>同年，年轻的 Bill Joy（比尔 · 乔伊）也进入了加利福尼亚大学伯克利分校，学习电子工程和计算机科学。他立刻就迷上了 Unix。在后面几年的硕士生涯里，他修正了 Unix 里的 Pascal 系统，使得 Pascal 成了学生编程的缺省选择。他在 1978 年负责发布了第一个伯克利发行版（BSD，即 Berkeley Software Distribution），其中包含了他写的 ex，一个编辑器 ed 的改进版本。随即，在 1979 年他发布了第二版的伯克利 Unix（2BSD），包含了他写的 vi 和 csh。他独立实现了 BSD 中的 TCP/IP 栈。&lt;/p>
&lt;p>离开伯克利后，他成了 Sun 的联合创始人和首席科学家，在 Solaris 操作系统、NFS 网络文件系统、SPARC 处理器、Java 语言的开发等多个领域中作出了自己的贡献&amp;hellip;&amp;hellip;&lt;/p>
&lt;p>在 Bill Joy 的无数传奇故事里，有一个是，他只花了一个周末就写出了 vi。这当然&amp;hellip;&amp;hellip;不是真的。vi 是演进的结果，前面还有 ed、em、en、ex（哈，对于两字母的 Unix 命令，我看得也是有点晕了🤔）等等一系列。只不过，那些都是基于命令的行编辑器，而不是全屏编辑器（部分原因是那时的很多系统仍然使用着电传打字机，而不是 CRT 终端）。vi 可以充分使用整个终端屏幕的资源，易用性的提升是毋庸置疑的。&lt;/p>
&lt;p>不管怎么说，vi 只是一个 Bill 无意插柳柳成荫的结果，是他职业生涯中的一个副产品而已。在 1982 年初，Bill Joy 加入 Sun 公司之后，vi 就不怎么有人维护了。此外，由于没有得到 AT&amp;amp;T 授权的公司和个人也不能使用 vi 的源码（律师又一次发挥了威力），因此，大量的 vi 克隆版本纷纷出现。&lt;/p>
&lt;p>目前大部分 Linux 发行版和 macOS 中的 vi 命令唤起的都是 Vim，一个由 Bram Moolenaar（布莱姆 · 穆勒纳尔）持续开发维护了三十多年的 vi 克隆（想想，三十年在计算机的发展中，那是经历了多少代技术的演进！）。在这些年里，其他的 vi 克隆诞生又死去，最后只剩下了 Vim（好吧，&amp;ldquo;只&amp;quot;是夸张手法）。起初，Vim 的意思是 Vi IMitation，但很快就成了 Vi IMproved。而这，就是我们这个课程的主题。&lt;br>
&lt;img src="https://static001.geekbang.org/resource/image/9b/25/9b1e4becb3efd52b7376142bc8584c25.jpeg" alt="">&lt;br>
三位大牛&lt;/p>
&lt;h1 id="vim-的优势">Vim 的优势&lt;/h1>
&lt;p>vi 有着一个非常老古董的设计，就是它是一个有&amp;quot;模式&amp;quot;的编辑器。其他大部分编辑器都相当于 vi 的插入模式，输入什么字符就会在屏幕上出现什么字符。但 vi 的行为不是如此。&lt;/p>
&lt;p>事实上，这种不那么直观的设计，即使在 vi 初次出现的 20 世纪 70 年代，也被认为是违反人机交互的原则的。所有的后续 vi 实现，包括 Vim，都继承了 vi 的模式设计。&lt;/p>
&lt;p>令人惊讶的恐怕是，尽管有这些问题，Vim 在程序员群体中的流行程度并没有受到影响。根据 Stack Overflow 的开发者调查：2015 年程序员中最流行的编辑器是 Notepad++，Vim 的使用比例是 15.2%；2019 年最流行的开发环境变成了 Visual Studio Code，而 Vim 的使用比例还保持在了 25.4%。&lt;/p>
&lt;p>这就是这门课程从头到尾都会试图回答的问题：Vim 到底好在哪里？&lt;/p>
&lt;p>拿我自己来说，我刚开始使用 Vim 时，不是出于选择，而是在 Linux 上开发的需要。不过，用着用着我就喜欢上 Vim 了&amp;mdash;&amp;mdash;不仅在 Linux 下用，也在 Windows 下用（从十几年前开始，我就一直自己编译和维护着一个 Windows 下的最新 Vim 可执行文件）。自打切换到了 Mac 上之后，当然就更不用说，MacVim 是日常打开次数最多的工具。这里面最最主要的原因，就是&lt;strong>使用 Vim 编辑文件非常高效&lt;/strong>。&lt;/p>
&lt;p>在很大程度上，vi 的&amp;quot;高效&amp;quot;是一种历史性的设计要求，当年程序员需要在网速 300 波特（大致认为是今天网速的百万分之一吧）的环境里编辑文本文件。那个时代，人们还不可能拥有自己的计算机，大学、政府、公司里的计算机全都通过终端来进行分时共用。因此，vi 在命令上不得不非常&amp;quot;经济&amp;rdquo;。好玩的是，这种经济性，在今天仍然非常有用，它是 vi 及其克隆软件的高效之源。&lt;/p>
&lt;p>我已经强调了几遍了，编辑的高效性，就是 Vim 最大的一个特点。除此之外，Vim 的优势还有很多，我来给你分享一下我认为最重要的三点。&lt;/p>
&lt;p>第一，与 vi 最初只运行在 Unix 平台上不同，&lt;strong>Vim 是一个完全跨平台的编辑器&lt;/strong>。&lt;/p>
&lt;p>它支持的第一个操作系统是 AmigaOS，然后被逐步移植到了大部分其他操作系统上，既有我们常见的 Unix/Linux、Windows、macOS，也有不常见或者过时的操作系统，如 OS/2、BeOS、OpenVMS，甚至在 iOS 和 Android 上也能找到 Vim 的移植版本。这可以算是 Vim 的一个重要优点了。这个课程里，我会介绍 Vim 在主流操作系统上的使用，包括 Linux、macOS 和 Windows。&lt;/p>
&lt;p>第二，&lt;strong>Vim 也是一个高度可定制、可扩展的编辑器&lt;/strong>。&lt;/p>
&lt;p>这对热爱折腾的程序员来说，绝对是一种乐趣，同时也是进一步提升效率的源泉。定制 Vim ，大部分情况下，你不需要什么特殊工具，使用 Vim 本身就可以。Vim 有自己的脚本语言，就叫 Vim 脚本（Vim script），语法相当简单，任何一个程序员应该都可以轻松地学会。配置文件和功能扩展都使用 Vim 脚本，使用统一的语法。同时，需要更强大的扩展能力还可以使用 Python、Perl、Ruby、Tcl 等其他通用的脚本语言，或者直接调用外部命令。你可以很容易打造一个你自己专属的开发环境，也很容易把这个环境从一台机器转移到另外一台机器上。&lt;/p>
&lt;p>第三，作为一个发展了几十年的老牌开源软件，&lt;strong>Vim 也有着良好的生态环境&lt;/strong>。&lt;/p>
&lt;p>网上可以找到大量的现成脚本和插件，能帮助你打造一个顺手的开发环境。总的来说，像语法检查、自动补全等程序员常用功能，全都可以在 Vim 里实现。你不需要离开 Vim，就可以完成从写代码、编译到运行的大部分工作。下面的这张图里，就展示了 Vim 的很多扩展一起工作的结果：&lt;br>
&lt;img src="https://static001.geekbang.org/resource/image/d7/yc/d71beed8a4e1e2b970c63f7317655yyc.png" alt="">&lt;br>
多个插件作用下的 Vim 界面&lt;/p>
&lt;p>你可以看到，左边栏展示了 Vim 相对当前 Git 版本的修改状态（一处增，一处改），波浪线标出了代码中目前有错误的部分，底部显示了错误的原因，下面有个小窗口显示了光标所在处相对 Git 版本的变化，状态栏里更是密密麻麻地显示了编辑器模式、Git 分支、文件名、修改状态等信息。这里面用到了好几个扩展，包括颜色主题也是一个扩展。&lt;/p>
&lt;p>虽然 Vim 最初是个针对字符界面的应用程序，但它也能支持主流的图形界面，包括 Windows 的图形界面，Linux 下的 GTK，以及 macOS 下的 Cocoa 和 Carbon，等等。作为一个并非&amp;quot;原教旨主义&amp;quot;的 Vim 用户，我个人是绝对赞成图形界面的使用的。因而我会推荐，只要有条件，就使用有图形界面的 Vim 版本。&lt;/p>
&lt;p>不过，这个课程的绝大部分内容是对图形界面和文本界面都有效的（在两者有区别的地方，我则会明确指出）。换句话说，在你只能使用基于字符界面进行远程连接时，Vim 的功能仍然大部分有效，只是界面的美观程度会受一定的影响而已。也由于这个原因，Vim 在后端开发人员中特别受欢迎。&lt;/p>
&lt;p>Vim 的模式是 Vim 的高效所在，但同时也是 Vim 学习上的一个难点。略有点搞笑的是，Stack Overflow 上有一个目前票数达到 3840 的问题是&amp;quot;如何退出 Vim 编辑器&amp;quot;，按问题票数排名可以进入前 100，这可能就是 Vim 的模式造成的困惑了。&lt;/p>
&lt;p>反过来，这个反常规的设计使得 Vim 可以使用很逻辑的多个按键来处理文本，比如，在正常模式使用 daw 三个按键代表 delete a word 来删除光标下的一个完整单词，也可以输入 : 进入命令模式使用&amp;quot;make&amp;quot;这样的完整命令来进行项目的构建。&lt;/p>
&lt;p>整体来说，Vim 会给你一个高效、跨平台、高定制性、易于扩展的开发环境。全面掌握 Vim 需要花费一定的时间进行学习。但这个时间不会白费，因为 Vim 可以在任何地方使用，它会成为你编程道路上一件称手的兵刃，让你成为更加高效的开发者。&lt;/p>
&lt;h1 id="课程主要内容">课程主要内容&lt;/h1>
&lt;p>比起很多&amp;quot;开箱即用&amp;quot;的编辑器，Vim 是有一定的学习曲线的。虽然学 Vim 比学编程容易多了，但对于非英语母语的人来说，Vim 又会难上一点点。我会尽量多讲原理，而不是枯燥地讲解命令。不得不讲命令的时候，我会使用图片和动画，让你能对相关内容有一个直观的理解。对于很多 Vim 的命令，我们是需要形成&amp;quot;肌肉记忆&amp;quot;的；我们不需要死记硬背，但需要多看、多练，熟能生巧，在学习过程中自然而然就掌握了使用 Vim 的技巧。&lt;/p>
&lt;p>作为一个有历史的编辑器，Vim 一直保持着非常良好的向后兼容性。学 Vim 学到的东西不会过时，在你的程序员生涯中一直可以用下去。我个人的 Vim 配置文件始于约 20 年前，慢慢地添砖加瓦，一直用到了今天。同时，Vim 也一直在发展，虽然不快，却也从来没有停下来（从发布 8.0 版本算起，平均每天 3.7 个补丁吧）。&lt;/p>
&lt;p>在这个课程中，我会基于目前最新的 Vim 8.2 来讲解 Vim 的功能。你将会学到：&lt;/p>
&lt;ul>
&lt;li>Vim 的安装&lt;/li>
&lt;li>Vim 的模式和命令&lt;/li>
&lt;li>Vim 的配置&lt;/li>
&lt;li>Vim 的使用技巧&lt;/li>
&lt;li>Vim 里的重要插件&lt;/li>
&lt;/ul>
&lt;p>及最最重要的&lt;/p>
&lt;ul>
&lt;li>如何把 Vim 集成到你的工作流里，让它成为一件称手的工具，来进行高效的编辑&lt;/li>
&lt;/ul>
&lt;h1 id="课程学习要求">课程学习要求&lt;/h1>
&lt;p>我对这门课程的定位是零基础课，哪怕你以前没有用过 Vim ，也完全可以上手。这个课程不是 Vim 的百科全书，不会把 Vim 的所有命令选项，不管有用没用，全部都教给你。这是一个&amp;quot;新&amp;quot;教程，里面讲述的版本、很多技巧和插件是最近几年才有的，甚至是我在写专栏的时候才发现的。这也是一个面向实践者的教程，会让一个需要或想要使用 Vim 的开发者，从入门到精通，学会高效地使用 Vim 完成程序或其他文本文件的编辑。&lt;/p>
&lt;p>虽然课程定位是零基础，但这并不意味着我对你没有任何要求。我仍然要求你在学习课程前：&lt;/p>
&lt;ul>
&lt;li>熟悉你使用的平台上的包管理器（yum、apt、brew 等；仅类 Unix 环境），知道如何完成程序的安装和卸载；&lt;/li>
&lt;li>安装了 Git，并对 Git 操作有基本的概念（不要求熟练掌握，因为我会给出大部分情况下需要的命令）；&lt;/li>
&lt;li>有一颗勇于探索的心，愿意花点力气把手里的&amp;quot;武器&amp;quot;打造得更为好用、称心。&lt;/li>
&lt;/ul>
&lt;p>使用 Vim 有不同的场景。在我设想的环境里，你是一个程序员，但我不对语言作出要求。课程的大部分内容完全是语言无关的，无论你使用什么编程语言开发，都应该可以获得有用的知识。&lt;/p>
&lt;p>不过，如果你使用 C、C++ 或 Python 进行开发，你可以得到一些额外的福利，因为这些是我主要使用的语言。这三个语言的额外重要性在于，Vim 的插件有可能会用到这三种语言。&lt;/p>
&lt;p>如果你使用其他语言的话，就多多留言，在留言区介绍你自己使用 Vim 的情况，有啥问题和困惑一定要及时提出来，这样，我也可以更有针对性地解决你的问题；如果说得太晚了，我可能就帮不上忙了哦😁。&lt;/p>
&lt;p>好了，闲话就说到这里。下一次，我们就进入正题，从 Vim 的基本安装和配置开始讲起。&lt;/p>
&lt;p>我是吴咏炜，我们下一讲见。&lt;/p></description></item><item><title>极客专栏: 00丨开篇词丨从成长角度看，为什么你应该成为全栈工程师？</title><link>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E5%85%A8%E6%A0%88%E5%B7%A5%E7%A8%8B%E5%B8%88%E4%BF%AE%E7%82%BC%E6%8C%87%E5%8D%97/00%E4%B8%A8%E5%BC%80%E7%AF%87%E8%AF%8D%E4%B8%A8%E4%BB%8E%E6%88%90%E9%95%BF%E8%A7%92%E5%BA%A6%E7%9C%8B%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%A0%E5%BA%94%E8%AF%A5%E6%88%90%E4%B8%BA%E5%85%A8%E6%A0%88%E5%B7%A5%E7%A8%8B%E5%B8%88/</link><pubDate>Tue, 07 Jun 2022 00:00:00 +0000</pubDate><guid>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E5%85%A8%E6%A0%88%E5%B7%A5%E7%A8%8B%E5%B8%88%E4%BF%AE%E7%82%BC%E6%8C%87%E5%8D%97/00%E4%B8%A8%E5%BC%80%E7%AF%87%E8%AF%8D%E4%B8%A8%E4%BB%8E%E6%88%90%E9%95%BF%E8%A7%92%E5%BA%A6%E7%9C%8B%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%A0%E5%BA%94%E8%AF%A5%E6%88%90%E4%B8%BA%E5%85%A8%E6%A0%88%E5%B7%A5%E7%A8%8B%E5%B8%88/</guid><description>
&lt;p>你好，我是软件工程师熊燚，网上大家都叫我四火，很高兴在这个专栏和你见面。&lt;/p>
&lt;p>先介绍下我自己。最早我在华为工作，曾是华为某大型视频门户和视频平台的初创人员，也是一名不折不扣的长期看护其基线版本的全栈工程师，这段经历其实为我的全栈技能打下了一个很好的基础。&lt;/p>
&lt;p>后来我加入了亚马逊（Amazon），负责数千万商品销量预测系统和成本利润计算平台的研发，从 0 到 1 重新设计并开发了数据分析和可视化系统，还维护和优化过数据分发的高可用服务，也改进过核算平台的分布式计算架构和工作流引擎，这些多领域的工作让我快速成长，并积累了大量的宝贵经验。&lt;/p>
&lt;p>现在，我在西雅图甲骨文（Oracle）的云计算部门就职，职位是首席软件工程师，主要负责研发云基础设施的分布式工作流引擎。&lt;/p>
&lt;p>入行这十来年，从前端页面到后端服务，从大小网站到分布式系统，从数据分析处理到可视化，从设计开发到线上运维，我都参与过，并带领团队攻克了很多大的项目堡垒，也以全栈工程师的身份上线了不少核心业务产品。&lt;/p>
&lt;p>可以说，我是一名全栈工程的实践者，也是一名程序员综合发展的信奉者，还是一名工程师文化的鼓吹者，有一个建立了很长时间的独立博客&amp;quot;&lt;a href="https://www.raychase.net/">四火的唠叨&lt;/a>&amp;quot;。&lt;/p>
&lt;p>那提到全栈工程师，你可能第一时间会想到 &amp;ldquo;全能&amp;quot;&amp;ldquo;大神&amp;quot;这些词语，也可能听到过其他人对它或褒或贬的评价。那么，究竟该怎么恰如其分地认识这个角色呢？我想和你说说我的看法。&lt;/p>
&lt;p>&lt;strong>软件工程的范畴里，人类创造了大量的概念和术语，绝大多数都清晰而精确，但&amp;quot;全栈工程师&amp;quot;却是个反例&lt;/strong>。在互联网出现以前，甚至在客户端和服务端模式出现以前，大多数的程序员，就已经是一定意义上的&amp;quot;全栈&amp;quot;了，他们往往涉足硬件、软件，完成程序从开始到终结各个阶段的工作。&lt;/p>
&lt;p>千禧年之后，Web，特别是 Ajax 等前端技术迅猛发展，而技术的进步就自然而然地带来了分工，于是有人负责前端，有人负责后端，甚至划分得更细，此时能够做两头事情的人，才显得更加珍贵。因此，我认为 &lt;strong>Web 技术的发展和自然而然引发的分工才是全栈工程师出现的最重要的因素&lt;/strong>。&lt;/p>
&lt;p>2008 年，在 forge38 上面出现了一篇题目为&amp;rdquo;&lt;a href="http://web.archive.org/web/20101204221657/http://forge38.com/blog/2008/06/full-stack-web-developers/">Full Stack Web Developers&lt;/a>&amp;ldquo;的文章，被认为是最早提及这个概念的媒体之一。&lt;/p>
&lt;p>文中是这样说的：&lt;/p>
&lt;blockquote>
&lt;p>A full stack web developer is someone that does design, markup, styling, behavior, and programming.&lt;/p>
&lt;/blockquote>
&lt;p>大概意思就是说，一个全栈的 web 开发者，会负责设计、标记、样式、行为和编程这些全部的事情。&lt;/p>
&lt;p>虽然从现在的眼光看，这个概念的解释似乎有些古老而片面 ，可从上面的历史文字中足以看出，为什么当我们提及全栈，往往总是基于&amp;quot;Web&amp;rdquo;，而非其他领域了。&lt;/p>
&lt;p>到了今天，全栈工程师已经变成了一个有些被滥用的概念，不同人有着天差地别的理解。&lt;/p>
&lt;p>我认为，首先必须明确的是，&amp;ldquo;全栈&amp;quot;不是&amp;quot;全能&amp;rdquo;，当然，在这个标准下我们依然可以将全栈理解为&amp;quot;广义&amp;quot;的全栈和&amp;quot;狭义&amp;quot;的全栈。显然前者的包容性和不确定性过大，我觉得只有后者才有更实际的讨论价值，并且，&lt;strong>广泛的 Web 技术才是一名通常意义上的全栈工程师最该专注的核心内容&lt;/strong>，而此处的 Web 技术，包括网络、前端、后端 MVC、持久化技术等多个层次。&lt;/p>
&lt;p>那从成长角度看，为什么我说你应该成为全栈工程师呢？&lt;/p>
&lt;p>和其他软件工程师发展的路线相比，除了通用工程师的技能以外，我认为基于 Web 的全栈技术是一种非常适合用来进一步发展和修炼的技能树，和其它的技术类别比起来，它至少有下面这样几个明显的优势。&lt;/p>
&lt;h2 id="关于个人发展">关于个人发展&lt;/h2>
&lt;p>首先，互联网是全栈概念的诞生地，也是软件领域最激动人心的产品和技术的诞生地，这是传统软件所无法比拟的。这些互联网的全栈工程师，每天都在接收新的资讯，每天都&amp;quot;不得不&amp;quot;和这些全新的技术理念搏斗，他们拥有着和这些产品与技术最近距离访问、全面接触和深入研究的机会。你可能很难预测下一波互联网的技术浪潮什么时候到来，技术主角又是谁，但全栈技术是可以帮你打好基础，做好随时拥抱它的准备的。&lt;/p>
&lt;p>其次，可以掌握能够快速获得反馈的学习方法，这对于保持持续学习的动力和热情很有助益。比如说，几行 HTML 代码就可以马上看到效果，简单安装和配置，就可以搭建一个健壮的 Web 服务，对当前浏览器即时的标签、脚本、样式修改，立即就能看到变化。&lt;/p>
&lt;p>再次，全栈技术的学习之路上有很多纷繁精彩的&amp;quot;套路&amp;rdquo;，而它们可以应用在软件工程的其它领域。可以说，&lt;strong>全栈技术中，有太多能帮助程序员开启新世界大门的东西了&lt;/strong>，比如 JavaScript 的异步编程，比如各种数据、模板和逻辑的解耦和分层，再比如说持久层技术里面的读写模型分析。&lt;/p>
&lt;p>最后，必然是视野的拓展。工程师的成长过程中，在早、中期可以利用全栈技术拓宽视野，并养成思考的习惯。&lt;strong>最终也许我们需要&amp;quot;学得精&amp;quot;，但是一开始我们一定要&amp;quot;学得杂&amp;quot;&lt;/strong>。只有在广度上有足够的积累，足够的内容去比较，才能养成思考的习惯，拥有更全面地看待问题的视野。&lt;/p>
&lt;p>拿我自己来说，工作以来我花了很多时间去做一些不同领域的项目，比如我现在的工作是研发一个分布式工作流引擎，从 Web 全栈技术上学到的东西，是能够帮助我快速上手这些技术的。同时，理解它们的本质，也能拓宽分析和解决问题的思路。毕竟，在软件领域，技术都是相通的。&lt;/p>
&lt;h2 id="关于就业和创业">关于就业和创业&lt;/h2>
&lt;p>首先，全栈工程师本身就拥有多技能、多角色。团队非常欢迎这样的人，因为当一个人可以扮演多个人的角色，就减少了沟通和配合的损耗，提高了效率。出了问题，从客户端到服务端，对多个层面都有所了解的全栈工程师可以更高效地分析和定位问题。这个世界需要专家，但我觉得更需要通晓各个层面知识，能够快速解决问题的人。&lt;/p>
&lt;p>其次，全栈工程师是创业的最佳技术角色。有了创意和点子，全栈工程师就可以快速地开发原型，迅速实现第一个版本，并能马上提供优质的宣传推广和用户体验。不要小看这一点，在很多情况下，&lt;strong>全栈工程师不需要其它额外的协助，自己就可以很快地将想法变现&lt;/strong>。&lt;/p>
&lt;p>再次，全栈工程师拥有最多的就业机会。有朋友半开玩笑说，你知道世界上什么类型的应用最多见吗？网站！各式各样的网站，内部的管理系统、报表系统、论坛、博客，但无论是哪种类型，它们都是全栈工程师最熟悉的东西。你可能耳闻过著名的 &lt;a href="https://www.laurencegellert.com/2012/08/what-is-a-full-stack-developer/">Facebook 只招全栈工程师&lt;/a>这样听起来似乎有些&amp;quot;极端&amp;quot;的故事，可事实上，几乎所有的互联网大型公司，都会招聘大量的全栈工程师。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/f9/9e/f90b92c41ca6ecedc5d8af2224aa9f9e.jpeg" alt="">&lt;/p>
&lt;p>（上图来自 &lt;a href="https://blog.hackerrank.com/full-stack-developer/">HackerRank&lt;/a>，报告原引用于 HackerRank 2018 Developer Skills Report，在开发者评价自己角色的时候，最多的人投票给了&amp;quot;全栈开发者&amp;quot;。）&lt;/p>
&lt;p>最后，不妨考虑下未来的职业延伸。&lt;strong>有了全栈工程师的底子，未来面对软件行业进一步细化，选择其它细分职业时，会因为有了全面而扎实的基础而更有利。&lt;/strong>&lt;/p>
&lt;p>举例来说，假如你做过一段时间的前端程序员，那往往对用户交互设计是有一定的心得的，我有朋友就是从一个擅长前端的全栈程序员转行做了产品经理；而在 MVC 部分学习的分层和解耦经验，持久层部分积攒的那些对于一致性、可用性的理解，对于将来想投身于分布式系统设计开发的程序员朋友会很有帮助。&lt;/p>
&lt;p>我认为对于大多数程序员来说，全栈工程师这个职位对于自己的发展而言，是个非常好的进阶方向。而基于 Web 的全栈技术学习，充满必要性，无论你今后是否志在互联网，无论你的远期目标是在哪个软件领域。&lt;/p>
&lt;p>最后，我想认识一下你。你可以在留言区中做个自我介绍，说说你现在的工作、学习情况。或是说说你眼中的全栈工程师是怎样的？你认为应该具备怎样的特质，才能成为全栈工程师呢？欢迎你在留言区和我交流。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/11/8b/1181246bbd51ce348d5729696d1dc28b.jpg" alt="unpreview">&lt;/p></description></item><item><title>极客专栏: 00丨开篇词你为什么需要学习并发编程？</title><link>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/00%E4%B8%A8%E5%BC%80%E7%AF%87%E8%AF%8D%E4%BD%A0%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%AD%A6%E4%B9%A0%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</link><pubDate>Sun, 29 May 2022 00:00:00 +0000</pubDate><guid>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/00%E4%B8%A8%E5%BC%80%E7%AF%87%E8%AF%8D%E4%BD%A0%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%AD%A6%E4%B9%A0%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</guid><description>
&lt;p>你好，我是王宝令，资深架构师，目前从事电商架构的设计工作。从毕业到现在，我前前后后写了 15 年的程序，刚毕业的时候从事证券业务的开发，开发语言是 C/C++，之后从事 ERP 产品的研发，开发语言主要是 C# 和 Java，最近几年主要是从事 Java 开发平台和基础中间件的设计开发工作。&lt;/p>
&lt;p>还记得毕业后我接触的第一个项目是证券相关的，国外的同事用 C 语言写了一个内存数据库，代码写得极为简练优美，我当时怀着无比崇敬的心情把代码看了又看，看完感觉受益匪浅。不过兴奋之余，我也有些焦虑，因为其中一块并发相关的代码，我看得是云里雾里，总感觉自己没有悟透。&lt;/p>
&lt;p>我下意识地告诉自己说这块的知识积累还不够，所以要勤学苦练。你可知道，15 年前相关的学习资料并不多，我的师傅向我推荐了《操作系统原理》这本教材，他说：&amp;ldquo;并发编程最早的应用领域就是操作系统的实现，你把这本书看懂了，并发的问题自然就解决了。&amp;ldquo;但是理论和实践之间总是有鸿沟的，之后好多年，最让我感到无助的还是处理并发相关的问题。&lt;/p>
&lt;p>并发编程的掌握过程并不容易。我相信为了解决这个问题，你也听别人总结过并发编程的第一原则，那就是不要写并发程序。这个原则在我刚毕业的那几年曾经是行得通的，那个时候多核服务器还是一种奢侈品，系统的并发量也很低，借助数据库和类似 Tomcat 这种中间件，我们基本上不用写并发程序。或者说，并发问题基本上都被中间件和数据库解决了。&lt;/p>
&lt;p>&lt;strong>但是最近几年，并发编程已经慢慢成为一项必备技能。&lt;/strong>&lt;/p>
&lt;p>这主要是硬件的驱动以及国内互联网行业的飞速发展决定的，现在 64 核的服务器已经飞入寻常百姓家，大型互联网厂商的系统并发量轻松过百万，传统的中间件和数据库已经不能为我们遮风挡雨，反而成了瓶颈所在。&lt;/p>
&lt;p>于是，并发编程最近几年成为非常热门的领域，人才稀缺。但与此同时，关于并发编程的书籍也渐渐丰富起来了。所以当极客时间团队和我聊这个专栏的时候，我的第一个疑问就是目前市面上已经有很多这方面的图书了，而且很多都非常优秀，是否还有必要搞一个这样的专栏。&lt;/p>
&lt;p>但是深入想过之后，我坚定了写作的信心。这些年接触的大部分同学，都是工作几年后很多技术突飞猛进，却只有并发编程成为瓶颈，虽然并发相关的类库他们也熟悉，却总是写不出正确、高效的并发程序，原因在哪里？我发现很多人是因为某个地方有了盲点，忽略了一些细节，但恰恰是这些细节决定了程序的正确性和效率。&lt;/p>
&lt;p>而这个盲点有时候涉及对操作系统的理解，有时候又涉及一点硬件知识，非常复杂，如果要推荐相关图书，可能要推荐好几本，这就有点&amp;quot;大炮打蚊子&amp;quot;的感觉了，效率很差。同时图书更追求严谨性，却也因此失掉了形象性，所以阅读的过程也确实有点艰辛。&lt;/p>
&lt;p>&lt;strong>我想，如果能够把这些问题解决，那么做这个事情应该是有意义的。&lt;/strong>&lt;/p>
&lt;p>例如，Java 里 synchronized、wait()/notify() 相关的知识很琐碎，看懂难，会用更难。但实际上 synchronized、wait()、notify() 不过是操作系统领域里管程模型的一种实现而已，Java SDK 并发包里的条件变量 Condition 也是管程里的概念，synchronized、wait()/notify()、条件变量这些知识如果单独理解，自然是管中窥豹。但是如果站在管程这个理论模型的高度，你就会发现这些知识原来这么简单，同时用起来也就得心应手了。&lt;/p>
&lt;p>管程作为一种解决并发问题的模型，是继信号量模型之后的一项重大创新，它与信号量在逻辑上是等价的（可以用管程实现信号量，也可以用信号量实现管程），但是相比之下管程更易用。而且，很多编程语言都支持管程，搞懂管程，对学习其他很多语言的并发编程有很大帮助。然而，很多人急于学习 Java 并发编程技术，却忽略了技术背后的理论和模型，而理论和模型却往往比具体的技术更为重要。&lt;/p>
&lt;p>此外，Java 经过这些年的发展，Java SDK 并发包提供了非常丰富的功能，对于初学者来说可谓是眼花缭乱，好多人觉得无从下手。但是，Java SDK 并发包乃是并发大师 Doug Lea 出品，堪称经典，它内部一定是有章可循的。那它的章法在哪里呢？&lt;/p>
&lt;p>&lt;strong>其实并发编程可以总结为三个核心问题：分工、同步、互斥。&lt;/strong>&lt;/p>
&lt;p>所谓&lt;strong>分工&lt;/strong> 指的是如何高效地拆解任务并分配给线程，而&lt;strong>同步&lt;/strong> 指的是线程之间如何协作，&lt;strong>互斥&lt;/strong>则是保证同一时刻只允许一个线程访问共享资源。Java SDK 并发包很大部分内容都是按照这三个维度组织的，例如 Fork/Join 框架就是一种分工模式，CountDownLatch 就是一种典型的同步方式，而可重入锁则是一种互斥手段。&lt;/p>
&lt;p>当把并发编程核心的问题搞清楚，再回过头来看 Java SDK 并发包，你会感觉豁然开朗，它不过是针对并发问题开发出来的工具而已，此时的 SDK 并发包可以任你&amp;quot;盘&amp;quot;了。&lt;/p>
&lt;p>而且，这三个核心问题是跨语言的，你如果要学习其他语言的并发编程类库，完全可以顺着这三个问题按图索骥。Java SDK 并发包其余的一部分则是并发容器和原子类，这些比较容易理解，属于辅助工具，其他语言里基本都能找到对应的。&lt;/p>
&lt;p>&lt;strong>所以，你说并发编程难学吗？&lt;/strong>&lt;/p>
&lt;p>首先，难是肯定的。因为这其中涉及操作系统、CPU、内存等等多方面的知识，如果你缺少某一块，那理解起来自然困难。其次，难不难学也可能因人而异，就我的经验来看，很多人在学习并发编程的时候，总是喜欢从点出发，希望能从点里找到规律或者本质，最后却把自己绕晕了。&lt;/p>
&lt;p>我前面说过，并发编程并不是 Java 特有的语言特性，它是一个通用且早已成熟的领域。Java 只是根据自身情况做了实现罢了，当你理解或学习并发编程的时候，如果能够站在较高层面，系统且有体系地思考问题，那就会容易很多。&lt;/p>
&lt;p>所以，我希望这个专栏更多地谈及问题背后的本质、问题的起源，同时站在理论、模型的角度讲解 Java 并发，让你的知识更成体系，融会贯通。最终让你能够得心应手地解决各种并发难题，同时将这些知识用于其他编程语言，让你的一分辛劳三分收获。&lt;/p>
&lt;p>下面就是这个专栏的目录，你可以快速了解下整个专栏的知识结构体系。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/d5/c0/d513beec13a20d5e858257313b3605c0.jpg" alt="">&lt;/p>
&lt;p>&lt;strong>当然，我们要坚持下去，不能三天打鱼两天晒网，因为滴水穿石非一日之功。&lt;/strong>&lt;/p>
&lt;p>很多人都说学习是反人性的，开始容易，但是长久的坚持却很难。这个我也认同，我面试的时候，就经常问候选人一个问题：&amp;ldquo;工作中，有没有一件事你自己坚持了很久，并且从中获益？&amp;ldquo;如果候选人能够回答出来，那会是整个面试的加分项，因为我觉得，坚持真是一个可贵的品质，一件事情，有的人三分热度，而有的人，一做就能做一年，或者更久。你放长到时间的维度里看，这两种人，最后的成就绝对是指数级的差距。&lt;/p>
&lt;p>我希望你能和我坚持下来，我们一起学习，一起交流，遇到问题不是简单地抱怨和逃避，而是努力探寻答案与解决方法。这一次，就让我们一起来坚持探索并发编程的奥秘，体会探索知识的乐趣。今天的文章是开篇词，我们的主菜很快就来，如果可以的话，还请在留言区中做个自我介绍，和我聊聊你目前的工作、学习情况，以及你在并发编程方面的学习痛点，方便我在后面针对性地给你讲解，这样，我们可以彼此了解。&lt;/p>
&lt;p>最后，感谢你对我的信任，我定会努力实现完美交付。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/cf/aa/cf393cd748a4f0e6451807c4b61843aa.jpg" alt="">&lt;/p></description></item><item><title>极客专栏: 《数据结构与算法之美》学习指导手册</title><link>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%AF%BC%E6%89%8B%E5%86%8C/</link><pubDate>Fri, 27 May 2022 00:00:00 +0000</pubDate><guid>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%AF%BC%E6%89%8B%E5%86%8C/</guid><description>
&lt;p>你好，我是王争。&lt;/p>
&lt;p>在设计专栏内容的时候，为了兼顾不同基础的同学，我在内容上做到了难易结合，既有简单的数组、链表、栈、队列这些基础内容，也有红黑树、BM、KMP 这些难度较大的算法。但是，对于初学者来说，一下子面对这么多知识，可能还是比较懵。&lt;/p>
&lt;p>我觉得，对于初学者来说，先把最简单、最基础、最重要的知识点掌握好，再去研究难度较高、更加高级的知识点，这样由易到难、循序渐进的学习路径，无疑是最合理的。&lt;/p>
&lt;p>基于这个路径，我对专栏内容，重新做了一次梳理，希望给你一份具体、明确、有效的学习指导。我会写清楚&lt;strong>每个知识点的难易程度、需要你掌握到什么程度、具体如何来学习&lt;/strong>。&lt;/p>
&lt;p>如果你是数据结构和算法的初学者，或者你觉得自己的基础比较薄弱，希望这份学习指导，能够让你学起来能更加有的放矢，能把精力、时间花在刀刃上，获得更好的学习效果。&lt;/p>
&lt;p>下面，我先给出一个大致的学习路线。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/54/48/54163f16e152f71b8f91d3fba652cf48.jpg" alt="">
（建议保存后查看大图）&lt;/p>
&lt;p>现在，针对每个知识点，我再给你逐一解释一下。我这里先说明一下，下面标记的难易程度、是否重点、掌握程度，都只是针对初学者来说的，如果你已经有一定基础，可以根据自己的情况，安排自己的学习。&lt;/p>
&lt;ol>
&lt;li>复杂度分析&lt;/li>
&lt;/ol>
&lt;hr>
&lt;p>尽管在专栏中，我只用了两节课的内容，来讲复杂度分析这个知识点。但是，我想说的是，它真的非常重要。你必须要牢牢掌握这两节，基本上要做到，简单代码能很快分析出时间、空间复杂度；对于复杂点的代码，比如递归代码，你也要掌握专栏中讲到的两种分析方法：递推公式和递归树。&lt;/p>
&lt;p>对于初学者来说，光看入门篇的两节复杂度分析文章，可能还不足以完全掌握复杂度分析。不过，在后续讲解每种数据结构和算法的时候，我都有详细分析它们的时间、空间复杂度。所以，你可以在学习专栏中其他章节的时候，再不停地、有意识地去训练自己的复杂度分析能力。&lt;/p>
&lt;p>难易程度：Medium&lt;/p>
&lt;p>是否重点：10 分&lt;/p>
&lt;p>掌握程度：在不看我的分析的情况下，能自行分析专栏中大部分数据结构和算法的时间、空间复杂度&lt;/p>
&lt;ol start="2">
&lt;li>数组、栈、队列&lt;/li>
&lt;/ol>
&lt;hr>
&lt;p>这一部分内容非常简单，初学者学起来也不会很难。但是，作为基础的数据结构，数组、栈、队列，是后续很多复杂数据结构和算法的基础，所以，这些内容你一定要掌握。&lt;/p>
&lt;p>难易程度：Easy&lt;/p>
&lt;p>是否重点：8 分&lt;/p>
&lt;p>掌握程度：能自己实现动态数组、栈、队列&lt;/p>
&lt;ol start="3">
&lt;li>链表&lt;/li>
&lt;/ol>
&lt;hr>
&lt;p>链表非常重要！虽然理论内容不多，但链表上的操作却很复杂。所以，面试中经常会考察，你一定要掌握。而且，我这里说&amp;quot;掌握&amp;quot;不只是能看懂专栏中的内容，还能将专栏中提到的经典链表题目，比如链表反转、求中间结点等，轻松无 bug 地实现出来。&lt;/p>
&lt;p>难易程度：Medium&lt;/p>
&lt;p>是否重点：9 分&lt;/p>
&lt;p>掌握程度：能轻松写出经典链表题目代码&lt;/p>
&lt;ol start="4">
&lt;li>递归&lt;/li>
&lt;/ol>
&lt;hr>
&lt;p>对于初学者来说，递归代码非常难掌握，不管是读起来，还是写起来。但是，这道坎你必须要跨过，跨不过就不能算是入门数据结构和算法。我们后面讲到的很多数据结构和算法的代码实现，都要用到递归。&lt;/p>
&lt;p>递归相关的理论知识也不多，所以还是要多练。你可以先在网上找些简单的题目练手，比如斐波那契数列、求阶乘等，然后再慢慢过渡到更加有难度的，比如归并排序、快速排序、二叉树的遍历、求高度，最后是回溯八皇后、背包问题等。&lt;/p>
&lt;p>难易程度：Hard&lt;/p>
&lt;p>是否重点：10 分&lt;/p>
&lt;p>掌握程度：轻松写出二叉树遍历、八皇后、背包问题、DFS 的递归代码&lt;/p>
&lt;ol start="5">
&lt;li>排序、二分查找&lt;/li>
&lt;/ol>
&lt;hr>
&lt;p>这一部分并不难，你只需要能看懂我专栏里的内容即可。&lt;/p>
&lt;p>难易程度：Easy&lt;/p>
&lt;p>是否重点：7 分&lt;/p>
&lt;p>掌握程度：能自己把各种排序算法、二分查找及其变体代码写一遍就可以了&lt;/p>
&lt;ol start="6">
&lt;li>跳表&lt;/li>
&lt;/ol>
&lt;hr>
&lt;p>对于初学者来说，并不需要非得掌握跳表，所以，如果没有精力，这一章节可以先跳过。&lt;/p>
&lt;p>难易程度：Medium&lt;/p>
&lt;p>是否重点：6 分&lt;/p>
&lt;p>掌握程度：初学者可以先跳过。如果感兴趣，看懂专栏内容即可，不需要掌握代码实现&lt;/p>
&lt;ol start="7">
&lt;li>散列表&lt;/li>
&lt;/ol>
&lt;hr>
&lt;p>尽管散列表的内容我讲了很多，有三节课。但是，总体上来讲，这块内容理解起来并不难。但是，作为一种应用非常广泛的数据结构，你还是要掌握牢固散列表。&lt;/p>
&lt;p>难易程度：Medium&lt;/p>
&lt;p>是否重点：8 分&lt;/p>
&lt;p>掌握程度：对于初学者来说，自己能代码实现一个拉链法解决冲突的散列表即可&lt;/p>
&lt;ol start="8">
&lt;li>哈希算法&lt;/li>
&lt;/ol>
&lt;hr>
&lt;p>这部分纯粹是为了开拓思路，初学者可以略过。&lt;/p>
&lt;p>难易程度：Easy&lt;/p>
&lt;p>是否重点：3 分&lt;/p>
&lt;p>掌握程度：可以暂时不看&lt;/p>
&lt;ol start="9">
&lt;li>二叉树&lt;/li>
&lt;/ol>
&lt;hr>
&lt;p>这一部分非常重要！二叉树在面试中经常会被考到，所以要重点掌握。但是我这里说的二叉树，并不包含专栏中红黑树的内容。红黑树我们待会再讲。&lt;/p>
&lt;p>难易程度：Medium&lt;/p>
&lt;p>是否重点：9 分&lt;/p>
&lt;p>掌握程度：能代码实现二叉树的三种遍历算法、按层遍历、求高度等经典二叉树题目&lt;/p>
&lt;ol start="10">
&lt;li>红黑树&lt;/li>
&lt;/ol>
&lt;hr>
&lt;p>对于初学者来说，这一节课完全可以不看。&lt;/p>
&lt;p>难易程度：Hard&lt;/p>
&lt;p>是否重点：3 分&lt;/p>
&lt;p>掌握程度：初学者不用把时间浪费在上面&lt;/p>
&lt;ol start="11">
&lt;li>B+ 树&lt;/li>
&lt;/ol>
&lt;hr>
&lt;p>虽然 B+ 树也算是比较高级的一种数据结构了，但是对初学者来说，也不是重点。有时候面试的时候还是会问的，所以这一部分内容，你能看懂专栏里的讲解就可以了。&lt;/p>
&lt;p>难易程度：Medium&lt;/p>
&lt;p>是否重点：5 分&lt;/p>
&lt;p>掌握程度：可看可不看&lt;/p>
&lt;ol start="12">
&lt;li>堆与堆排序&lt;/li>
&lt;/ol>
&lt;hr>
&lt;p>这一部分内容不是很难，初学者也是要掌握的。&lt;/p>
&lt;p>难易程度：Medium&lt;/p>
&lt;p>是否重点：8 分&lt;/p>
&lt;p>掌握程度：能代码实现堆、堆排序，并且掌握堆的三种应用（优先级队列、Top k、中位数）&lt;/p>
&lt;ol start="13">
&lt;li>图的表示&lt;/li>
&lt;/ol>
&lt;hr>
&lt;p>图的内容很多，但是初学者不需要掌握那么多。一般 BAT 等大厂面试，不怎么会面试有关图的内容，因为面试官可能也对这块不会很熟悉哈：）。但是，最基本图的概念、表示方法还是要掌握的。&lt;/p>
&lt;p>难易程度：Easy&lt;/p>
&lt;p>是否重点：8 分&lt;/p>
&lt;p>掌握程度：理解图的三种表示方法（邻接矩阵、邻接表、逆邻接表），能自己代码实现&lt;/p>
&lt;ol start="14">
&lt;li>深度广度优先搜索&lt;/li>
&lt;/ol>
&lt;hr>
&lt;p>这算是图上最基础的遍历或者说是搜索算法了，所以还是要掌握一下。这两种算法的原理都不难哈，但是代码实现并不简单，一个用到了队列，另一个用到了递归。对于初学者来说，看懂这两个代码实现就是一个挑战！可以等到其他更重要的内容都掌握之后，再来挑战，也是可以的。&lt;/p>
&lt;p>难易程度：Hard&lt;/p>
&lt;p>是否重点：8 分&lt;/p>
&lt;p>掌握程度：能代码实现广度优先、深度优先搜索算法&lt;/p>
&lt;ol start="15">
&lt;li>拓扑排序、最短路径、A* 算法&lt;/li>
&lt;/ol>
&lt;hr>
&lt;p>这几个算法稍微高级点。如果你能轻松实现深度、广度优先搜索，那看懂这三个算法不成问题。不过，这三种算法不是重点。面试不会考的。&lt;/p>
&lt;p>难易程度：Hard&lt;/p>
&lt;p>是否重点：5 分&lt;/p>
&lt;p>掌握程度：有时间再看，暂时可以不看&lt;/p>
&lt;ol start="16">
&lt;li>字符串匹配（BF、RK）&lt;/li>
&lt;/ol>
&lt;hr>
&lt;p>BF 非常简单，RK 稍微复杂点，但都不难。这个最好还是掌握下。&lt;/p>
&lt;p>难易程度：Easy&lt;/p>
&lt;p>是否重点：7 分&lt;/p>
&lt;p>掌握程度：能实践 BF 算法，能看懂 RK 算法&lt;/p>
&lt;ol start="17">
&lt;li>字符串匹配（BM、KMP、AC 自动机）&lt;/li>
&lt;/ol>
&lt;hr>
&lt;p>这三个算法都挺难的，对于算法有一定基础的人来说，看懂也不容易。所以，对于初学者来说，千万别浪费时间在这上面。即便有余力，看懂就好了，不用非得能自己实现。&lt;/p>
&lt;p>难易程度：Hard&lt;/p>
&lt;p>是否重点：3 分&lt;/p>
&lt;p>掌握程度：初学者不用把时间浪费在上面&lt;/p>
&lt;ol start="18">
&lt;li>字符串匹配（Trie）&lt;/li>
&lt;/ol>
&lt;hr>
&lt;p>这个还是要能看懂，不过不需要能代码实现。有些面试官喜欢考这个东西，主要是结合应用场景来考察，只是看你知不知道要用 Trie 树这个东西。&lt;/p>
&lt;p>难易程度：Medium&lt;/p>
&lt;p>是否重点：7 分&lt;/p>
&lt;p>掌握程度：能看懂，知道特点、应用场景即可，不要求代码实现&lt;/p>
&lt;ol start="19">
&lt;li>位图&lt;/li>
&lt;/ol>
&lt;hr>
&lt;p>位图不是重点，如果有余力最好掌握一下。&lt;/p>
&lt;p>难易程度：Easy&lt;/p>
&lt;p>是否重点：6 分&lt;/p>
&lt;p>掌握程度：看懂即可，能自己实现一个位图结构最好&lt;/p>
&lt;ol start="20">
&lt;li>四种算法思想&lt;/li>
&lt;/ol>
&lt;hr>
&lt;p>这个是重点，也是难点。贪心、分治、回溯、动态规划，每一个都不简单，其中动态规划又是最难、最烧脑的。要应付 FLAG 这样公司的面试，必须拿下这块内容。但是呢，学习要循序渐进，这块能内容的学习可以放到最后，做个长时间的学习计划来攻克。&lt;/p>
&lt;p>这块内容理论的东西不多，要想真的掌握，还是要大量刷题。&lt;/p>
&lt;p>难易程度：Hard&lt;/p>
&lt;p>是否重点：10 分&lt;/p>
&lt;p>掌握程度：可以放到最后，但是一定要掌握！做到能实现 Leetcode 上 Medium 难度的题目&lt;/p>
&lt;hr>
&lt;p>学而时习之，专栏虽然已经结束，但是学习的同学和留言依旧源源不断。希望这份学习指导手册对你有帮助，也欢迎你继续给我留言，和大家一起交流、学习、进步。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/8e/d3/8e603e3d795fc0ab2698f6f5eabf14d3.jpg" alt="">&lt;/p></description></item><item><title>极客专栏: 00丨导读｜池建强：Vim就是四个字“唯快不破”</title><link>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/vim-%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/00%E4%B8%A8%E5%AF%BC%E8%AF%BB%E6%B1%A0%E5%BB%BA%E5%BC%BAvim%E5%B0%B1%E6%98%AF%E5%9B%9B%E4%B8%AA%E5%AD%97%E5%94%AF%E5%BF%AB%E4%B8%8D%E7%A0%B4/</link><pubDate>Fri, 08 Jul 2022 00:00:00 +0000</pubDate><guid>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/vim-%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/00%E4%B8%A8%E5%AF%BC%E8%AF%BB%E6%B1%A0%E5%BB%BA%E5%BC%BAvim%E5%B0%B1%E6%98%AF%E5%9B%9B%E4%B8%AA%E5%AD%97%E5%94%AF%E5%BF%AB%E4%B8%8D%E7%A0%B4/</guid><description>
&lt;p>你好，我是池建强。&lt;/p>
&lt;p>操作系统、编程语言和编辑器是程序员永恒的讨论话题，技术发展了几十年，大家聊起这个来依然能争个面红耳赤。今天我就和你聊聊文本编辑器的那些事儿。&lt;/p>
&lt;p>在文本编辑器领域，Vim 和 Emacs 是永恒的焦点。使用 Emacs 和 Vim 的程序员，平时大家各用各的，各自沿着不同的道路和目标前进，但总会在某个场景下相遇，愣一下就互相扔石头和臭鸡蛋，砸得对方鼻青脸肿，然后擦擦眼泪和口水继续前行。你看，编程也是有宗教信仰的，其实是个危险的工种，当真不是瞎扯。&lt;/p>
&lt;p>我工作了二十多年，写程序有十几年，用过各种编程工具，用错过，也用对过，虽然每种优秀的编辑器都有传奇的故事，每个程序员都有自己的脾气，但是，如果让我推荐一款编程工具，那一定是 Vim。&lt;/p>
&lt;p>&lt;strong>Vim 号称编辑器之神，唯快不破，可扩展，插件遍天下。学习曲线虽然陡峭，但是学成之后，基本上就成肌肉记忆了，写程序双手不离键盘，上下翻飞，可谓快意编程。&lt;/strong>&lt;/p>
&lt;p>我和 Vim 怎么结缘的呢？那得从 2000 年说起。&lt;/p>
&lt;h1 id="缘起">缘起&lt;/h1>
&lt;p>当时正值第一波互联网浪潮，我刚毕业不久，一如现在的热血青年，投身到互联网的大熔炉中。我所在的公司叫洪恩教育，公司里聚集了很多清华北大的同学，技术牛人扎堆，大家清一色使用 Vim 在服务器端编程，语法高亮都不设，内部 BBS 也是水木清华那种，通过终端访问，非常极客。走进办公室一眼望去，满目皆是黑漆漆的屏，绿瓦瓦的字，每个人都在那里噼噼啪啪地敲击键盘，韵律十足，我想，这简直酷毙了。&lt;br>
&lt;img src="https://static001.geekbang.org/resource/image/da/ed/da42a443cbd9e74c049a1a23e1e458ed.jpeg" alt="">&lt;br>
水木清华 BBS&lt;/p>
&lt;p>我最初还在使用 Editplus 编程，隶属菜鸟帮。别人的开发、编译和发布环境都在服务器端，而我则需要在本地编写好程序，通过 Editplus 的 ftp 功能上传到服务器端，再进行调试、测试和发布，不仅麻烦，而且不够酷。&lt;/p>
&lt;p>那时候不酷是不行的，我这种行为遭到了小伙伴的无情嘲讽，于是我把愤怒都发泄在键盘上，每天在满天星斗的夜色中学习 Vim 技法，在清晨的微光中编译 Linux 内核，上午敲打键盘输出 Perl 程序，中午吃完五又四分之一口米饭之后开始研习 Vim 的多窗口和标签&amp;hellip;&amp;hellip;&lt;/p>
&lt;p>那时候我住在公司，时间充裕到让你不好意思不学习，虽然 Vim 资料匮乏，但我周边都是牛人啊，随时随地请教，不断练习，很快小有所成，编码时鼠标锁进抽屉，双手敲击键盘上下翻飞，成就感十足。我对语法高亮情有独钟，经常把自己的界面配置得花花绿绿，没事看看也是一件乐事。&lt;/p>
&lt;p>自此以后，我就与 Vim 结下不解之缘，十几年过去了，工作中一直没有离开过 Vim，断断续续一直在用。到了 2009 年，我开始把工作环境完全切换到了 Mac 上，记得当时打开 Mac 的终端时，欣喜若狂地想，这不就是 Vim、Shell 和 IDE 的完美集成么？&lt;/p>
&lt;h1 id="场景">场景&lt;/h1>
&lt;p>在不同的场景下应该采用最适合的工具，这时就会有人问了，Vim 适合什么场景呢？&lt;/p>
&lt;p>简单说来，Vim 比较适合 Unix/Linux 服务器端编程，如果你使用 Mac 电脑，Vim 是直接集成在你的终端环境中的，用起来十分方便。我以前用 Vim 主要用来进行 Shell/Python/C 编程。在 Unix/Linux 服务器端编辑和修改文件也离不开 Vim，另外由于我个人工作环境是 Mac，所以修改文本文件、Code Reiview、批量替换文件、比对文件等工作，用 Vim 顺手就做了。&lt;/p>
&lt;p>写 Java 程序、前端 HTML/CSS/JS、Objective-C 和 Swift，最优方案依次是 IDEA、VS Code、XCode 等，这些优秀的工具可以帮助我们提升效率，减少错误，但是如果你还想更进一步，那么 Vim 绝对值得拥有。&lt;/p>
&lt;h1 id="历史">历史&lt;/h1>
&lt;p>Vim 源于 vi，但不是 vi，vi 作为计算机的文本编辑器历史极为悠远，它是由美国计算机科学家比尔·乔伊编写并于 1976 年发布的，同年苹果公司成立。比尔·乔伊是 Sun 公司的联合创始人和首席科学家，一位传奇的技术天才，我个人以为他最伟大的贡献是独立编写 BSD 操作系统，开发 vi 编辑器，创立 Sun 公司，当然，他还是 Java 语言的主要贡献者之一，任何人有幸完成其中一项工作已经足以名垂计算机发展史，而乔伊则通过一己之力完成了这些科技成果，推动了整个计算机科技的发展。&lt;/p>
&lt;p>Vim 诞生得要晚一些，它的第一个版本由布莱姆·米勒在 1991 年发布，这个兄弟也是一位声名显赫的程序员，80 年代买了一台 Amiga 电脑，打开电脑一看，米勒鼻子差点气歪了，居然没有他最常用的 vi 编辑器！对于米勒来说这是不可接受的。&lt;/p>
&lt;p>愤怒的米勒决定自己开发一个文本编辑器，完全复制 vi 的功能，并起名为 Vi IMitation（模拟）。事实证明，优秀的程序员都具备这种品质，感到不爽了，就会写出个什么东西，要么完善一下，要么创新一下，要么是你写，要么是我写，于是很多伟大的软件程序就发明出来了。随着 Vim 的不断发展，更多更好的功能被加了进来，正式名称改成了 Vi IMproved（增强），也就形成了现代的 Vim，目前最新的稳定版本是 8.2，Vim 的开发语言是 C 和 VimScript。&lt;/p>
&lt;h1 id="理念">理念&lt;/h1>
&lt;p>Vim 是一款完全面向程序员的软件，我很少见到用 Vim 编辑文字的普通用户，如果你是，一定要告诉我。&lt;/p>
&lt;p>写过程序的人都知道，编程的时候双手大部分时间都放在键盘上，或编码、或插入、或移动、或定位、或查找，这种连续操作的时间和频率远远大于阅读、翻页、设置字体、摆弄样式等文案工作，而二者往往产生很多停顿和间隙，而编程时的停顿是非常影响编程效率的，所以 Vim 的设计理念就是通过模式的转换、命令的组合和数以万计的插件，保证程序员在编程的过程中，双手尽可能保留在键盘中央的区域，并且，不需要鼠标。&lt;/p>
&lt;p>想用好 Vim，先要理解 Vim 的模式转换。Vim 常用的模式有四种：&lt;/p>
&lt;ul>
&lt;li>普通模式：Vim 启动后的默认模式，用来移动光标、删除文本、覆盖输入文本、恢复操作、粘贴文本等等。&lt;/li>
&lt;li>插入模式：输入 i 或 a 进入插入模式，在这个模式下敲击键盘会往文字缓冲区增加文字，相当于普通编辑器的编辑模式。&lt;/li>
&lt;li>可视模式：选择文本，可以行选、块选和依次选择，选择后可以进行复制、删除、排序等操作。&lt;/li>
&lt;li>命令模式：执行内部和外部命令，通过&amp;quot;:&amp;quot;&amp;quot;/&amp;quot;&amp;quot;?&amp;quot;&amp;quot;:!&amp;ldquo;可以进入命令模式，分别对应的是：执行内部命令、向上或向下搜索、执行外部命令。&lt;/li>
&lt;/ul>
&lt;p>Vim 的模式和普通的编辑器有所不同，而且命令繁多千变万化，所以初期的学习曲线较高，一旦你坚持练习并且度过了最早的平台期，就会领略 Vim 的妙和全键盘的好。事实上 Vim 除了能够快速编辑文本文件之外，还能够通过简单的命令做更多的事情。&lt;/p>
&lt;p>如何帮助你度过这个陡峭的学习曲线呢？这就是极客时间开设 Vim 专栏的初衷，吴咏炜老师是前英特尔亚太研发中心资深系统架构师，是《现代 C++ 实战 30 讲》的专栏作者，也是一位深度 Vim 用户。&lt;/p>
&lt;p>他会带着你掌握即学即用的 Vim 高频命令，了解 Vim 高阶用法和技巧，利用 Vim 脚本和插件实现常用功能，以及定制自己专属的 Vim 环境。&lt;/p>
&lt;p>一旦你跟着吴老师学完了专栏，真正掌握了 Vim 这个高效率的工具，你会进入一个全新的世界，以前繁琐的编程和文本处理会变得简单有趣，如果你有兴趣，完全可以根据专栏所学的内容，定制一个强大的个性化开发工具，提升自己编程和日常工作效率。&lt;/p>
&lt;p>下面我就交棒给吴咏炜老师，让我们一起开始学习吧。&lt;/p></description></item><item><title>极客专栏: 00丨开篇词丨怎样才能做好性能调优？</title><link>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98/00%E4%B8%A8%E5%BC%80%E7%AF%87%E8%AF%8D%E4%B8%A8%E6%80%8E%E6%A0%B7%E6%89%8D%E8%83%BD%E5%81%9A%E5%A5%BD%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/</link><pubDate>Fri, 08 Jul 2022 00:00:00 +0000</pubDate><guid>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98/00%E4%B8%A8%E5%BC%80%E7%AF%87%E8%AF%8D%E4%B8%A8%E6%80%8E%E6%A0%B7%E6%89%8D%E8%83%BD%E5%81%9A%E5%A5%BD%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/</guid><description>
&lt;p>你好，我是刘超，目前在金山西山居担任技术经理，很高兴通过这个专栏，跟你一起讨论 Java 性能调优这个话题。&lt;/p>
&lt;p>先给你讲个故事吧。多年前我加入了一家大型互联网公司，刚进入就以 996 标准，参与新品研发。公司业务发展急需互联网产品，因此我们的时间很紧张，4 个月新产品就上线了。&lt;/p>
&lt;p>开始还算顺利，但不久后的一天晚上，系统突然就瘫痪了，重启之后，问题仍然无规律地重现。当时运维同事马上写了一个重启脚本，定时排队重启各个服务，但也只能做到&amp;quot;治标不治本&amp;quot;。&lt;/p>
&lt;p>作为主力开发，我和公司的系统架构师一起排查问题。架构师轻车熟路地通过各种 Linux 命令在线上环境查看性能指标，也 dump 出日志文件，走查代码，最后定位到了问题，后面就是分析原因、制定解决方案、更新版本等一系列操作。那是我第一次深刻感受到性能调优的重要性。&lt;/p>
&lt;p>后来的几年里，我又陆续参与过物流、电商、游戏支付系统的研发，这些项目都存在一个共性，就是经常会运营一些大促以及抢购类活动。活动期间，系统不仅要保证处理请求业务的严谨性，还要历经短时间内高并发的考验。我也一直处于性能调优的一线。&lt;/p>
&lt;p>正所谓&amp;quot;实践出真知&amp;quot;。这些年在生产环境中遇到的事故不少，很多坑一点点踩平，就走出了一条路，这个过程中我收获了很多实打实的经验，希望能分享给更多的人，我们一起学习、交流和探讨。&lt;/p>
&lt;p>关于性能调优，我先来说说的我的感受。Java 性能调优不像是学一门编程语言，无法通过直线式的思维来掌握和应用，它对于工程师的技术广度和深度都有着较高的要求。&lt;/p>
&lt;p>互联网时代，一个简单的系统就囊括了应用程序、数据库、容器、操作系统、网络等技术，线上一旦出现性能问题，就可能要你协调多方面组件去进行优化，这就是技术广度；而很多性能问题呢，又隐藏得很深，可能因为一个小小的代码，也可能因为线程池的类型选择错误&amp;hellip;可归根结底考验的还是我们对这项技术的了解程度，这就是技术深度。&lt;/p>
&lt;p>显然，性能调优不是一件容易的事。但有没有什么方法能把这件事情做好呢？接下来跟你分享几点我的心得。&lt;/p>
&lt;p>&lt;strong>1. 扎实的计算机基础&lt;/strong>&lt;/p>
&lt;p>我们调优的对象不是单一的应用服务，而是错综复杂的系统。应用服务的性能可能与操作系统、网络、数据库等组件相关，所以我们需要储备计算机组成原理、操作系统、网络协议以及数据库等基础知识。具体的性能问题往往还与传输、计算、存储数据等相关，那我们还需要储备数据结构、算法以及数学等基础知识。&lt;/p>
&lt;p>&lt;strong>2. 习惯透过源码了解技术本质&lt;/strong>&lt;/p>
&lt;p>我身边有很多好学的同学，他们经常和我分享在一些技术论坛或者公众号上学到的技术。这个方式很好，因为论坛上边的大部分内容，都是生产者自己吸收消化后总结的知识点，能帮助我们快速获取、快速理解。但是只做到这个程度还不够，因为你缺失了自己的判断。怎么办呢？我们需要深入源码，通过分析来学习、总结一项技术的实现原理和优缺点，这样我们就能更客观地去学习一项技术，还能透过源码来学习牛人的思维方式，收获更好的编码实现方式。&lt;/p>
&lt;p>&lt;strong>3. 善于追问和总结&lt;/strong>&lt;/p>
&lt;p>很多同学在使用一项技术时，只是因为这项技术好用就用了，从来不问自己：为什么这项技术可以提升系统性能？对比其他技术它好在哪儿？实现的原理又是什么呢？事实上，&amp;ldquo;知其然且知所以然&amp;quot;才是我们积累经验的关键。知道了一项技术背后的实现原理，我们才能在遇到性能问题时，做到触类旁通。&lt;/p>
&lt;p>&lt;strong>综合这三点心得，我也就想清楚了该怎么交付这个专栏。&lt;/strong>&lt;/p>
&lt;p>在这个专栏里，我将从实战出发，精选高频性能问题，透过 Java 底层源码，提炼出优化思路和它背后的实现原理，最后形成一套&amp;quot;学完就能用的调优方法论&amp;rdquo;。这也是很多一线大厂对于高级工程师的要求，希望通过这个专栏帮助你快速进阶。&lt;/p>
&lt;p>那这个专栏具体是怎么设计的呢？结合 Java 应用开发的知识点，我将内容分为七大模块，从上到下依次详解 Java 应用服务的每一层优化实战。&lt;/p>
&lt;p>**模块一，概述。**为你建立两个标准。一个是性能调优标准，告诉你可以通过哪些参数去衡量系统性能；另一个是调优过程标准，带你了解通过哪些严格的调优策略，我们可以排查性能问题，从而解决问题。&lt;/p>
&lt;p>**模块二，Java 编程性能调优。**JDK 是 Java 语言的基础库，熟悉 JDK 中各个包中的工具类，可以帮助你编写出高性能代码。这里我会从基础的数据类型讲起，涉及容器在实际应用场景中的调优，还有现在互联网系统架构中比较重要的网络通信调优。&lt;/p>
&lt;p>**模块三，多线程性能调优。**目前大部分服务器都是多核处理器，多线程编程的应用广泛。为了保证线程的安全性，通常会用到同步锁，这会为系统埋下很多隐患；除此之外，还有多线程高并发带来的性能问题，这些都会在这个模块重点讲解。&lt;/p>
&lt;p>**模块四，JVM 性能监测及调优。**Java 应用程序是运行在 JVM 之上的，对 JVM 进行调优可以提升系统性能。这里重点讲解 Java 对象的创建和回收、内存分配等。&lt;/p>
&lt;p>**模块五，设计模式调优。**在架构设计中，我们经常会用到一些设计模式来优化架构设计。这里我将结合一些复杂的应用场景，分享设计优化案例。&lt;/p>
&lt;p>**模块六，数据库性能调优。**数据库最容易成为整个系统的性能瓶颈，这里我会重点解析一些数据库的常用调优方法。&lt;/p>
&lt;p>**模块七，实战演练场。**以上六个模块的内容，都是基于某个点的调优，现在是时候把你前面所学都调动起来了，这里我将带你进入综合性能问题高频出现的应用场景，学习整体调优方法。&lt;/p>
&lt;p>纵观整个专栏，以点带面，目的就是交付给你一套&amp;quot;学完就用的调优方法论&amp;quot;，让你在遇到性能问题时，能够调动所学，触类旁通，技术水平更上一层楼。&lt;/p>
&lt;p>&amp;ldquo;纸上得来终觉浅，绝知此事要躬行&amp;rdquo;。这个专栏从实战中来，也希望你能应用到实战中去，最终在学习的基础上，融会贯通，补充完善，形成属于你自己的一套调优方法论。&lt;/p>
&lt;p>今天的内容就到这里，期待在下一讲，和你共同开启一段新的旅程。你可以在留言区做个简单的自我介绍，聊聊你目前的工作、学习情况，以及在 Java 性能调优上的痛点，我们认识一下，也方便我后续有针对性地为你讲解。&lt;/p>
&lt;p>最后，感谢你的信任，我定会全力以赴，和你一起实现完美交付。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/bb/67/bbe343640d6b708832c4133ec53ed967.jpg" alt="unpreview">&lt;/p></description></item><item><title>极客专栏: 00丨开篇词丨想成为技术牛人？先搞定网络协议！</title><link>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E8%B6%A3%E8%B0%88%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/00%E4%B8%A8%E5%BC%80%E7%AF%87%E8%AF%8D%E4%B8%A8%E6%83%B3%E6%88%90%E4%B8%BA%E6%8A%80%E6%9C%AF%E7%89%9B%E4%BA%BA%E5%85%88%E6%90%9E%E5%AE%9A%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/</link><pubDate>Fri, 08 Jul 2022 00:00:00 +0000</pubDate><guid>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E8%B6%A3%E8%B0%88%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/00%E4%B8%A8%E5%BC%80%E7%AF%87%E8%AF%8D%E4%B8%A8%E6%83%B3%E6%88%90%E4%B8%BA%E6%8A%80%E6%9C%AF%E7%89%9B%E4%BA%BA%E5%85%88%E6%90%9E%E5%AE%9A%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/</guid><description>
&lt;p>你好，我是刘超，网易研究院云计算技术部的首席架构师。我主要负责两部分工作，对内支撑网易核心业务上云，对外帮助客户搞定容器化与微服务化架构。&lt;/p>
&lt;p>当极客时间约我做&amp;quot;趣谈网络协议&amp;quot;专栏的时候，我非常开心，因为网络协议也是我长期研究和关注的点。摸爬滚打 15 年，有了一些收获也溅了一身血，我才能在这里和你分享。&lt;/p>
&lt;p>为什么网络协议这么重要呢？为什么&amp;quot;计算机组成与系统结构&amp;quot;&amp;ldquo;数据结构与算法&amp;quot;&amp;ldquo;操作系统&amp;quot;&amp;ldquo;计算机网络&amp;quot;&amp;ldquo;编译原理&amp;rdquo;，会成为大学计算机的核心课程呢？至少看起来，这些内容没有&amp;quot;多少天搞定 MFC、Structs&amp;quot;这样的内容更容易帮你找到工作。我毕业的时候，也感到很困惑。&lt;/p>
&lt;p>不过当时我抱着一个理想，也可能是大多数程序员的理想：我要做技术牛人，我要搞定大系统。&lt;/p>
&lt;p>工作 15 年，我在 EMC 做过类似 GFS 的分布式存储开发，做过基于 Lucene 的搜索引擎，做过 Hadoop 的运维；在 HP 和华为做过 OpenStack 的开发、实施和解决方案；还创业倒腾过 Mesos 容器平台，后来在网易做 Kubernetes。&lt;/p>
&lt;p>随着见过的世面越来越多，我渐渐发现，无论是对于大规模系统的架构，还是对于程序员的个人职业生涯，网络和网络协议都是绕不过去的坎儿。&lt;/p>
&lt;p>集群规模一大，我们首先想到的就是网络互通的问题；应用吞吐量压不上去，我们首先想到的也是网络互通的问题。不客气地讲，很多情况下，只要搞定了网络，一个大型系统也就搞定了一半。所以，要成为技术牛人，搞定大系统，一定要过网络这一关，而网络协议在网络中占有举足轻重的地位。&lt;/p>
&lt;p>相信大部分人都思考过&amp;quot;技术变化太快，容易过时&amp;quot;的问题。毕竟，技术浪潮一浪接一浪，新技术层出不穷。从搜索引擎、大数据、云计算，到人工智能、区块链，简直就是&amp;quot;你方唱罢我登场&amp;rdquo;。&lt;strong>这里面究竟有没有最本质的东西，使得你掌握了它，就能在新技术的滚滚浪潮中，保持快速学习的能力？&lt;/strong>&lt;/p>
&lt;p>通过对大量开源技术的代码进行分析，我发现很多技术看起来轰轰烈烈，扒下外衣，本质的东西其实就是基础知识和核心概念。&lt;strong>想要不被滚滚而来的新技术淘汰，就要掌握这些可以长久使用的知识，而网络协议就是值得你学习，而且是到 40 岁之后依然有价值的知识。&lt;/strong>&lt;/p>
&lt;p>但是，要想真正学习和掌握网络协议，也并非易事。下面这些场景，你是不是也感同身受呢？&lt;/p>
&lt;ul>
&lt;li>
&lt;p>**网络协议知识点太多，学完记不住。**我们都学过计算机网络课程，学的时候感觉并不难。尤其这门课没有公式，更像是文科。学了一大堆，也背了一大堆，应付完考试之后，最终都&amp;quot;还给老师&amp;quot;了。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>**看上去懂了，但是经不住问。**没关系，网上有很多的文章嘛。于是，你会搜索很多文章去看。看的时候，你感觉别人说的很有道理，好像理解了，但是经不住问，一问就发现，你只是了解了大概的流程，很多细节还是不知道。所以说，从能看懂到能给别人讲明白，中间还有很长一段距离。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>知识学会了，实际应用依旧不会&lt;/strong>。细节都摸索得差不多了，但是当你自己去应用和调试的时候，发现还是没有思路。比如，当创建出来的虚拟机不能上网的时候，该怎么办呢？学过的东西，怎么还是不会用？&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>我把这样的网络协议学习过程总结为：&lt;strong>一看觉得懂，一问就打鼓，一用就糊涂。&lt;/strong>&lt;/p>
&lt;p>那网络协议究竟该怎么学？基于这个问题，我决定从以下三个角度和你分享我所理解的网络协议。&lt;/p>
&lt;p>&lt;strong>第一，我会从身边经常见到的事情出发，用故事来讲解各种网络协议，然后慢慢扩展到不熟悉的领域。&lt;/strong>&lt;/p>
&lt;p>例如，每个人都会查看 IP 地址，那我们就从这个命令开始，展开一些概念；很多人都在大学宿舍组过简单的网络来打游戏，我就从宿舍里最简单的网络概念开始讲；然后说到办公室，说到日常上网、购物、视频下载等过程涉及的协议；最后说到最陌生的数据中心。&lt;/p>
&lt;p>&lt;strong>第二，我会用贴近场景的方式来讲解网络协议，将各个层次的关系串起来，而非孤立地讲解某个概念。&lt;/strong>&lt;/p>
&lt;p>常见的计算机网络课程往往会按照网络分层，一层一层地讲，却很少讲层与层之间的关系。例如，我们学习路由协议的时候，在真实场景中，这么多的算法和二层是什么关系呢？和四层又是什么关系呢？例如，在真实的网络通信中，我们访问一个网站，做一个支付，在 TCP 进行三次握手的时候，IP 层在干嘛？MAC 层又在干嘛？这些你是不是都清楚？&lt;/p>
&lt;p>&lt;strong>第三，我会在讲解完各个层次的网络协议之后，着重剖析如何在当下热门领域使用这些协议，比如云计算、容器和微服务。&lt;/strong>&lt;/p>
&lt;p>一方面你可以知道网络协议真实应用的地方，另一方面你也可以通过上手使用云计算、容器、微服务来进一步加深对于协议的理解。&lt;/p>
&lt;p>千里之行，始于足下。不管何时，我相信，扎实的功底和过硬的技术，都会是你职业发展的助力器。&lt;/p>
&lt;p>希望这个专栏，不仅可以帮你理清繁杂的网络协议概念，帮你构建一个精准的网络协议知识框架，帮你在热门领域应用这些底层知识，更重要的是给你一种学习知识的方法和态度：&lt;strong>看似最枯燥、最基础的东西往往具有最长久的生命力&lt;/strong>。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/b5/fb/b5bc14cb81d3630919fee94a512cc3fb.jpg" alt="">&lt;/p></description></item><item><title>极客专栏: 00丨一键直达丨法律专栏“食用”指南</title><link>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E7%99%BD%E8%AF%9D%E6%B3%95%E5%BE%8B/00%E4%B8%A8%E4%B8%80%E9%94%AE%E7%9B%B4%E8%BE%BE%E4%B8%A8%E6%B3%95%E5%BE%8B%E4%B8%93%E6%A0%8F%E9%A3%9F%E7%94%A8%E6%8C%87%E5%8D%97/</link><pubDate>Tue, 07 Jun 2022 00:00:00 +0000</pubDate><guid>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E7%99%BD%E8%AF%9D%E6%B3%95%E5%BE%8B/00%E4%B8%A8%E4%B8%80%E9%94%AE%E7%9B%B4%E8%BE%BE%E4%B8%A8%E6%B3%95%E5%BE%8B%E4%B8%93%E6%A0%8F%E9%A3%9F%E7%94%A8%E6%8C%87%E5%8D%97/</guid><description>
&lt;p>你好，很荣幸我们能够一起走过三个多月的时间，我是这个专栏的编辑 Lisa。&lt;/p>
&lt;p>在法律专栏中，周律师特别针对职场、技术、生活三大领域的法律问题以及认知常识，进行了细致而通俗的讲解。不过，这些文章，并非严格按照领域次序更新，所以在专栏最后，我特别整理了各领域法律文章的直达目录，方便你来回顾。&lt;/p>
&lt;p>点击相关领域下的标题，直达你最需要了解的那篇。&lt;/p>
&lt;h2 id="认知篇">认知篇&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>&lt;a href="https://time.geekbang.org/column/article/42553">&amp;ldquo;老周，我想知道&amp;rdquo; | 常见法律认知盲区（一）&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://time.geekbang.org/column/article/76454">&amp;ldquo;老周，我想知道&amp;rdquo; | 律师就在你身边（二）&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://time.geekbang.org/column/article/77460">&amp;ldquo;老周，我想知道&amp;rdquo; | 律师就在你身边（三）&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://time.geekbang.org/column/article/79422">&amp;ldquo;老周，我想知道&amp;rdquo; | 律师就在你身边（四）&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h2 id="职场篇">职场篇&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>&lt;a href="https://time.geekbang.org/column/article/42724">创业未捷老板跑，社保工资哪里讨？&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://time.geekbang.org/column/article/64970">保密还是卖身，霸王条款怎么看？&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://time.geekbang.org/column/article/70867">又见猝死！工&amp;quot;殇&amp;quot;究竟是不是工伤？&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://time.geekbang.org/column/article/67836">合同在手欠款难收，报警有用吗？&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://time.geekbang.org/column/article/67842">编造流言蹭热度？看守所里降温度&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://time.geekbang.org/column/article/69879">致创业：谁动了我的股权？&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://time.geekbang.org/column/article/71474">致创业：期权的前世今生&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://time.geekbang.org/column/article/72839">抄袭、盗图为什么做不得？&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://time.geekbang.org/column/article/73207">加班、工资、休假，你知道多少？&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://time.geekbang.org/column/article/74280">受贿原来这么&amp;quot;容易&amp;quot;&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://time.geekbang.org/column/article/71821">裁员面前，你能做的还有什么？&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h2 id="技术篇">技术篇&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>&lt;a href="https://time.geekbang.org/column/article/44260">今天你用 VPN 了吗？&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://time.geekbang.org/column/article/67379">漏洞在眼前，可以悄悄破解吗？&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://time.geekbang.org/column/article/68668">&amp;ldquo;爬虫&amp;quot;真的合法吗？&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://time.geekbang.org/column/article/69697">技术做宣传竟是非法集资？&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://time.geekbang.org/column/article/79140">&amp;ldquo;网络诈骗&amp;quot;真的离你很远吗？&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://time.geekbang.org/column/article/70578">黄色网站？不仅仅是&amp;quot;黄色&amp;quot;而已&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://time.geekbang.org/column/article/73856">是谁修改了我的积分资产？&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://time.geekbang.org/column/article/77144">伪基站是你的避风湾吗？&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://time.geekbang.org/column/article/74778">外挂真能&amp;quot;大吉大利&amp;quot;吗？&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://time.geekbang.org/column/article/75673">如何看待&amp;quot;从删库到跑路&amp;rdquo;？&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h2 id="生活篇">生活篇&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>&lt;a href="https://time.geekbang.org/column/article/42676">智斗中介：&amp;ldquo;北上广&amp;quot;租房图鉴&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://time.geekbang.org/column/article/64417">买买买！买房的&amp;quot;避坑&amp;quot;指南&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://time.geekbang.org/column/article/65208">闪婚又闪离，彩礼怎么理？&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://time.geekbang.org/column/article/67977">离婚还想和平？你要这么做&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://time.geekbang.org/column/article/70217">骗术升级？假结婚、假离婚的那些事儿&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://time.geekbang.org/column/article/69350">遗产继承的爱恨情仇&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://time.geekbang.org/column/article/71169">孩子学校受伤，到底谁的&amp;quot;锅&amp;rdquo;？&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://time.geekbang.org/column/article/72315">如何让欠债还钱真正&amp;quot;天经地义&amp;rdquo;？&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://time.geekbang.org/column/article/73518">从透支到盗刷：人人须知的银行卡纠纷&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://time.geekbang.org/column/article/75249">远离&amp;quot;套路贷&amp;quot;的套路大全&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://time.geekbang.org/column/article/76196">老人倒地，&amp;ldquo;扶&amp;quot;&amp;ldquo;不服&amp;rdquo;？&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://time.geekbang.org/column/article/75815">危险！酒驾为什么被罚那么重？&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://time.geekbang.org/column/article/76848">&amp;ldquo;能动手就别吵吵&amp;rdquo;，代价你真的知道吗？&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://time.geekbang.org/column/article/77808">发生交通事故，如何处理？&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://time.geekbang.org/column/article/78459">婚姻家庭综合法宝&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://time.geekbang.org/column/article/78014">交通事故综合法宝&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://time.geekbang.org/column/article/78784">买卖房屋综合法宝&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/cc/ff/cc229a6309f93017826a07452f3250ff.jpg" alt="">&lt;/p></description></item><item><title>极客专栏: 00丨学习路径丨怎样成为一名优秀的全栈工程师？</title><link>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E5%85%A8%E6%A0%88%E5%B7%A5%E7%A8%8B%E5%B8%88%E4%BF%AE%E7%82%BC%E6%8C%87%E5%8D%97/00%E4%B8%A8%E5%AD%A6%E4%B9%A0%E8%B7%AF%E5%BE%84%E4%B8%A8%E6%80%8E%E6%A0%B7%E6%88%90%E4%B8%BA%E4%B8%80%E5%90%8D%E4%BC%98%E7%A7%80%E7%9A%84%E5%85%A8%E6%A0%88%E5%B7%A5%E7%A8%8B%E5%B8%88/</link><pubDate>Tue, 07 Jun 2022 00:00:00 +0000</pubDate><guid>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E5%85%A8%E6%A0%88%E5%B7%A5%E7%A8%8B%E5%B8%88%E4%BF%AE%E7%82%BC%E6%8C%87%E5%8D%97/00%E4%B8%A8%E5%AD%A6%E4%B9%A0%E8%B7%AF%E5%BE%84%E4%B8%A8%E6%80%8E%E6%A0%B7%E6%88%90%E4%B8%BA%E4%B8%80%E5%90%8D%E4%BC%98%E7%A7%80%E7%9A%84%E5%85%A8%E6%A0%88%E5%B7%A5%E7%A8%8B%E5%B8%88/</guid><description>
&lt;p>你好，我是四火。&lt;/p>
&lt;p>每一项综合技术都有自己的特点，基于 Web 的全栈技术也不例外。它五花八门，涉及面广，同类技术多，技术迭代迅猛，技术资料新等等，就如同下山的猛虎，成为了很多程序员朋友迈向全栈大门的一道阻碍。经常听到这样的抱怨：&lt;/p>
&lt;blockquote>
&lt;p>想学 Web 全栈技术，期待能独立交付产品，但真的很迷茫。&lt;br>
具体某项技术还好说，可全栈包含了那么多技术，眼都要看花了。&lt;br>
我该从哪里开始，遵循哪些原则，学习哪些技术？&lt;/p>
&lt;/blockquote>
&lt;p>今天，专栏伊始，徙木为信，言能践行，就让我带你一起打破这道障碍。想要入门或者正在进阶的你，期待这个专栏能让你产生不一样的理解，收获独特的方法，在全栈技术的道路上迈上一个更高的台阶。&lt;/p>
&lt;h2 id="怎样修炼全栈技术">怎样修炼全栈技术？&lt;/h2>
&lt;p>首先，我想说的是，&lt;strong>先成为合格的工程师，再谈全栈&lt;/strong>。&lt;/p>
&lt;p>就像相声演员的说学逗唱一样，工程师也有自己的必修课，比如数据结构和算法，可以说没有基础代码能力时一切都无从谈起。对于任何一个领域的软件工程师而言，它们都是基础，怎样强调其重要性都不为过。并且无论你是刚入行的程序员，还是打拼了几十年的架构师，标准都是一样的。&lt;/p>
&lt;p>就拿我工作过的 Amazon 和 Oracle 来说，我们面试的时候，虽然对技术级别高的程序员候选人，会更多地考察基于经验和思路的系统设计等方面，但代码层面的要求，包括数据结构和算法，对于不同级别的工程师来说 ，基本是一样的。&lt;/p>
&lt;p>请注意，这里的要求不只是能够写代码，而是要在面试现场，在有限的时间内，在白板上写代码。而在这个专栏里，我不讲解这些最基础的知识，但并不代表它们不重要。&lt;/p>
&lt;p>对于进阶的工程师来说，英文能力是突破天花板的一个必选项。我觉得英文是所有进阶的软件工程师应当强化的能力，对全栈工程师来说更甚。因为基于 Web 的全栈技术迭代很快，新的技术资料一般都是英文的，英文能力，尤其是英文的阅读能力会很大程度地影响知识获取的速度。&lt;/p>
&lt;p>其次，&lt;strong>在获取知识的基础上思考，尤其是从比较中思考&lt;/strong>。&lt;/p>
&lt;p>思考，我认为是一个软件工程师所有习惯中最重要的一项。我们在实际工作中需要解决各种各样不可预料的问题，缺乏思考的人只会用自己所知道的技术生硬地往上套，而不去考虑是否适合问题本身，不去分析和比对不同解决方法的优劣。&lt;strong>对于全栈技术学习而言，由于技术种类多，同类技术多，基于比较的思考就显得更为重要&lt;/strong>。但在这方面，我认为入门和进阶的工程师应当有所区别：&lt;/p>
&lt;ul>
&lt;li>如果你在这方面入门不久，那么我建议你还是以知识性学习为主，先建立概念，了解全局。在选择要学习的技术时，要找那些经典的、使用的人多，以及接受度高的技术。在此基础上，尝试去思考这些技术的特点，为什么要这样做，好处和坏处各是什么。了解背景，即在所介绍的技术出现以前，程序员都是怎样做的，比较一下二者的区别是什么，或者说，新技术，带来了什么。&lt;/li>
&lt;li>如果你是这方面的进阶工程师，那么&amp;quot;思考&amp;quot;的比重需要更高。全栈的技术太多太杂，不思考而以知识堆叠的方式记忆，是根本学不过来的。因此需要结合自身经验，尤其是针对同类的不同技术，要不断地去权衡，并强化自己的思考习惯&amp;mdash;&amp;mdash;针对学习材料，哪些观点是自己不同意的，哪些内容是自己需要补充的，哪些部分是自己需要延伸学习一下的。&lt;/li>
&lt;/ul>
&lt;p>通过耐心地思考和比较，知识积累能够逐渐形成体系，而它，是帮助你融会贯通和保证记忆的最佳方法。请不要在开始时担心这一点，只有具备一定量的积累才能自然而然地孕育出体系来。&lt;/p>
&lt;p>最后，&lt;strong>请不要忽视实践的力量&lt;/strong>。&lt;/p>
&lt;p>对于感兴趣的内容，请打开浏览器，打开命令行，打开 IDE，使用 Google 去搜索，把软件包下载下来，照着学习材料中的例子做一下，按着自己的理解试验一下。&lt;/p>
&lt;p>这样的过程听起来很简单，却是能让你形成深刻印象的捷径。有时候你可能对于内容表述不理解，可动手操作一下，往往就突然领悟了。毕竟，最终我们的能力都要落到关于程序代码的实践上去。&lt;/p>
&lt;h2 id="专栏内容是怎样设计的">专栏内容是怎样设计的？&lt;/h2>
&lt;p>说到专栏，特别是关于内容定位、广度和深度，我必须要做一个说明。这个说明于我们彼此都非常重要，它能够保证你我对专栏文章持有一个正确的预期。&lt;/p>
&lt;p>我希望这个专栏的主要目的是介绍原理、分享认识、探讨观点、串联知识，并引发思考，带给你进一步学习和实践的机会，而不是完全一步一步教导具体怎么做。因此，这个专栏最直接的目标不是希望你了解所有的细节，或者一下子精通其中的某一项技术。&lt;/p>
&lt;p>比如，我不会具体而全面地讲解 Spring MVC 怎么配置，Tomcat 怎么搭建，而是希望能突出某几项有代表性的技术特性来介绍&amp;mdash;&amp;mdash;它们为什么被创建出来，它们的价值在哪里，都有什么优劣，并在整体上着眼于全局，对基于 Web 的全栈技术有一个认识和把握。如果你初涉 Web 全栈技术不久，我更希望你能在阅读学习之后感慨，哇～居然有这么多有意思的技术，技术还能这样玩！&lt;/p>
&lt;p>即便没有这个专栏，我相信你也一定可以学习自己感兴趣的全栈技术，但是，这个专栏可以帮助你开拓眼界，将这些知识点逐项整理并系统化，帮助你养成在学习实践中思考的良好习惯。先知道&amp;quot;有什么&amp;quot;，才知道&amp;quot;学什么&amp;quot;，最后才能具体去学习，虽然具体的学习往往是没有捷径的，但是&amp;quot;有什么&amp;quot;和&amp;quot;学什么&amp;quot;却可以充分借由他人经验。&lt;/p>
&lt;p>再进一步说说内容广度和深度的问题。&lt;/p>
&lt;ul>
&lt;li>**内容广度：我会选择每个核心领域的代表性技术来介绍。**全栈的技术集合就像一个大观园，每一个子领域，技术往往都非常丰富，因此我们在学习它们的的时候，代表性技术的挑选尤为重要。专栏中每一讲涉及的技术，都是我精心比较后挑选出来的，它们典型、常用，而且深刻，专注于不同的问题领域，在全栈体系中有非常强的代表性，很适合拿来和同类技术做比较。&lt;/li>
&lt;li>**内容深度：我会把深度控制在合适的位置，让入门到进阶的工程师都有收获。**如果你刚刚入门，你可以看得懂大部分内容，并产生兴趣、建立概念；如果你处于进阶阶段，有的内容可能之前有了解过，但学习以后会有新的认识，或者是能把已经掌握的知识点串联起来。同时，请尽可能不要略过总结思考之后的选修课堂和扩展阅读，它们是可以帮助你快速提升的。&lt;/li>
&lt;/ul>
&lt;p>具体内容上，专栏包含网络协议和 Web 接口，MVC 架构相关，前端技术，持久层技术和最佳实践等几大章，这些内容会覆盖到基于 Web 的全栈技术最核心的部分。最后还有一章是综合性、自恰性强的专题，比如网站的性能优化、分页技术等。&lt;/p>
&lt;p>这里再来个小提示。在文章中，我经常会提到一些工具，也会谈到一些关键的命令执行和配置过程，但具体到某些工具的安装，部分我会给出网址，还有一部分工具则是可以使用常规的包管理工具下载安装，比如 macOS 下的 Homebrew，比如 Ubuntu 的 apt-get。通常情况下，请尽量使用 *nix（包括 Linux 和 MacOS） 而不是 Windows。&lt;/p>
&lt;p>最后，我想说每个全栈工程师的学习路径都是独特的，全栈和许多其它软件领域的技术一样，五花八门，日新月异，因此并不好学。我想很少有职业和程序员一样，需要持续、广泛地学习。有诸多品质在学习的过程中都起着至关重要的作用，但是我认为，恒心的作用尤为突出。&lt;/p>
&lt;p>我不想提著名的&amp;quot;一万小时理论&amp;quot;，但这个过程也绝不会一帆风顺，特别是在这个专栏的学习过程中，如果你有困惑、茫然，甚至是沮丧，欢迎你和我聊一聊，一起想想办法，让我们把全栈技术学习这件意义非凡的事情坚持下去。&lt;/p>
&lt;p>谈到这儿，我很想听听你的想法，进而有针对性地为你讲解，更好地帮助你进阶。请来留言区和我讨论吧：&lt;/p>
&lt;ul>
&lt;li>对于全栈技术的学习，和其它技术相比，你觉得有什么样的特点，学习它们最需要做到什么？&lt;/li>
&lt;li>对于专栏的内容设计，你最想听关于全栈技术哪一部分的知识讲解呢？&lt;/li>
&lt;/ul>
&lt;p>现在，就让我们正式开始全栈之旅吧！而故事，就从你输入网址、按下回车的那一瞬间开始&amp;hellip;&amp;hellip;&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/11/8b/1181246bbd51ce348d5729696d1dc28b.jpg" alt="unpreview">&lt;/p></description></item><item><title>极客专栏: 00丨开篇词丨你写的每一行代码，都是你的名片</title><link>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E4%BB%A3%E7%A0%81%E7%B2%BE%E8%BF%9B%E4%B9%8B%E8%B7%AF/00%E4%B8%A8%E5%BC%80%E7%AF%87%E8%AF%8D%E4%B8%A8%E4%BD%A0%E5%86%99%E7%9A%84%E6%AF%8F%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%E9%83%BD%E6%98%AF%E4%BD%A0%E7%9A%84%E5%90%8D%E7%89%87/</link><pubDate>Tue, 07 Jun 2022 00:00:00 +0000</pubDate><guid>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E4%BB%A3%E7%A0%81%E7%B2%BE%E8%BF%9B%E4%B9%8B%E8%B7%AF/00%E4%B8%A8%E5%BC%80%E7%AF%87%E8%AF%8D%E4%B8%A8%E4%BD%A0%E5%86%99%E7%9A%84%E6%AF%8F%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%E9%83%BD%E6%98%AF%E4%BD%A0%E7%9A%84%E5%90%8D%E7%89%87/</guid><description>
&lt;p>你好，我是范学雷，现在是 Oracle 的主任工程师，也是 OpenJDK 和 Java 安全的评审成员。很高兴和你一起聊聊怎么写好代码这个话题。&lt;/p>
&lt;p>我第一次接触计算机，是在 1994 年。那时候，我还是大学一年级的一枚青瓜。当时的计算机发展，正处于青涩的少年阶段。&amp;ldquo;互联网&amp;quot;也还是一个非常生僻的名词。当时，我们用的计算机是&amp;quot;286&amp;rdquo;，操作系统是 DOS，编程语言还是 Fortran 和 C 语言，Java 语言还没有正式诞生。每次上课，都要随身携带容量为 360KB 的 5.25 英寸软盘。娇气的软盘啊，可是不好伺候，动不动就损坏。那时候最渴望的事情，就是能有一张存储容量高达 1.44MB 的高密度 3.5 英寸软盘。&lt;/p>
&lt;p>计算机启蒙课给我印象最深的是什么呢？不是怎么写程序，而是不停地折腾软盘，一直重复&amp;quot;修复、备份&amp;quot;这个过程。也许是因为软盘的拷贝和修复太无聊，我一直对计算机以及编程没有特别大的兴趣。&lt;/p>
&lt;p>但大学最后一年，两件小事让我改变了对计算机和编程的态度，给我带来了巨大的影响。&lt;/p>
&lt;p>第一件事是，我一个同学编写的五子棋人机对弈程序，当时打遍全班无敌手。厉害吧！用现在的话说，就是&amp;quot;怎么可以这么炸&amp;quot;！这可不是使蛮力，用穷举法就可以搞定的，到底是怎么做到的？这引起了我对计算机程序的强烈兴趣。&lt;/p>
&lt;p>第二件事是，我另一个同学的毕业论文选择了密码学作为研究方向。这个同学有一个优点，不管什么事情，都特别喜欢分享。用东北话说，就是爱嘚瑟，逢人便絮叨。最后差不多全班都知道了密码学的一些基本概念，了解了与之相关的好多传奇故事。密码学这种超神秘、超有趣、超复杂的存在，简直吊足了我的胃口。&lt;/p>
&lt;p>**我们的每一次经历，都塑造着我们自己。**写人机对弈程序的同学，第一次面试就找好了工作，进了最好的公司。研究密码学的同学，是中国商业密码产业化最早的参与者之一。而我自己呢，在他们的影响下，也找到了计算机的乐趣，享受着解决复杂问题带来的喜悦。&lt;/p>
&lt;p>编程和密码学这两个东西合在一起，就是我现在每天工作的主要内容。具体来说就是两件事：&lt;strong>写代码和看代码&lt;/strong>。&lt;/p>
&lt;p>写代码这件事，就我自己的经历来说，有点像过山车。&lt;/p>
&lt;p>我刚开始学习编程时，写几十行代码都觉得痛苦、费劲，不知道从哪儿下手。这种状况一直持续了很多年，直到 1998 年我参加工作，编写程序成了我的职业。职业也就意味着，编码有了具体的目标，代码有了具体的质量要求。&lt;/p>
&lt;p>我是幸运的。目标，有人掰碎了、揉烂了给我讲；质量，有人睁大了眼睛盯着看，也有人不顾情面地给我指出各种问题。有了目标就有了思路，有了要求就有了动力。如果再有人不离不弃地帮助，每一个度日如年的煎熬，最终都会变成&amp;quot;士别三日&amp;quot;的惊喜。慢慢地，我就可以写几百行、几千行、几万行甚至十几万行的代码了。而且越写越快，越写越好。&lt;/p>
&lt;p>大概到了 2000 年的时候，代码设计对我来说可能依然很费时间，但是只要写起代码来，一天数千行也是很常见的。一天洋洋洒洒写数千行代码，暗暗觉得自己挺牛，挺了不起的。&lt;/p>
&lt;p>&amp;ldquo;&lt;strong>无知要比知识更容易产生自信&lt;/strong> &amp;ldquo;。幸运的是，这种盲目的自信没有持续太久，我很快就见识到了更宽阔的世界。2004 年，我加入了 Java 安全组，真正地见识到了，优秀的设计和优秀的代码，是怎么一步一个脚印地出炉的，了解到代码背后的各种综合考量和艰难取舍。慢慢地，我自己也完成了从&amp;quot;代码数量优先&amp;quot;到&amp;quot;代码质量优先&amp;quot;的思路转变**。**&lt;/p>
&lt;p>如果回头看十多年前编写的代码，就像是看筛子一样，到处都是清清楚楚的破洞。也许，这是每个程序员都要经历的过程吧。&lt;/p>
&lt;p>&lt;strong>我们总是先要解决掉数量问题，然后才能解决掉质量问题。&lt;/strong>&lt;/p>
&lt;p>这个过程，还真的有点&amp;quot;看山是山，看山不是山，看山还是山&amp;quot;的味道。&lt;/p>
&lt;p>看代码这件事，对我来说，其实是一个收获大于付出的过程。&lt;/p>
&lt;p>OpenJDK 的代码必须通过评审才可以提交。OpenJDK 社区有非常广泛的代码贡献群体，有些是还没有毕业的年轻学生，也有些资深的业界老专家。新手当然有新手的困惑，而老辣的程序员，也会犯简单的错误。&lt;/p>
&lt;p>一个代码评审者的主要工作，不是批准或者拒绝提交的代码，而是提出合理的建议，帮助代码提交者规避这些失误或者错误，编写出更优秀的代码。&lt;/p>
&lt;p>看代码看得多了，对代码就有更多的了解。 比如，&lt;strong>什么样的代码更容易出问题？ 什么样的代码会招惹麻烦？ 什么样的代码出力不讨好？ 什么样的代码小问题闯大祸？&lt;/strong>&lt;/p>
&lt;p>同时，也对程序员有了更多的了解。 比如，&lt;strong>为什么我们不愿意写注释呢？ 为什么代码写完就不愿意修改了呢？为什么我们不愿意做测试呢？ 为什么我们向往自由而不愿意遵守规范呢？&lt;/strong>&lt;/p>
&lt;p>每一行代码，都体现着程序员的修为，思考问题的深度，甚至是处理问题的习惯和态度。&lt;strong>代码，是我们交流的语言和处世的名片。&lt;/strong>&lt;/p>
&lt;p>这些问题，思考总结下来，就是代码评审的经历馈赠给我的礼物，而且是天大的礼物。&lt;/p>
&lt;p>现在我把这份礼物沉淀下来，就是我们这个专栏的主要内容。我想通过这样一个专栏，让你拥有和我一样的收获。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/56/f6/56a1b164ece4b2c70ee4e49521eb06f6.jpg" alt="">&lt;/p>
&lt;p>回顾我这二十多年的程序员经历，我觉得自己是非常幸运的。现在，我们常常调侃&amp;quot;35 岁码农大龄恐惧症&amp;rdquo;。幸运的是，当这种病毒一般的焦虑开始流传开来的时候，我早已经过了 35 岁，已经来不及担心了。&lt;/p>
&lt;p>这种焦虑之所以广泛流传，背后传达的一个本质问题就是：&lt;strong>作为一名软件工程师，我们该怎么快速成长，并且保持长久的竞争力？&lt;/strong>&lt;/p>
&lt;p>解决这个问题的终极方法，只有一个，那就是&lt;strong>持续地交付优秀的结果&lt;/strong>。宜早不宜迟。&lt;/p>
&lt;p>作为解决现实问题的软件工程师，不管资历深、资历浅，我们都需要编写优秀的代码，并且是越来越优秀的代码，因为这是我们生存的基本依靠。作为活在现实世界的技术工程师，我们需要保持长久的竞争力，甚至是越来越强的竞争力，因为这是改善我们生存质量的最好方式。&lt;/p>
&lt;p>在这个专栏里，我会带着你开始一段代码精进的旅程。和你一起来看一看、摸一摸那些年别人踩过的坑，来聊一聊、试一试我们的代码可以写得有多棒，享受这个打怪升级的过程。&lt;/p>
&lt;p>那么现在，给你一个机会，你敢不敢吐槽一下你见过的或者写过的，最&amp;quot;差劲儿&amp;quot;的代码？或者，你愿不愿意秀秀你自己最中意的代码？&lt;/p>
&lt;p>也欢迎你在留言区写下自己的编程故事，等到专栏结束后，我们再回过头来，看看你走出了怎样的成长轨迹。&lt;/p>
&lt;blockquote>
&lt;p>我渴望做那些伟大而高贵的任务，但是，我首要的责任和快乐却是去完成那些卑微的任务，把它们也当作伟大而且高贵的一样。世界在前行，不只是那些英雄们的力量在推动，也同样包括那些来自每个诚实的工作者微小推动的积累。&amp;mdash;&amp;mdash; 海伦•凯勒&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/5a/98/5a96a612403912b80de030e742e2e598.jpg" alt="">&lt;/p></description></item><item><title>极客专栏: 00丨开篇词丨怎样成长为优秀的软件架构师？</title><link>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E8%AE%B8%E5%BC%8F%E4%BC%9F%E7%9A%84%E6%9E%B6%E6%9E%84%E8%AF%BE/00%E4%B8%A8%E5%BC%80%E7%AF%87%E8%AF%8D%E4%B8%A8%E6%80%8E%E6%A0%B7%E6%88%90%E9%95%BF%E4%B8%BA%E4%BC%98%E7%A7%80%E7%9A%84%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E5%B8%88/</link><pubDate>Tue, 07 Jun 2022 00:00:00 +0000</pubDate><guid>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E8%AE%B8%E5%BC%8F%E4%BC%9F%E7%9A%84%E6%9E%B6%E6%9E%84%E8%AF%BE/00%E4%B8%A8%E5%BC%80%E7%AF%87%E8%AF%8D%E4%B8%A8%E6%80%8E%E6%A0%B7%E6%88%90%E9%95%BF%E4%B8%BA%E4%BC%98%E7%A7%80%E7%9A%84%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E5%B8%88/</guid><description>
&lt;p>你好，我是许式伟。从今天起，我想和你一起来聊聊架构的话题。&lt;/p>
&lt;p>开始之前，我先来和你简单介绍下我自己。&lt;/p>
&lt;p>我是 2000 年开始工作的，曾经做过 WPS 的首席架构师，也在盛大从事过技术研究方面的工作，后来在 2011 年创立了七牛云，现在我是一名创业者、CEO。但不管角色怎么轮换，我觉得我的另一面始终是一名程序员、架构师（如果你想了解更多我的经历，可以观看下面的短视频）。&lt;/p>
&lt;br />
&lt;br />
&lt;p>让我们来想象一下，如果把信息世界看成一座大厦，把程序员看成这个世界的建筑师，那么，现在的你在负责什么样的工作呢？&lt;/p>
&lt;p>当我们把程序员类比成建筑师时，按照能力水平来分，我觉得大体可以分为三个层次：搬砖师、工程师、架构师。&lt;/p>
&lt;p>软件搬砖师之名对应到建筑行业的建筑工人，他们的编程能力和业务基本上停留在堆叠代码，按照要求去实现功能需求的层面。&lt;/p>
&lt;p>只要能让程序跑起来，能正确地实现业务逻辑，就可以称为&amp;quot;会编程&amp;quot;的人。有时候，我们也会看见程序员自称为&amp;quot;码农&amp;quot;&amp;ldquo;搬砖的&amp;rdquo;，虽然二者的工种不同，但从基础工作的相似度来说，确实有可类比的成分。&lt;/p>
&lt;p>很多外行的人都会觉得程序员是一个很神秘的职业，但实际上程序员的基础门槛并不算高。我自己从 2016 年 2 月开始至今，一直在教几位 8~12 岁的小朋友学习编程。这个实践经验告诉我：小学生完全有能力学编程。而且，并不是只有部分小学生可以，而是任何一位小学生都可以学会。&lt;/p>
&lt;p>然而，只让代码跑起来是不够的。这个世界是不断变化的，作为程序员，我们更多的时间是用来维护代码：增加新的需求，对已有的功能进行调整，修改之前代码遗留下来的问题，优化性能等等。&lt;/p>
&lt;p>这是因为一个软件诞生之后，后续就是需要花费大量的代价去维护它，演进它。一个人是完全维护不过来的，需要更多的人，很多的团队一起协作。如果面临了员工离职、岗位调整等情况，还会导致软件代码在不同人之间流转。&lt;/p>
&lt;p>所以，一些有追求的程序员会关注代码的质量。代码质量的评判可以有这样一些基本维度：可阅读性（方便代码流转）、可扩展性 / 可维护性（方便修改功能，添加新功能）、可测试性（质量管理）、可复用性（简化后续功能开发的难度）。&lt;/p>
&lt;p>这一类致力于不断提升软件代码的工程质量的程序员，我们可以称他们为软件工程师。&lt;/p>
&lt;p>工程师不会简单把写代码看作一门工作，把任务交代过去就完事。他们会有&amp;quot;洁癖&amp;quot;，代码在他们眼里是一种艺术，是自己生命的一部分。&lt;/p>
&lt;p>他们会把写出来的代码改了又改，直到让自己满意为止。阅读和维护软件工程师写的代码会有一种赏心悦目的感觉。&lt;/p>
&lt;p>但是，大部分商业软件都是一项极其复杂的工程，它们远比很多传统的建筑工程复杂得多，无论是涉及的人力、时间还是业务的变数都要多很多。&lt;/p>
&lt;p>人力上，大部分大型的软件系统都有几千甚至几万人的规模，而这几千几万人中，却没有两个人的工作是重复的，他们都是在从事着前所未有的创造性工作。&lt;/p>
&lt;p>时间上，只要软件还在服务客户中，程序员们的创造过程便不会停止，软件系统仍然持续迭代更新，以便形成更好的市场竞争力。&lt;/p>
&lt;p>这些都与传统建筑工程的模式大相径庭。一幢建筑自它完成之后，所有的变化便主要集中在一些软装的细节上，很少会再发生剧烈的变动，更不会持续地发生变动。但软件却不是这样，它从诞生之初到其生命周期结束，自始至终都在迭代变化，从未停止。&lt;/p>
&lt;p>所以，光靠把控软件工程师的水平，依赖他们自觉保障的工程质量，是远远不够的。软件工程是一项非常复杂的系统工程，它需要依赖一个能够掌控整个工程全局的团队，来规划和引导整个系统的演变过程。这个团队就是架构师团队。&lt;/p>
&lt;p>软件架构师的职责，并不单单是我们通常理解的，对软件系统进行边界划分和模块规格的定义。&lt;/p>
&lt;p>从根本目标来说，软件架构师要对软件工程的执行结果负责，这包括：按时按质进行软件的迭代和发布、敏捷地响应需求变更、防范软件质量风险（避免发生软件质量事故）、降低迭代维护成本。&lt;/p>
&lt;p>&lt;strong>那怎么才能成长为优秀的软件架构师？软件架构师和软件工程师最根本的差别又在哪里？我认为关键在于四个字：掌控全局。&lt;/strong>&lt;/p>
&lt;p>掌控全局，就是对系统的全貌了然于胸。从传统的建筑工程来说，建筑架构师并不单单要会画建筑图纸，而是要对地基构建、土质、材料、建筑工艺等等所有有可能影响建筑质量的因素都要了然于胸。&lt;/p>
&lt;p>掌控全局，并不是无所不能，不是成为全栈，怎么做到掌控全局？核心在于对知识脉络的体系化梳理。这是架构能力构建和全面提升的关键。这种方法不单单是在软件工程中适用。&lt;/p>
&lt;p>比如学数学，我个人非常喜欢做的一件事情是自己去推导书上所有的公式。每一个公式我都亲自推导而来。&lt;/p>
&lt;p>这样做的核心意义在于，我在尝试从 0 开始，去构建整个精彩纷呈的数学世界，整个数学发展史在自己的笔下重新演绎了一遍，来龙去脉清清楚楚。有时候你甚至会推导出还没有学到的公式，但是在后面学到了。这种体验非常有趣而又让人满足。&lt;/p>
&lt;p>是的，掌控全局的前提是：在自己心中去重新构建出整个世界。在这个过程中，你不需要一上来沉浸在某个技术的实现细节（除非它影响了你对这个世界构建过程的理解），但是你知道整个世界的脉络，知道整个世界的骨架。&lt;/p>
&lt;p>这个时候，你对这个世界的感觉是完全不同的，因为，你已经成为了这个世界的构建者。&lt;/p>
&lt;p>而架构的本质，不也正是构建和创造么？&lt;/p>
&lt;p>作为一个软件行业的从业人员，我们可能接触各种各样的技术书籍。有讲编程语言的、讲数据结构与算法的、讲操作系统的、讲编译原理的、讲架构设计的，还有领域技术类的（比如数据库、存储、大数据、人工智能之类）。&lt;/p>
&lt;p>大部分类别的技术书，多多少少都能够找到几本经典著作。但是，架构设计很可能是个例外，当我想推荐一本经典的架构设计书时，我并不能非常快速地想到应该推荐哪本。&lt;/p>
&lt;p>从个人经验来说，我接触过的与架构相关的图书，大概有如下这些分类。&lt;/p>
&lt;ul>
&lt;li>架构思维类。这类图书通常从一些著名的架构理论讲起，比如开闭原则、单一职责原则、依赖倒置原则、接口分离原则，等等。这种图书的问题在于过度理论化。计算机科学归根到底属于工程技术类，实践第一。&lt;/li>
&lt;li>设计模式类。这一类图书则一下子进入架构的局部细节，每个模式的来龙去脉并不容易理解。就算理解了某个具体的模式，但是也很难真正做到活学活用，不知道还是不知道。&lt;/li>
&lt;li>分布式系统架构设计类。这类图书通常从服务端的通用问题如一致性、高可用、高并发挑战等话题讲起，讲大型业务系统面临的挑战。这些知识是非常有价值的，但无法延伸到通用业务架构，对大部分企业的架构实践并不具备真正的指导意义。&lt;/li>
&lt;li>重构类。这类图书主要讲怎么把坏代码一步步改进到好代码。我认为这是最实用的一类。但在没有优秀架构师主导的情况下，大部分公司的代码不可避免地越变越坏，直到不堪重负最后不得不重写。实际上，一个模块最初的地基是最重要的，基本决定了这座大厦能够撑多久，而重构更多侧重于大厦建成之后，在服务于人的前提下怎么去修修补补，延长生命。&lt;/li>
&lt;/ul>
&lt;p>这些架构类的图书并没有达到我个人的期望。因为它们都没有揭开架构设计的全貌。&lt;/p>
&lt;p>我自己在职业生涯中前后大概做过十几次的架构类演讲，这也是我最为重视、重复次数最多的一类演讲。但同样地，这样零星的演讲对于传递架构设计思想来说，仍然远远不够。&lt;/p>
&lt;p>&lt;strong>所以一直以来，我就心存着这样一个念头：&amp;ldquo;要写一本不一样的架构类图书&amp;rdquo;。这个念想，也正是今天这个专栏的由来。&lt;/strong>&lt;/p>
&lt;p>这个专栏的内容组织算是我的一次尝试。它和今天你看得到的大部分架构书并不太一样。我基本上围绕着两个脉络主线来展开内容：&lt;/p>
&lt;ul>
&lt;li>如何从零开始一步步构建出整个信息世界；&lt;/li>
&lt;li>在整个信息世界的构建过程中，都用了哪些重要的架构思维范式，以及这些范式如何去运用于你平常的工程实践中。&lt;/li>
&lt;/ul>
&lt;p>这两大脉络相辅相成。首先，我们通过还原信息世界的构建过程，剥离出了整个信息世界的核心骨架，这也是最真实、最宏大的架构实践案例。其次，我们结合这个宏大的架构实践来谈架构思维，避免因对架构思维的阐述过于理论化而让人难以理解。&lt;/p>
&lt;p>我想，每个程序员都有一颗成为架构师的心。所以，从内容设计来说，我希望这是一个门槛最低的架构设计专栏，也希望它可以帮助到想成为架构师的初学者，达成自己的目标。&lt;/p>
&lt;p>在行文上，我会尽量避免深奥的术语，尽可能以通俗易懂的文字，来描述信息世界构建者们的所思所想。如果你在阅读的过程中遇到了理解上的障碍，非常欢迎你来给我留言，我将尽可能地根据你的反馈，做出必要的调整。&lt;/p>
&lt;p>如果你已经成为了架构师，我也希望可以为你规避一些错误的经验。在过去的工作经历里，我看到不少架构师都会倾向于把架构看作一项纯技术性的行为。他们的工作流程是这样的：产品经理根据用户的需求做出产品设计，然后架构师再依据产品设计给出实现，也就是软件的架构设计方案。&lt;/p>
&lt;p>在我看来，这其实是个误解。架构关乎的是整个复杂的软件工程，它关乎实现它的人，它又因团队的能力而异。&lt;/p>
&lt;p>同时，架构也关乎用户需求，作为架构师，我们不只是要知道当前的用户需求是什么，我们还要预测需求未来可能的变化，预判什么会发生，而什么一定不会发生。预测什么不会发生最为重要，只有做到这一点，才能真正防止架构的过度设计，把简单的事情复杂化。&lt;/p>
&lt;p>谈了这么多，那么，应该怎样成长为优秀的软件架构师？**我想，一靠匠心，二靠悟心。**架构设计并无标准答案，但我仍然希望把我这些年的所思所想分享给你，更希望这些内容能给你一些启发。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/43/00/43231f3789095eb4cdb38e67ff3d7900.jpg" alt="">&lt;/p></description></item><item><title>极客专栏: 00丨开篇词丨这年头，你真应该懂点法律常识</title><link>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E7%99%BD%E8%AF%9D%E6%B3%95%E5%BE%8B/00%E4%B8%A8%E5%BC%80%E7%AF%87%E8%AF%8D%E4%B8%A8%E8%BF%99%E5%B9%B4%E5%A4%B4%E4%BD%A0%E7%9C%9F%E5%BA%94%E8%AF%A5%E6%87%82%E7%82%B9%E6%B3%95%E5%BE%8B%E5%B8%B8%E8%AF%86/</link><pubDate>Tue, 07 Jun 2022 00:00:00 +0000</pubDate><guid>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E7%99%BD%E8%AF%9D%E6%B3%95%E5%BE%8B/00%E4%B8%A8%E5%BC%80%E7%AF%87%E8%AF%8D%E4%B8%A8%E8%BF%99%E5%B9%B4%E5%A4%B4%E4%BD%A0%E7%9C%9F%E5%BA%94%E8%AF%A5%E6%87%82%E7%82%B9%E6%B3%95%E5%BE%8B%E5%B8%B8%E8%AF%86/</guid><description>
&lt;p>你好，我是周甲德，是北京市京师律师事务所的一名律师，你可以叫我老周。工作十年，我办过大大小小一百多起案件，杀人放火的、骗财骗色的，各种或奇葩或惊悚的事儿都没少见。按理来说经历过这么多，人的心态应该很&amp;quot;淡定&amp;quot;。但是，一年前的一条新闻还是震惊到了我，这也是我接受&amp;quot;极客时间&amp;quot;的邀请来写这个专栏的原因。&lt;/p>
&lt;p>你大概猜到了是哪个新闻，没错，就是技术圈有名的 WePhone 开发者苏享茂事件。苏享茂是一名创业的程序员，因为跟前妻离婚被索要了巨额钱财，同时公司的资金链断裂，不堪重负跳楼自杀。这个案件本身很普通，但让我震惊的是，像苏享茂这样的技术人才，却丝毫不懂法。&lt;/p>
&lt;p>我甚至怀疑他没有咨询过律师，不然他起码了解前妻的要求是否有法律依据，也会知道，&lt;strong>即使一个人做了错事犯了法，也只有法律才有定罪的资格&lt;/strong>。如果他稍微有点法律意识，可能就是另外一个结局，起码不用付出生命的代价。&lt;/p>
&lt;p>如果觉得这个话题太沉重，再看看下面的新闻，是不是你非常熟悉的情节？&lt;/p>
&lt;ul>
&lt;li>
&lt;p>程序员非法出售 VPN，被判刑三年并罚款一万&lt;/p>
&lt;/li>
&lt;li>
&lt;p>男子卖&amp;quot;绝地求生&amp;quot;外挂月入数万，最后却被抓&lt;/p>
&lt;/li>
&lt;li>
&lt;p>腾讯 23 岁工程师检查酒店 WiFi 漏洞，被新加坡安全局逮捕&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>你看，这些事情触目惊心，并不是因为事件本身多恶劣、罪名多严重，而是&lt;strong>这些都是你习以为常的&amp;quot;小事&amp;quot;&lt;/strong>！你不以为意，承担后果时才唏嘘不已！&lt;/p>
&lt;p>每当发生这样的事情，媒体上就会有各种&amp;quot;技术人单纯&amp;quot;的言论。作为一名律师，我看到的其实是大多数人都没有基本的法律常识，甚至是精英的技术人也不例外。&lt;/p>
&lt;p>别等到身陷囹圄或人财两空才后悔，预防永远是上乘之选。&lt;strong>事实上，法律作为一种底层能力，最重要的价值正是风险防范&lt;/strong>。事想到前头做，话想到前面说，就更容易有好结果。但要做到这些并不容易，是需要懂点法律、有点风险意识的。&lt;/p>
&lt;p>你是不是这么想过，我又不去招惹是非，一直本本份份，法与我何关？我想和你说，法律就在我们每个人生活中，一呼一吸都关乎法律。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/97/5e/97cdda494c3cfb7b702f2af5bf3b535e.jpeg" alt="">&lt;/p>
&lt;p>比如在刚入职签劳动合同时，我会仔细阅读工资待遇、五险一金和保密事项等内容，因为我清楚，一旦&lt;strong>落笔&lt;/strong>，这张纸便成了我板上钉钉的法律责任，即使有不合理的地方也得认了。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/f4/43/f481267482baad8312466364e25b4543.jpeg" alt="">&lt;/p>
&lt;p>再如租房时，我会查清楚中介的资质和房东的手续，正式入住之前也会&lt;strong>记录好&lt;/strong>所有大件物品的交接，然后严肃对待租房合同，这样在出问题时，才知道怎么保护自己的利益。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/0c/26/0cadacc872e167b32376295229345226.jpeg" alt="">&lt;/p>
&lt;p>哪怕是我身边做技术的朋友，也会死死记住不去碰一些&amp;quot;&lt;strong>雷区&lt;/strong>&amp;quot;，像是给私人建设黄色网站、帮人搭建套现平台这些活儿，甚至只是&amp;quot;爬虫&amp;quot;获取一些数据信息，他们也会注意不能&amp;quot;过了线&amp;quot;。因为我平常总强调相关罪行的具体场景和后果界定，他们也就记住了。&lt;/p>
&lt;p>这些都是懂点法、有风险意识的具体体现，也是专栏中我想要教给你、让你能做到的东西。我选取了职场上、技术上和生活中的 40 多个经典场景，结合自已多年的执业经验和感受，把我见过的&amp;quot;雷区&amp;quot;和解决手段都告诉你，让你尽可能不走或少走法律的弯路。&lt;strong>我们一起，从现实场景出发，再回到现实的风险意识和解决方案。&lt;/strong>&lt;/p>
&lt;p>你不用害怕会有晦涩的法律条文，这其实是一个认识误区，很多人都以为学法就是去背数不清又难懂的法律条文。其实，对于大多数人来说，这完全没有必要。实际上，你需要学的是法律常识，是法律在日常的应用。这些东西，我会用最直白的语言和真实的案例来讲，保证你能轻松学懂、会用。&lt;/p>
&lt;p>另外每天学习结束，我会给你留一个思考题，帮你加深对内容的印象，同时也是为了让留言区成为我们交流的平台。除了回答问题，我还希望你有更多的想法，比如可以总结你的学习笔记，分享你的某些故事，或是对某句话、某个观点的感触，你都可以记录下来。你还可以写下你的疑惑，提出最关心的法律问题，我也会抽空回复你。&lt;/p>
&lt;p>参与、思考并输出，才是学习的最佳途径。这样，&amp;ldquo;我的&amp;quot;才可以内化成&amp;quot;你的&amp;rdquo;。&lt;/p>
&lt;p>说了这么多，其实我的目的很简单，那就是希望你学完这个专栏后，可以解锁这三个成就：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>了解法律常识，有风险防范意识；&lt;/strong>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>会用法律思维处理问题，不走弯路；&lt;/strong>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>做到&amp;quot;我不坑人，不被人坑&amp;quot;。&lt;/strong>&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>这是我的期许，在正式开始学习之前也很想听听你的声音，你觉得法律和自己的关系是怎样的？有没有什么问题或者困惑，希望可以咨询律师呢？你都可以给我留言。&lt;/p>
&lt;p>我很喜欢一句话，上帝只救自救之人。我不希望你坑人或是被人坑，只想让法律给你生存底气，成为保护你的&amp;quot;三级盔甲&amp;quot;。接下来，就让我们一起为你组装专属的法律盔甲吧！&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/10/ae/109d74bf33e68fa4206ce2ae524c75ae.jpg" alt="">&lt;/p></description></item><item><title>极客专栏: 00丨开篇词丨业务代码真的会有这么多坑？</title><link>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/java%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF100%E4%BE%8B/00%E4%B8%A8%E5%BC%80%E7%AF%87%E8%AF%8D%E4%B8%A8%E4%B8%9A%E5%8A%A1%E4%BB%A3%E7%A0%81%E7%9C%9F%E7%9A%84%E4%BC%9A%E6%9C%89%E8%BF%99%E4%B9%88%E5%A4%9A%E5%9D%91/</link><pubDate>Sun, 29 May 2022 00:00:00 +0000</pubDate><guid>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/java%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF100%E4%BE%8B/00%E4%B8%A8%E5%BC%80%E7%AF%87%E8%AF%8D%E4%B8%A8%E4%B8%9A%E5%8A%A1%E4%BB%A3%E7%A0%81%E7%9C%9F%E7%9A%84%E4%BC%9A%E6%9C%89%E8%BF%99%E4%B9%88%E5%A4%9A%E5%9D%91/</guid><description>
&lt;p>你好，我是朱晔，贝壳金服的资深架构师。&lt;/p>
&lt;p>我先和你说说我这 15 年的工作经历吧，以加深彼此的了解。前 7 年，我专注于.NET 领域，负责业务项目的同时，也做了很多社区工作。在 CSDN 做版主期间，我因为回答了大量有关.NET 的问题，并把很多问题的答案总结成了博客，获得了 3 次微软 MVP 的称号。&lt;/p>
&lt;p>后来，我转到了 Java 领域，也从程序员变为了架构师，更关注开源项目和互联网架构设计。在空中网，我整体负责了百万人在线的大型 MMO 网游《激战》技术平台的架构设计，期间和团队开发了许多性能和稳定性都不错的 Java 框架；在饿了么，我负责过日千万订单量的物流平台的开发管理和架构工作，遇到了许多只有高并发下才会出现的问题，积累了大量的架构经验；现在，我在贝壳金服的基础架构团队，负责基础组件、中间件、基础服务开发规划，制定一些流程和规范，带领团队自研 Java 后端开发框架、微服务治理平台等，在落地 Spring Cloud 结合 Kubernetes 容器云平台技术体系的过程中，摸索出了很多适合公司项目的基础组件和最佳实践。&lt;/p>
&lt;p>这 15 年来，我一直没有脱离编码工作，接触过大大小小的项目不下 400 个，自己亲身经历的、见别人踩过的坑不计其数。我感触很深的一点是，业务代码中真的有太多的坑：有些是看似非常简单的知识点反而容易屡次踩坑，比如 Spring 声明式事务不生效的问题；而有些坑因为&amp;quot;潜伏期&amp;quot;长，引发的线上事故造成了大量的人力和资金损失。因此，我系统梳理了这些案例和坑点，最终筛选出 100 个案例，涉及 130 多个坑点，组成了这个课程。&lt;/p>
&lt;h1 id="意识不到业务代码的坑很危险">意识不到业务代码的坑，很危险&lt;/h1>
&lt;p>我想看到 100、130 这两个数字，你不禁要问了：&amp;ldquo;我写了好几年的业务代码了，遇到问题时上网搜一下就有答案，遇到最多的问题就是服务器不稳定，重启一下基本就可以解决，哪里会有这么多坑呢？&amp;ldquo;带着这个问题，你继续听我往下说吧。&lt;/p>
&lt;p>据我观察，很多开发同学没意识到这些坑，有以下三种可能：&lt;/p>
&lt;ul>
&lt;li>意识不到坑的存在，比如所谓的服务器不稳定很可能是代码问题导致的，很多时候遇到 OOM、死锁、超时问题在运维层面通过改配置、重启、扩容等手段解决了，没有反推到开发层面去寻找根本原因。&lt;/li>
&lt;li>有些问题只会在特定情况下暴露。比如，缓存击穿、在多线程环境使用非线程安全的类，只有在多线程或高并发的情况才会暴露问题。&lt;/li>
&lt;li>有些性能问题不会导致明显的 Bug，只会让程序运行缓慢、内存使用增加，但会在量变到质变的瞬间爆发。&lt;/li>
&lt;/ul>
&lt;p>而正是因为没有意识到这些坑和问题，采用了错误的处理方式，最后问题一旦爆发，处理起来就非常棘手，这是非常可怕的。下面这些场景有没有感觉似曾相识呢？&lt;/p>
&lt;p>比如，我曾听说过有一个订单量很大的项目，每天总有上千份订单的状态或流程有问题，需要花费大量的时间来核对数据，修复订单状态。开发同学因为每天牵扯太多经历在排查问题上，根本没时间开发新需求。技术负责人为此头痛不已，无奈之下招了专门的技术支持人员。最后痛定思痛，才决定开启明细日志彻查这个问题，结果发现是自调用方法导致事务没生效的坑。&lt;/p>
&lt;p>再比如，有个朋友告诉我，他们的金融项目计算利息的代码中，使用了 float 类型而不是 BigDecimal 类来保存和计算金额，导致给用户结算的每一笔利息都多了几分钱。好在，日终对账及时发现了问题。试想一下，结算的有上千个用户，每个用户有上千笔小订单，如果等月终对账的时候再发现，可能已经损失了几百万。&lt;/p>
&lt;p>再比如，我们使用 RabbitMQ 做异步处理，业务处理失败的消息会循环不断地进入 MQ。问题爆发之前，可能只影响了消息处理的时效性。但等 MQ 彻底瘫痪时，面对 MQ 中堆积的、混杂了死信和正常消息的几百万条数据，你除了清空又能怎么办。但清空 MQ，就意味着要花费几小时甚至几十小时的时间，来补正常的业务数据，对业务影响时间很长。&lt;/p>
&lt;p>像这样由一个小坑引发的重大事故，不仅仅会给公司造成损失，还会因为自责影响工作状态，降低编码的自信心。我就曾遇到过一位比较负责的核心开发同学，因为一个 Bug 给公司带来数万元的经济损失，最后心理上承受不住提出了辞职。&lt;/p>
&lt;p>其实，很多时候不是我们不想从根本上解决问题，只是不知道问题到底在了哪里。要避开这些坑、找到这些定时炸弹，第一步就是得知道它们是什么、在哪里、为什么会出现。而讲清楚这些坑点和相关的最佳实践，正是本课程的主要内容。&lt;/p>
&lt;h1 id="这个课程是什么">这个课程是什么？&lt;/h1>
&lt;p>如果用几个关键词概括这个课程的话，那我会选择&amp;quot;Java&amp;quot;&amp;ldquo;业务开发&amp;quot;&amp;ldquo;避坑 100 例&amp;quot;这 3 个。接下来，我就和你详细说说这个课程是什么，以及有什么特点。&lt;/p>
&lt;p>&lt;strong>第一个关键词是&amp;quot;Java&amp;rdquo;&lt;/strong>，指的是课程内所有 Demo 都是基于 Java 语言的。&lt;/p>
&lt;p>如果你熟悉 Java，那可以 100% 体会到这些坑点，也可以直接用这些 Demo 去检查你的业务代码是否也有类似的错误实现。&lt;/p>
&lt;p>如果你不熟悉 Java 问题也不大，现在大部分高级语言的特性和结构都差不多，许多都是共性问题。此外&amp;quot;设计篇&amp;quot;&amp;ldquo;安全篇&amp;quot;的内容，基本是脱离具体语言层面的、高层次的问题。因此，即使不使用 Java，你也可以有不少收获，这也是本课程的第一个特点。&lt;/p>
&lt;p>讲到这里，我要说明的是，这个课程是围绕坑点而不是 Java 语言体系展开的，因此不是系统学习 Java 的教材。&lt;/p>
&lt;p>&lt;strong>第二个关键词是&amp;quot;业务开发&amp;rdquo;，也就是说课程内容限定在业务项目的开发，侧重业务项目开发时可能遇到的坑。&lt;/strong>&lt;/p>
&lt;p>我们先看&amp;quot;业务&amp;quot;这个词。做业务开发时间长的同学尤其知道，业务项目有两大特点：&lt;/p>
&lt;ul>
&lt;li>工期紧、逻辑复杂，开发人员会更多地考虑主流程逻辑的正确实现，忽略非主流程逻辑，或保障、补偿、一致性逻辑的实现；&lt;/li>
&lt;li>往往缺乏详细的设计、监控和容量规划的闭环，结果就是随着业务发展出现各种各样的事故。&lt;/li>
&lt;/ul>
&lt;p>根据这些性质，我总结出了近 30 个方面的内容，力求覆盖业务项目开发的关键问题。案例的全面性，是本课程的第二大特点。&lt;/p>
&lt;p>这些案例可以看作是 Java 业务代码的避坑大全，帮助你写出更好的代码，也能帮你进一步补全知识网增加面试的信心。你甚至可以把二级目录当作代码审核的 Checklist，帮助业务项目一起成长和避坑。&lt;/p>
&lt;p>我们再看&amp;quot;开发&amp;quot;这个词。为了更聚焦，也更有针对性，我把专栏内容限定在业务开发，不会过多地讨论架构、测试、部署运维等阶段的问题。而&amp;quot;设计篇&amp;rdquo;，重在讲述架构设计上可能会遇到的坑，不会全面、完整地介绍高可用、高并发、可伸缩性等架构因素。&lt;/p>
&lt;p>&lt;strong>第三个关键词是&amp;quot;避坑 100 例&amp;rdquo;。坑就是容易犯的错，避坑就是踩坑后分析根因，避免重复踩同样的坑。&lt;/strong>&lt;/p>
&lt;p>整个课程 30 篇文章，涉及 100 个案例、约 130 个小坑，其中 40% 来自于我经历过或者是见过的 200 多个线上生产事故，剩下的 60% 来自于我开发业务项目，以及日常审核别人的代码发现的问题。贴近实际，而不是讲述过时的或日常开发根本用不到的技术或框架，就是本课程的第三大特点了。&lt;/p>
&lt;p>大部分案例我会配合一个可执行的 Demo 来演示，Demo 中不仅有错误实现（踩坑），还有修正后的正确实现（避坑）。完整且连续、授人以渔，是本课程的第四大特点。&lt;/p>
&lt;ul>
&lt;li>完整且连续，知其所以然。我会按照&amp;quot;知识介绍 -&amp;gt; 还原业务场景 -&amp;gt; 错误实现 -&amp;gt; 正确实现 -&amp;gt; 原理分析 -&amp;gt; 小总结 &amp;ldquo;来讲解每个案例，针对每个坑点我至少会给出一个解决方案，并会挑选核心的点和你剖析源码。这样一来，你不仅能避坑，更能知道产生坑的根本原因，提升自己的技术能力。&lt;/li>
&lt;li>授人以渔。在遇到问题的时候，我们一定是先通过经验和工具来定位分析问题，然后才能定位到坑，并不是一开始就知道为什么的。在这个课程中，我会尽可能地把分析问题的过程完整地呈现给你，而不是直接告诉你为什么，这样你以后遇到问题时也能有解决问题的思路。&lt;/li>
&lt;/ul>
&lt;p>这也是为什么，网络上虽然有很多关于 Java 代码踩坑的资料，但很多同学却和我反馈说，看过之后印象不深刻，也因为没吃透导致在一个知识点上重复踩坑。鉴于此，我还会与你分析我根据多年经验和思考，梳理出的一些最佳实践。&lt;/p>
&lt;p>看到这里，是不是迫不及待地想要看看这个专栏的内容都会涉及哪些坑点了呢？那就看看下面这张思维导图吧：&lt;br>
&lt;img src="https://static001.geekbang.org/resource/image/0e/20/0ee7e3490bae45d6f0ce06a050695020.jpg" alt="">&lt;/p>
&lt;p>鉴于这个专栏的内容和特点，我再和你说说最佳的学习方式是什么。&lt;/p>
&lt;h1 id="学习课程的最佳方法">学习课程的最佳方法&lt;/h1>
&lt;p>我们都知道，编程是一门实践科学，只看不练、不思考，效果通常不会太好。因此，我建议你打开每篇文章后，能够按照下面的方式深入学习：&lt;/p>
&lt;ul>
&lt;li>对于每一个坑点，实际运行调试一下源码，使用文中提到的工具和方法重现问题，眼见为实。&lt;/li>
&lt;li>对于每一个坑点，再思考下除了文内的解决方案和思路外，是否还有其他修正方式。&lt;/li>
&lt;li>对于坑点根因中涉及的 JDK 或框架源码分析，你可以找到相关类再系统阅读一下源码。&lt;/li>
&lt;li>实践课后思考题。这些思考题，有的是对文章内容的补充，有的是额外容易踩的坑。&lt;/li>
&lt;/ul>
&lt;p>理解了课程涉及的所有案例后，你应该就对业务代码大部分容易犯错的点了如指掌了，不仅仅自己可以写出更高质量的业务代码，还可以在审核别人代码时发现可能存在的问题，帮助整个团队成长。&lt;/p>
&lt;p>当然了，你从这个课程收获的将不仅是解决案例中那些问题的方法，还可以提升自己分析定位问题、阅读源码的能力。当你再遇到其他诡异的坑时，也能有清晰的解决思路，也可以成长为一名救火专家，帮助大家一起定位、分析问题。&lt;/p>
&lt;p>好了，以上就是我今天想要和你分享的内容了。请赶快跟随我们的课程开启避坑之旅吧，也欢迎你留言说说自己的情况，你都踩过哪些坑、对写业务代码又有哪些困惑？我们下一讲见！&lt;/p></description></item><item><title>极客专栏: 00丨开篇词丨跟着学，你也能成为Go语言高手</title><link>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/go-%E8%AF%AD%E8%A8%80%E6%A0%B8%E5%BF%83-36-%E8%AE%B2/00%E4%B8%A8%E5%BC%80%E7%AF%87%E8%AF%8D%E4%B8%A8%E8%B7%9F%E7%9D%80%E5%AD%A6%E4%BD%A0%E4%B9%9F%E8%83%BD%E6%88%90%E4%B8%BAgo%E8%AF%AD%E8%A8%80%E9%AB%98%E6%89%8B/</link><pubDate>Sun, 29 May 2022 00:00:00 +0000</pubDate><guid>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/go-%E8%AF%AD%E8%A8%80%E6%A0%B8%E5%BF%83-36-%E8%AE%B2/00%E4%B8%A8%E5%BC%80%E7%AF%87%E8%AF%8D%E4%B8%A8%E8%B7%9F%E7%9D%80%E5%AD%A6%E4%BD%A0%E4%B9%9F%E8%83%BD%E6%88%90%E4%B8%BAgo%E8%AF%AD%E8%A8%80%E9%AB%98%E6%89%8B/</guid><description>
&lt;p>你好，我是郝林。今天想跟你聊聊我和 Go 语言的故事。&lt;/p>
&lt;p>Go 语言是由 Google 出品的一门通用型计算机编程语言。作为在近年来快速崛起的编程语言，Go 已经成功跻身主流编程语言的行列。&lt;/p>
&lt;p>它的种种亮点都受到了广大编程爱好者的追捧。特别是一些对团队协作有较高要求的公司和技术团队，已经在有意识地大量使用 Go 语言编程，并且，使用的人群还在持续迅猛增长。&lt;/p>
&lt;p>我个人很喜欢 Go 语言。我是从 2012 年底开始关注 Go 语言的，虽然这个日期与 Go 语言诞生的 2009 年 11 月 10 日相比并不算早，但我也算得上国内比较早期的使用者了。&lt;/p>
&lt;p>Go 程序可以在装有 Windows、Linux、FreeBSD 等操作系统的服务器上运行，并用于提供基础软件支撑、API 服务、Web 服务、网页服务等等。&lt;/p>
&lt;p>Go 语言也在移动端进行了积极的探索，现在在 Android 和 iOS 上都可以运行其程序。另外，Go 语言也已经与 WebAssembly 强强联合，加入了 WASM 平台。这意味着过不了多久，互联网浏览器也可以运行 Go 编写的程序了。&lt;/p>
&lt;p>从业务维度看，在云计算、微服务、大数据、区块链、物联网等领域，Go 语言早已蓬勃发展。有的使用率已经非常之高，有的已有一席之地。即使是在 Python 为王的数据科学和人工智能领域，Go 语言也在缓慢渗透，并初露头角。&lt;/p>
&lt;p>从公司角度看，许多大厂都已经拥抱 Go 语言，包括以 Java 打天下的阿里巴巴，更别提深爱着 Go 语言的滴滴、今日头条、小米、奇虎 360、京东等明星公司。同时，创业公司也很喜欢 Go 语言，主要因为其入门快、程序库多、运行迅速，很适合快速构建互联网软件产品，比如轻松筹、快手、知乎、探探、美图、猎豹移动等等。&lt;/p>
&lt;p>我从 2013 年开始准备撰写《Go 并发编程实战》这本书，在经历了一些艰辛和坎坷之后，本书终于在 2014 年底由人民邮电出版社的图灵公司正式出版。&lt;/p>
&lt;p>时至今日，《Go 并发编程实战》的第 2 版已经出版一年多了，也受到了广大 Go 语言爱好者的欢迎。同时，我也发起和维护着一个 Go 语言爱好者组织 GoHackers，至今已有近 4000 人的规模。我们每年都会举办一些活动，交流技术、互通有无。当然，我们平常都会在一些线上的群组里交流。欢迎你的加入。&lt;/p>
&lt;p>2015 年初，我开始帮助公司和团队招聘 Go 程序员。我面试过的 Go 程序员应该已经有几百个了。虽然一场面试的交流内容远不止技术能力这种硬技能，更别提只限于一门编程语言。&lt;/p>
&lt;p>但是就事论事，我在这里只说 Go 语言。在所有的应聘者当中，真正掌握 Go 语言基础知识的比例恐怕超不过 50%，而真正熟悉 Go 语言高阶技术的比例也不超过 30%。当然了，情况是明显一年比一年好的，尤其是今年。&lt;/p>
&lt;p>我写此专栏的初衷是，让希望迅速掌握 Go 语言的爱好者们，通过一种比较熟悉和友好的路径去学习。我并不想事无巨细地去阐述 Go 语言规范的每个细节以及其标准库中的每个 API，更不想写那种填鸭式的教学文章，我更想去做的是详细论述这门语言的重点和主线。&lt;/p>
&lt;p>我会努力探究我们对新技能，尤其是编程语言的学习方式，并以这种方式一步步带领和引导你去记忆和实践。我几乎总会以一道简单的题目为引子，并以一连串相关且重要的概念和知识为主线，而后再进行扩充，以助你进行发散性的思考。&lt;/p>
&lt;p>我希望用这种先点、后线、再面的方式，帮你占领一个个重要的阵地。别的不敢说，如果你认真地跟我一起走完这个专栏，那么基本掌握 Go 语言是肯定的。&lt;/p>
&lt;p>为什么说基本掌握？因为软件技术，尤其是编程技术，必须经过很多的实践甚至历练才能完全掌握，这需要时间而不能速成。不过，本专栏一定会成为你学习 Go 语言最重要的敲门砖和垫脚石。&lt;/p>
&lt;p>下面，我们一起浏览一下本专栏的主要模块，一共分成 3 大模块，5 个章节。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>基础概念：我会讲述 Go 语言基础中的基础，包括一些基本概念和运作机制。它们都应该是你初识 Go 语言时必须知道的，同时也有助于你理解后面的知识。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>数据类型和语句：Go 语言中的数据类型大都是很有特色的，你只有理解了它们才能真正玩转 Go 语言。我将和你一起与探索它们的奥妙。另外，我也会一一揭示怎样使用各种语法和语句操纵它们。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Go 程序的测试：很多程序员总以为测试是另一个团队的事情，其实不然。单元测试甚至接口测试其实都应该是程序员去做的，并且应该受到重视。在 Go 语言中怎样做好测试这件事？我会跟你说清楚、讲明白。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>标准库的用法：虽然 Go 语言提供了自己的高效并发编程方式，但是同步方法依然不容忽视。这些方法集中在&lt;code>sync&lt;/code>代码包及其子包中。这部分还涉及了字节和字符问题、OS 操控方法和 Web 服务写法等，这些都是我们在日常工作中很可能会用到的。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Go 语言拾遗：这部分将会讲述一些我们使用 Go 语言做软件项目的过程中很可能会遇到的问题，至少会包含两篇文章，是附赠给广大 Go 语言爱好者的。虽然我已经有一个计划了，但是具体会讲哪些内容我还是选择暂时保密。请你和我一起小期待一下吧。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>我希望本专栏能帮助或推动你去做更多的实践和思考。同时我也希望，你能通过学习本专栏感受到学习的快乐，并能够在应聘 Go 语言相关岗位的时候更加游刃有余。&lt;/p>
&lt;p>所以，如果学，请深学。我不敢自称布道师，但很愿意去做推广优秀技术的事情。如果我的输出能为你的宝塔添砖加瓦，那将会是我的快乐之源。我也相信这几十篇文章可以做到这一点。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/35/48/358e4e8578a706598e18a7dfed3ed648.jpg" alt="">&lt;/p></description></item><item><title>极客专栏: 00丨预习篇丨写给0基础入门的Go语言学习者</title><link>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/go-%E8%AF%AD%E8%A8%80%E6%A0%B8%E5%BF%83-36-%E8%AE%B2/00%E4%B8%A8%E9%A2%84%E4%B9%A0%E7%AF%87%E4%B8%A8%E5%86%99%E7%BB%990%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E7%9A%84go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E8%80%85/</link><pubDate>Sun, 29 May 2022 00:00:00 +0000</pubDate><guid>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/go-%E8%AF%AD%E8%A8%80%E6%A0%B8%E5%BF%83-36-%E8%AE%B2/00%E4%B8%A8%E9%A2%84%E4%B9%A0%E7%AF%87%E4%B8%A8%E5%86%99%E7%BB%990%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E7%9A%84go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E8%80%85/</guid><description>
&lt;p>你好，我是郝林，今天我分享的内容是：0 基础的你，如何开始入门学习 Go 语言。&lt;/p>
&lt;ol>
&lt;li>你需要遵循怎样的学习路径来学习 Go 语言？&lt;/li>
&lt;/ol>
&lt;hr>
&lt;p>我们发现，订阅本专栏的同学们都在非常积极的学习和讨论，这让我们非常欣慰，并且和你一样干劲十足。不过，我在留言中发现，大家的基础好像都不太一样，大致可以分为这么几类。&lt;/p>
&lt;ul>
&lt;li>零基础的同学：可能正准备入行或者刚刚对编程感兴趣，可以熟练操作电脑，但是对计算机、操作系统以及网络方面的知识不太了解。&lt;/li>
&lt;li>无编程经验或者编程经验较少的同学：可能正在从事其他的技术相关工作，也许可以熟练编写脚本，但是对程序设计的通用知识和技巧还不太了解。&lt;/li>
&lt;li>有其他语言编程经验的同学：可能已成为程序员或软件工程师，可以用其他的编程语言熟练编写程序，但是对 Go 语言还不太了解。&lt;/li>
&lt;li>有一定 Go 语言编程经验的同学：已有 Go 语言编程基础，写过一些 Go 语言程序，但是急需进阶却看不清途径。&lt;/li>
&lt;/ul>
&lt;p>基于以上分类，我为大家制定了一份 Go 语言学习路径。不论你属于上面的哪一类，都可以按照此路径去学习深造。具体请看下面的思维导图。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/c7/b7/c702df29da67be3c4083ecce1d0eadb7.png" alt="">&lt;/p>
&lt;p>（长按保存大图）&lt;/p>
&lt;ol start="2">
&lt;li>学习本专栏前，你需要有哪些基础知识储备？&lt;/li>
&lt;/ol>
&lt;hr>
&lt;p>在这个专栏里，我会假设你有一定的计算机基础，比如，知道操作系统是什么、环境变量怎么设置、命令行怎样使用，等等。&lt;/p>
&lt;p>另外，我还会假定你具备一点点编程知识，比如，知道程序是什么、程序通常会以怎样的形式存在，以及程序与操作系统和计算机有哪些关系，等等。&lt;/p>
&lt;p>对了，还有在这个早已成熟的移动互联网时代，想学编程的你，一定也应该知道那些最最基本的网络知识。&lt;/p>
&lt;p>我在本专栏里只会讨论 Go 语言的代码和程序，而不会提及太多计算机体系结构或软件工程方面的事情。所以你即使没有专门学过计算机系统或者软件工程也没有关系，我会尽量连带讲一些必要的基础概念和知识。&lt;/p>
&lt;p>从 2018 年开始，随着 Google 逐渐重回中国，Go 语言的官方网站在 Google 中国的域名下也有了镜像，毕竟中国是 Go 语言爱好者最多的国家，同时也是 Go 语言使用最广泛的一片土地。如果你在国内，可以敲入&lt;a href="https://golang.google.cn">这个网址&lt;/a>来访问 Go 语言的官网。&lt;/p>
&lt;p>这个专栏专注于 Go 语言的核心知识，因此我并不会深入说明所有关于语法和命令的细枝末节。如果你想去全面了解 Go 语言的所有语法，那么可以去 Go 语言官网的&lt;a href="https://golang.google.cn/ref/spec">语言规范页面&lt;/a>仔细查阅。&lt;/p>
&lt;p>当然了，这里的语言规范是全英文的，如果你想看汉化的内容也是有选择的，我记得先后有几拨国内的 Go 语言爱好者自发组织翻译过。不过我都没有仔细看过，不知道质量如何，所以在这里就不特别推荐了。&lt;/p>
&lt;p>对于从事计算机和软件开发相关工作的同学，我强烈建议你们要有意地训练快速阅读英文文档的能力，不论是否借助字典和翻译工具。&lt;/p>
&lt;p>不过，如果你想专门学习一下 Go 命令方面的知识和技巧，那么我推荐你看看我之前写的免费开源教程《&lt;a href="https://github.com/hyper0x/go_command_tutorial">Go 命令教程&lt;/a>》。这份教程的内容虽然稍显陈旧，但是帮助你学会使用 Go 语言自带的常用命令和工具肯定是没问题的。&lt;/p>
&lt;p>好了，其实即使你是个编程小白也不用过于担心，我们会一起帮助你的。至于我刚刚说的 Go 语言规范和 Go 命令教程，你也可以在学习本专栏的过程中根据实际需要去有针对性的阅读。&lt;/p>
&lt;ol start="3">
&lt;li>这里有一份基础知识列表，请查收&lt;/li>
&lt;/ol>
&lt;hr>
&lt;p>如果你阅读本专栏的第一个模块时感觉有些吃力，那可能是你还没有熟悉 Go 语言的一些基础概念和知识。我为你精心制作了一张 Go 语言基础知识的导图，里面几乎包含了入门 Go 语言所需的所有知识点。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/ad/85/add8566dc5431378bda313a32a6ebb85.jpg" alt="">&lt;br>
（长按保存大图）&lt;/p>
&lt;p>有了这些，你是否已经感觉学习本专栏会更加轻松了呢？&lt;/p>
&lt;p>总之，教程、资料和助推就交给我和极客时间的编辑、运营们来共同负责。而你需要做的，就是保存好这一份对 Go 语言学习的决心，你可以自己去尝试整理一份 Go 语言的学习笔记，遇见不懂的地方，你也可以在文章下面留言，我们一起讨论。&lt;/p>
&lt;p>好了，感谢你的收听，我们下期再见。&lt;/p>
&lt;p>&lt;a href="https://github.com/hyper0x/Golang_Puzzlers">戳此查看 Go 语言专栏文章配套详细代码。&lt;/a>&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/35/48/358e4e8578a706598e18a7dfed3ed648.jpg" alt="">&lt;/p></description></item><item><title>极客专栏: 学习攻略如何才能学好并发编程？</title><link>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/%E5%AD%A6%E4%B9%A0%E6%94%BB%E7%95%A5%E5%A6%82%E4%BD%95%E6%89%8D%E8%83%BD%E5%AD%A6%E5%A5%BD%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</link><pubDate>Sun, 29 May 2022 00:00:00 +0000</pubDate><guid>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/%E5%AD%A6%E4%B9%A0%E6%94%BB%E7%95%A5%E5%A6%82%E4%BD%95%E6%89%8D%E8%83%BD%E5%AD%A6%E5%A5%BD%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</guid><description>
&lt;p>并发编程并不是一门相对独立的学科，而是一个综合学科。并发编程相关的概念和技术看上非常零散，相关度也很低，总给你一种这样的感觉：我已经学习很多相关技术了，可还是搞不定并发编程。那如何才能学习好并发编程呢？&lt;/p>
&lt;p>其实很简单，只要你能从两个方面突破一下就可以了。一个是&amp;quot;跳出来，看全景&amp;quot;，另一个是&amp;quot;钻进去，看本质&amp;quot;。&lt;/p>
&lt;h2 id="跳出来看全景">跳出来，看全景&lt;/h2>
&lt;p>我们先说&amp;quot;跳出来&amp;quot;。你应该也知道，学习最忌讳的就是&amp;quot;盲人摸象&amp;quot;，只看到局部，而没有看到全局。所以，你需要从一个个单一的知识和技术中&amp;quot;跳出来&amp;quot;，高屋建瓴地看并发编程。当然，这&lt;strong>首要之事就是你建立起一张全景图&lt;/strong>。&lt;/p>
&lt;p>不过，并发编程相关的知识和技术还真是错综复杂，时至今日也还没有一张普遍认可的全景图，也许这正是很多人在并发编程方面难以突破的原因吧。好在经过多年摸爬滚打，我自己已经&amp;quot;勾勒&amp;quot;出了一张全景图，不一定科学，但是在某种程度上我想它还是可以指导你学好并发编程的。&lt;/p>
&lt;p>在我看来，并发编程领域可以抽象成&lt;strong>三个核心问题：分工、同步和互斥&lt;/strong>。&lt;/p>
&lt;h3 id="1-分工">1. 分工&lt;/h3>
&lt;p>所谓分工，类似于现实中一个组织完成一个项目，项目经理要拆分任务，安排合适的成员去完成。&lt;/p>
&lt;p>在并发编程领域，你就是项目经理，线程就是项目组成员。任务分解和分工对于项目成败非常关键，不过在并发领域里，分工更重要，它直接决定了并发程序的性能。在现实世界里，分工是很复杂的，著名数学家华罗庚曾用&amp;quot;烧水泡茶&amp;quot;的例子通俗地讲解了统筹方法（一种安排工作进程的数学方法），&amp;ldquo;烧水泡茶&amp;quot;这么简单的事情都这么多说道，更何况是并发编程里的工程问题呢。&lt;/p>
&lt;p>既然分工很重要又很复杂，那一定有前辈努力尝试解决过，并且也一定有成果。的确，在并发编程领域这方面的成果还是很丰硕的。Java SDK 并发包里的 Executor、Fork/Join、Future 本质上都是一种分工方法。除此之外，并发编程领域还总结了一些设计模式，基本上都是和分工方法相关的，例如生产者 - 消费者、Thread-Per-Message、Worker Thread 模式等都是用来指导你如何分工的。&lt;/p>
&lt;p>学习这部分内容，最佳的方式就是和现实世界做对比。例如生产者 - 消费者模式，可以类比一下餐馆里的大厨和服务员，大厨就是生产者，负责做菜，做完放到出菜口，而服务员就是消费者，把做好的菜给你端过来。不过，我们经常会发现，出菜口有时候一下子出了好几个菜，服务员是可以把这一批菜同时端给你的。其实这就是生产者 - 消费者模式的一个优点，生产者一个一个地生产数据，而消费者可以批处理，这样就提高了性能。&lt;/p>
&lt;h3 id="2-同步">2. 同步&lt;/h3>
&lt;p>分好工之后，就是具体执行了。在项目执行过程中，任务之间是有依赖的，一个任务结束后，依赖它的后续任务就可以开工了，后续工作怎么知道可以开工了呢？这个就是靠沟通协作了，这是一项很重要的工作。&lt;/p>
&lt;p>在并发编程领域里的同步，主要指的就是线程间的协作，本质上和现实生活中的协作没区别，不过是&lt;strong>一个线程执行完了一个任务，如何通知执行后续任务的线程开工&lt;/strong>而已。&lt;/p>
&lt;p>协作一般是和分工相关的。Java SDK 并发包里的 Executor、Fork/Join、Future 本质上都是分工方法，但同时也能解决线程协作的问题。例如，用 Future 可以发起一个异步调用，当主线程通过 get() 方法取结果时，主线程就会等待，当异步执行的结果返回时，get() 方法就自动返回了。主线程和异步线程之间的协作，Future 工具类已经帮我们解决了。除此之外，Java SDK 里提供的 CountDownLatch、CyclicBarrier、Phaser、Exchanger 也都是用来解决线程协作问题的。&lt;/p>
&lt;p>不过还有很多场景，是需要你自己来处理线程之间的协作的。&lt;/p>
&lt;p>工作中遇到的线程协作问题，基本上都可以描述为这样的一个问题：&lt;strong>当某个条件不满足时，线程需要等待，当某个条件满足时，线程需要被唤醒执行&lt;/strong>。例如，在生产者 - 消费者模型里，也有类似的描述，&amp;ldquo;当队列满时，生产者线程等待，当队列不满时，生产者线程需要被唤醒执行；当队列空时，消费者线程等待，当队列不空时，消费者线程需要被唤醒执行。&amp;rdquo;&lt;/p>
&lt;p>在 Java 并发编程领域，解决协作问题的核心技术是&lt;strong>管程&lt;/strong> ，上面提到的所有线程协作技术底层都是利用管程解决的。管程是一种解决并发问题的通用模型，除了能解决线程协作问题，还能解决下面我们将要介绍的互斥问题。可以这么说，&lt;strong>管程是解决并发问题的万能钥匙&lt;/strong>。&lt;/p>
&lt;p>所以说，这部分内容的学习，关键是理解管程模型，学好它就可以解决所有问题。其次是了解 Java SDK 并发包提供的几个线程协作的工具类的应用场景，用好它们可以妥妥地提高你的工作效率。&lt;/p>
&lt;h3 id="3-互斥">3. 互斥&lt;/h3>
&lt;p>分工、同步主要强调的是性能，但并发程序里还有一部分是关于正确性的，用专业术语叫&amp;rdquo;&lt;strong>线程安全&lt;/strong>&amp;quot;。并发程序里，当多个线程同时访问同一个共享变量的时候，结果是不确定的。不确定，则意味着可能正确，也可能错误，事先是不知道的。而导致不确定的主要源头是可见性问题、有序性问题和原子性问题，为了解决这三个问题，Java 语言引入了内存模型，内存模型提供了一系列的规则，利用这些规则，我们可以避免可见性问题、有序性问题，但是还不足以完全解决线程安全问题。解决线程安全问题的核心方案还是互斥。&lt;/p>
&lt;p>&lt;strong>所谓互斥，指的是同一时刻，只允许一个线程访问共享变量。&lt;/strong>&lt;/p>
&lt;p>实现互斥的核心技术就是锁，Java 语言里 synchronized、SDK 里的各种 Lock 都能解决互斥问题。虽说锁解决了安全性问题，但同时也带来了性能问题，那如何保证安全性的同时又尽量提高性能呢？可以分场景优化，Java SDK 里提供的 ReadWriteLock、StampedLock 就可以优化读多写少场景下锁的性能。还可以使用无锁的数据结构，例如 Java SDK 里提供的原子类都是基于无锁技术实现的。&lt;/p>
&lt;p>除此之外，还有一些其他的方案，原理是不共享变量或者变量只允许读。这方面，Java 提供了 Thread Local 和 final 关键字，还有一种 Copy-on-write 的模式。&lt;/p>
&lt;p>使用锁除了要注意性能问题外，还需要注意死锁问题。&lt;/p>
&lt;p>这部分内容比较复杂，往往还是跨领域的，例如要理解可见性，就需要了解一些 CPU 和缓存的知识；要理解原子性，就需要理解一些操作系统的知识；很多无锁算法的实现往往也需要理解 CPU 缓存。这部分内容的学习，需要博览群书，在大脑里建立起 CPU、内存、I/O 执行的模拟器。这样遇到问题就能得心应手了。&lt;/p>
&lt;p>跳出来，看全景，可以让你的知识成体系，所学知识也融汇贯通起来，由点成线，由线及面，画出自己的知识全景图。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/11/65/11e0c64618c04edba52619f41aaa3565.png" alt="">
并发编程全景图之思维导图&lt;/p>
&lt;h2 id="钻进去看本质">钻进去，看本质&lt;/h2>
&lt;p>但是光跳出来还不够，还需要下一步，就是在某个问题上钻进去，深入理解，找到本质。&lt;/p>
&lt;p>就拿我个人来说，我已经烦透了去讲述或被讲述一堆概念和结论，而不分析这些概念和结论是怎么来的，以及它们是用来解决什么问题的。在大学里，这样的教材很流行，直接导致了芸芸学子成绩很高，但解决问题的能力很差。其实，知其然知其所以然，才算真的学明白了。&lt;/p>
&lt;p>我属于理论派，&lt;strong>我认为工程上的解决方案，一定要有理论做基础&lt;/strong>。所以在学习并发编程的过程中，我都会探索它背后的理论是什么。比如，当看到 Java SDK 里面的条件变量 Condition 的时候，我会下意识地问，&amp;ldquo;它是从哪儿来的？是 Java 的特有概念，还是一个通用的编程概念？&amp;ldquo;当我知道它来自管程的时候，我又会问，&amp;ldquo;管程被提出的背景和解决的问题是什么？&amp;ldquo;这样一路探索下来，我发现 Java 语言里的并发技术基本都是有理论基础的，并且这些理论在其他编程语言里也有类似的实现。所以我认为，技术的本质是背后的理论模型。&lt;/p>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>当初我学习 Java 并发编程的时候，试图上来就看 Java SDK 的并发包，但是很快就放弃了。原因是我觉得东西太多，眼花缭乱的，虽然借助网络上的技术文章，感觉都看懂了，但是很快就又忘了。实际应用的时候大脑也一片空白，根本不知道从哪里下手，有时候好不容易解决了个问题，也不知道这个方案是不是合适的。&lt;/p>
&lt;p>我知道根本原因是，我的并发知识还没有成体系。&lt;/p>
&lt;p>我想，要让自己的知识成体系，一定要挖掘 Java SDK 并发包背后的设计理念。Java SDK 并发包是并发大师 Doug Lea 设计的，他一定不是随意设计的，一定是深思熟虑的，其背后是 Doug Lea 对并发问题的深刻认识。可惜这个设计的思想目前并没有相关的论文，所以只能自己琢磨了。&lt;/p>
&lt;p>分工、同步和互斥的全景图，是我对并发问题的个人总结，不一定正确，但是可以帮助我快速建立解决并发问题的思路，梳理并发编程的知识，加深认识。我将其分享给你，希望对你也有用。&lt;/p>
&lt;p>对于某个具体的技术，我建议你探索它背后的理论本质，理论的应用面更宽，一项优秀的理论往往在多个语言中都有体现，在多个不同领域都有应用。所以探求理论本质，既能加深对技术本身的理解，也能拓展知识深度和广度，这是个一举多得的方法。这方面，希望我们一起探讨，共同进步。&lt;/p>
&lt;p>欢迎在留言区跟我分享你的经历与想法。感谢阅读，如果你觉得这篇文章对你有帮助的话，也欢迎把它分享给更多的朋友。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/cf/aa/cf393cd748a4f0e6451807c4b61843aa.jpg" alt="">&lt;/p></description></item><item><title>极客专栏: 00丨开篇词丨别老想着怎么用好RPC框架，你得多花时间琢磨原理</title><link>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/rpc%E5%AE%9E%E6%88%98%E4%B8%8E%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/00%E4%B8%A8%E5%BC%80%E7%AF%87%E8%AF%8D%E4%B8%A8%E5%88%AB%E8%80%81%E6%83%B3%E7%9D%80%E6%80%8E%E4%B9%88%E7%94%A8%E5%A5%BDrpc%E6%A1%86%E6%9E%B6%E4%BD%A0%E5%BE%97%E5%A4%9A%E8%8A%B1%E6%97%B6%E9%97%B4%E7%90%A2%E7%A3%A8%E5%8E%9F%E7%90%86/</link><pubDate>Sat, 28 May 2022 00:00:00 +0000</pubDate><guid>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/rpc%E5%AE%9E%E6%88%98%E4%B8%8E%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/00%E4%B8%A8%E5%BC%80%E7%AF%87%E8%AF%8D%E4%B8%A8%E5%88%AB%E8%80%81%E6%83%B3%E7%9D%80%E6%80%8E%E4%B9%88%E7%94%A8%E5%A5%BDrpc%E6%A1%86%E6%9E%B6%E4%BD%A0%E5%BE%97%E5%A4%9A%E8%8A%B1%E6%97%B6%E9%97%B4%E7%90%A2%E7%A3%A8%E5%8E%9F%E7%90%86/</guid><description>
&lt;p>你好，我是何小锋。欢迎你和我一起学习 RPC。&lt;/p>
&lt;p>在专栏开始之前，我先简单介绍下自己。我是 1998 年从北航毕业的，毕业以后我就一直在一线编程写代码。2011 年，我正式加入京东，刚好赶上了京东的快速发展期，一路做到了现在的技术架构部首席架构师。盘点下在京东的这 9 年时间，我参加过 17 次大促备战，和我的技术团队一起见证了京东的技术演进过程。我也曾带领团队攻克过很多技术领域难题，包括自主研发微服务框架、高性能消息中间件、智能监控以及容器平台等等。&lt;/p>
&lt;p>近几年，我主攻分布式系统架构与设计，这也是我的专长所在。而在搭建分布式系统的过程中，我发现 RPC 总能充当较为关键的角色，它对整个分布式系统性能的提升起到了非常重要的作用。&lt;/p>
&lt;p>我期待通过这个专栏，能把我这些年积攒的一些有关 RPC 的实战经验分享给你。&lt;/p>
&lt;h1 id="为什么要学习-rpc">为什么要学习 RPC？&lt;/h1>
&lt;p>做任何事情都应该 Start with Why，那我们就先来说说为什么要学习 RPC。要回答这个问题，我们就得先考虑下 RPC 的实际应用场景。&lt;/p>
&lt;p>说到 RPC，可能你的第一反应就是&amp;quot;微服务&amp;quot;。RPC 最大的特点就是可以让我们像调用本地一样发起远程调用，这一特点常常会让人感觉 RPC 就是为&amp;quot;微服务&amp;quot;或 SOA 而生的。现在的大多数应用系统发展到一定规模之后，都会向&amp;quot;微服务化&amp;quot;演进，演进后的大型应用系统也的确是由一个个&amp;quot;微服务&amp;quot;组成的。&lt;/p>
&lt;p>我们可以说 RPC 是&amp;quot;微服务&amp;quot;的基础，这一点是毋庸置疑的。现在我们就可以反过来想这样一个问题&amp;mdash;&amp;mdash;RPC 是不是只应用在&amp;quot;微服务&amp;quot;中呢？&lt;/p>
&lt;p>**当然不是，只要涉及到网络通信，我们就可能用到 RPC。**一起看这样两个例子。&lt;/p>
&lt;p>例 1：大型分布式应用系统可能会依赖消息队列、分布式缓存、分布式数据库以及统一配置中心等，应用程序与依赖的这些中间件之间都可以通过 RPC 进行通信。比如 etcd，它作为一个统一的配置服务，客户端就是通过 gRPC 框架与服务端进行通信的。&lt;/p>
&lt;p>例 2：我们经常会谈到的容器编排引擎 Kubernetes，它本身就是分布式的，Kubernetes 的 kube-apiserver 与整个分布式集群中的每个组件间的通讯，都是通过 gRPC 框架进行的。&lt;/p>
&lt;p>所以说，RPC 的应用场景还是非常广泛的。既然应用如此广泛，那它的核心价值又在哪里呢？&lt;/p>
&lt;p>&lt;strong>在我看来，RPC 是解决分布式系统通信问题的一大利器。&lt;/strong>&lt;/p>
&lt;p>分布式系统中的网络通信一般都会采用四层的 TCP 协议或七层的 HTTP 协议，在我的了解中，前者占大多数，这主要得益于 TCP 协议的稳定性和高效性。网络通信说起来简单，但实际上是一个非常复杂的过程，这个过程主要包括：对端节点的查找、网络连接的建立、传输数据的编码解码以及网络连接的管理等等，每一项都很复杂。&lt;/p>
&lt;p>你可以想象一下，在搭建一个复杂的分布式系统过程中，如果开发人员在编码时要对每个涉及到网络通信的逻辑都进行一系列的复杂编码，这将是件多么恐怖的事儿。所以说，网络通信是搭建分布式系统的一个大难题，是一点不为过的，我们必须给予足够的重视。&lt;/p>
&lt;p>而 RPC 对网络通信的整个过程做了完整包装，在搭建分布式系统时，它会使网络通信逻辑的开发变得更加简单，同时也会让网络通信变得更加安全可靠。&lt;/p>
&lt;p>现在你是不是感觉到学好 RPC 是很有必要的？&lt;/p>
&lt;h1 id="如何学习-rpc">如何学习 RPC？&lt;/h1>
&lt;p>那我们应该怎么去学习 RPC 呢？&lt;/p>
&lt;p>其实，深刻了解了为什么之后，怎么学这个问题并不难找到答案。就我自己的经验来看，我觉得可以用&amp;quot;&lt;strong>逐步深入&lt;/strong>&amp;ldquo;这四个字来概括我的学习方式。&lt;/p>
&lt;p>说起来也特别简单。当我们认识到，使用 RPC 就可以像调用本地一样发起远程调用，用它可以解决通信问题，这时候我们肯定要去学序列化、编解码以及网络传输这些内容。&lt;/p>
&lt;p>把这些内容掌握后，你就会发现，原来这些只是 RPC 的基础，RPC 还有更吸引人的点，它真正强大的地方是它的治理功能，比如连接管理、健康检测、负载均衡、优雅启停机、异常重试、业务分组以及熔断限流等等。突然间，你会感觉自己走进了一个新世界，这些内容会成为你今后学习 RPC 的重点和难点。&lt;/p>
&lt;p>这个逐步深入的过程，一定离不开真实的实践场景。学习知识，解决问题，遇到新问题，继续学习，不断解决问题，最后你会发现自己的学习曲线大概是这样的。&lt;br>
&lt;img src="https://static001.geekbang.org/resource/image/74/8c/74539ca9da65ee0461ddb9299c277f8c.jpeg" alt="">&lt;/p>
&lt;p>总结一下，学习 RPC 时，我们先要了解其基本原理以及关键的网络通信部分，不要一味依赖现成的框架；之后我们再学习 RPC 的重点和难点，了解 RPC 框架中的治理功能以及集群管理功能等；这个时候你已经很厉害了，但这还不是终点，我们要对 RPC 活学活用，学会提升 RPC 的性能以及它在分布式环境下如何定位问题等等。&lt;/p>
&lt;h1 id="整个专栏能让你学到什么">整个专栏能让你学到什么？&lt;/h1>
&lt;p>上面提到的这些内容，就是我想通过这个专栏和你分享的。下面我来讲下本专栏的设计思路。&lt;/p>
&lt;p>我把整个专栏的内容分为了三大部分，分别是基础篇、进阶篇和高级篇。&lt;/p>
&lt;p>**基础篇：**重点讲解 RPC 的基础知识，包括 RPC 的基本原理以及它的基本功能模块，夯实基础之后，我们会以一场实战，通过剖析一款 RPC 框架来将知识点串联起来。&lt;/p>
&lt;p>**进阶篇：**重点讲解 RPC 框架的架构设计，以及 RPC 框架集群、治理相关的知识。这部分我会列举很多我在运营 RPC 框架中遇到的实际问题，以及这些问题的解决方案。&lt;/p>
&lt;p>**高级篇：**通过对上述两部分的学习，你已经对 RPC 有了较高层次的理解了。在这部分，我主要会从性能优化、线上问题排查以及一些比较有特色的功能设计上讲解 RPC 的应用。&lt;br>
&lt;img src="https://static001.geekbang.org/resource/image/d1/bf/d15af80828fc3a9da2fea7a1aa232dbf.jpg" alt="">&lt;/p>
&lt;p>整个专栏跟下来，虽然主要讲解的都是 RPC 相关的知识，但你会接触到很多的案例和解决方案，它们首先会使你对 RPC 的理解到达一个较高的层次；其次就是这些知识和解决方案会有相通性，只要你能举一反三，对你今后的工作就会有很大的帮助。&lt;/p>
&lt;p>最后，我也很想听听你的想法。我们可以在留言区认识一下，期待你和我讲讲你的工作经历，你对 RPC 的认识，以及学习它的痛点、难点，我也好有针对性地为你讲解。现在，就让我们共同开启这段学习之旅吧！&lt;/p></description></item><item><title>极客专栏: 00丨开篇词丨这一次，我们从“丑”代码出发</title><link>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E4%BB%A3%E7%A0%81%E4%B9%8B%E4%B8%91/00%E4%B8%A8%E5%BC%80%E7%AF%87%E8%AF%8D%E4%B8%A8%E8%BF%99%E4%B8%80%E6%AC%A1%E6%88%91%E4%BB%AC%E4%BB%8E%E4%B8%91%E4%BB%A3%E7%A0%81%E5%87%BA%E5%8F%91/</link><pubDate>Sat, 28 May 2022 00:00:00 +0000</pubDate><guid>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E4%BB%A3%E7%A0%81%E4%B9%8B%E4%B8%91/00%E4%B8%A8%E5%BC%80%E7%AF%87%E8%AF%8D%E4%B8%A8%E8%BF%99%E4%B8%80%E6%AC%A1%E6%88%91%E4%BB%AC%E4%BB%8E%E4%B8%91%E4%BB%A3%E7%A0%81%E5%87%BA%E5%8F%91/</guid><description>
&lt;p>你好，我是郑晔！我又回来了！&lt;/p>
&lt;p>我在&amp;quot;极客时间&amp;quot;里已经写了两个专栏，分别是《10x 程序员工作法》和《软件设计之美》，从工作原则和设计原则两个方面对软件开发的各种知识进行了探讨，帮助你搭建了一个开启程序员精进之路的框架。&lt;/p>
&lt;p>不过，无论懂得多少道理，程序员依然要回归到写代码的本职工作上。所以，这次我准备和你从代码的坏味道出发，一起探讨如何写代码。&lt;/p>
&lt;h1 id="千里之堤毁于蚁穴">千里之堤毁于蚁穴&lt;/h1>
&lt;p>为什么要讲这个话题，就让我们先从一次代码评审讲起。在一次代码评审中，我注意到了这样一段代码：&lt;/p>
&lt;pre tabindex="0">&lt;code>public void approve(final long bookId) {
...
book.setReviewStatus(ReviewStatus.APPROVED);
...
}
&lt;/code>&lt;/pre>&lt;p>这是在一个服务类里面写的，它的主要逻辑就是从仓库中找出一个作品，然后，将它的状态设置为审核通过，再将它存回去。前后的代码都属于常规的代码，但是，设置作品评审状态的代码引起了我的注意，于是有了下面这段对话。&lt;/p>
&lt;blockquote>
&lt;p>我：这个地方为什么要这么写？
同事：我要将作品的审核状态设置为审核通过。
我：这个我知道，但为什么要在这里写 setter 呢？
同事：你的意思是？
我：这个审核的状态是作品的一个内部状态，为什么服务需要知道它呢？也就是说，这里通过 setter，将一个类的内部行为暴露了出来，这是一种破坏封装的做法。&lt;/p>
&lt;/blockquote>
&lt;p>同事被我说动了，于是这段代码变成了下面这个样子：&lt;/p>
&lt;pre tabindex="0">&lt;code>public void approve(final long bookId) {
...
book.approve();
...
}
&lt;/code>&lt;/pre>&lt;p>之所以我注意到这段代码，完全是因为这里用到了 setter。在我看来，setter 就是一个坏味道，每次一看到 setter，我就会警觉起来。&lt;/p>
&lt;p>setter 的出现，是对于封装的破坏，它把一个类内部的实现细节暴露了出来。我在《软件设计之美》中讲过，面向对象的封装，关键点是行为，而使用 setter 多半只是做了数据的聚合，缺少了行为的设计，这段代码改写后的 approve 函数，就是这里缺少的行为。&lt;/p>
&lt;p>再扩展一步，setter 通常还意味着变化，而我在《软件设计之美》中讲函数式编程时也说过，一个好的设计应该尽可能追求不变性。所以，setter 也是一个提示符，告诉我们，这个地方的设计可能有问题。&lt;/p>
&lt;p>你看，一个小小的 setter，背后却隐藏着这么多的问题。而所有这些问题，都会让代码在未来的日子变得更加不可维护，这就是软件团队陷入泥潭的开始。&lt;/p>
&lt;p>我也一直和我团队的同学说，&amp;ldquo;写代码&amp;quot;有两个维度：正确性和可维护性，不要只关注正确性。能把代码写对，是每个程序员的必备技能，&lt;strong>但能够把代码写得更具可维护性，这是一个程序员从业余迈向职业的第一步&lt;/strong>。&lt;/p>
&lt;h1 id="将坏味道重构为整洁代码">将坏味道重构为整洁代码&lt;/h1>
&lt;p>或许你也认同代码要有可维护性，也看了很多书，比如《程序设计实践》《代码整洁之道》等等，这些无一不是经典中的经典，甚至连怎么改代码，都有《重构》等着我们。没错，这些书我都读过，也觉得从中受益匪浅。&lt;/p>
&lt;p>不过，回到真实的工作中，我发现了一个无情的事实：&lt;strong>程序员们大多会认同这些书上的观点，但每个人对于这些观点的理解却是千差万别的。&lt;/strong>&lt;/p>
&lt;p>比如书上说：&amp;ldquo;命名是要有意义的&amp;rdquo;，但什么样的命名才算是有意义的呢？有的人只理解到不用 xyz 命名，虽然他起出了自认为&amp;quot;有意义&amp;quot;的名字，但这些名字依然是难以理解的。事实上，大部分程序员在真实世界中面对的代码，就是这样难懂的代码。&lt;/p>
&lt;p>这是因为，&lt;strong>很多人虽然知道正面的代码是什么样子，却不知道反面的代码是什么样子&lt;/strong>。这些反面代码，Martin Fowler 在《重构》这本书中给起了一个好名字，代码的坏味道（Bad Smell）。&lt;/p>
&lt;p>在我写代码的这 20 多年里，一直对代码的坏味道非常看重，因为它是写出好代码的起点。有对代码坏味道的嗅觉，能够识别出坏味道，接下来，你才有机会去&amp;quot;重构（Refactoring）&amp;quot;，把代码一点点打磨成一个整洁的代码（Clean Code）。Linux 内核开发者 Linus Torvalds 在行业里有个爱骂人的坏名声，原因之一就是他对于坏味道的不容忍。&lt;/p>
&lt;p>所以，我也推荐那些想要提高自己编程水平的人读《重构》，如果时间比较少，就去读第三章&amp;quot;代码的坏味道&amp;rdquo;。&lt;/p>
&lt;p>不过，《重构》中的&amp;quot;代码的坏味道&amp;quot;意图虽好，但却需要一个人对于整洁代码有着深厚的理解，才能识别出这些坏味道。否则，即使你知道有哪些坏味道，但真正有坏味道的代码出现在你面前时，你仍然无法认得它。&lt;/p>
&lt;p>比如，你可以看看 Info、Data、Manager 是不是代码库经常使用的词汇，而它们往往是命名没有经过仔细思考的地方。在很多人眼中，这些代码是没有问题的。正因如此，才有很多坏味道的代码才堂而皇之地留在你的眼皮底下。&lt;/p>
&lt;p>所以，我才想做一个讲坏味道的专栏，把最常见的坏味道直接用代码形式展现出来。在这个专栏里，我给你的都是即学即用的&amp;quot;坏味道&amp;quot;，我不仅会告诉你典型的坏味道是什么，而且也能让你在实际的编程过程中发现它们。比如前面那个例子里面的 setter，只要它一出现，你就需要立即警觉起来。&lt;/p>
&lt;p>这里我也整理了一份&amp;quot;坏味道自查表&amp;quot;，把一些明显的&amp;quot;坏味道&amp;quot;信号列了出来，你可以和自己的代码做对比。&lt;br>
&lt;img src="https://static001.geekbang.org/resource/image/2e/f1/2e543283f04aa3706d60a7b1e0f257f1.jpg" alt="">&lt;/p>
&lt;p>除了为你列出来哪些代码有坏味道之外，我还会给你讲支撑这些&amp;quot;坏味道&amp;quot;之所以为&amp;quot;坏味道&amp;quot;的原因，比如说：长方法和大类之所以为坏味道，因为它们都违背了单一职责的原则。&lt;/p>
&lt;p>有坏味道的代码需要经过重构才能长成新的样子，在这个专栏里，我也会提到一些重构的手法，比如，改名（Rename）、提取方法（Extract Method）等等。在今天，拜许多能力强大的 IDE 所赐，重构已经变得越来越自动化，《重构》里的很多手法已经成为了 IDE 中的一个选项。&lt;/p>
&lt;p>我还想给你一个安全提示，即便 IDE 功能再强大，也不要忘了重构的重要根基：测试。即便像 Java 这样，IDE 功能已经非常强大了，依然会有一些像反射之类的场景可能会从自动化重构的鼻子底下溜走。所以，重构一段代码之前，最好能够给它写下测试，确保改动前后的代码，功能上是一致的。&lt;/p>
&lt;p>如果你订阅过我的《10x 程序员工作法》和《软件设计之美》，你就会发现，三个专栏一脉相承，这些背后的道理恰恰就是我在那两个专栏中已经提到过的内容。所以，三个专栏一并服用，效果会更佳。&lt;/p>
&lt;h1 id="写在最后">写在最后&lt;/h1>
&lt;p>最后，还是要做一个自我介绍。我叫郑晔，一个写代码超过二十年的程序员，做过与软件开发的各种工作：编代码、带团队、做咨询、写开源。正如前面所说，我已经在极客时间平台上写了两个专栏，分享我在软件开发中的各种思考。这次，我会带你进入到我的基本功里，帮你一起写好代码。&lt;/p>
&lt;p>十年前，我在 InfoQ 写过一个专栏《代码之丑》，把一些真实世界的代码展示了出来，让大家看到丑陋代码是什么样子的。&lt;/p>
&lt;p>不少读者都表示，那个专栏让他们受益匪浅。不过，那个系列只是我日常工作的随手之作，没有更好地整理。这个专栏就是脱胎于 InfoQ 上的《代码之丑》，我对相关内容进行了更系统地整理，保证即便看过那个《代码之丑》专栏，你依然能够在这里有所收获。&lt;/p>
&lt;p>这是一条通往代码精进之路，我愿意与你一起前行，成为你在这条路上的向导。如果你想摆脱平庸的小白程序员状态，成为一个更优秀的程序员，那么，请加入我的专栏，让我们一起修炼，日益精进写代码的手艺！&lt;/p></description></item><item><title>极客专栏: 00丨开篇词丨从今天起，跨过“数据结构与算法”这道坎</title><link>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/00%E4%B8%A8%E5%BC%80%E7%AF%87%E8%AF%8D%E4%B8%A8%E4%BB%8E%E4%BB%8A%E5%A4%A9%E8%B5%B7%E8%B7%A8%E8%BF%87%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%BF%99%E9%81%93%E5%9D%8E/</link><pubDate>Fri, 27 May 2022 00:00:00 +0000</pubDate><guid>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/00%E4%B8%A8%E5%BC%80%E7%AF%87%E8%AF%8D%E4%B8%A8%E4%BB%8E%E4%BB%8A%E5%A4%A9%E8%B5%B7%E8%B7%A8%E8%BF%87%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%BF%99%E9%81%93%E5%9D%8E/</guid><description>
&lt;p>你好，我是王争，毕业于西安交通大学计算机专业。现在回想起来，本科毕业的时候，我的编程水平其实是很差的。直到读研究生的时候，一个师兄给了我一本《算法导论》，说你可以看看，对你的编程会很有帮助。&lt;/p>
&lt;p>没想到，从此我对算法的&amp;quot;迷恋&amp;quot;便一发不可收拾。之后，我如饥似渴地把图书馆里几乎所有数据结构和算法书籍都读了一遍。&lt;/p>
&lt;p>我常常边读边练。没多久，我就发现，写代码的时候，我会不由自主考虑很多性能方面的问题。我写出时间复杂度高、空间复杂度高的垃圾代码越来越少了，算法能力提升了很多，编程能力也有了质的飞跃。得益于此，研究生毕业后，我直接进入 Google，从事 Google 翻译相关的开发工作。&lt;/p>
&lt;p>这是我自己学习数据结构与算法的经历，现在，你可以想想你的情况。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>是不是从学校开始，你就觉得数据结构难学，然后一直没认真学？&lt;/p>
&lt;/li>
&lt;li>
&lt;p>工作中，一遇到数据结构这个坑，你又发自本能地迅速避让，因为你觉得自己不懂，所以也不想深究，反正看起来无关大局？&lt;/p>
&lt;/li>
&lt;li>
&lt;p>当你想换工作面试，或者研究某个开源项目源码，亦或者和团队讨论某个非框架层面的高可用难题的时候，你又发现，自己的基础跟不上别人的节奏？&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>如果你是这种情况，其实你并不孤独，这不是你一个人遇到的问题。工作十年间，我见过许多程序员。他们有着各种各样的背景，有很多既有潜力又非常努力，但始终无法在自己现有水平上更进一步。&lt;/p>
&lt;p>在技术圈里，我们经常喜欢谈论高大上的架构，比如高可用、微服务、服务治理等等。鲜有人关注代码层面的编程能力，而愿意沉下心来，花几个月时间啃一啃计算机基础知识、认认真真夯实基础的人，简直就是凤毛麟角。&lt;/p>
&lt;p>我认识一位原来腾讯 T4 的技术大牛。在区块链大潮之前，他在腾讯工作了 10 多年，长期负责手机 QQ 后台整体建设。他经历了手机 QQ 从诞生到亿级用户在线的整个过程。后来他去了微众银行，有一天老板让他去做区块链。&lt;strong>他用了不到半年时间，就把区块链的整个技术脉络摸清楚了。&lt;/strong> 现在，他是微众银行的区块链负责人，微众科技创新产品部的老总。你说厉害不？你可以花半年时间就能精通一个新的领域吗？为什么他就可以做到？&lt;/p>
&lt;p>我觉得这其中最重要的就是基础足够扎实。他曾经跟我说，像区块链、人工智能这些看似很新的技术，其实一点儿都不&amp;quot;新&amp;quot;。最初学编程的时候，他就把那些基础的知识都学透了。当面临行业变动、新技术更迭的时候，他不断发现，那些所谓的新技术，核心和本质的东西其实就是当初学的那些知识。掌握了这个&amp;quot;规律&amp;quot;之后，他学任何东西都很快，任何新技术都能快速迎头赶上。这就是他快速学习并且获得成功的秘诀。&lt;/p>
&lt;p>所以说，&lt;strong>基础知识就像是一座大楼的地基，它决定了我们的技术高度。而要想快速做出点事情，前提条件一定是基础能力过硬，&amp;ldquo;内功&amp;quot;要到位&lt;/strong>。&lt;/p>
&lt;p>那技术人究竟都需要修炼哪些&amp;quot;内功&amp;quot;呢？我觉得，无外乎就是大学里的那些基础课程，操作系统、计算机网络、编译原理等等，当然还有数据结构和算法。&lt;/p>
&lt;p>可是，我们都知道，像《算法导论》这些经典书籍，虽然很全面，但是过于理论，学起来非常枯燥；而市面很多课程大多缺失真实的开发场景，费劲学完感觉好像还是用不上，过不了几天就忘了。&lt;/p>
&lt;p>所以，我尝试做一个让你能真正受用的数据结构与算法课程，希望给你指明一个简洁、高效的学习路径，教你一个学习基础知识的通用方法 。那么，关于专栏内容，我是怎样设计的呢？&lt;/p>
&lt;ol>
&lt;li>
&lt;p>我根据自己研读数十本算法书籍和多年项目开发的经验，在众多的数据结构和算法中，精选了最实用的内容进行讲解。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>我不只会教你怎么用，还会告诉你，我们为什么需要这种数据结构和算法，一点点帮你捋清它们背后的设计思想，培养你举一反三的能力。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>对于每种数据结构和算法，我都会结合真实的软件开发案例来讲解，让你知道，数据结构和算法，究竟应该如何应用到实际的编码中。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>为了&lt;strong>由浅入深&lt;/strong> 地带你学习，我把专栏分成四个&lt;strong>递进&lt;/strong>的模块。&lt;/p>
&lt;ol>
&lt;li>&lt;strong>入门篇&lt;/strong>&lt;/li>
&lt;/ol>
&lt;p>时间、空间复杂度分析是数据结构和算法中非常重要的知识点，贯穿整个专栏的学习过程。但同时也是比较难掌握的，所以我用了 2 节课来讲这部分内容，而且还举了大量的实例，让你一边学一边练，真正能掌握复杂度分析，为后面的学习铺路。&lt;/p>
&lt;p>我希望通过这一模块，你能掌握时间、空间复杂度的概念，大 O 表示法的由来，各种复杂度分析技巧，以及最好、最坏、平均、均摊复杂度分析方法。之后，面对任何代码的复杂度分析，你都能游刃有余、毫不畏惧！&lt;/p>
&lt;ol start="2">
&lt;li>&lt;strong>基础篇&lt;/strong>&lt;/li>
&lt;/ol>
&lt;p>这部分是专栏中篇幅最大的内容，也是我们学习的重点，共有 26 节内容，涵盖了最基础、最常用的数据结构和算法。针对每种数据结构和算法，我都会结合具体的软件开发实例，由浅入深进行讲解，并适时总结一些实用&amp;quot;宝典&amp;rdquo;，保证你印象深刻、学有所用。&lt;/p>
&lt;p>比如递归这一节，我会讲到，为什么递归代码比较难写？如何避免堆栈溢出？如何避免递归冗余计算？如何将递归代码转化为非递归代码？&lt;/p>
&lt;ol start="3">
&lt;li>&lt;strong>高级篇&lt;/strong>&lt;/li>
&lt;/ol>
&lt;p>这部分我会讲一些不是那么常用的数据结构和算法。虽然不常用，但是这些内容你也需要知道。设置这一部分的目的，是为了让你开拓视野，强化训练算法思维、逻辑思维。如果说学完基础部分可以考 80 分，那掌握这一部分就能让你成为尖子生！&lt;/p>
&lt;ol start="4">
&lt;li>&lt;strong>实战篇&lt;/strong>&lt;/li>
&lt;/ol>
&lt;p>我们整个专栏都是围绕数据结构和算法在具体软件实践中的应用来讲的，所以最后我会通过实战部分串讲一下前面讲到的数据结构和算法。我会拿一些开源项目、框架或者系统设计问题，剖析它们背后的数据结构和算法，让你有一个更加直观的感受。&lt;/p>
&lt;p>人生路上，我们会遇到很多的坎。跨过去，你就可以成长，跨不过去就是困难和停滞。而在后面很长的一段时间里，你都需要为这个困难买单。对于我们技术人来说，更是这样。&lt;strong>既然数据结构和算法这个坎，我们总归是要跨过去，为什么不是现在呢？&lt;/strong>&lt;/p>
&lt;p>我很感激师兄当年给我的那本《算法导论》，这是我人生中为数不多的转折点之一。没有那本书，也可能就没有今天的我。我希望这个专栏也能成为你的一个人生转折点。&lt;/p>
&lt;p>我希望，通过这个专栏，不仅能帮你跨过数据结构与算法这个坎，还能帮你掌握一种学习知识和技能的方法，帮你度过职场甚至人生的重要时刻！一起加油吧！&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/8e/d3/8e603e3d795fc0ab2698f6f5eabf14d3.jpg" alt="">&lt;/p></description></item><item><title>极客专栏: 00丨开篇词丨洞悉技术的本质，享受科技的乐趣</title><link>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E/00%E4%B8%A8%E5%BC%80%E7%AF%87%E8%AF%8D%E4%B8%A8%E6%B4%9E%E6%82%89%E6%8A%80%E6%9C%AF%E7%9A%84%E6%9C%AC%E8%B4%A8%E4%BA%AB%E5%8F%97%E7%A7%91%E6%8A%80%E7%9A%84%E4%B9%90%E8%B6%A3/</link><pubDate>Fri, 27 May 2022 00:00:00 +0000</pubDate><guid>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E/00%E4%B8%A8%E5%BC%80%E7%AF%87%E8%AF%8D%E4%B8%A8%E6%B4%9E%E6%82%89%E6%8A%80%E6%9C%AF%E7%9A%84%E6%9C%AC%E8%B4%A8%E4%BA%AB%E5%8F%97%E7%A7%91%E6%8A%80%E7%9A%84%E4%B9%90%E8%B6%A3/</guid><description>
&lt;p>你好，我是陈皓，网名左耳朵耗子。我目前在创业，MegaEase 是我的公司，致力于为企业提供高可用、高并发、高性能的分布式技术产品，同时也提供物联网（IoT）方向的技术产品。&lt;/p>
&lt;p>我之前在阿里巴巴、亚马逊、汤森路透等公司任职，职业背景是金融和电子商务行业，主要研究的技术方向是一些大规模分布式系统的基础架构。&lt;/p>
&lt;p>从大学毕业一直做技术工作，到今天有 20 年了，还在写代码，因为我对技术有很大的热情。我从 2002 年开始写技术博客，到 2009 年左右开始在独立的域名 &lt;a href="http://CoolShell.cn">CoolShell.cn&lt;/a>（酷壳）上分享我对技术的一些见解和心得。&lt;/p>
&lt;p>本来只想记录一下，没想到得到了很多人的认可，这对我来说是一个不小的鼓励。我的文章和分享始终坚持观点鲜明的特点，因为我希望可以引发大家的讨论和批评，这样分享才更有意义。&lt;/p>
&lt;p>无论我的观点是否偏激、不成熟，或者言辞犀利，在经历过大家的批评和讨论后，我都能够从中得到不在我视角内的思考和认知，这对我来说是非常重要的补充，对我的个人成长非常重要。&lt;/p>
&lt;p>我相信，看到这些文章和讨论的人，也能从中收获到更多的东西。&lt;/p>
&lt;p>坦率地讲，刚收到专栏撰写邀请的时候，我心里面是拒绝的。正如前面所说的，我分享的目的是跟大家交流和讨论，我认为，全年付费专栏这样的方式可能并不好。而且，付费专栏还有文章更新频率的 KPI，这对于像我这样一定要有想法才会写文章的人来说是很痛苦的，因为我不想为了写而写。&lt;/p>
&lt;p>所以，最初，我是非常不情愿的。&lt;/p>
&lt;p>极客邦科技的编辑跟我沟通过很多次，也问过我是否在做一些收费的咨询或是培训，并表明这个专栏就是面对这样的场景的。我想想也是。我其实从 2003 年就开始为很多企业做内部的培训和分享了。&lt;/p>
&lt;p>这些培训涵盖了很多方面，如软件团队管理、架构技术、编程语言、操作系统等，以及一些为企业量身定制的咨询或软件开发，这些都是收费的。&lt;/p>
&lt;p>而我一直以来也没有把这些内容分享在我的博客里，主要原因是我觉得这些内容是有商业价值的，是适合收费的。它们都是实实在在的，是我多年来对实战经验的深入总结和思考，非常来之不易。&lt;/p>
&lt;p>我不太舍得拿出来大范围地分享，以前基本上仅小范围地在企业内部比较封闭的环境里讲讲。所以说，我这边其实是有两种分享，一种是企业内的分享，一种则是像 CoolShell 或是大会这样的公开分享。&lt;/p>
&lt;p>前者更企业化一些，后者更通俗化一些。&lt;/p>
&lt;p>在这个付费专栏中，除了继续保持观点鲜明的行文风格，我会分享一些与个人或企业切身利益更为相关的内容，或者说更具指导性、更有商业价值的东西。而 CoolShell，我还会保持现有的风格继续写下去。&lt;/p>
&lt;p>正如这个专栏的 Slogan 所说：&amp;ldquo;洞悉技术的本质，享受科技的乐趣&amp;rdquo;，我会在这个专栏里分享包括但不限于如下这些内容。&lt;/p>
&lt;h1 id="技术">技术&lt;/h1>
&lt;p>对于技术方面，我不会写太多关于知识点的东西，因为这些知识点你可以自行 Google 可以 RTFM。我要写的一定是以体系化的，而且要能直达技术的本质。入行这 20 年来，我最擅长的就是架构和开发各种大规模的系统，所以，我会有 2-3 个和分布式系统相关的系列文章。&lt;/p>
&lt;p>我学过也用过好多编程语言，所以，也会有一系列的关于编程本质的文章。而我对一些基础知识研究得也比较多，所以，还会有一系列与基础知识相关的文章。&lt;/p>
&lt;p>当然，其中还会穿插一些其它的技术文章，比如一些热点事件，还有一些经验之谈，包括我会把我的《程序员技术练级攻略》在这个专栏里重新再写一遍。这些东西一定会让你有醍醐灌顶的感觉。&lt;/p>
&lt;h1 id="成长">成长&lt;/h1>
&lt;p>在过去这 20 年中，我感觉到，很多人都非常在意自己的成长。所以，我会分享一堆我亲身经历的，也是我自己实验的与个人发展相关的文章。&lt;/p>
&lt;p>比如，如何利用技术变现、如何面试、如何选择新的技术、如何学习、如何管理自己的时间、如何管理自己的老板和工作、如何成为一个 Leader&amp;hellip;&amp;hellip;这些东西一定会对你有用。（但是，我这里一定不会有速成的东西。一切都是要花时间和精力的。如果你想要速成，你不应该来订阅我的专栏。）&lt;/p>
&lt;h1 id="管理">管理&lt;/h1>
&lt;p>这 20 年，我觉得做好技术工作的前提是，得做好技术的管理工作。只有管理好了软件工程和技术团队，技术才能发挥出最大的潜力。大多数的技术问题都是管理上的问题。&lt;/p>
&lt;p>所以，我会写上一系列的和管理相关的文章，涵盖管理三个要素：团队、项目和管理者自己。比如，人员招聘、绩效考核、提升士气、解决冲突、面对变化、沟通说服、项目管理、任务排期、会议、远程管理，等等。&lt;/p>
&lt;p>这些内容都是我在外企工作时，接受到的世界顶级管理培训机构培训内容，我会把我的实践写出来分享给你。这其中一定少不了亚马逊相关的各种实践。这些东西，我和很多公司和大佬都讲过，到目前为止还没有人不赞的。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/7f/7b/7f428c8dd8f26668a727bd46227ec17b.jpg" alt="">&lt;/p>
&lt;p>为了对付费用户负责，保证文章能够达到收费的质量，我承诺这个专栏的每一篇文章一定是用心创作的，而且是可以让你从中受益的。&lt;/p>
&lt;p>但因为是第一次做全年专栏，收费也让我有一定的压力，所以，我非常希望你能够跟我分享你的感受和体会。&lt;/p>
&lt;p>我会根据你的反馈及时做出调整和修正，并不断努力提高文章的质量和思想高度，以满足你对有价值、有营养的文章的需求。&lt;/p></description></item><item><title>极客专栏: 00丨开篇词丨这一次，让我们一起来搞懂MySQL</title><link>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/mysql-%E5%AE%9E%E6%88%98-45-%E8%AE%B2/00%E4%B8%A8%E5%BC%80%E7%AF%87%E8%AF%8D%E4%B8%A8%E8%BF%99%E4%B8%80%E6%AC%A1%E8%AE%A9%E6%88%91%E4%BB%AC%E4%B8%80%E8%B5%B7%E6%9D%A5%E6%90%9E%E6%87%82mysql/</link><pubDate>Fri, 27 May 2022 00:00:00 +0000</pubDate><guid>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/mysql-%E5%AE%9E%E6%88%98-45-%E8%AE%B2/00%E4%B8%A8%E5%BC%80%E7%AF%87%E8%AF%8D%E4%B8%A8%E8%BF%99%E4%B8%80%E6%AC%A1%E8%AE%A9%E6%88%91%E4%BB%AC%E4%B8%80%E8%B5%B7%E6%9D%A5%E6%90%9E%E6%87%82mysql/</guid><description>
&lt;p>你好，我是林晓斌，网名&amp;quot;丁奇&amp;quot;，欢迎加入我的专栏，和我一起开始 MySQL 学习之旅。我曾先后在百度和阿里任职，从事 MySQL 数据库方面的工作，一步步地从一个数据库小白成为 MySQL 内核开发人员。回想起来，从我第一次带着疑问翻 MySQL 的源码查到答案至今，已经有十个年头了。在这个过程中，走了不少弯路，但同时也收获了很多的知识和思考，希望能在这个专栏里分享给你。&lt;/p>
&lt;p>记得刚开始接触 MySQL，是我在百度贴吧做权限系统的时候。我们遇到了一个奇怪的问题，一个正常 10 毫秒就能完成的 SQL 查询请求偶尔要执行 100 多毫秒才结束。当时主管问我是什么原因，我其实也搞不清楚，就上网查答案，但怎么找都找不到，又脸皮薄不想说自己不知道，只好硬着头皮翻源码。后来遇到了越来越多的问题，也是类似的情景，所以我逐步养成了通过分析源码理解原理的习惯。&lt;/p>
&lt;p>当时，我自己的感觉是，即使我只是一个开发工程师，只是 MySQL 的用户，在了解了一个个系统模块的原理后，再来使用它，感觉是完全不一样的。当在代码里写下一行数据库命令的时候，我就能想到它在数据库端将怎么执行，它的性能是怎么样的，怎样写能让我的应用程序访问数据库的性能最高。进一步，哪些数据处理让数据库系统来做性能会更好，哪些数据处理在缓存里做性能会更好，我心里也会更清楚。在建表和建索引的时候，我也会更有意识地为将来的查询优化做综合考虑，比如确定是否使用递增主键、主键的列怎样选择，等等。&lt;/p>
&lt;p>但随后我又有了一个新的困惑，我觉得自己了解的 MySQL 知识点是零散的，没有形成网络。于是解决完一个问题后，很容易忘记。再碰到类似的问题，我又得再翻一次代码。&lt;/p>
&lt;p>所幸在阿里工作的时候，我参与了阿里云关系型数据库服务内核的开发，并且负责开发开源分支 AliSQL，让我对 MySQL 内核和源码有了更深层次的研究和理解。在服务内部客户和公有云客户的过程中，我有机会面对和解决足够多的问题，再通过手册进行系统的学习，算是比较坎坷地将 MySQL 的知识网络补了起来。&lt;/p>
&lt;p>所以，在回顾这个过程的时候，我的第一个感受是，如果一开始就有一些从理论到实战的系统性指导，那该多好啊，也许我可以学习得更快些。&lt;/p>
&lt;p>在极客时间团队跟我联系策划这个专栏的时候，我还是持怀疑态度的。为什么呢？现在不比当年了，犹记得十余年前，你使用 MySQL 的过程中碰到问题的话，基本上都只能到代码里去找答案，因为那时网上的资料太少了。&lt;/p>
&lt;p>而近十年来，MySQL 在中国广泛普及，技术分享文章可以说是浩如烟海。所以，现在要系统地介绍一遍 MySQL 的话，恐怕里面提及的大多数知识点，都可以在社区文章中找到。那么我们做这个专栏的意义在哪里，而它又凭什么可以收费呢？&lt;/p>
&lt;p>直到收到极客时间团队的答复，我才开始对这个专栏&amp;quot;想做和可以做&amp;quot;的事情感觉清晰起来。数据库是一个综合系统，其背后是发展了几十年的数据库理论。同时，数据库系统也是一个应用系统，可能一个业务开发人员用了两三年 MySQL，还未必清楚那些自己一直在用的&amp;quot;最佳实践&amp;quot;为什么是最佳的。&lt;/p>
&lt;p>于是，我希望这个专栏能够帮助这样的一些开发者：他们正在使用 MySQL，知道如何写出逻辑正确的 SQL 语句来实现业务目标，却不确定这个语句是不是最优的；他们听说了一些使用数据库的最佳实践，但是更想了解为什么这么做；他们使用的数据库偶尔会出问题，亟需了解如何更快速、更准确地定位问题，甚至自己解决问题&amp;hellip;&amp;hellip;&lt;/p>
&lt;p>在过去的七年里，我带过十几个应届毕业生，看着他们成长，要求他们原理先行，再实践验证。几年下来，他们的成长速度都很快，其中好几个毕业没两年就成为团队的骨干力量了。我也在社招的时候面试过很多有着不错的运维实践经验和能力的候选人，但都因为对数据库原理仅有一知半解的了解，而最终遗憾地没有通过面试。&lt;/p>
&lt;p>因此，我希望这个专栏能够激发开发者对数据库原理的探索欲，从而更好地理解工作中遇到的问题，更能知道背后的为什么。所以&lt;strong>我会选那些平时使用数据库时高频出现的知识，如事务、索引、锁等内容构成专栏的主线&lt;/strong>。这些主线上是一个个的知识点。每个点就是一个概念、一个机制或者一个原理说明。在每个说明之后，我会和你讨论一个实践相关的问题。&lt;/p>
&lt;p>希望能以这样的方式，让你对 MySQL 的几条主线有一个整体的认识，并且了解基本概念。在之后的实践篇中，我会引用到这些主线的知识背景，并着力说明它们是怎样指导实践的。这样，&lt;strong>你可以从点到线，再到面，形成自己的 MySQL 知识网络。&lt;/strong>&lt;/p>
&lt;p>在这里，有一份目录，你也可以先了解下整个专栏的知识结构。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/a7/7e/a78db0b99bbf1149c39b7960f7183c7e.jpg" alt="">&lt;/p>
&lt;p>如前面说的，这几条主线上的每个知识点几乎都不是最新的，有些甚至十年前就这样，并没有改过。但我希望针对这些点的说明，可以让你在使用 MySQL 时心里更有底，知道怎么做选择，并且明白为什么。了解了原理，才能在实践中不断创新，提升个人的价值和工作输出。&lt;/p>
&lt;p>从这里开始，跟我一起搞懂 MySQL!&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/ce/d9/ce7f4e35916ed1aa49206a53a0547bd9.jpg" alt="">&lt;/p></description></item><item><title>极客专栏: 01 _ 认识容器：容器的基本操作和实现原理</title><link>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E5%AE%B9%E5%99%A8%E9%AB%98%E6%89%8B%E5%AE%9E%E6%88%98%E8%AF%BE/01%E4%B8%A8%E8%AE%A4%E8%AF%86%E5%AE%B9%E5%99%A8%E5%AE%B9%E5%99%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E5%92%8C%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</link><pubDate>Fri, 08 Jul 2022 00:00:00 +0000</pubDate><guid>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E5%AE%B9%E5%99%A8%E9%AB%98%E6%89%8B%E5%AE%9E%E6%88%98%E8%AF%BE/01%E4%B8%A8%E8%AE%A4%E8%AF%86%E5%AE%B9%E5%99%A8%E5%AE%B9%E5%99%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E5%92%8C%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</guid><description>
&lt;p>你好，我是程远。作为一名工程师，我猜在过去的几年时间里，你肯定用过或者听人提起过容器（Container）。&lt;/p>
&lt;p>说实话，容器这东西一点都不复杂，如果你只是想用的话，那跟着Docker 官网的说明，应该十来分钟就能搞定。&lt;/p>
&lt;p>简单来说，它就是个小工具，可以把你想跑的程序，库文件啊，配置文件都一起&amp;quot;打包&amp;quot;。&lt;/p>
&lt;p>然后，我们在任何一个计算机的节点上，都可以使用这个打好的包。有了容器，一个命令就能把你想跑的程序跑起来，做到了&lt;strong>一次打包，就可以到处使用。&lt;/strong>&lt;/p>
&lt;p>今天是咱们整个课程的第一讲，我想和你来聊聊容器背后的实现机制。&lt;/p>
&lt;p>当然，空讲原理也没什么感觉，所以我还是会先带着你启动一个容器玩玩，然后咱们再一起来探讨容器里面的两大关键技术&amp;mdash;&amp;mdash; Namespace 和 Cgroups。基本上理解了这两个概念，你就能彻底搞懂容器的核心原理了。&lt;/p>
&lt;h1 id="做个镜像">做个镜像&lt;/h1>
&lt;p>话不多说，咱们就先动手玩一玩。启动容器的工具有很多，在这里我们还是使用 Docker 这个最常用的容器管理工具。&lt;/p>
&lt;p>如果你之前根本没用过 Docker 的话，那我建议你先去官网看看文档，一些基础的介绍我就不讲了，那些内容你随便在网上一搜就能找到。&lt;/p>
&lt;p>安装完 Docker 之后，咱们先来用下面的命令运行一个 httpd 服务。&lt;/p>
&lt;pre tabindex="0">&lt;code># docker run -d centos/httpd:latest
&lt;/code>&lt;/pre>&lt;p>这命令也很简单，run 的意思就是要启动一个容器， -d 参数里 d 是 Daemon 的首字母，也就是让容器在后台运行。&lt;/p>
&lt;p>最后一个参数 centos/httpd:latest 指定了具体要启动哪一个镜像，比如这里咱们启动的是 centos/httpd 这个镜像的 latest 版本。&lt;/p>
&lt;p>镜像是 Docker 公司的创举，也是一个伟大的发明。你想想，在没有容器之前，你想安装 httpd 的话，会怎么做？是不是得运行一连串的命令？甚至不同的系统上操作方法也不一样？&lt;/p>
&lt;p>但你看，有了容器之后，你只要运行一条命令就搞定了。其实所有的玄机都在这个镜像里面。&lt;/p>
&lt;p>镜像这么神奇，那它到底是怎么一回事呢？其实，镜像就是一个特殊的文件系统，&lt;/p>
&lt;p>**它提供了容器中程序执行需要的所有文件。**具体来说，就是应用程序想启动，需要三类文件：相关的程序可执行文件、库文件和配置文件，这三类文件都被容器打包做好了。&lt;/p>
&lt;p>这样，在容器运行的时候就不再依赖宿主机上的文件操作系统类型和配置了，做到了想在哪个节点上运行，就可以在哪个节点上立刻运行。&lt;/p>
&lt;p>那么我们怎么来做一个容器镜像呢？&lt;/p>
&lt;p>刚才的例子里，我们用的 centos/httpd:latest 这个镜像是 &lt;strong>Docker 镜像库&lt;/strong>里直接提供的。当然，我们也可以自己做一个提供 httpd 服务的容器镜像，这里仍然可以用 Docker 这个工具来自定义镜像。&lt;/p>
&lt;p>Docker 为用户自己定义镜像提供了一个叫做 Dockerfile 的文件，在这个 Dockerfile 文件里，你可以设定自己镜像的创建步骤。&lt;/p>
&lt;p>如果我们自己来做一个 httpd 的镜像也不难，举个例子，我们可以一起来写一个 Dockerfile，体会一下整个过程。用 Dockerfile build image 的 Dockerfile 和对应的目录我放在这里了。&lt;/p>
&lt;p>操作之前，我们首先要理解这个 Dockerfile 做了什么，其实它很简单，只有下面这 5 行：&lt;/p>
&lt;pre tabindex="0">&lt;code># cat Dockerfile
FROM centos:8.1.1911
RUN yum install -y httpd
COPY file1 /var/www/html/
ADD file2.tar.gz /var/www/html/
CMD [&amp;#34;/sbin/httpd&amp;#34;, &amp;#34;-D&amp;#34;, &amp;#34;FOREGROUND&amp;#34;]
&lt;/code>&lt;/pre>&lt;p>我们看下它做了哪几件事：在一个 centos 的基准镜像上安装好 httpd 的包，然后在 httpd 提供文件服务的配置目录下，把需要对外提供的文件 file1 和 file2 拷贝过去，最后指定容器启动以后，需要自动启动的 httpd 服务。&lt;/p>
&lt;p>有了这个镜像，我们希望容器启动后，就运行这个 httpd 服务，让用户可以下载 file1 还有 file2 这两个文件。&lt;/p>
&lt;p>我们具体来看这个 Dockerfile 的每一行，第一个大写的词都是 Dockerfile 专门定义的指令，也就是 FROM、RUN、COPY、ADD、CMD，这些指令都很基础，所以我们不做详细解释了，你可以参考 Dockerfile 的官方文档。&lt;/p>
&lt;p>我们写完这个 Dockerfile 之后，想要让它变成一个镜像，还需要执行一下 docker build 命令。&lt;/p>
&lt;p>下面这个命令中 -f ./Dockerfile 指定 Dockerfile 文件，-t registry/httpd:v1 指定了生成出来的镜像名，它的格式是&amp;quot;name:tag&amp;quot;，这个镜像名也是后面启动容器需要用到的。&lt;/p>
&lt;pre tabindex="0">&lt;code># docker build -t registry/httpd:v1 -f ./Dockerfile .
&lt;/code>&lt;/pre>&lt;p>docker build 执行成功之后，我们再运行 docker images 这个命令，就可以看到生成的镜像了。&lt;/p>
&lt;pre tabindex="0">&lt;code># docker images
REPOSITORY TAG IMAGEID CREATED SIZE
registry/httpd v1 c682fc3d4b9a 4 seconds ago 277MB
&lt;/code>&lt;/pre>&lt;h1 id="启动一个容器-container">启动一个容器 (Container)&lt;/h1>
&lt;p>做完一个镜像之后，你就可以用这个镜像来启动一个容器了，我们刚才做的镜像名字是 registry/httpd:v1，那么还是用 docker run 这个命令来启动容器。&lt;/p>
&lt;pre tabindex="0">&lt;code># docker run -d registry/httpd:v1
&lt;/code>&lt;/pre>&lt;p>容器启动完成后，我们可以用 docker ps 命令来查看这个已经启动的容器：&lt;/p>
&lt;pre tabindex="0">&lt;code># docker ps
CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES
c5a9ff78d9c1 registry/httpd:v1 &amp;#34;/sbin/httpd -D FORE…&amp;#34; 2 seconds ago Up 2 seconds loving_jackson
&lt;/code>&lt;/pre>&lt;p>在前面介绍 Dockerfile 的时候，我们说过做这个镜像是用来提供 HTTP 服务的，也就是让用户可以下载 file1、file2 这两个文件。&lt;/p>
&lt;p>那怎样来验证我们建起来的容器是不是正常工作的呢？可以通过这两步来验证：&lt;/p>
&lt;ul>
&lt;li>第一步，我们可以进入容器的运行空间，查看 httpd 服务是不是启动了，配置文件是不是正确的。&lt;/li>
&lt;li>第二步，对于 HTTP 文件服务，如果我们能用 curl 命令下载文件，就可以证明这个容器提供了我们预期的 httpd 服务。&lt;/li>
&lt;/ul>
&lt;p>我们先来做第一步验证，我们可以运行 docker exec 这个命令进入容器的运行空间，至于什么是容器的运行空间，它的标准说法是容器的命名空间（Namespace），这个概念我们等会儿再做介绍。&lt;/p>
&lt;p>进入容器运行空间之后，我们怎么确认 httpd 的服务进程已经在容器里启动了呢？&lt;/p>
&lt;p>我们运行下面这个 docker exec 命令，也就是执行 docker exec c5a9ff78d9c1 ps -ef ，可以看到 httpd 的服务进程正在容器的空间中运行。&lt;/p>
&lt;pre tabindex="0">&lt;code># docker exec c5a9ff78d9c1 ps -ef
UID PID PPID C STIME TTY TIME CMD
root 1 0 0 01:59 ? 00:00:00 /sbin/httpd -D FOREGROUND
apache 6 1 0 01:59 ? 00:00:00 /sbin/httpd -D FOREGROUND
apache 7 1 0 01:59 ? 00:00:00 /sbin/httpd -D FOREGROUND
apache 8 1 0 01:59 ? 00:00:00 /sbin/httpd -D FOREGROUND
apache 9 1 0 01:59 ? 00:00:00 /sbin/httpd -D FOREGROUND
&lt;/code>&lt;/pre>&lt;p>这里我解释一下，在这个 docker exec 后面紧跟着的 ID 表示容器的 ID，这个 ID 就是我们之前运行 docker ps 查看过那个容器，容器的 ID 值是 c5a9ff78d9c1 。在这个 ID 值的后面，就是我们要在容器空间里运行的 ps -ef 命令。&lt;/p>
&lt;p>接下来我们再来确认一下，httpd 提供文件服务的目录中 file1 和 file2 文件是否存在。&lt;/p>
&lt;p>我们同样可以用 docker exec 来查看一下容器的文件系统中，httpd 提供文件服务的目录 /var/www/html 是否有这两个文件。&lt;/p>
&lt;p>很好，我们可以看到 file1、file2 这两个文件也都放在指定目录中了。&lt;/p>
&lt;pre tabindex="0">&lt;code># docker exec c5a9ff78d9c1 ls /var/www/html
file1
file2
&lt;/code>&lt;/pre>&lt;p>到这里我们完成了第一步的验证，进入到容器的运行空间里，验证了 httpd 服务已经启动，配置文件也是正确的。&lt;/p>
&lt;p>那下面我们要做第二步的验证，用 curl 命令来验证是否可以从容器的 httpd 服务里下载到文件。&lt;/p>
&lt;p>如果要访问 httpd 服务，我们就需要知道这个容器的 IP 地址。容器的网络空间也是独立的，有一个它自己的 IP。我们还是可以用 docker exec 进入到容器的网络空间，查看一下这个容器的 IP。&lt;/p>
&lt;p>运行下面的这条 docker exec c5a9ff78d9c1 ip addr 命令，我们可以看到容器里网络接口 eth0 上配置的 IP 是 172.17.0.2 。&lt;/p>
&lt;p>这个 IP 目前只能在容器的宿主机上访问，在别的机器上目前是不能访问的。关于容器网络的知识，我们会在后面的课程里介绍。&lt;/p>
&lt;pre tabindex="0">&lt;code># docker exec c5a9ff78d9c1 ip addr
1: lo: &amp;lt;LOOPBACK,UP,LOWER_UP&amp;gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
inet 127.0.0.1/8 scope host lo
valid_lft forever preferred_lft forever
168: eth0@if169: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu 1500 qdisc noqueue state UP group default
link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid 0
inet 172.17.0.2/16 brd 172.17.255.255 scope global eth0
valid_lft forever preferred_lft forever
&lt;/code>&lt;/pre>&lt;p>好了，获取了 httpd 服务的 IP 地址之后，我们随便下载一个文件试试，比如选 file2。&lt;/p>
&lt;p>我们在宿主机上运行 curl ，就可以下载这个文件了，操作如下。很好，文件下载成功了，这证明了我们这个提供 httpd 服务的容器正常运行了。&lt;/p>
&lt;pre tabindex="0">&lt;code># curl -L -O http://172.17.0.2/file2
% Total % Received % Xferd Average Speed Time Time Time Current
Dload Upload Total Spent Left Speed
100 6 100 6 0 0 1500 0 --:--:-- --:--:-- --:--:-- 1500
# ls
file2
&lt;/code>&lt;/pre>&lt;p>上面的步骤完成之后，我们的第二步验证，用 curl 下载 httpd 服务提供的文件也成功了。&lt;/p>
&lt;p>好了，我们刚才自己做了容器镜像，用这个镜像启动了容器，并且用 docker exec 命令检查了容器运行空间里的进程、文件和网络设置。&lt;/p>
&lt;p>通过这上面的这些操作练习，估计你已经初步感知到，容器的文件系统是独立的，运行的进程环境是独立的，网络的设置也是独立的。但是它们和宿主机上的文件系统，进程环境以及网络感觉都已经分开了。&lt;/p>
&lt;p>我想和你说，这个感觉没错，的确是这样。我们刚才启动的容器，已经从宿主机环境里被分隔出来了，就像下面这张图里的描述一样。&lt;br>
&lt;img src="https://static001.geekbang.org/resource/image/4b/3a/4b67ff2f9070afbc2d0966464a67b83a.jpeg" alt="">&lt;/p>
&lt;p>从用户使用的角度来看，容器和一台独立的机器或者虚拟机没有什么太大的区别，但是它和虚拟机相比，却没有各种复杂的硬件虚拟层，没有独立的 Linux 内核。&lt;/p>
&lt;p>容器所有的进程调度，内存访问，文件的读写都直接跑在宿主机的内核之上，这是怎么做到的呢？&lt;/p>
&lt;h1 id="容器是什么">容器是什么&lt;/h1>
&lt;p>要回答这个问题，你可以先记住这两个术语 &lt;strong>Namespace 和 Cgroups&lt;/strong>。如果有人问你 Linux 上的容器是什么，最简单直接的回答就是 Namesapce 和 Cgroups。Namespace 和 Cgroups 可以让程序在一个资源可控的独立（隔离）环境中运行，这个就是容器了。&lt;/p>
&lt;p>我们现在已经发现：容器的进程、网络还有文件系统都是独立的。那问题来了，容器的独立运行环境到底是怎么创造的呢？这就要提到 Namespace 这个概念了。所以接下来，就先从我们已经有点感觉的 Namespace 开始分析。&lt;/p>
&lt;h1 id="namespace">Namespace&lt;/h1>
&lt;p>接着前面的例子，我们正好有了一个正在运行的容器，那我们就拿这个运行的容器来看看 Namespace 到底是什么？&lt;/p>
&lt;p>在前面我们运行 docker exec c5a9ff78d9c1 ps -ef，看到了 5 个 httpd 进程，而且也只有这 5 个进程。&lt;/p>
&lt;pre tabindex="0">&lt;code># docker exec c5a9ff78d9c1 ps -ef
UID PID PPID C STIME TTY TIME CMD
root 1 0 0 01:59 ? 00:00:00 /sbin/httpd -D FOREGROUND
apache 6 1 0 01:59 ? 00:00:00 /sbin/httpd -D FOREGROUND
apache 7 1 0 01:59 ? 00:00:00 /sbin/httpd -D FOREGROUND
apache 8 1 0 01:59 ? 00:00:00 /sbin/httpd -D FOREGROUND
apache 9 1 0 01:59 ? 00:00:00 /sbin/httpd -D FOREGROUND
&lt;/code>&lt;/pre>&lt;p>如果我们不用 docker exec，直接在宿主机上运行 ps -ef，就会看到很多进程。如果我们运行一下 grep httpd ，同样可以看到这 5 个 httpd 的进程：&lt;/p>
&lt;pre tabindex="0">&lt;code># ps -ef | grep httpd
UID PID PPID C STIME TTY TIME CMD
root 20731 20684 0 18:59 ? 00:00:01 /sbin/httpd -D FOREGROUND
48 20787 20731 0 18:59 ? 00:00:00 /sbin/httpd -D FOREGROUND
48 20788 20731 0 18:59 ? 00:00:06 /sbin/httpd -D FOREGROUND
48 20789 20731 0 18:59 ? 00:00:05 /sbin/httpd -D FOREGROUND
48 20791 20731 0 18:59 ? 00:00:05 /sbin/httpd -D FOREGROUN
&lt;/code>&lt;/pre>&lt;p>这两组输出结果到底有什么差别呢，你可以仔细做个对比，最大的不同就是**进程的 PID 不一样。**那为什么 PID 会不同呢？或者说，运行 docker exec c5a9ff78d9c1 ps -ef 和 ps -ef 实质的区别在哪里呢？&lt;/p>
&lt;p>如果理解了 PID 为何不同，我们就能搞清楚 Linux Namespace 的概念了，为了方便后文的讲解，我们先用下面这张图来梳理一下我们看到的 PID。&lt;br>
&lt;img src="https://static001.geekbang.org/resource/image/88/7a/888c00e0e8fe40edce3f1a9f6yye717a.jpeg" alt="">&lt;/p>
&lt;p>Linux 在创建容器的时候，就会建出一个 PID Namespace，PID 其实就是进程的编号。这个 PID Namespace，就是指每建立出一个 Namespace，就会单独对进程进行 PID 编号，每个 Namespace 的 PID 编号都从 1 开始。&lt;/p>
&lt;p>同时在这个 PID Namespace 中也只能看到 Namespace 中的进程，而且看不到其他 Namespace 里的进程。&lt;/p>
&lt;p>这也就是说，如果有另外一个容器，那么它也有自己的一个 PID Namespace，而这两个 PID Namespace 之间是不能看到对方的进程的，这里就体现出了 Namespace 的作用：&lt;strong>相互隔离&lt;/strong>。&lt;/p>
&lt;p>而在宿主机上的 Host PID Namespace，它是其他 Namespace 的父亲 Namespace，可以看到在这台机器上的所有进程，不过进程 PID 编号不是 Container PID Namespace 里的编号了，而是把所有在宿主机运行的进程放在一起，再进行编号。&lt;/p>
&lt;p>讲了 PID Namespace 之后，我们了解到 &lt;strong>Namespace 其实就是一种隔离机制，主要目的是隔离运行在同一个宿主机上的容器，让这些容器之间不能访问彼此的资源。&lt;/strong>&lt;/p>
&lt;p>这种隔离有两个作用：&lt;strong>第一是可以充分地利用系统的资源，也就是说在同一台宿主机上可以运行多个用户的容器；第二是保证了安全性，因为不同用户之间不能访问对方的资源。&lt;/strong>&lt;/p>
&lt;p>除了 PID Namespace，还有其他常见的 Namespace 类型，比如我们之前运行了 docker exec c5a9ff78d9c1 ip addr 这个命令去查看容器内部的 IP 地址，这里其实就是在查看 Network Namespace。&lt;/p>
&lt;p>在 Network Namespace 中都有一套独立的网络接口比如这里的 lo，eth0，还有独立的 TCP/IP 的协议栈配置。&lt;/p>
&lt;pre tabindex="0">&lt;code># docker exec c5a9ff78d9c1 ip addr
1: lo: &amp;lt;LOOPBACK,UP,LOWER_UP&amp;gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
inet 127.0.0.1/8 scope host lo
valid_lft forever preferred_lft forever
168: eth0@if169: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu 1500 qdisc noqueue state UP group default
link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid 0
inet 172.17.0.2/16 brd 172.17.255.255 scope global eth0
valid_lft forever preferred_lft forever
&lt;/code>&lt;/pre>&lt;p>我们还可以运行 docker exec c5a9ff78d9c1 ls/ 查看容器中的根文件系统（rootfs）。然后，你会发现，它和宿主机上的根文件系统也是不一样的。&lt;strong>容器中的根文件系统，其实就是我们做的镜像。&lt;/strong>&lt;/p>
&lt;p>那容器自己的根文件系统完全独立于宿主机上的根文件系统，这一点是怎么做到的呢？其实这里依靠的是 &lt;strong>Mount Namespace&lt;/strong>，Mount Namespace 保证了每个容器都有自己独立的文件目录结构。&lt;/p>
&lt;p>Namespace 的类型还有很多，我们查看&amp;quot;Linux Programmer&amp;rsquo;s Manual&amp;quot;，可以看到 Linux 中所有的 Namespace：cgroup/ipc/network/mount/pid/time/user/uts。&lt;/p>
&lt;p>在这里呢，你需要记住的是 **Namespace 是 Linux 中实现容器的两大技术之一，它最重要的作用是保证资源的隔离。**在后面的课程，讲解到具体问题时，我会不断地提到 Namespace 这个概念。&lt;br>
&lt;img src="https://static001.geekbang.org/resource/image/5b/d2/5bbf4ac2fa9f81066732yy6f6202b8d2.jpg" alt="">&lt;/p>
&lt;p>好了，我们刚才说了 Namespace，这些 Namespace 尽管类型不同，其实都是为了隔离容器资源：&lt;strong>PID Namespace 负责隔离不同容器的进程，Network Namespace 又负责管理网络环境的隔离，Mount Namespace 管理文件系统的隔离。&lt;/strong>&lt;/p>
&lt;p>正是通过这些 Namespace，我们才隔离出一个容器，这里你也可以把它看作是一台&amp;quot;计算机&amp;quot;。&lt;/p>
&lt;p>既然是一台&amp;quot;计算机&amp;quot;，你肯定会问这个&amp;quot;计算机&amp;quot;有多少 CPU，有多少 Memory 啊？那么 Linux 如何为这些&amp;quot;计算机&amp;quot;来定义 CPU，定义 Memory 的容量呢？&lt;/p>
&lt;h1 id="cgroups">Cgroups&lt;/h1>
&lt;p>想要定义&amp;quot;计算机&amp;quot;各种容量大小，就涉及到支撑容器的第二个技术 **Cgroups （Control Groups）**了。Cgroups 可以对指定的进程做各种计算机资源的限制，比如限制 CPU 的使用率，内存使用量，IO 设备的流量等等。&lt;/p>
&lt;p>Cgroups 究竟有什么好处呢？要知道，在 Cgroups 出现之前，任意一个进程都可以创建出成百上千个线程，可以轻易地消耗完一台计算机的所有 CPU 资源和内存资源。&lt;/p>
&lt;p>但是有了 Cgroups 这个技术以后，我们就可以对一个进程或者一组进程的计算机资源的消耗进行限制了。&lt;/p>
&lt;p>Cgroups 通过不同的子系统限制了不同的资源，每个子系统限制一种资源。每个子系统限制资源的方式都是类似的，就是把相关的一组进程分配到一个控制组里，然后通过&lt;strong>树结构&lt;/strong>进行管理，每个控制组都设有自己的资源控制参数。&lt;/p>
&lt;p>完整的 Cgroups 子系统的介绍，你可以查看Linux Programmer&amp;rsquo;s Manual 中 Cgroups 的定义。&lt;/p>
&lt;p>这里呢，我们只需要了解几种比较常用的 Cgroups 子系统：&lt;/p>
&lt;ul>
&lt;li>CPU 子系统，用来限制一个控制组（一组进程，你可以理解为一个容器里所有的进程）可使用的最大 CPU。&lt;/li>
&lt;li>memory 子系统，用来限制一个控制组最大的内存使用量。&lt;/li>
&lt;li>pids 子系统，用来限制一个控制组里最多可以运行多少个进程。&lt;/li>
&lt;li>cpuset 子系统， 这个子系统来限制一个控制组里的进程可以在哪几个物理 CPU 上运行。&lt;/li>
&lt;/ul>
&lt;p>因为 memory 子系统的限制参数最简单，所以下面我们就用 memory 子系统为例，一起看看 Cgroups 是怎么对一个容器做资源限制的。&lt;/p>
&lt;p>对于启动的每个容器，都会在 Cgroups 子系统下建立一个目录，在 Cgroups 中这个目录也被称作控制组，比如下图里的&amp;quot;docker-&amp;lt;id1&amp;gt;&amp;ldquo;&amp;ldquo;docker-&amp;lt;id2&amp;gt;&amp;ldquo;等。然后我们设置这个控制组的参数，通过这个方式，来限制这个容器的内存资源。&lt;br>
&lt;img src="https://static001.geekbang.org/resource/image/61/63/6193bba2757e5cc34bb023b13cac7663.jpeg" alt="">&lt;/p>
&lt;p>还记得，我们之前用 Docker 创建的那个容器吗？在每个 Cgroups 子系统下，对应这个容器就会有一个目录 docker-**c5a9ff78d9c1&amp;hellip;&amp;hellip;**这个容器的 ID 号，容器中所有的进程都会储存在这个控制组中 cgroup.procs 这个参数里。&lt;/p>
&lt;p>你看下面的这些进程号是不是很熟悉呢？没错，它们就是前面我们用 ps 看到的进程号。&lt;/p>
&lt;p>我们实际看一下这个例子里的 memory Cgroups，它可以控制 Memory 的使用量。比如说，我们将这个控制组 Memory 的最大用量设置为 2GB。&lt;/p>
&lt;p>具体操作是这样的，我们把（2* 1024 * 1024 * 1024 = 2147483648）这个值，写入 memory Cgroup 控制组中的 memory.limit_in_bytes 里，&lt;strong>这样设置后，cgroup.procs 里面所有进程 Memory 使用量之和，最大也不会超过 2GB。&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code># cd /sys/fs/cgroup/memory/system.slice/docker-c5a9ff78d9c1fedd52511e18fdbd26357250719fa0d128349547a50fad7c5de9.scope
# cat cgroup.procs
20731
20787
20788
20789
20791
# echo 2147483648 &amp;gt; memory.limit_in_bytes
# cat memory.limit_in_bytes
2147483648
&lt;/code>&lt;/pre>&lt;p>刚刚我们通过 memory Cgroups 定义了容器的 memory 可以使用的最大值。其他的子系统稍微复杂一些，但用法也和 memory 类似，我们在后面的课程中会结合具体的实例来详细解释其他的 Cgroups。&lt;/p>
&lt;p>这里我们还要提一下 &lt;strong>Cgroups 有 v1 和 v2 两个版本&lt;/strong>：&lt;/p>
&lt;p>Cgroups v1 在 Linux 中很早就实现了，各种子系统比较独立，每个进程在各个 Cgroups 子系统中独立配置，可以属于不同的 group。&lt;/p>
&lt;p>虽然这样比较灵活，但是也存在问题，会导致对&lt;strong>同一进程的资源协调比较困难&lt;/strong>（比如 memory Cgroup 与 blkio Cgroup 之间就不能协作）。虽然 v1 有缺陷，但是在主流的生产环境中，大部分使用的还是 v1。&lt;/p>
&lt;p>Cgroups v2 做了设计改进，&lt;strong>解决了 v1 的问题，使各个子系统可以协调统一地管理资源。&lt;/strong>&lt;/p>
&lt;p>不过 Cgroups v2 在生产环境的应用还很少，因为该版本很多子系统的实现需要较新版本的 Linux 内核，还有无论是主流的 Linux 发行版本还是容器云平台，比如 Kubernetes，对 v2 的支持也刚刚起步。&lt;/p>
&lt;p>所以啊，我们在后面 Cgroups 的讲解里呢，主要还是用 &lt;strong>Cgroups v1 这个版本&lt;/strong>，在磁盘 I/O 的这一章中，我们也会介绍一下 Cgroups v2。&lt;/p>
&lt;p>好了，上面我们解读了 Namespace 和 Cgroups 两大技术，它们是 Linux 下实现容器的两个基石，后面课程中要讨论的容器相关问题，或多或少都和 Namespace 或者 Cgroups 相关，我们会结合具体问题做深入的分析。&lt;/p>
&lt;p>目前呢，你只需要先记住这两个技术的作用，&lt;strong>Namespace 帮助容器来实现各种计算资源的隔离，Cgroups 主要限制的是容器能够使用的某种资源量。&lt;/strong>&lt;/p>
&lt;h1 id="重点总结">重点总结&lt;/h1>
&lt;p>这一讲，我们对容器有了一个大致的认识，包括它的&amp;quot;形&amp;rdquo;，&lt;strong>一些基本的容器操作&lt;/strong>；还有它的&amp;quot;神&amp;rdquo;，也就是&lt;strong>容器实现的原理&lt;/strong>。&lt;/p>
&lt;p>启动容器的基本操作是这样的，首先用 Dockerfile 来建立一个容器的镜像，然后再用这个镜像来启动一个容器。&lt;/p>
&lt;p>那启动了容器之后，怎么检验它是不是正常工作了呢？&lt;/p>
&lt;p>我们可以运行 docker exec 这个命令进入容器的运行空间，查看进程是否启动，检查配置文件是否正确，检验我们设置的服务是否能够正常提供。&lt;/p>
&lt;p>我们用 docker exec 命令查看了容器的进程，网络和文件系统，就能体会到容器的文件系统、运行的进程环境和网络的设置都是独立的，所以从用户使用的角度看，容器和一台独立的机器或者虚拟机没有什么太大的区别。&lt;/p>
&lt;p>最后，我们一起学习了 Namespace 和 Cgroups，它们是 Linux 的两大技术，用于实现容器的特性。&lt;/p>
&lt;p>具体来说，&lt;strong>Namespace 帮助容器实现各种计算资源的隔离，Cgroups 主要对容器使用某种资源量的多少做一个限制。&lt;/strong>&lt;/p>
&lt;p>所以我们在这里可以直接记住：&lt;strong>容器其实就是 Namesapce+Cgroups。&lt;/strong>&lt;/p>
&lt;h1 id="思考题">思考题&lt;/h1>
&lt;p>用 Dockerfile 为你最熟悉的应用程序做个镜像，然后用 Docker 命令启动这个容器。&lt;/p>
&lt;p>欢迎在留言区分享你的疑惑和见解。你也可以把今天的内容分享给你的朋友，和他一起学习和进步。&lt;/p></description></item><item><title>极客专栏: 01｜各平台下的Vim安装方法：上路前准备好你的宝马</title><link>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/vim-%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/01%E5%90%84%E5%B9%B3%E5%8F%B0%E4%B8%8B%E7%9A%84vim%E5%AE%89%E8%A3%85%E6%96%B9%E6%B3%95%E4%B8%8A%E8%B7%AF%E5%89%8D%E5%87%86%E5%A4%87%E5%A5%BD%E4%BD%A0%E7%9A%84%E5%AE%9D%E9%A9%AC/</link><pubDate>Fri, 08 Jul 2022 00:00:00 +0000</pubDate><guid>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/vim-%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/01%E5%90%84%E5%B9%B3%E5%8F%B0%E4%B8%8B%E7%9A%84vim%E5%AE%89%E8%A3%85%E6%96%B9%E6%B3%95%E4%B8%8A%E8%B7%AF%E5%89%8D%E5%87%86%E5%A4%87%E5%A5%BD%E4%BD%A0%E7%9A%84%E5%AE%9D%E9%A9%AC/</guid><description>
&lt;p>你好，我是吴咏炜。&lt;/p>
&lt;p>今天第一讲，我们先来讨论一下 Vim 在 Linux、macOS、Windows 系统下的安装和配置问题。&lt;/p>
&lt;p>Vim 在 Linux 和 macOS 上一般是默认安装的，在 Windows 上不是。不过 Vim 的网站上提供了 Windows 下的安装包，自己安装也很容易。所以，今天的课程我不会手把手、一步步地讲，而是挑选一些重点。对于默认安装的情况，主要讨论的是版本老旧或功能不全的问题。对于其他情况，我则会给出一个基本指引，减少你走弯路的可能性。&lt;/p>
&lt;p>好了，下面我们就分各个不同的平台，一一来看。&lt;/p>
&lt;h1 id="linux-下的安装">Linux 下的安装&lt;/h1>
&lt;h1 id="red-hat-和-centos-系列">Red Hat 和 CentOS 系列&lt;/h1>
&lt;p>在 Red Hat Linux 和 CentOS Linux 上，默认安装的 Vim 可能是一个最小功能的版本。虽然这个版本启动速度很快，但它缺少了很多对开发有用的功能，如语法加亮、Python 集成和图形界面。一般情况下，应至少安装更全功能版本的 Vim；如果能使用 X Window 的话，则应安装图形界面版本。&lt;/p>
&lt;p>你可以通过下面的命令来查看已经安装的 Vim 版本：&lt;/p>
&lt;pre tabindex="0">&lt;code>yum list installed | grep vim
&lt;/code>&lt;/pre>&lt;p>如果输出只有下面这样的内容的话，就说明安装的 Vim 版本只有基本功能：&lt;/p>
&lt;blockquote>
&lt;p>vim-minimal.x86_64 2:8.0.1763-13.el8 @System&lt;/p>
&lt;/blockquote>
&lt;p>此时，我建议使用 sudo yum install vim-X11 来安装图形界面的 Vim，或至少使用 sudo yum install vim-enhanced 来安装增强版本的 Vim（如果你不在这台机器上进行图形界面登录的话）。&lt;/p>
&lt;p>只要你使用图形界面，一般而言，你都应该安装有图形界面支持的 Vim。总体而言，图形界面 Vim 的功能更丰富，并且即使你只在终端里使用 Vim，含图形界面支持的 Vim 会带剪贴板支持，跟整个图形环境的交互也就比较容易。当然，如果你只是远程通过 SSH 使用 Vim 的话，那确实图形界面支持就没有意义了。&lt;/p>
&lt;h1 id="debian-和-ubuntu-系列">Debian 和 Ubuntu 系列&lt;/h1>
&lt;p>在 Debian、Ubuntu 等使用 apt 的 Linux 发行版上，Vim 同样有着不同功能版本的区别，而且选择更多。我们可能会看到：&lt;/p>
&lt;ul>
&lt;li>vim&lt;/li>
&lt;li>vim-athena&lt;/li>
&lt;li>vim-gnome&lt;/li>
&lt;li>vim-gtk&lt;/li>
&lt;li>vim-gtk3&lt;/li>
&lt;li>vim-nox&lt;/li>
&lt;li>vim-tiny&lt;/li>
&lt;/ul>
&lt;p>它们中有编译进最小功能的 Vim 包（vim-tiny），有较全功能的文本界面 Vim 包（vim-nox），有适用于老的 X-Window 界面的版本（vim-athena），有适用于 KDE 环境的 GTK2 版本（vim-gtk），等等。&lt;br>
&lt;img src="https://static001.geekbang.org/resource/image/dc/94/dc83899514bd661b41d1e8a902d47294.png" alt="">&lt;br>
一个估计你不会去用的古老界面的 Vim（Athena 界面）&lt;/p>
&lt;p>如果你不确定要装什么版本的话，那可以遵循我下面的建议：&lt;/p>
&lt;ul>
&lt;li>如果你使用标准的 GNOME 桌面环境的话（大部分的情况），安装 vim-gtk3 或 vim-gnome。&lt;/li>
&lt;li>如果你使用 KDE 桌面的话，安装 vim-gtk。&lt;/li>
&lt;li>如果你只使用文本界面的话，安装 vim-nox。&lt;/li>
&lt;li>都不是？那你是个爱自己定制的家伙，也就不需要我告诉你该安装什么了。&lt;/li>
&lt;/ul>
&lt;p>你可以通过下面的命令来查看已经安装的 Vim 版本：&lt;/p>
&lt;pre tabindex="0">&lt;code>apt list --installed | grep vim
&lt;/code>&lt;/pre>&lt;p>我们先执行 sudo apt update 来确保更新环境，然后使用 sudo apt install vim-gtk3 安装 GTK3 版本的 Vim（或者其他你需要的版本）。如果你安装了图形界面的版本，不必单独再另外安装其他版本的 Vim，因为图形版本的 Vim 也是可以纯文本启动的。事实上，在 Ubuntu 上，vim 和 gvim 都是指向同一个应用程序的符号链接，且 gvim 的执行效果和 vim -g 相同。&lt;br>
&lt;img src="https://static001.geekbang.org/resource/image/39/5a/39d5f8bef475c6b223cee68de8376f5a.png" alt="">&lt;br>
在终端中运行 vim.gtk3，执行 :version&lt;/p>
&lt;h1 id="手工编译">手工编译&lt;/h1>
&lt;p>如果你用的 Linux 发行版较老的话，你可能会希望手工编译 Vim 来得到最新的版本。此时需要注意的是，Vim 有很多的编译配置选项，有些缺省是不打开的。对于这个课程来讲，我们会希望至少加上 Python 支持和图形界面支持。&lt;/p>
&lt;p>你首先需要确保自己已经安装了所需的开发包（可以参考这个网上的回答）。然后，我们可以使用下面的命令来配置 Vim 和编译（根据需要，&amp;ldquo;auto&amp;quot;也可以替换成&amp;quot;gtk3&amp;quot;等其他需要的数值）：&lt;/p>
&lt;pre tabindex="0">&lt;code>./configure --enable-pythoninterp \
--enable-python3interp \
--enable-gui=auto
make -j
sudo make install
&lt;/code>&lt;/pre>&lt;p>如果上述步骤正常没有出错，Vim 就被成功安装到 /usr/local 下了。你可以用 which vim 来检查系统是否会自动优先选择你的 vim：如果不是的话，你可能需要调整 PATH 里的顺序，或者设置别名来优先启动 /usr/local/bin/vim）。然后，你可以使用 vim &amp;ndash;version 命令来输出 vim 的版本信息。我们希望能在输出里看到：&lt;/p>
&lt;blockquote>
&lt;p>Huge version with &amp;hellip; GUI
+python/dyn
+python3/dyn&lt;/p>
&lt;/blockquote>
&lt;p>目前 Python 2 已经停止支持，所以你最好可以确保上面的输出中包含&amp;rdquo;+python3&amp;quot;（很多 Vim 的插件已经开始要求 Python 3、不再支持 Python 2 了）；没有&amp;quot;+python&amp;quot;（即 Python 2）则没什么关系（有没有&amp;quot;dyn&amp;quot;关系也不大）。&lt;br>
&lt;img src="https://static001.geekbang.org/resource/image/f0/30/f05a0a02cbea3b6412790ab7a1aa6d30.png" alt="">&lt;br>
我在 CentOS 7 上编译的 gvim&lt;/p>
&lt;p>好了，关于 Linux 环境下的 Vim 安装和配置要点我们就讲完了，接下来继续看在 macOS 上如何安装。&lt;/p>
&lt;h1 id="macos-下的安装">macOS 下的安装&lt;/h1>
&lt;p>在 macOS 中一般已经内置了 vim，并提供了除图形界面外的较完整功能集。如果你希望使用图形界面，则需要自行安装 MacVim，一个跟现代 macOS 融合较好的独立 Vim 版本。安装 MacVim 有两种常用方式：&lt;/p>
&lt;ul>
&lt;li>使用 Homebrew。我推荐你使用这种方式，这样的话，以后升级也会比较容易。&lt;/li>
&lt;li>使用 MacVim 的独立安装包。如果你之前没有在用 Homebrew 的话，或处于不方便使用 Homebrew 的网络环境中，这种方式也可以。&lt;/li>
&lt;/ul>
&lt;p>由于使用 Homebrew 已经足够简单，日后升级也非常方便，我个人觉得我们没必要自己去编译 MacVim。&lt;br>
&lt;img src="https://static001.geekbang.org/resource/image/f4/75/f49cb907c0b34b9c2b8f7579de9d5075.png" alt="">&lt;br>
MacVim 的界面&lt;/p>
&lt;h1 id="使用-homebrew-安装-macvim">使用 Homebrew 安装 MacVim&lt;/h1>
&lt;p>首先，如果你没有 Homebrew，那你需要先安装 Homebrew。安装信息可以在 Homebrew 的主页上找到（这个网站是支持中文的）。&lt;/p>
&lt;p>在安装了 Homebrew 之后，一般情况下，你需要修改你的 .bash_profile（如果使用 Bash 的话）、.zprofile（如果使用 Zsh 的话）或是相应的 shell 的配置文件，调整 PATH，把 /usr/local/bin 放到 /usr/bin 前面。我个人在 .bash_profile 里是这样配置的：&lt;/p>
&lt;pre tabindex="0">&lt;code>if [[ $PATH != &amp;#34;$HOME/bin&amp;#34;* ]]; then
PATH=~/bin:/usr/local/bin:/usr/local/sbin:`echo $PATH|sed -e &amp;#34;s!:$HOME/bin!!&amp;#34; -e &amp;#39;s!:/usr/local/bin!!&amp;#39;`
fi
&lt;/code>&lt;/pre>&lt;p>这样，可以确保个人的路径优先于 /usr/local，而 /usr/local 下的路径又优先于系统的路径。&lt;/p>
&lt;p>如果你这样配置的话，那只要执行 brew install macvim，然后在等待安装完成之后，你用 vim 启动的就是 MacVim 了。缺省用 vim 运行的仍然是纯文本界面的 Vim，但跟 Linux 一样，你可以用 vim -g 或 gvim（还有仅用在 Mac 上的 mvim）来启动 Vim 的图形界面。&lt;/p>
&lt;p>跟 Homebrew 里的其他软件一样，你以后要升级 MacVim 的话，只需要输入命令 brew upgrade macvim 即可。是不是很简单？这就是为什么我比较推荐这种安装方式，后期升级真的更容易。不过我下面还是会介绍下安装包的方式，以满足我们不同的应用需求。&lt;/p>
&lt;h1 id="使用安装包安装-macvim">使用安装包安装 MacVim&lt;/h1>
&lt;p>跟大部分的 Mac 软件一样，你也可以直接使用 DMG 安装包来安装 MacVim。目前可从以下网址下载 MacVim 的安装包：&lt;/p>
&lt;p>&lt;a href="https://github.com/macvim-dev/macvim/releases">https://github.com/macvim-dev/macvim/releases&lt;/a>&lt;/p>
&lt;p>等待下载完成后，双击下载的文件，然后会打开一个访达（Finder）窗口。你只需要把 MacVim 拖拽复制到应用程序文件夹即可。&lt;/p>
&lt;p>在这种安装方式下，手工键入 vim、gvim 或 mvim 命令是无法启动 MacVim 的。你需要手工创建这些命令的符号链接（symlink）或别名（alias）才行。假设你的 MacVim 是直接安装在应用程序文件夹里的话，这些命令本身可以在 /Applications/MacVim.app/Contents/bin 文件夹里找到；使用下面的命令可以在你自己的 bin 目录下创建这些命令的符号链接：&lt;/p>
&lt;pre tabindex="0">&lt;code>[ -d ~/bin ] || mkdir ~/bin
ln -s /Applications/MacVim.app/Contents/bin/* ~/bin/
&lt;/code>&lt;/pre>&lt;h1 id="windows-下的安装">Windows 下的安装&lt;/h1>
&lt;p>最后，我们来看在 Windows 下怎么安装。课程开头我提到了，Windows 上缺省是没有 Vim 的。我们可以从 Vim 的网站下载 Windows 下的安装包：&lt;/p>
&lt;p>&lt;a href="https://www.vim.org/download.php#pc">https://www.vim.org/download.php#pc&lt;/a>&lt;/p>
&lt;p>在 Linux 和 macOS 上，64 位应用程序已经成为主流。而与此不同的是，在 64 位 Windows 上，32 位应用程序仍然很常见。默认的 Vim 8 的安装包安装的仍然是一个 32 位的应用程序。不过，32 位的 Vim 也足够满足一般需求了，除非你需要编辑 2 GB 以上的大文件。&lt;/p>
&lt;p>安装界面会有一个选择组件的步骤，如下图所示：&lt;br>
&lt;img src="https://static001.geekbang.org/resource/image/3a/80/3a9291c280033a71f80d924467546580.png" alt="">&lt;br>
Vim 的组件选择界面&lt;/p>
&lt;p>这个界面中，下面几项我们可以关注一下：&lt;/p>
&lt;ul>
&lt;li>&amp;ldquo;安装批处理文件&amp;rdquo;（Create .bat files）：对于用 Vim 的开发者来说，通常命令行是刚需，所以我们一般需要勾上这项。&lt;/li>
&lt;li>&amp;ldquo;创建图标&amp;rdquo;（Create icons for Vim）：根据你自己的需要进行选择，通常我会去掉展开子项里的&amp;quot;桌面图标&amp;quot;（On the Desktop），不在桌面上创建 Vim 的图标。&lt;/li>
&lt;li>&amp;ldquo;创建默认配置文件&amp;rdquo;（Create Default Config）：去掉这项&amp;mdash;&amp;mdash;我们马上会创建配置文件。&lt;/li>
&lt;li>&amp;ldquo;安装多语言支持&amp;rdquo;（Native Language Support）：这项功能使得 Vim 的菜单可以显示中文的命令，但实际上还是有点鸡肋，因为 Vim 的主要功能不是靠菜单驱动的，安装程序安装的帮助文件也只有英文版。所以，这项选和不选关系不大，你可以自由选择。&lt;/li>
&lt;/ul>
&lt;p>然后我们点&amp;quot;下一步&amp;quot;（Next），不需要修改安装目标文件夹，完成安装即可。&lt;/p>
&lt;p>完成安装后，Vim 会缺省打开一个 README 文件。在这个窗口中，我们应当键入&amp;quot;:e ~\_vimrc&amp;quot;，回车键，然后把下面的内容粘贴进去（这些配置项的意义我们以后会讨论）：&lt;/p>
&lt;pre tabindex="0">&lt;code>set enc=utf-8
set nocompatible
source $VIMRUNTIME/vimrc_example.vim
&lt;/code>&lt;/pre>&lt;p>然后键入&amp;quot;ZZ&amp;quot;（大写）存盘退出即可。&lt;br>
&lt;img src="https://static001.geekbang.org/resource/image/07/17/07ebd8b7d535e516e8d68517a6338717.gif" alt="">&lt;br>
创建基本的 _vimrc 配置文件&lt;/p>
&lt;p>注意由于历史上的文件系统限制，在 Windows 下 Vim 的配置文件名称是 _vimrc 而不是 .vimrc（虽然 Windows 命令行不支持像 Unix 一样用&amp;quot;~&amp;ldquo;代表用户的主目录，在 Vim 里我们仍然可以使用&amp;rdquo;~\_vimrc&amp;quot;或&amp;quot;~/_vimrc&amp;quot;这样的写法）。这是 Unix 和 Windows 下的 Vim 配置的区别之一。其他的主要区别是以下两点：&lt;/p>
&lt;ul>
&lt;li>点打头的 Vim 文件都成了&amp;quot;_&amp;ldquo;打头，如 .viminfo 也成了 _viminfo&lt;/li>
&lt;li>点打头的 Vim 配置目录 .vim 在 Windows 下则成了 vimfiles&lt;/li>
&lt;/ul>
&lt;p>除此之外，Vim 的配置在 Windows 下和 Unix 下（如 Linux 和 macOS）并没有根本不同。Windows 上的主要麻烦在于，由于 Vim 的生态主要在 Unix 上，某些 Vim 的插件在 Windows 上安装配置需要花费更大的力气。但就一般的文本和程序编辑而言，Vim 在 Windows 下和 Linux 下没有本质的不同。甚至 Windows 下还有一个小小的优势：Unix 下虽然 Vim 可以编译成支持 Python 2 和 Python 3，但在 Vim 里一旦执行了 Python 2 的代码，就不能再执行 Python 3 的代码了；反之亦然。Windows 下则没有这个限制。&lt;/p>
&lt;p>有没有注意到我只在 Windows 的安装部分讨论了配置？这是因为 Unix 下主流的缺省编码已经是 UTF-8 了，而 Vim 只能在内码是 UTF-8 的情况下才能处理多语言的文本。而我们有自己的配置文件，是为了确保启用一些最为基本的配置选项，来保证基本行为的一致性。&lt;/p>
&lt;p>Windows 上可以把 Vim 配置成跟普通的编辑器行为差不多，包括支持 Ctrl-A 全选，选择内容后输入任何内容替换选择的内容，等等。但是，这种行为跟 Vim 的标准行为是冲突的。我们要学习 Vim，还是忘了这些 Windows 特有的功能为好，去学习掌握 Vim 的跨平台标准功能。上面的配置文件也同样没有启用 Windows 下的特有行为。&lt;/p>
&lt;h1 id="cygwinmsys2">Cygwin/MSYS2&lt;/h1>
&lt;p>Windows 有 Cygwin 和 MSYS2，可以提供类似于 Linux 的 POSIX shell。在这些环境里，Vim 都是标准组件，按这些环境的标准方式来安装 Vim 就行。如果你使用 Git Bash 的话，里面就直接包含了 MSYS2 的终端、Bash 和 Vim。唯一需要提一句的是，这些类 POSIX 环境里面的 Vim 配置应当参照 Linux 终端来，而不是 Windows 下的标准方式（也就是说，个人配置目录和配置文件是 .vim 和 .vimrc，而非 vimfiles 和 _vimrc）。我以后对这种情况就不再单独描述了。&lt;/p>
&lt;h1 id="远程使用-vim">远程使用 Vim&lt;/h1>
&lt;p>还有一种常用的环境恐怕是使用 mintty、PuTTY、SecureCRT 之类的软件在 Windows 上远程连接到 Linux 机器上。在这种情况下，需要特别注意的，是远程终端软件的远程字符集（如 PuTTY 中的&amp;quot;Windows &amp;gt; Translation &amp;gt; Remote character set&amp;rdquo;）应当设置成 UTF-8。这个设定跟具体的软件及其版本有关，我就不详细说明了；请自行查看你所使用的远程终端软件的设定和相关文档。&lt;/p>
&lt;h1 id="学习-vim">学习 Vim&lt;/h1>
&lt;p>上面我们讲解了 Vim 的安装。如果安装过程中遇到了什么问题，可以留言提问。接下来，我会给你提供一些 Vim 的学习资料，帮助你进入 Vim 的世界。你应该仔细看一下你所使用的平台上的 Vim 安装信息（其他平台的可以略过），并且应该自己打开 Vim 教程练习一遍（除非这些基础知识你都了解了）。键盘配置相关信息属于可选，可以根据自己的兴趣和需要决定是否了解一下。&lt;/p>
&lt;h1 id="中文帮助文件">中文帮助文件&lt;/h1>
&lt;p>Vim 内置了完整的英文帮助文件。如果你想要中文帮助文件的话，有个好消息是，有网友同步翻译了最新的帮助文件，而且安装过程在 Vim 8 （或将来的版本）里是非常简单的。以 Unix 下为例（Windows 下类似，但路径 .vim 需要修改为 vimfiles）：&lt;/p>
&lt;pre tabindex="0">&lt;code>cd ~/.vim
mkdir -p pack/my/start
git clone https://github.com/yianwillis/vimcdoc.git pack/my/start/vimcdoc
&lt;/code>&lt;/pre>&lt;p>如果你不需要以后利用 Git 来快速升级文档的话， 也可以在这个 Vim 中文文档计划的下载页面下载 tar 包，然后自行解压到 ~/.vim/pack/my/start 目录下（或 Windows 用户目录下的 vimfiles\pack\my\start 目录下）。&lt;/p>
&lt;p>Windows 用户有一个简单的安装程序（当前为 vimcdoc-2.3.0-setup-unicode.exe），可以自动帮你完成中文帮助文件的安装任务。如果你的机器上没有 git 和 tar 可执行程序的话，那这个方式最简单。&lt;br>
&lt;img src="https://static001.geekbang.org/resource/image/fe/a7/fe5d4b5cbf08c939feb8d453f919d1a7.png" alt="">&lt;br>
中文 Vim 帮助&lt;/p>
&lt;h1 id="vim-教程">Vim 教程&lt;/h1>
&lt;p>Vim 在安装中自带了一个教程，可供快速入手使用。如果你对 Vim 的基本操作不熟的话，建议你完整学习一下，我也就不必多费笔墨介绍一些最基础的用法了。&lt;/p>
&lt;p>Vim 教程支持多语言，可使用命令 vimtutor 来启动。如果启动的教程的语言不是你希望的，你可以使用环境变量 LANG 来设定希望的语言。比如，下面的命令可以在 Unix 环境中启动一个中文的 Vim 教程：&lt;/p>
&lt;pre tabindex="0">&lt;code>LANG=zh_CN.UTF-8 vimtutor
&lt;/code>&lt;/pre>&lt;p>Windows 下你可以在开始菜单里找到 Vim tutor。但我测试下来它有一个问题。虽然我提交的解决方法已经作为补丁（8.2.0412）合并，但目前（Vim 8.2）安装程序安装的文件多半仍然是有问题的，你会无法成功地创建一个 tutor 文件的副本供编辑使用。我建议手工创建一个这个教程的副本。可以在命令提示符下输入：&lt;/p>
&lt;pre tabindex="0">&lt;code>vim --clean -c &amp;#34;e $VIMRUNTIME/tutor/tutor.zh_cn.utf-8&amp;#34; -c &amp;#34;w! TUTORCOPY&amp;#34; -c &amp;#34;q&amp;#34;
&lt;/code>&lt;/pre>&lt;p>这样即可在当前目录下创建一个教程的副本。然后我们可以用 gvim TUTORCOPY 来打开这个副本进行学习。&lt;br>
&lt;img src="https://static001.geekbang.org/resource/image/20/c5/208992f818376e6010066c4a544286c5.png" alt="">&lt;br>
Vim 教程&lt;/p>
&lt;h1 id="键盘重配置">键盘重配置&lt;/h1>
&lt;p>最后，有些重度的 Vim 用户会重新配置键盘，把使用频度较低的大写锁定键（Caps Lock）重新映射成 Esc 或 Ctrl 键。对于这个问题，如果你需要的话，网上很容易就能找到攻略，如：&lt;/p>
&lt;ul>
&lt;li>Linux 下将大写锁定键 (CapsLock) 键映射为 Ctrl 键 (Ubuntu, Manjaro，CentOS)&lt;/li>
&lt;li>mac book 更改 caps lock 键为 esc 键 /ctrl 键&lt;/li>
&lt;li>windows 交换大写锁定键与 ESC 键（注册表修改）&lt;/li>
&lt;li>在任何操作系统上，如何禁用或者重新分配 Caps Lock 键&lt;/li>
&lt;/ul>
&lt;p>这当然是一件非常个人化的事情，而且有一个风险，你一旦跑到别人的机器上操作，你的&amp;quot;肌肉记忆&amp;quot;可能会让你常常按错键。鉴于你目前可能只是个 Vim 的初学者，现在不一定需要这么去做。等到你觉得按 Esc 太麻烦了，再想起这个可能性去修改键盘配置也来得及。&lt;/p>
&lt;h1 id="内容小结">内容小结&lt;/h1>
&lt;p>今天我们讨论了 Vim 在常见平台上的安装过程。顺便说一句，以后在牵涉到环境问题时，我一般也会以上面提到的几种典型情况为例来进行讲解：&lt;/p>
&lt;ul>
&lt;li>Linux（CentOS 和 Ubuntu）&lt;/li>
&lt;li>macOS&lt;/li>
&lt;li>Windows&lt;/li>
&lt;/ul>
&lt;p>你可能看着多个平台的安装过程有点晕，这却是我的实际使用环境了&amp;mdash;&amp;mdash;我就是在各个平台下都安装、配置、使用着 Vim 的，这也就是 Vim 的全平台、跨平台优势了。&lt;/p>
&lt;p>当然，必须得承认，Vim 还是最适合类 Unix 环境，它的生态系统也是在类 Unix 环境下最好。鉴于在 Windows 下已经越来越容易接触到类 Unix 环境（像 Git Bash、Docker 和 Windows Subsystem for Linux），服务器开发上 Linux 也已经成了主流，在 Windows 上熟悉 Vim 的完整环境对你也应该是件好事&amp;mdash;&amp;mdash;尤其如果你是做服务器或嵌入式开发的话。&lt;/p>
&lt;p>下一讲，我们就会进一步学习一下 Vim 的基本概念和配置。&lt;/p>
&lt;h1 id="课后练习">课后练习&lt;/h1>
&lt;p>如果你之前不常使用 Vim ，请务必花点时间看一下 Vim 教程。在下一讲开始时，我将会假设你已经掌握了 Vim 教程里的基本用法。&lt;/p>
&lt;p>当然，如果有任何问题的话，可以在讨论区留言和我进行交流。&lt;/p>
&lt;p>我是吴咏炜，我们下一讲再见。&lt;/p></description></item><item><title>极客专栏: 01丨为什么要学习网络协议？</title><link>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E8%B6%A3%E8%B0%88%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/01%E4%B8%A8%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%AD%A6%E4%B9%A0%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/</link><pubDate>Fri, 08 Jul 2022 00:00:00 +0000</pubDate><guid>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E8%B6%A3%E8%B0%88%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/01%E4%B8%A8%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%AD%A6%E4%B9%A0%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/</guid><description>
&lt;p>《圣经》中有一个通天塔的故事，大致是说，上帝为了阻止人类联合起来，就让人类说不同的语言。人类没法儿沟通，达不成&amp;quot;协议&amp;quot;，通天塔的计划就失败了。&lt;/p>
&lt;p>但是千年以后，有一种叫&amp;quot;程序猿&amp;quot;的物种，敲着一种这个群体通用的语言，连接着全世界所有的人，打造这互联网世界的通天塔。如今的世界，正是因为互联网，才连接在一起。&lt;/p>
&lt;p>当 &amp;ldquo;Hello World!&amp;rdquo; 从显示器打印出来的时候，还记得你激动的心情吗？&lt;/p>
&lt;pre>&lt;code>public class HelloWorld {
public static void main(String[] args){
System.out.println(&amp;quot;Hello World!&amp;quot;);
}
}
&lt;/code>&lt;/pre>
&lt;p>如果你是程序员，一定看得懂上面这一段文字。这是每一个程序员向计算机世界说&amp;quot;你好，世界&amp;quot;的方式。但是，你不一定知道，这段文字也是一种协议，是人类和计算机沟通的协议，&lt;strong>只有通过这种协议，计算机才知道我们想让它做什么。&lt;/strong>&lt;/p>
&lt;h2 id="-">协议三要素&lt;/h2>
&lt;p>当然，这种协议还是更接近人类语言，机器不能直接读懂，需要进行翻译，翻译的工作教给编译器，也就是程序员常说的 compile。这个过程比较复杂，其中的编译原理非常复杂，我在这里不进行详述。﻿&lt;img src="https://static001.geekbang.org/resource/image/47/7a/47f340b2d76fd29bb937006f19dd3e7a.png" alt="">&lt;/p>
&lt;p>但是可以看得出，计算机语言作为程序员控制一台计算机工作的协议，具备了协议的三要素。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>语法&lt;/strong>，就是这一段内容要符合一定的规则和格式。例如，括号要成对，结束要使用分号等。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>语义&lt;/strong>，就是这一段内容要代表某种意义。例如数字减去数字是有意义的，数字减去文本一般来说就没有意义。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>顺序&lt;/strong>，就是先干啥，后干啥。例如，可以先加上某个数值，然后再减去某个数值。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>会了计算机语言，你就能够教给一台计算机完成你的工作了。恭喜你，入门了！&lt;/p>
&lt;p>但是，要想打造互联网世界的通天塔，只教给一台机器做什么是不够的，你需要学会教给一大片机器做什么。这就需要网络协议。&lt;strong>只有通过网络协议，才能使一大片机器互相协作、共同完成一件事。&lt;/strong>&lt;/p>
&lt;p>这个时候，你可能会问，网络协议长啥样，这么神奇，能干成啥事？我先拿一个简单的例子，让你尝尝鲜，然后再讲一个大事。&lt;/p>
&lt;p>当你想要买一个商品，常规的做法就是打开浏览器，输入购物网站的地址。浏览器就会给你显示一个缤纷多彩的页面。&lt;/p>
&lt;p>那你有没有深入思考过，浏览器是如何做到这件事情的？它之所以能够显示缤纷多彩的页面，是因为它收到了一段来自 HTTP 协议的&amp;quot;东西&amp;quot;。我拿网易考拉来举例，格式就像下面这样：&lt;/p>
&lt;pre>&lt;code>HTTP/1.1 200 OK
Date: Tue, 27 Mar 2018 16:50:26 GMT
Content-Type: text/html;charset=UTF-8
Content-Language: zh-CN
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
&amp;lt;base href=&amp;quot;https://pages.kaola.com/&amp;quot; /&amp;gt;
&amp;lt;meta charset=&amp;quot;utf-8&amp;quot;/&amp;gt; &amp;lt;title&amp;gt; 网易考拉 3 周年主会场 &amp;lt;/title&amp;gt;
&lt;/code>&lt;/pre>
&lt;p>这符合协议的三要素吗？我带你来看一下。&lt;/p>
&lt;p>首先，符合语法，也就是说，只有按照上面那个格式来，浏览器才认。例如，上来是&lt;strong>状态&lt;/strong> ，然后是&lt;strong>首部&lt;/strong> ，然后是&lt;strong>内容&lt;/strong>。&lt;/p>
&lt;p>第二，符合语义，就是要按照约定的意思来。例如，状态 200，表述的意思是网页成功返回。如果不成功，就是我们常见的&amp;quot;404&amp;quot;。&lt;/p>
&lt;p>第三，符合顺序，你一点浏览器，就是发送出一个 HTTP 请求，然后才有上面那一串 HTTP 返回的东西。&lt;/p>
&lt;p>浏览器显然按照协议商定好的做了，最后一个五彩缤纷的页面就出现在你面前了。&lt;/p>
&lt;h2 id="-">我们常用的网络协议有哪些？&lt;/h2>
&lt;p>接下来揭秘我要说的大事情，&amp;ldquo;双十一&amp;rdquo;。这和我们要讲的网络协议有什么关系呢？&lt;/p>
&lt;p>在经济学领域，有个伦纳德·里德（Leonard E. Read）创作的《铅笔的故事》。这个故事通过一个铅笔的诞生过程，来讲述复杂的经济学理论。这里，我也用一个下单的过程，看看互联网世界的运行过程中，都使用了哪些网络协议。&lt;/p>
&lt;p>你先在浏览器里面输入 &lt;a href="https://www.kaola.com">https://www.kaola.com&lt;/a> ，这是一个&lt;strong>URL&lt;/strong> 。浏览器只知道名字是&amp;quot;www.kaola.com&amp;quot;，但是不知道具体的地点，所以不知道应该如何访问。于是，它打开地址簿去查找。可以使用一般的地址簿协议&lt;strong>DNS&lt;/strong> 去查找，还可以使用另一种更加精准的地址簿查找协议&lt;strong>HTTPDNS&lt;/strong>。&lt;/p>
&lt;p>无论用哪一种方法查找，最终都会得到这个地址：106.114.138.24。这个是&lt;strong>IP&lt;/strong>地址，是互联网世界的&amp;quot;门牌号&amp;quot;。&lt;/p>
&lt;p>知道了目标地址，浏览器就开始打包它的请求。对于普通的浏览请求，往往会使用&lt;strong>HTTP&lt;/strong> 协议；但是对于购物的请求，往往需要进行加密传输，因而会使用&lt;strong>HTTPS&lt;/strong>协议。无论是什么协议，里面都会写明&amp;quot;你要买什么和买多少&amp;quot;。﻿&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/d8/c6/d8a65ca347ad26acc9f1de49b10320c6.png" alt="">&lt;/p>
&lt;p>DNS、HTTP、HTTPS 所在的层我们称为&lt;strong>应用层&lt;/strong> 。经过应用层封装后，浏览器会将应用层的包交给下一层去完成，通过 socket 编程来实现。下一层是&lt;strong>传输层&lt;/strong> 。传输层有两种协议，一种是无连接的协议&lt;strong>UDP&lt;/strong> ，一种是面向连接的协议&lt;strong>TCP&lt;/strong>。对于支付来讲，往往使用 TCP 协议。所谓的面向连接就是，TCP 会保证这个包能够到达目的地。如果不能到达，就会重新发送，直至到达。&lt;/p>
&lt;p>TCP 协议里面会有两个端口，一个是浏览器监听的端口，一个是电商的服务器监听的端口。操作系统往往通过端口来判断，它得到的包应该给哪个进程。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/53/ee/53c753a7d49c9dfe3cfeb26497e47eee.png" alt="">&lt;/p>
&lt;p>传输层封装完毕后，浏览器会将包交给操作系统的&lt;strong>网络层&lt;/strong>。网络层的协议是 IP 协议。在 IP 协议里面会有源 IP 地址，即浏览器所在机器的 IP 地址和目标 IP 地址，也即电商网站所在服务器的 IP 地址。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/45/1b/459a421975b27f6187d2aa4673171f1b.png" alt="">&lt;/p>
&lt;p>操作系统既然知道了目标 IP 地址，就开始想如何根据这个门牌号找到目标机器。操作系统往往会判断，这个目标 IP 地址是本地人，还是外地人。如果是本地人，从门牌号就能看出来，但是显然电商网站不在本地，而在遥远的地方。&lt;/p>
&lt;p>操作系统知道要离开本地去远方。虽然不知道远方在何处，但是可以这样类比一下：如果去国外要去海关，去外地就要去&lt;strong>网关&lt;/strong>。而操作系统启动的时候，就会被 DHCP 协议配置 IP 地址，以及默认的网关的 IP 地址 192.168.1.1。&lt;/p>
&lt;p>操作系统如何将 IP 地址发给网关呢？在本地通信基本靠吼，于是操作系统大吼一声，谁是 192.168.1.1 啊？网关会回答它，我就是，我的本地地址在村东头。这个本地地址就是&lt;strong>MAC&lt;/strong> 地址，而大吼的那一声是&lt;strong>ARP&lt;/strong>协议。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/cc/4f/cc02190ac57af7fb6c3839534f2b674f.png" alt="">&lt;/p>
&lt;p>于是操作系统将 IP 包交给了下一层，也就是&lt;strong>MAC 层&lt;/strong>。网卡再将包发出去。由于这个包里面是有 MAC 地址的，因而它能够到达网关。&lt;/p>
&lt;p>网关收到包之后，会根据自己的知识，判断下一步应该怎么走。网关往往是一个路由器，到某个 IP 地址应该怎么走，这个叫作路由表。&lt;/p>
&lt;p>路由器有点像玄奘西行路过的一个个国家的一个个城关。每个城关都连着两个国家，每个国家相当于一个局域网，在每个国家内部，都可以使用本地的地址 MAC 进行通信。&lt;/p>
&lt;p>一旦跨越城关，就需要拿出 IP 头来，里面写着贫僧来自东土大唐（就是源 IP 地址），欲往西天拜佛求经（指的是目标 IP 地址）。路过宝地，借宿一晚，明日启行，请问接下来该怎么走啊？﻿&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/f7/e2/f7ea602aec91c67b35e710fb72a975e2.png" alt="">&lt;/p>
&lt;p>城关往往是知道这些&amp;quot;知识&amp;quot;的，因为城关和临近的城关也会经常沟通。到哪里应该怎么走，这种沟通的协议称为&lt;strong>路由协议&lt;/strong> ，常用的有&lt;strong>OSPF&lt;/strong> 和&lt;strong>BGP&lt;/strong>。﻿&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/b2/d4/b25ad7afba7b79331d95875dd0f451d4.png" alt="">&lt;/p>
&lt;p>城关与城关之间是一个国家，当网络包知道了下一步去哪个城关，还是要使用国家内部的 MAC 地址，通过下一个城关的 MAC 地址，找到下一个城关，然后再问下一步的路怎么走，一直到走出最后一个城关。&lt;/p>
&lt;p>最后一个城关知道这个网络包要去的地方。于是，对着这个国家吼一声，谁是目标 IP 啊？目标服务器就会回复一个 MAC 地址。网络包过关后，通过这个 MAC 地址就能找到目标服务器。&lt;/p>
&lt;p>目标服务器发现 MAC 地址对上了，取下 MAC 头来，发送给操作系统的网络层。发现 IP 也对上了，就取下 IP 头。IP 头里会写上一层封装的是 TCP 协议，然后将其交给传输层，即&lt;strong>TCP 层&lt;/strong>。&lt;/p>
&lt;p>在这一层里，对于收到的每个包，都会有一个回复的包说明收到了。这个回复的包绝非这次下单请求的结果，例如购物是否成功，扣了多少钱等，而仅仅是 TCP 层的一个说明，即收到之后的回复。当然这个回复，会沿着刚才来的方向走回去，报个平安。&lt;/p>
&lt;p>因为一旦出了国门，西行路上千难万险，如果在这个过程中，网络包走丢了，例如进了大沙漠，或者被强盗抢劫杀害怎么办呢？因而到了要报个平安。&lt;/p>
&lt;p>如果过一段时间还是没到，发送端的 TCP 层会重新发送这个包，还是上面的过程，直到有一天收到平安到达的回复。&lt;strong>这个重试绝非你的浏览器重新将下单这个动作重新请求一次&lt;/strong>。对于浏览器来讲，就发送了一次下单请求，TCP 层不断自己闷头重试。除非 TCP 这一层出了问题，例如连接断了，才轮到浏览器的应用层重新发送下单请求。&lt;/p>
&lt;p>当网络包平安到达 TCP 层之后，TCP 头中有目标端口号，通过这个端口号，可以找到电商网站的进程正在监听这个端口号，假设一个 Tomcat，将这个包发给电商网站。﻿&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/b4/3f/b465ccfafe333bfdfb9daf78f96e123f.png" alt="">&lt;/p>
&lt;p>电商网站的进程得到 HTTP 请求的内容，知道了要买东西，买多少。往往一个电商网站最初接待请求的这个 Tomcat 只是个接待员，负责统筹处理这个请求，而不是所有的事情都自己做。例如，这个接待员要告诉专门管理订单的进程，登记要买某个商品，买多少，要告诉管理库存的进程，库存要减少多少，要告诉支付的进程，应该付多少钱，等等。&lt;/p>
&lt;p>如何告诉相关的进程呢？往往通过 RPC 调用，即远程过程调用的方式来实现。远程过程调用就是当告诉管理订单进程的时候，接待员不用关心中间的网络互连问题，会由 RPC 框架统一处理。RPC 框架有很多种，有基于 HTTP 协议放在 HTTP 的报文里面的，有直接封装在 TCP 报文里面的。&lt;/p>
&lt;p>当接待员发现相应的部门都处理完毕，就回复一个 HTTPS 的包，告知下单成功。这个 HTTPS 的包，会像来的时候一样，经过千难万险到达你的个人电脑，最终进入浏览器，显示支付成功。&lt;/p>
&lt;h2 id="-">小结&lt;/h2>
&lt;p>看到了吧，一个简简单单的下单过程，中间牵扯到这么多的协议。而管理一大片机器，更是一件特别有技术含量的事情。除此之外，像最近比较火的云计算、容器、微服务等技术，也都需要借助各种协议，来达成大规模机器之间的合作。&lt;/p>
&lt;p>我在这里列一下之后要讲的网络协议，之后我会按照从底层到上层的顺序来讲述。﻿&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/af/34/afde9b4b90ee1c43c53948ab85fd6734.jpg" alt="">&lt;/p>
&lt;p>上面的&amp;quot;双十一&amp;quot;故事只是为了给你一个大致的框架，这里面有些协议，我在故事里已经提到了，有些还没有提到。在这门课的最后一章，当所有的协议都讲过之后，我会再重新讲一遍这个故事，到时候你就能明白更多的细节。&lt;/p>
&lt;p>最后，学完了这一节，给你留一个问题吧。&lt;/p>
&lt;p>当网络包到达一个城关的时候，可以通过路由表得到下一个城关的 IP 地址，直接通过 IP 地址找就可以了，为什么还要通过本地的 MAC 地址呢？&lt;/p>
&lt;p>欢迎你留言和我讨论。趣谈网络协议，我们下期见！&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/b5/fb/b5bc14cb81d3630919fee94a512cc3fb.jpg" alt="">&lt;/p></description></item><item><title>极客专栏: 01丨如何制定性能调优标准？</title><link>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98/01%E4%B8%A8%E5%A6%82%E4%BD%95%E5%88%B6%E5%AE%9A%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E6%A0%87%E5%87%86/</link><pubDate>Fri, 08 Jul 2022 00:00:00 +0000</pubDate><guid>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98/01%E4%B8%A8%E5%A6%82%E4%BD%95%E5%88%B6%E5%AE%9A%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E6%A0%87%E5%87%86/</guid><description>
&lt;p>你好，我是刘超。&lt;/p>
&lt;p>我有一个朋友，有一次他跟我说，他们公司的系统从来没有经过性能调优，功能测试完成后就上线了，线上也没有出现过什么性能问题呀，那为什么很多系统都要去做性能调优呢？&lt;/p>
&lt;p>当时我就回答了他一句，如果你们公司做的是 12306 网站，不做系统性能优化就上线，试试看会是什么情况。&lt;/p>
&lt;p>如果是你，你会怎么回答呢？今天，我们就从这个话题聊起，希望能跟你一起弄明白这几个问题：我们为什么要做性能调优？什么时候开始做？做性能调优是不是有标准可参考？&lt;/p>
&lt;h2 id="为什么要做性能调优">为什么要做性能调优？&lt;/h2>
&lt;p>一款线上产品如果没有经过性能测试，那它就好比是一颗定时炸弹，你不知道它什么时候会出现问题，你也不清楚它能承受的极限在哪儿。&lt;/p>
&lt;p>有些性能问题是时间累积慢慢产生的，到了一定时间自然就爆炸了；而更多的性能问题是由访问量的波动导致的，例如，活动或者公司产品用户量上升；当然也有可能是一款产品上线后就半死不活，一直没有大访问量，所以还没有引发这颗定时炸弹。&lt;/p>
&lt;p>现在假设你的系统要做一次活动，产品经理或者老板告诉你预计有几十万的用户访问量，询问系统能否承受得住这次活动的压力。如果你不清楚自己系统的性能情况，也只能战战兢兢地回答老板，有可能大概没问题吧。&lt;/p>
&lt;p>所以，要不要做性能调优，这个问题其实很好回答。所有的系统在开发完之后，多多少少都会有性能问题，我们首先要做的就是想办法把问题暴露出来，例如进行压力测试、模拟可能的操作场景等等，再通过性能调优去解决这些问题。&lt;/p>
&lt;p>比如，当你在用某一款 App 查询某一条信息时，需要等待十几秒钟；在抢购活动中，无法进入活动页面等等。你看，系统响应就是体现系统性能最直接的一个参考因素。&lt;/p>
&lt;p>那如果系统在线上没有出现响应问题，我们是不是就不用去做性能优化了呢？再给你讲一个故事吧。&lt;/p>
&lt;p>曾经我的前前东家系统研发部门来了一位大神，为什么叫他大神，因为在他来公司的一年时间里，他只做了一件事情，就是把服务器的数量缩减到了原来的一半，系统的性能指标，反而还提升了。&lt;/p>
&lt;p>好的系统性能调优不仅仅可以提高系统的性能，还能为公司节省资源。这也是我们做性能调优的最直接的目的。&lt;/p>
&lt;h2 id="什么时候开始介入调优">什么时候开始介入调优？&lt;/h2>
&lt;p>解决了为什么要做性能优化的问题，那么新的问题就来了：如果需要对系统做一次全面的性能监测和优化，我们从什么时候开始介入性能调优呢？是不是越早介入越好？&lt;/p>
&lt;p>其实，在项目开发的初期，我们没有必要过于在意性能优化，这样反而会让我们疲于性能优化，不仅不会给系统性能带来提升，还会影响到开发进度，甚至获得相反的效果，给系统带来新的问题。&lt;/p>
&lt;p>我们只需要在代码层面保证有效的编码，比如，减少磁盘 I/O 操作、降低竞争锁的使用以及使用高效的算法等等。遇到比较复杂的业务，我们可以充分利用设计模式来优化业务代码。例如，设计商品价格的时候，往往会有很多折扣活动、红包活动，我们可以用装饰模式去设计这个业务。&lt;/p>
&lt;p>在系统编码完成之后，我们就可以对系统进行性能测试了。这时候，产品经理一般会提供线上预期数据，我们在提供的参考平台上进行压测，通过性能分析、统计工具来统计各项性能指标，看是否在预期范围之内。&lt;/p>
&lt;p>在项目成功上线后，我们还需要根据线上的实际情况，依照日志监控以及性能统计日志，来观测系统性能问题，一旦发现问题，就要对日志进行分析并及时修复问题。&lt;/p>
&lt;h2 id="有哪些参考因素可以体现系统的性能">有哪些参考因素可以体现系统的性能？&lt;/h2>
&lt;p>上面我们讲到了在项目研发的各个阶段性能调优是如何介入的，其中多次讲到了性能指标，那么性能指标到底有哪些呢？&lt;/p>
&lt;p>在我们了解性能指标之前，我们先来了解下哪些计算机资源会成为系统的性能瓶颈。&lt;/p>
&lt;p>&lt;strong>CPU&lt;/strong>：有的应用需要大量计算，他们会长时间、不间断地占用 CPU 资源，导致其他资源无法争夺到 CPU 而响应缓慢，从而带来系统性能问题。例如，代码递归导致的无限循环，正则表达式引起的回溯，JVM 频繁的 FULL GC，以及多线程编程造成的大量上下文切换等，这些都有可能导致 CPU 资源繁忙。&lt;/p>
&lt;p>&lt;strong>内存&lt;/strong>：Java 程序一般通过 JVM 对内存进行分配管理，主要是用 JVM 中的堆内存来存储 Java 创建的对象。系统堆内存的读写速度非常快，所以基本不存在读写性能瓶颈。但是由于内存成本要比磁盘高，相比磁盘，内存的存储空间又非常有限。所以当内存空间被占满，对象无法回收时，就会导致内存溢出、内存泄露等问题。&lt;/p>
&lt;p>&lt;strong>磁盘 I/O&lt;/strong>：磁盘相比内存来说，存储空间要大很多，但磁盘 I/O 读写的速度要比内存慢，虽然目前引入的 SSD 固态硬盘已经有所优化，但仍然无法与内存的读写速度相提并论。&lt;/p>
&lt;p>&lt;strong>网络&lt;/strong>：网络对于系统性能来说，也起着至关重要的作用。如果你购买过云服务，一定经历过，选择网络带宽大小这一环节。带宽过低的话，对于传输数据比较大，或者是并发量比较大的系统，网络就很容易成为性能瓶颈。&lt;/p>
&lt;p>&lt;strong>异常&lt;/strong>：Java 应用中，抛出异常需要构建异常栈，对异常进行捕获和处理，这个过程非常消耗系统性能。如果在高并发的情况下引发异常，持续地进行异常处理，那么系统的性能就会明显地受到影响。&lt;/p>
&lt;p>&lt;strong>数据库&lt;/strong>：大部分系统都会用到数据库，而数据库的操作往往是涉及到磁盘 I/O 的读写。大量的数据库读写操作，会导致磁盘 I/O 性能瓶颈，进而导致数据库操作的延迟性。对于有大量数据库读写操作的系统来说，数据库的性能优化是整个系统的核心。&lt;/p>
&lt;p>&lt;strong>锁竞争&lt;/strong>：在并发编程中，我们经常会需要多个线程，共享读写操作同一个资源，这个时候为了保持数据的原子性（即保证这个共享资源在一个线程写的时候，不被另一个线程修改），我们就会用到锁。锁的使用可能会带来上下文切换，从而给系统带来性能开销。JDK1.6 之后，Java 为了降低锁竞争带来的上下文切换，对 JVM 内部锁已经做了多次优化，例如，新增了偏向锁、自旋锁、轻量级锁、锁粗化、锁消除等。而如何合理地使用锁资源，优化锁资源，就需要你了解更多的操作系统知识、Java 多线程编程基础，积累项目经验，并结合实际场景去处理相关问题。&lt;/p>
&lt;p>了解了上面这些基本内容，我们可以得到下面几个指标，来衡量一般系统的性能。&lt;/p>
&lt;h3 id="响应时间">响应时间&lt;/h3>
&lt;p>响应时间是衡量系统性能的重要指标之一，响应时间越短，性能越好，一般一个接口的响应时间是在毫秒级。在系统中，我们可以把响应时间自下而上细分为以下几种：&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/7b/f7/7b9946fd1a3512ded6d2ab0e563870f7.jpg" alt="">&lt;/p>
&lt;ul>
&lt;li>数据库响应时间：数据库操作所消耗的时间，往往是整个请求链中最耗时的；&lt;/li>
&lt;li>服务端响应时间：服务端包括 Nginx 分发的请求所消耗的时间以及服务端程序执行所消耗的时间；&lt;/li>
&lt;li>网络响应时间：这是网络传输时，网络硬件需要对传输的请求进行解析等操作所消耗的时间；&lt;/li>
&lt;li>客户端响应时间：对于普通的 Web、App 客户端来说，消耗时间是可以忽略不计的，但如果你的客户端嵌入了大量的逻辑处理，消耗的时间就有可能变长，从而成为系统的瓶颈。&lt;/li>
&lt;/ul>
&lt;h3 id="吞吐量">吞吐量&lt;/h3>
&lt;p>在测试中，我们往往会比较注重系统接口的 TPS（每秒事务处理量），因为 TPS 体现了接口的性能，TPS 越大，性能越好。在系统中，我们也可以把吞吐量自下而上地分为两种：磁盘吞吐量和网络吞吐量。&lt;/p>
&lt;p>我们先来看&lt;strong>磁盘吞吐量&lt;/strong>，磁盘性能有两个关键衡量指标。&lt;/p>
&lt;p>一种是 IOPS（Input/Output Per Second），即每秒的输入输出量（或读写次数），这种是指单位时间内系统能处理的 I/O 请求数量，I/O 请求通常为读或写数据操作请求，关注的是随机读写性能。适应于随机读写频繁的应用，如小文件存储（图片）、OLTP 数据库、邮件服务器。&lt;/p>
&lt;p>另一种是数据吞吐量，这种是指单位时间内可以成功传输的数据量。对于大量顺序读写频繁的应用，传输大量连续数据，例如，电视台的视频编辑、视频点播 VOD（Video On Demand），数据吞吐量则是关键衡量指标。&lt;/p>
&lt;p>接下来看&lt;strong>网络吞吐量&lt;/strong>，这个是指网络传输时没有帧丢失的情况下，设备能够接受的最大数据速率。网络吞吐量不仅仅跟带宽有关系，还跟 CPU 的处理能力、网卡、防火墙、外部接口以及 I/O 等紧密关联。而吞吐量的大小主要由网卡的处理能力、内部程序算法以及带宽大小决定。&lt;/p>
&lt;h3 id="计算机资源分配使用率">计算机资源分配使用率&lt;/h3>
&lt;p>通常由 CPU 占用率、内存使用率、磁盘 I/O、网络 I/O 来表示资源使用率。这几个参数好比一个木桶，如果其中任何一块木板出现短板，任何一项分配不合理，对整个系统性能的影响都是毁灭性的。&lt;/p>
&lt;h3 id="负载承受能力">负载承受能力&lt;/h3>
&lt;p>当系统压力上升时，你可以观察，系统响应时间的上升曲线是否平缓。这项指标能直观地反馈给你，系统所能承受的负载压力极限。例如，当你对系统进行压测时，系统的响应时间会随着系统并发数的增加而延长，直到系统无法处理这么多请求，抛出大量错误时，就到了极限。&lt;/p>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>通过今天的学习，我们知道性能调优可以使系统稳定，用户体验更佳，甚至在比较大的系统中，还能帮公司节约资源。&lt;/p>
&lt;p>但是在项目的开始阶段，我们没有必要过早地介入性能优化，只需在编码的时候保证其优秀、高效，以及良好的程序设计。&lt;/p>
&lt;p>在完成项目后，我们就可以进行系统测试了，我们可以将以下性能指标，作为性能调优的标准，响应时间、吞吐量、计算机资源分配使用率、负载承受能力。&lt;/p>
&lt;p>回顾我自己的项目经验，有电商系统、支付系统以及游戏充值计费系统，用户级都是千万级别，且要承受各种大型抢购活动，所以我对系统的性能要求非常苛刻。除了通过观察以上指标来确定系统性能的好坏，还需要在更新迭代中，充分保障系统的稳定性。&lt;/p>
&lt;p>这里，**给你延伸一个方法，**就是将迭代之前版本的系统性能指标作为参考标准，通过自动化性能测试，校验迭代发版之后的系统性能是否出现异常，这里就不仅仅是比较吞吐量、响应时间、负载能力等直接指标了，还需要比较系统资源的 CPU 占用率、内存使用率、磁盘 I/O、网络 I/O 等几项间接指标的变化。&lt;/p>
&lt;h2 id="思考题">思考题&lt;/h2>
&lt;p>除了以上这些常见的性能参考指标，你是否还能想到其他可以衡量系统性能的指标呢？&lt;/p>
&lt;p>期待在留言区看到你的见解。也欢迎你点击&amp;quot;请朋友读&amp;quot;，把今天的内容分享给身边的朋友，邀请他一起讨论。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/bb/67/bbe343640d6b708832c4133ec53ed967.jpg" alt="unpreview">&lt;/p></description></item><item><title>极客专栏: 01丨“老周，我想知道”丨常见法律认知盲区（一）</title><link>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E7%99%BD%E8%AF%9D%E6%B3%95%E5%BE%8B/01%E4%B8%A8%E8%80%81%E5%91%A8%E6%88%91%E6%83%B3%E7%9F%A5%E9%81%93%E4%B8%A8%E5%B8%B8%E8%A7%81%E6%B3%95%E5%BE%8B%E8%AE%A4%E7%9F%A5%E7%9B%B2%E5%8C%BA%E4%B8%80/</link><pubDate>Tue, 07 Jun 2022 00:00:00 +0000</pubDate><guid>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E7%99%BD%E8%AF%9D%E6%B3%95%E5%BE%8B/01%E4%B8%A8%E8%80%81%E5%91%A8%E6%88%91%E6%83%B3%E7%9F%A5%E9%81%93%E4%B8%A8%E5%B8%B8%E8%A7%81%E6%B3%95%E5%BE%8B%E8%AE%A4%E7%9F%A5%E7%9B%B2%E5%8C%BA%E4%B8%80/</guid><description>
&lt;p>在学习三大主题之前，我想先帮你扫除一些常识上的盲区，所以选取了以往咨询者最迷惑的十个问题，并给出了相应的解答。接下来我们来看这些问答。&lt;/p>
&lt;p>&lt;strong>第一问：到法院打官司最重要的是找关系？打官司就是打关系吗？&lt;/strong>&lt;/p>
&lt;p>&lt;strong>老周答&lt;/strong>：当律师到现在，我最大的感受就是，如果你一遇事，就急慌慌地先去找关系，去找那些号称关系很&amp;quot;硬&amp;quot;的人，那么往往会走向歪路，把简单的问题复杂化，最后的结局基本上不是被骗就是被黑。要么你的事情根本解决不了，要么你就得多花好几倍的冤枉钱。&lt;/p>
&lt;p>我想从法律人的视角告诉你，打官司就是打是非曲直，靠的是证据。遇到事情时，尽可能先找专业人士了解一下原则性问题，会用证据和法律才是真正的保障。&lt;/p>
&lt;p>&lt;strong>第二问：打官司的流程是什么？&lt;/strong>&lt;/p>
&lt;p>&lt;strong>老周答&lt;/strong>：打官司，其实就是我们在法律上所说的&amp;quot;诉讼&amp;quot;，我总结为&amp;quot;告状七步曲&amp;quot;。&lt;/p>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>准备&lt;/strong>：搜集证据，并写好起诉状。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>立案&lt;/strong>：带上起诉状、身份证原件及复印件、相关证据的复印件到有管辖权的法院立案。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>等通知&lt;/strong>：立案后会当场发传票确定开庭时间，或者等法院的后续通知确定，现在一般为后者。如果收到法院的快递，一定要仔细阅读，里面可能有举证期限、答辩时间等，都很重要。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>开庭&lt;/strong>：按规定的时间到法院开庭，要带上证据原件，涉及到的法律法规也要充分准备好。也许只有这一次庭审机会，一定要带齐证据，不然&amp;quot;有证不举等于无证&amp;quot;。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>等待一审判决&lt;/strong>：开完庭后，就该等待接收判决结果了，由于每个法官手中案子较多，等待时间可能会比较长。判决书主要邮寄送达或者通知领取，现在也在推行电子送达。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>等待生效或二审&lt;/strong>：如果任意一方对一审的判决结果不服，可以在 15 天内提起上诉，进入二审；如果双方都服从一审的判决，那就等待判决生效。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>判决生效并执行&lt;/strong>：判决生效后，正常按照判决执行；如果对方没执行，可以向法院申请强制执行。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>第三问：打官司，需要多少钱？&lt;/strong>&lt;/p>
&lt;p>&lt;strong>老周答&lt;/strong> ：打官司的主要费用分两块：一个是&lt;strong>诉讼费&lt;/strong> 。去法院起诉时，法院会根据诉讼费收费标准，对不同案件收取不同的费用；另一个是律师费，如果聘请律师，你就需要支付&lt;strong>律师费&lt;/strong>。每个律师事务所的收费标准都不太一样，每个律师报价方式也不同，所以具体费用要看双方协商的结果。&lt;/p>
&lt;p>这里我要强调一点，&lt;strong>符合法律援助条件的案件不收取律师费用&lt;/strong>。你可以向当地司法局的法律援助中心咨询，如果符合条件，申请法律援助，便会有律师来免费代理。&lt;/p>
&lt;p>另外，律师每年也会做&lt;strong>公益案件&lt;/strong>，如果家里经济困难或有特殊情况，可以和律师事务所或者律师直接沟通。&lt;/p>
&lt;p>&lt;strong>第四问：符合法律援助的条件是什么？&lt;/strong>&lt;/p>
&lt;p>&lt;strong>老周答&lt;/strong> ：首先要&lt;strong>符合经济困难的情况&lt;/strong>，这里的经济困难主要是指各地的低保户水平。如果符合，在遇到下列几种情况时，可以向法律援助机构申请法律援助。&lt;/p>
&lt;ol>
&lt;li>
&lt;p>请求国家赔偿。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>请求发放抚恤金、抚养费等。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>请求支付劳动报酬。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>请求社保或低保待遇。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>解决因见义勇为而产生的民事纠纷。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>另外，&lt;strong>刑事案件辩护&lt;/strong>目前正在北京、上海等地试点。也就是说，在这些地方，刑事案件的被告人即使没律师，也会有法律援助律师来为其辩护。试点期结束后，这一措施预计会在全国推行。&lt;/p>
&lt;p>&lt;strong>第五问：什么情况下我需要请律师？&lt;/strong>&lt;/p>
&lt;p>&lt;strong>老周答&lt;/strong>：事实上，如果经济条件允许，我建议遇到法律纠纷时，都优先考虑请律师，毕竟专业事情让专业人士来处理，更能找到关键来解决问题。&lt;/p>
&lt;p>此外，如果你有这两种困扰，就该考虑请律师了。&lt;/p>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>证据不足&lt;/strong>。如果手头的证据不足，或者是取证本身比较困难时，尽量请律师代理。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>案件复杂&lt;/strong>。比如在合同问题上，如果钱财的流转复杂，或者是有争议的数目比较大，就应该找专业人士来分析。再如，民事诉讼是根据你的请求来判决的，通常适用&amp;quot;不告不理&amp;quot;的原则，也就是说，哪怕你符合了某个赔偿的规定，如果自己没有主动提出赔偿的请求，法院就不会去判决，而有律师在，你就不会吃这个亏了。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>第六问：如何选择律师？&lt;/strong>&lt;/p>
&lt;p>&lt;strong>老周答&lt;/strong> ：我可以给出几点选择律师的参考意见，你可以简单记为&amp;quot;&lt;strong>三要两不要&lt;/strong>&amp;quot;。&lt;/p>
&lt;p>三要：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>要挑选正规的律师事务所，并要约定在律师的执业办公地点见面，考察律师事务所的实力；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>要查清楚律师的资质，必须有《律师执业证》；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>要和律师当面交流、谈案子，听律师的法律分析是否专业、理性，判断律师的能力。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>两不要：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>不要选择所谓的&amp;quot;关系&amp;quot;律师，张嘴就是和法院某某很熟的，一般不靠谱；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>不要选择那些吹牛的律师，有一大堆头衔还号称必赢的，一般都是忽悠。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>最后，一定要明确知道你在事务所最终请到的律师是谁，是谁替你出庭。在选好律师后，还要和律师事务所&lt;strong>签订一份委托代理协议&lt;/strong>，协议会明确规定收费的问题，包括具体费用、付款方式及期限等。所以，在签协议时一定要细心耐心，确认好这些地方。&lt;/p>
&lt;p>&lt;strong>第七问：请律师打官司，输了还要给律师钱吗？&lt;/strong>&lt;/p>
&lt;p>&lt;strong>老周答&lt;/strong>：这里我们需要分民事诉讼、刑事诉讼两种情况来了解律师费用。&lt;/p>
&lt;p>如果律师代理的是民事诉讼，一般有两种方式。一种是&lt;strong>风险代理&lt;/strong> ，其中就有根据结果来收费的情况，当然，这种代理方式相对来说比较少。另一种是&lt;strong>普通代理&lt;/strong>，通常是签合同并收取律师费，不管最后的结果如何，费用都不会退还，所以前期挑个好律师很重要。&lt;/p>
&lt;p>如果律师代理的是刑事诉讼，那就只有普通代理这一种方式，跟民事诉讼一样，签合同并收费，与最终的结果无关。&lt;/p>
&lt;p>因此，大部分情况下，律师费和&amp;quot;输赢&amp;quot;没有关系。只有少部分的民事诉讼，可以根据双方的约定来付费，也就可能存在&amp;quot;输了不用给钱&amp;quot;的情况。但是，具体什么算是&amp;quot;输了&amp;quot;，还是要看一开始签订的协议的规定。&lt;/p>
&lt;p>事实上，&amp;ldquo;胜了才付费、输了不付费&amp;quot;一般只能当宣传语听听，一个专业、负责的律师，会更客观理性地对待案件，而不是打包票来吸引注意。我们还是要记住&amp;quot;三要两不要&amp;quot;的挑选原则，再有就是重点关注代理协议了。&lt;/p>
&lt;p>&lt;strong>第八问：民事案件与刑事案件的差别是什么？&lt;/strong>&lt;/p>
&lt;p>&lt;strong>老周答&lt;/strong>：简单来说，民事案件是指民事纠纷不能协商时，需要向法院起诉来解决。我们生活中的大多数问题属于民事纠纷，比如合同纠纷、交通事故纠纷、婚姻家庭纠纷、继承纠纷等。民事案件的一般流程是，某一方向法院起诉，获得判决。起诉的一方叫原告，被起诉的一方叫被告。&lt;/p>
&lt;p>刑事案件可以理解为，某人犯了罪，触犯了刑法，然后被抓了。这就是一个简单的刑事案件模型，而这个犯罪的人，被称为犯罪嫌疑人或被告人。刑事案件的一般流程是公安立案侦察、检察院审查起诉、最后法院来审判，并进行刑事处罚。罚金、拘役、有期徒刑、死刑、剥夺政治权利等这些熟悉的名词，都属于刑事处罚。&lt;/p>
&lt;p>共同点：两种案件都以起诉作为法院审判的前提。刑事案件一般由检察机关提起公诉，民事案件则是由原告人起诉，这样法院才会审判。&lt;/p>
&lt;p>不同点：后果上来看，民事案件的结果一般为要求停止侵权行为、赔偿经济损失或者违约金等；刑事案件的结果一般会有判刑，除了罚钱还需要坐牢。&lt;/p>
&lt;p>&lt;strong>第九问：劳动仲裁需要花多长时间、多少钱呢？&lt;/strong>&lt;/p>
&lt;p>&lt;strong>老周答&lt;/strong> ：劳动仲裁与职场问题关系密切，我们在讲职场纠纷时经常会提到。它一般解决员工和单位在劳动合同上的纠纷，并且是&lt;strong>不收费&lt;/strong>的。&lt;/p>
&lt;p>通常整个流程会花费 45 天时间，延长的话&lt;strong>最多也会在 60 天内结案&lt;/strong>。如果被仲裁的一方，对劳动仲裁的结果不服，可以在收到裁决书起的 15 天内向法院起诉，由法院审理；如果不起诉，满 15 天裁决书就会生效了。&lt;/p>
&lt;p>&lt;strong>第十问：能不能介绍下与个人关系比较密切的法律，并说说它们分别覆盖什么领域？&lt;/strong>&lt;/p>
&lt;p>&lt;strong>老周答&lt;/strong>：我们生活中会接触到的法律主要有这么几个。&lt;/p>
&lt;ol>
&lt;li>
&lt;p>《劳动合同法》解决职工和单位在劳动合同上的纠纷，覆盖职场领域。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>《婚姻法》解决基本的婚姻家庭关系纠纷，其中一些有争议的事项在相关的司法解释里，覆盖婚姻家庭领域。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>《合同法》内容比较多，劳动合同之外的其他合同规定都包括在内，因此，职场、生活领域都有覆盖。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>《刑法》讲的是什么事儿犯罪、什么事儿不犯罪以及犯了罪怎么罚的问题，可以说是成年人的行为准则，覆盖面也很广。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>今天我们主要扫清这十个盲区，当然，比较常见、常用的法律知识，在后续课程中我都会讲到。&lt;/p>
&lt;p>那么，在法律的认知方面，你还有什么疑惑想问我，或者有什么心得想要和我分享的吗？欢迎留言告诉我，也欢迎点击右下方的&amp;rdquo;&lt;strong>请朋友读&lt;/strong>&amp;quot;，把今天所学分享给你的家人、朋友。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/10/ae/109d74bf33e68fa4206ce2ae524c75ae.jpg" alt="">&lt;/p></description></item><item><title>极客专栏: 01丨从条件运算符说起，反思什么是好代码</title><link>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E4%BB%A3%E7%A0%81%E7%B2%BE%E8%BF%9B%E4%B9%8B%E8%B7%AF/01%E4%B8%A8%E4%BB%8E%E6%9D%A1%E4%BB%B6%E8%BF%90%E7%AE%97%E7%AC%A6%E8%AF%B4%E8%B5%B7%E5%8F%8D%E6%80%9D%E4%BB%80%E4%B9%88%E6%98%AF%E5%A5%BD%E4%BB%A3%E7%A0%81/</link><pubDate>Tue, 07 Jun 2022 00:00:00 +0000</pubDate><guid>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E4%BB%A3%E7%A0%81%E7%B2%BE%E8%BF%9B%E4%B9%8B%E8%B7%AF/01%E4%B8%A8%E4%BB%8E%E6%9D%A1%E4%BB%B6%E8%BF%90%E7%AE%97%E7%AC%A6%E8%AF%B4%E8%B5%B7%E5%8F%8D%E6%80%9D%E4%BB%80%E4%B9%88%E6%98%AF%E5%A5%BD%E4%BB%A3%E7%A0%81/</guid><description>
&lt;p>写出优秀的代码是我们每一个程序员的毕生追求，毕竟写代码本身就是个技术活，代码的好坏，其实也就是我们工艺的好坏。作为一个技术类的工种，我们没有理由不去思考如何写出优秀、让人惊叹的代码。&lt;/p>
&lt;p>那什么样的代码才是优秀的代码呢？对于这个问题，我想每个人心中都会有自己的答案。今天我就来和你聊聊我的思考。&lt;/p>
&lt;p>对于条件运算符（?:）的使用，我估摸着你看到过相关的争论，或者自己写代码的时候也不知道到底该不该使用条件运算符，或者什么情况下使用？这些微不足道的小话题随时都可以挑起激烈的争论。&lt;/p>
&lt;p>C 语言之父丹尼斯·里奇就属于支持者。在《C 程序设计语言》这本书里，他使用了大量简短、直观的条件运算符。&lt;/p>
&lt;p>然而还有一些人，对条件运算符完全丧失了好感，甚至把&amp;quot;永远不要使用条件运算符&amp;quot;作为一条 C 语言高效编程的重要技巧。&lt;/p>
&lt;p>比如说吧，下面的这个例子，第一段代码使用条件语句，第二段代码使用条件运算符。 你觉得哪一段代码更&amp;quot;优秀&amp;quot;呢？&lt;/p>
&lt;pre>&lt;code>if (variable != null) {
return variable.getSomething();
}
return null;
return variable != null ? variable.getSomething() : null;
&lt;/code>&lt;/pre>
&lt;p>同样使用条件运算符，你会喜欢下面代码吗？&lt;/p>
&lt;pre>&lt;code>return x &amp;gt;= 90 ? &amp;quot;A&amp;quot; : x &amp;gt;= 80 ? &amp;quot;B&amp;quot; : x &amp;gt;= 70 ? &amp;quot;C&amp;quot; : x &amp;gt;= 60 ? &amp;quot;D&amp;quot; : &amp;quot;E&amp;quot;;
&lt;/code>&lt;/pre>
&lt;p>十多年前，作为一名 C 语言程序员，我非常喜欢使用条件运算符。因为条件运算符的这种压缩方式，使代码看起来简短、整洁、干净。 而且，如果能把代码以最少的行数、最简短的方式表达出来，心里也颇有成就感。&lt;/p>
&lt;p>后来，我的一位同事告诉我，对于我使用的条件运算符的部分代码，他要仔细分析才知道这一小行代码想要表达的逻辑，甚至有时候还要翻翻书、查查操作符的优先级和运算顺序，拿笔画一画逻辑关系，才能搞清楚这一小行代码有没有疏漏。&lt;/p>
&lt;p>这么简单的代码，为什么还要确认运算符的优先级和运算顺序呢？因为只是&amp;quot;看起来&amp;quot;对的代码，其实特别容易出问题。所以，一定要反复查验、确认无误才能放心。&lt;/p>
&lt;p>这么简单的代码，真的需要这么认真检查吗？超级简单的代码的错误，往往是我们最容易犯的一类编码错误。我个人就是犯过很多次这种低级、幼稚的错误，并且以后一定还会再犯。比如下面的这段有问题的代码，就是我最近犯的一个非常低级的代码错误：&lt;/p>
&lt;pre>&lt;code>// Map for debug logging. Enable debug log if SSLLogger is on.
private final Map&amp;lt;Integer, byte[]&amp;gt; logMap =
SSLLogger.isOn ? null : new LinkedHashMap&amp;lt;&amp;gt;();
&lt;/code>&lt;/pre>
&lt;p>正确的代码应该是：&lt;/p>
&lt;pre>&lt;code>// Map for debug logging. Enable debug log if SSLLogger is on.
private final Map&amp;lt;Integer, byte[]&amp;gt; logMap =
SSLLogger.isOn ? new LinkedHashMap&amp;lt;&amp;gt;() : null;
&lt;/code>&lt;/pre>
&lt;p>你可能会说，这个代码错误看起来太幼稚、太低级、太可笑了吧？ 确实是这样的。这段错误的代码，我的眼睛不知道看过了它们多少次，可是这个小虫子（bug）还是华丽丽地逃脱了我的注意，进入了&lt;strong>JDK 11 的最终发布版&lt;/strong>。&lt;/p>
&lt;p>如果使用条件语句，而不是条件运算符，这个幼稚错误发生的概率会急剧下降。 &lt;strong>坚持使用最直观的编码方式，而不是追求代码简短，真的可以避免很多不必要的错误&lt;/strong>。所以说啊，选择适合的编码方式，强调代码的检查、评审、校验，真的怎么都不算过分。&lt;/p>
&lt;p>现在，如果你要再问我喜欢哪种编码方式，毫无疑问，我喜欢使用条件语句，而不是条件运算符。因为，用条件语句这种编码方式，可以给我确定感，我也不需要挑战什么高难度动作；而看代码的人，也可以很确定，很轻松，不需要去查验什么模糊的东西。&lt;/p>
&lt;p>这种阅读起来的确定性至少有三点好处，第一点是可以减少代码错误；第二点是可以节省我思考的时间；第三点是可以节省代码阅读者的时间。&lt;/p>
&lt;p>&lt;strong>减少错误、节省时间，是我们现在选择编码方式的一个最基本的原则。&lt;/strong>&lt;/p>
&lt;p>《C 程序设计语言》这本 C 程序员的圣经，初次发表于 1978 年。那个年代的代码，多数很简单直接。简短的代码，意味着节省昂贵的计算能力，是当时流行的编码偏好。而现在，计算能力不再是瓶颈，如何更高效率地开发复杂的软件，成了我们首先需要考虑的问题。&lt;/p>
&lt;p>有一些新设计的编程语言，不再提供条件运算符。 比如，Kotlin 语言的设计者认为，编写简短的代码绝对不是 Kotlin 的目标。所以，Kotlin 不支持条件运算符。 Go 语言的设计者认为，条件运算符的滥用，产生了许多难以置信的、难以理解的复杂表达式。所以，Go 语言也不支持条件运算符。&lt;/p>
&lt;p>我们看到，&lt;strong>现实环境的变化，影响着我们对于代码&amp;quot;好&amp;quot;与&amp;quot;坏&amp;quot;的判断标准。&lt;/strong>&lt;/p>
&lt;h2 id="好的代码与坏的代码">&amp;ldquo;好&amp;quot;的代码与&amp;quot;坏&amp;quot;的代码&lt;/h2>
&lt;p>虽然对于&amp;quot;什么是优秀的代码&amp;quot;难以形成一致意见，但是这么多年的经验，让我对代码&amp;quot;好&amp;quot;与&amp;quot;坏&amp;quot;积累了一些自己的看法。&lt;/p>
&lt;p>比如说，&amp;ldquo;好&amp;quot;的代码应该：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>容易理解；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>没有明显的安全问题；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>能够满足最关键的需求；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>有充分的注释；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>使用规范的命名；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>经过充分的测试。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>&amp;ldquo;坏&amp;quot;的代码包括：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>难以阅读的代码；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>浪费大量计算机资源的代码；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>代码风格混乱的代码；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>复杂的、不直观的代码；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>没有经过适当测试的代码。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>当然，上面的列表还可以很长很长，长到一篇文章都列不完、长到我们都记不住的程度。&lt;/p>
&lt;h2 id="优秀的代码是经济的代码">优秀的代码是&amp;quot;经济&amp;quot;的代码&lt;/h2>
&lt;p>大概也没人想记住这么多条标准吧？所以，&lt;strong>关于优秀代码的特点，我想用&amp;quot;经济&amp;quot;这一个词语来表达&lt;/strong> 。这里的&amp;quot;经济&amp;rdquo;，指的是使用较少的人力、物力、财力、时间、空间，来获取较大的成果或收益 。或者简单地说，&lt;strong>投入少、收益大、投资回报高&lt;/strong>。为了方便，你也可以先理解为节俭或者抠门儿的意思。&lt;/p>
&lt;p>当然，使用一个词语表达肯定是以偏概全的。但是，比起一长串的准则，一个关键词的好处是，更容易让人记住。我想这点好处可以大致弥补以偏概全的损失。&lt;/p>
&lt;p>该怎么理解&amp;quot;经济&amp;quot;呢？这需要我们把代码放到软件的整个生命周期里来考察。&lt;/p>
&lt;p>关于软件生命周期，我想你应该很熟悉了，我们一起来复习一下。一般而言，一个典型的软件生命周期，大致可以划分计划、分析和设计、代码实现、测试、运营和维护这六个阶段。在软件维护阶段，可能会有新的需求出现、新的问题产生、旧问题的浮现，这些因素可能就又要推动新一轮的计划，分析、设计、实现、测试、运营。这样，这个周期就会反复迭代，反复的循环，像一个周而复始的流水线。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/14/04/144679d37d552e4d5c436cab88582f04.png" alt="">&lt;/p>
&lt;p>当我们说投入少的时候，说的是这整个生命周期，甚至是这个周而复始的生命周期的投入少。 比如说，代码写得快，可是测试起来一大堆问题，就不是经济的。&lt;/p>
&lt;p>现代的大型软件开发，一般都会有比较细致的分工，在各个阶段参与的人是不同的；甚至在相同的阶段，也会有多人参与。一个稍有规模的软件，可能需要数人参与设计和实现。而为了使测试相对独立，软件测试人员和软件实现人员也是相对独立的，而且他们具备不同的优势和技能。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/89/df/89bb4250efc6702f638f8981030927df.png" alt="">&lt;/p>
&lt;p>所以，当我们考虑投入的时候，还要考虑这个生命周期里所有的参与人员。这些参与人员所处的立场、看问题的角度，所具有的资源禀赋，可能千差万别。比如说，如果客户需要阅读代码，才知道系统怎么使用，就不是经济的。&lt;/p>
&lt;p>是不是所有的软件都有这六个阶段呢？显然不是的，我本科的毕业论文程序，就完全没有运营和维护阶段，甚至也不算有测试阶段。我当时的毕业论文是一个关于加快神经网络学习的数学算法。只要验证了这个算法收缩得比较快，程序的使命就完成了，程序就可以退出销毁了。 所以，运营和维护阶段，甚至测试阶段，对当时的我而言，都是不需要投入的阶段。&lt;/p>
&lt;p>在现代商业社会里，尤其我们越来越倾向于敏捷开发、精益创业，提倡&amp;quot;快速地失败、廉价地失败&amp;rdquo;，很多软件走不到维护阶段就已经结束了。而且，由于人力资源的限制，当然包括资金的限制，一个程序员可能要承担很多种角色，甚至从开始有了想法，到软件实现结束，都是一个人在战斗，哪里分什么设计人员、测试人员。&lt;/p>
&lt;p>对软件开发流程选择的差异，就带来了我们对代码质量理解，以及对代码质量重视程度的千差万别。 比如说，一个创业公司是万万不能照搬大型成熟软件的开发流程的。因为，全面的高质量、高可靠、高兼容性的软件可能并不是创业公司最核心的目标。如果过分纠缠于这些代码指标，创始人的时间、投资人的金钱可能都没有办法得到最有效的使用。&lt;/p>
&lt;p>当然，越成熟的软件开发机制越容易写出优秀的代码。但是，&lt;strong>最适合当前现实环境的代码，才是最优秀的代码。&lt;/strong>&lt;/p>
&lt;p>所以，当我们考虑具体投入的时候，还要考虑我们所处的现实环境。 如果我们超出现实环境去讨论代码的质量，有时候会有失偏颇，丧失我们讨论代码质量的意义。&lt;/p>
&lt;p>既然具体环境千差万别，那我们还有必要讨论什么是优秀的代码吗？优秀的代码还能有什么共同的规律吗？ 即使一个人做所有的事情，即使代码用完一次就废弃，我们长期积累下来的编写优秀代码的经验，依然可以帮助到很多人。&lt;/p>
&lt;p>比如说，虽然创业公司的软件刚开始最核心的追求不是全面的高可靠性。可是，你也要明白，创业的目的不是为了失败，一旦创业公司稳住了阵脚，这个时候如果它们没有高可靠性的软件作为支撑，很快就会有反噬作用。 而程序员背锅，就是反噬的其中一个后果。&lt;/p>
&lt;p>如何使用最少的时间、最少的资源，提供最可靠的软件，什么时候开始把可靠性提高到不可忽视的程度，有没有可能一开始就是高可靠的, 这些就都是一个富有经验的创业公司技术负责人不得不考虑的问题。而我们总结出来的编写代码的经验，毫无疑问，可以为这些问题提供一些思路和出路。&lt;/p>
&lt;p>为什么我们要从&amp;quot;经济&amp;quot;这个角度来衡量优秀的代码呢？ 因为这是一个可以让我们更加理性的概念。&lt;/p>
&lt;p>一个营利性的公司，必须考虑投入产出比，没有人愿意做亏本的买卖，股东追求的是利润最大化。作为程序员，我们也必须考虑投入和产出。 首先，我们的产出必须大幅度大于公司对我们的投入，否则就有随时被扫地出门的风险。然后，我们必须使用好我们的时间，在单位时间内创造更多的价值，否则，真的是没有功劳，只有徒劳。&lt;/p>
&lt;p>编写代码的时候，如果遇到困惑或者两难，你要想一想，怎么做才能做到投资少、收益大？&lt;/p>
&lt;p>即便具体环境千差万别，我还是有一些例子，可以和你一起分享：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>代码写得又快又好，是&amp;quot;经济&amp;quot;的；代码写得快，但是错误多，不是一个&amp;quot;经济&amp;quot;的行为。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>代码跑得又快又好，是&amp;quot;经济&amp;quot;的；代码跑得快，但是安全问题突出，不是一个&amp;quot;经济&amp;quot;的行为。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>代码写得精简易懂，是&amp;quot;经济&amp;quot;的；代码写得精简，但是没人看得懂，不是一个&amp;quot;经济&amp;quot;的行为。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>对于所有的程序员来说，每个人都会遇到两个有名的捣蛋鬼，一个捣蛋鬼是&amp;quot;合作&amp;rdquo;，另一个捣蛋鬼是&amp;quot;错误&amp;quot;。&lt;/p>
&lt;p>要合作，就需要用大部分人都舒服的方式。程序员间合作交流最重要的语言便是代码，换句话说，这就需要我们规范地编写代码，使用大家都接受的风格。不规范的代码，我们可能节省了眼前的时间，但是测试、运营、维护阶段，就需要更多的时间。而一旦问题出现，这些代码会重新返工，又回到我们手里，需要阅读、修改，再一次浪费我们自己的时间。对于这些代码，每一点时间的付出，都意味着投入，意味着浪费，意味着我们损失了做更有意义事情的机会。&lt;/p>
&lt;p>人人都会犯错误，代码都会有 bug，可是有些错误的破坏力是我们无法承受的，其中，最典型的就是安全问题。很多安全问题对公司和个人造成不容忽视的恶劣影响。我见过因为安全问题破产的公司。这时候，甚至都不要谈什么投入产出比、经济效益了，所有的投入归零，公司破产，员工解散。这需要我们分外地卖力，拿出十二分的精神来处理潜在的安全威胁，编写安全的代码。&lt;/p>
&lt;p>如果我们把规范和安全作为独立的话题，优秀的代码需要具备三个特征： 经济、规范、安全。这些内容就是我们接下来要在专栏里一起学习的主体。&lt;/p>
&lt;p>好了，今天我们一口气聊了很多，主要是在探讨到底什么样的代码才是优秀的代码。这个问题你之前考虑过吗？和我今天讲的是否一样呢？欢迎你在留言区写写自己的想法，我们可以进一步讨论。也欢迎你把今天的文章分享给跟你协作的同学，看看你们之间的理解是否一致。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/5a/98/5a96a612403912b80de030e742e2e598.jpg" alt="">&lt;/p></description></item><item><title>极客专栏: 01丨架构设计的宏观视角</title><link>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E8%AE%B8%E5%BC%8F%E4%BC%9F%E7%9A%84%E6%9E%B6%E6%9E%84%E8%AF%BE/01%E4%B8%A8%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E7%9A%84%E5%AE%8F%E8%A7%82%E8%A7%86%E8%A7%92/</link><pubDate>Tue, 07 Jun 2022 00:00:00 +0000</pubDate><guid>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E8%AE%B8%E5%BC%8F%E4%BC%9F%E7%9A%84%E6%9E%B6%E6%9E%84%E8%AF%BE/01%E4%B8%A8%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E7%9A%84%E5%AE%8F%E8%A7%82%E8%A7%86%E8%A7%92/</guid><description>
&lt;p>你好，我是七牛云许式伟。今天我们来谈谈架构设计的宏观视角。&lt;/p>
&lt;p>在信息科技高度发展的今天，我们每个人随时随地都可以接触到由程序驱动的智能电子设备，包括手机（如 iPhone、oppo 拍照手机）、平板电脑（如 iPad）、手表（如 iWatch、小天才智能手表）、音箱（如天猫精灵）、汽车（如特斯拉）等等。&lt;/p>
&lt;p>这些东西背后是怎么工作的？单就其中的软件系统而言，这些小小的设备上往往运行着成千上万个软件模块，这些模块是如何如此精密地一起协作的？&lt;/p>
&lt;p>对此，我过去接触过很多的软件开发工程师，或者架构师，很多人对这些原理也是一知半解，虽然&amp;quot;知其然&amp;quot;，但却&amp;quot;不知其所以然&amp;quot;。甚至有些朋友可能觉得，学这些有什么用处呢，在我看来，这部分内容恰恰是我们成为架构师很重要的一门基础课。&lt;/p>
&lt;h2 id="为什么需要建立宏观视角">为什么需要建立宏观视角？&lt;/h2>
&lt;p>如同造房子有建筑工人（负责搬砖）和建筑师（负责架构设计）一样，软件系统的开发过程同样需要有程序员（负责搬&amp;quot;砖&amp;quot;）和架构师（负责架构设计）。作为架构师，我们需要的第一个能力是宏观的全局掌控能力。&lt;/p>
&lt;p>如果把应用程序比作一座大厦，那么我们作为大厦的架构师，需要把大厦的结构搭建好，让程序员可以把砖填充进去，我们都知道，一个大厦的结构建得是否稳固，与地基密不可分。&lt;/p>
&lt;p>所以，我们首先就需要从大厦的地基开始，熟悉这座大厦。毕竟，你对所依赖的基础架构了解得越全面，做业务架构设计就会越发从容。&lt;/p>
&lt;p>介绍基础架构的知识点并不是让你真的去实现它们。但你仍然需要懂得它们的核心思想是什么，知道有哪些信息是你必须深刻理解的，以便可以更好地驾驭它们。&lt;/p>
&lt;p>&lt;strong>我们的整个专栏内容也会从基础架构开始讲起，最后逐步过渡到业务架构，到最终完成一个完整应用程序的设计过程。&lt;/strong>&lt;/p>
&lt;p>那么，在今天的开篇第一篇，我们需要站在宏观视角，从基础架构开始，逐渐来解剖一个应用程序的整体构成，我希望，通过今天的文章，可以让你对于一个程序的全貌，形成完整的认识。&lt;/p>
&lt;p>我们从头开始。&lt;/p>
&lt;h2 id="应用程序的基础架构">应用程序的基础架构&lt;/h2>
&lt;p>我们想学习一个程序的基础架构，其实就是弄清楚电脑的工作原理，以及程序的运行原理。&lt;/p>
&lt;p>无论是什么样的智能电子设备，手机也好，汽车也罢，它们都可以称为&amp;quot;电脑&amp;quot;。所有的电脑都可以统一看作由&amp;quot;&lt;strong>中央处理器 + 存储 + 一系列的输入输出设备&lt;/strong>&amp;ldquo;构成。&lt;/p>
&lt;p>中央处理器，也就是我们平常说的 CPU，负责按指令执行命令；存储负责保存数据，包括我们要执行的命令，也是以数据形式保存在存储中的。&lt;/p>
&lt;p>每次在打开电脑的电源后，中央处理器都会从存储的某个固定位置处开始读入数据（也就是指令），并且按指令执行命令，执行完一条指令就会继续执行下一条指令。电脑就这样开始工作了。&lt;/p>
&lt;p>你可能会说，就这么简单？是的，就是这么简单。&lt;/p>
&lt;p>&lt;strong>那这么简单的话，为何电脑能够完成这么多复杂而多样化的工作？&lt;/strong>&lt;/p>
&lt;p>这整个过程，在我看来主要依赖两点。&lt;/p>
&lt;p>**第一是可编程性。**大体来说，中央处理器（CPU）的指令分为如下这几类。&lt;/p>
&lt;ul>
&lt;li>计算类，也就是支持我们大家都熟知的各类数学运算，如加减乘除、sin/cos 等等。&lt;/li>
&lt;li>I/O 类，（从存储读写数据）从输入输出设备读数据、写数据。&lt;/li>
&lt;li>指令跳转类，在满足特定条件下跳转到新的当前程序执行位置。&lt;/li>
&lt;/ul>
&lt;p>虽然， CPU 指令是一个很有限的指令集，但是 CPU 执行的指令序列（或者叫&amp;quot;程序&amp;rdquo;）并不是固定的，而是依赖保存在存储中的数据&amp;mdash;&amp;mdash; 由软件工程师（或者叫&amp;quot;程序员&amp;quot;）编写的软件来决定。指令序列的可能性是无穷的，这也就意味着电脑能够做的事情的可能性也是无穷的。&lt;/p>
&lt;p>**第二是开放设计的外部设备支持。**虽然我们电脑可以连接非常非常多种类的外部设备，比如键盘、打印机、屏幕、汽车马达等等，但 CPU 并不理解这些设备具体有什么样的能力，它只和这些设备交换数据。它能够做的是从某个编号的设备（通常这个设备编号被称为&amp;quot;端口&amp;quot;）读入一段数据，或者向设备的端口写入一段数据。&lt;/p>
&lt;p>例如，当你在键盘上按下了 A 的时候，CPU 可以从键盘连接的端口读到一段数据，通过这段数据来表达你按了&amp;quot;A&amp;quot;，可能 CPU 会向打印机连接的端口发送一段数据，来驱动打印机打印特定的文本；还有可能 CPU 会向汽车马达所在的端口发送数据，来驱动马达转动，从而让汽车按照预期来行驶。&lt;/p>
&lt;p>值得注意的是，CPU 知道的是如何和这些设备交换数据，但是并不理解数据代表什么含义。这些外部设备的厂商在提供设备硬件的同时，往往也需要提供和硬件匹配的软件，来完成和 CPU 的协作，让软件工程师可以轻松使用这些设备。&lt;/p>
&lt;p>从上面可以看出，**电脑的 CPU 是一个非常简洁的模型，它只读入和写出数据，对数据进行计算。**这也是为什么我们往往把电脑也叫作&amp;quot;计算机&amp;quot;，这是因为 CPU 这个计算机的大脑的确只会做&amp;quot;计算&amp;quot;。&lt;/p>
&lt;p>这个基础的设计体系，我们很多人都知道，这就是冯·诺依曼计算机体系。1945 年 6 月，冯·诺依曼以&amp;quot;关于 EDVAC 的报告草案&amp;quot;为题起草的长达 101 页的总结报告，定义了&amp;quot;冯·诺依曼体系结构&amp;quot;，他现在也被称为计算机之父。我想看到这里，你应该不难理解他的伟大之处了吧？&lt;/p>
&lt;p>有了这个基础的计算机体系之后，我们就可以编写软件了。&lt;/p>
&lt;p>当然我们遇到的第一个问题是&lt;strong>直接用机器指令编写软件太累，而且这些机器指令像天书一样没人看得懂，没法维护。&lt;/strong>&lt;/p>
&lt;p>所以，&lt;strong>编程语言 + 编译器&lt;/strong>就出现了。编译器负责把我们人类容易理解的语言，转换为机器可以理解的机器指令，这样一来就大大解放了编写软件的门槛。&lt;/p>
&lt;p>在编写软件不是问题时，我们遇到的第二个问题，就是&lt;strong>多个软件在同一个电脑上怎么共处。多个软件大家往同一个存储地址写数据冲突怎么办？一起往打印机去发送打印指令怎么办？有的软件可能偷偷搞破坏怎么办？&lt;/strong>&lt;/p>
&lt;p>于是，&lt;strong>操作系统&lt;/strong>就出现了。&lt;/p>
&lt;p>**它首先要解决的是软件治理的问题。**它要建立安全保护机制，确保你的电脑免受恶意软件侵害。同时，它也要建立软件之间的协作秩序，让大家按照期望的方式进行协作。比如存储你写到这里，那么我就要写到别处；使用打印机要排队，你打完了，我才能接着去打印。&lt;/p>
&lt;p>操作系统**其次解决的是基础编程接口问题。**这些编程接口一方面简化了软件开发，另一方面提供了多软件共存（多任务）的环境，实现了软件治理。&lt;/p>
&lt;p>例如，对于屏幕设备，操作系统需要提供多任务窗口系统，以避免屏幕被多个软件画得乱七八糟；对于键盘输入设备，操作系统引入焦点窗口，以确定键盘输入的事件被正确发送到正确的软件程序。&lt;/p>
&lt;p>你会发现，今天的我们开发软件的时候，已经处于一些基础的架构设计之中。像冯·诺依曼计算机体系，像操作系统和编程语言，这些都是我们开发一个应用程序所依赖的基础架构。&lt;/p>
&lt;p>基础架构解决的是与业务无关的一些通用性的问题，这些问题往往无论你具体要做什么样的应用都需要面对。而且，基础架构通常以独立的软件存在，所以也称为基础软件。&lt;/p>
&lt;p>例如，我们熟知的 Linux、Nginx、MySQL、PHP 等这些软件都属于基础软件，这些基础软件极大地降低了应用开发的难度。在今天软件服务化的大趋势下，很多基础软件最终以互联网服务的方式提供，这就是所谓的&amp;quot;云计算&amp;quot;。&lt;/p>
&lt;h2 id="完整的程序架构是怎样的">完整的程序架构是怎样的？&lt;/h2>
&lt;p>讲完了程序的地基，让我们来总览一下程序的完整架构。&lt;/p>
&lt;p>在越强大的基础架构支撑下，应用程序开发需要关注的问题就越收敛，我们的开发效率就越高。&lt;strong>在我们只需要关注应用程序本身的业务问题如何构建时，我们说自己是在设计应用程序的业务架构（或者叫&amp;quot;应用架构&amp;quot;）。&lt;/strong>&lt;/p>
&lt;p>业务架构虽然会因为应用的领域不同而有很大的差异，但不同业务架构之间，仍然会有许多共通的东西。它们不只遵循相同的架构原则，还可以遵循相同的设计范式。&lt;/p>
&lt;p>一些设计范式被人们以应用程序框架的方式固化下来。例如，在用户交互领域有著名的 MVC 框架（如 JavaScript 语言的 Angular，PHP 语言的 Zend，Python 语言的 Django），在游戏开发领域有各种游戏引擎（如 JavaScript 语言的 Phaser，C# 语言的 Unity3D），等等。&lt;/p>
&lt;p>**对于一个服务端应用程序来说，其完整的架构体系大体如下，**如果你在收听音频，你可以点击文稿查看：&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/55/37/5553453858eb86bf88a5623255f20037.png" alt="">&lt;/p>
&lt;p>对于客户端应用程序来说，和服务端的情况会有非常大的差别。客户端首先面临的是多样性的挑战。&lt;/p>
&lt;p>单就操作系统来说，PC 就有 Windows、Mac、Linux 等数十种，手机也有 Android、iOS，Windows Mobile 等等。而设备种类而言就更多了，不只有笔记本、平板电脑，还有手机、手表、汽车，未来只会更加多样化。&lt;/p>
&lt;p>第一个想消除客户端的多样性，并且跨平台提供统一编程接口的，是浏览器。&lt;/p>
&lt;p>可能在很多人看来，浏览器主要改变的是软件分发的方式，让软件可以即取即用，无需安装。但从技术角度来说，底层操作系统对软件的支持同样可以做到即取即用。&lt;/p>
&lt;p>这方面苹果在 iOS 上已经在尝试，大家可能已经留意到，如果你一个软件很久没有用，iPhone 就会把这个软件从本地清理出去，而在你下一次使用它时又自动安装回来。&lt;/p>
&lt;p>假如软件包足够小，那么这种行为和 Web 应用就毫无区别。不同之处只在于 Web 应用基于的指令不是机器码，而是更高阶的 JavaScript 脚本。&lt;/p>
&lt;p>JavaScript 因为指令更高阶，所以程序的尺寸比机器码会有优势。但另一方面来说 JavaScript 是文本指令，表达效率又要比机器码低。&lt;/p>
&lt;p>但这一点也在发生变化，近年来 WebAssembly 技术开始蓬勃发展，JavaScript 作为浏览器的机器码的地位会被逐步改变，我们前端开发会面临更多的可能性。&lt;/p>
&lt;p>浏览器的地位非常特殊，我们可以看作操作系统之上的操作系统。一旦某种浏览器流行起来，开发人员都在浏览器上做应用，那么必然会导致底层操作系统管道化，这是操作系统厂商所不愿意看到的。&lt;/p>
&lt;p>而如果浏览器用户量比较少，那么通过它能够触达的用户量就太少，消除不同底层操作系统差异的价值就不存在，开发人员也就不乐意在上面开发应用。&lt;/p>
&lt;p>我们知道，PC 的浏览器之战打到今天，基本上就剩下 Chrome、Internet Explorer、Safari、Firefox 等。&lt;/p>
&lt;p>有趣的是，移动浏览器的战场似乎是从中国开始打起的，这就是微信引发的小程序之战，它本质上是一场浏览器的战争。&lt;/p>
&lt;p>浏览器是一个基础软件，它能够解决多大的问题，依赖于它的市场占有率。但是基于同样的浏览器技术核心也可以构建出跨平台的应用框架。我们看到 React Native 就是沿着这个思路走的。当然这不是唯一的一条路，还有人会基于类似 QT 这样的传统跨平台方案。&lt;/p>
&lt;p>&lt;strong>整体来说，对于一个客户端应用程序来说，其完整的架构体系大体如下&lt;/strong>，你可以点击文稿查看：&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/3a/c7/3af7a4830566a5b3e1058f409422b7c7.png" alt="">&lt;/p>
&lt;p>对于架构师来说，不仅仅只是想清楚业务应该怎么去做好分解，整个应用从底到最顶层的上层建筑，每一层都需要进行各种决策。先做 iOS 版本，还是先做小程序？是选择 Java 还是 Go 语言？这些都是架构的一部分。&lt;/p>
&lt;h2 id="结语">结语&lt;/h2>
&lt;p>今天，我们从&amp;quot;计算机是如何工作&amp;quot;开始，一起登高鸟瞰，总览了程序完整的架构体系。&lt;/p>
&lt;p>&lt;strong>可能有人看到今天的内容心里会有些担心：&amp;ldquo;原来架构师要学这么多东西，看来我离成为架构师好远。&amp;rdquo;&lt;/strong>&lt;/p>
&lt;p>好消息是：我们就是来打消这个担心的。如果我们把写代码的能力比作武功招式，那么架构能力就好比内功。内功修炼好了，武功招式的运用才能得心应手。&lt;/p>
&lt;p>**而架构能力的提升，本质上是对你的知识脉络（全身经络）的反复梳理与融会贯通的过程。**具备架构思维并不难，而且极有必要。不管今天的你是不是团队里的一位架构师，对任何一位程序员来说，具备架构思维将会成为让你脱颖而出的关键。&lt;/p>
&lt;p>这就像你没有从事云计算行业，但是你仍然需要理解云计算的本质，需要驾驭云计算。你也不必去做出一个浏览器，但是你需要理解它们的思考方式，因为你在深度依赖于它们。&lt;/p>
&lt;p>接下来我们将进一步展开来谈这个程序架构体系里面的每一个环节。你对今天的内容有什么思考与解读，欢迎给我留言，我们一起讨论。如果你觉得有所收获，也欢迎把文章分享给你的朋友。感谢你的收听，我们下期再见。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/43/00/43231f3789095eb4cdb38e67ff3d7900.jpg" alt="">&lt;/p></description></item><item><title>极客专栏: 01丨网络互联的昨天、今天和明天：HTTP协议的演化</title><link>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E5%85%A8%E6%A0%88%E5%B7%A5%E7%A8%8B%E5%B8%88%E4%BF%AE%E7%82%BC%E6%8C%87%E5%8D%97/01%E4%B8%A8%E7%BD%91%E7%BB%9C%E4%BA%92%E8%81%94%E7%9A%84%E6%98%A8%E5%A4%A9%E4%BB%8A%E5%A4%A9%E5%92%8C%E6%98%8E%E5%A4%A9http%E5%8D%8F%E8%AE%AE%E7%9A%84%E6%BC%94%E5%8C%96/</link><pubDate>Tue, 07 Jun 2022 00:00:00 +0000</pubDate><guid>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E5%85%A8%E6%A0%88%E5%B7%A5%E7%A8%8B%E5%B8%88%E4%BF%AE%E7%82%BC%E6%8C%87%E5%8D%97/01%E4%B8%A8%E7%BD%91%E7%BB%9C%E4%BA%92%E8%81%94%E7%9A%84%E6%98%A8%E5%A4%A9%E4%BB%8A%E5%A4%A9%E5%92%8C%E6%98%8E%E5%A4%A9http%E5%8D%8F%E8%AE%AE%E7%9A%84%E6%BC%94%E5%8C%96/</guid><description>
&lt;p>你好，我是四火。&lt;/p>
&lt;p>HTTP 协议是互联网基础中的基础，和很多技术谈具体应用场景不同的是，几乎所有的互联网服务都是它的应用，没有它，互联网的&amp;quot;互联&amp;quot;将无从谈起，因此我们把它作为正式学习的开篇。&lt;/p>
&lt;p>说到其原理和协议本身，我相信大多数人都能说出个大概来，比如，有哪些常见的方法，常见 HTTP 头，返回码的含义等等。但你是否想过，这个古老而富有生命力的互联网&amp;quot;基石&amp;quot;是怎样发展演化过来的呢？从它身上，我们能否管中窥豹，一叶知秋，找到互联网成长和演进的影子？&lt;/p>
&lt;p>今天，我想带你从实践的角度，亲身感受下这个过程，相信除了 HTTP 本身，你还可以发现网络协议发展过程中的一些通用和具有共性的东西。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/ac/2a/ac90bdd14bced3d81e314a7eddf6972a.png" alt="">&lt;/p>
&lt;h2 id="http09">HTTP/0.9&lt;/h2>
&lt;p>和很多其它协议一样，1991 年，HTTP 在最开始的 0.9 版就定义了协议最核心的内容，虽说从功能上看只是具备了如今内容的一个小小的子集。比如，确定了客户端、服务端的这种基本结构，使用域名 /IP 加端口号来确定目标地址的方式，还有换行回车作为基本的分隔符。&lt;/p>
&lt;p>它非常简单，不支持请求正文，不支持除了 GET 以外的其它方法，不支持头部，甚至没有版本号的显式指定，而且整个请求只有一行，因而也被称为&amp;quot;The One-line Protocol&amp;quot;。比如：&lt;/p>
&lt;pre>&lt;code>GET /target.html
&lt;/code>&lt;/pre>
&lt;p>虽说 0.9 版本如今已经极少见到了，但幸运的是 Google 还依然支持（Bing 和 Baidu 不支持）。我们不妨自己动手，实践一下！虽然不能使用浏览器，但别忘了，我们还有一个更古老的工具 telnet。在命令行下建立连接：&lt;/p>
&lt;pre>&lt;code>telnet www.google.com 80
&lt;/code>&lt;/pre>
&lt;p>你会看到类似这样的提示：&lt;/p>
&lt;pre>&lt;code>Trying 2607:f8b0:400a:803::2004...
Connected to www.google.com.
Escape character is '^]'.
&lt;/code>&lt;/pre>
&lt;p>好，现在输入以下请求：&lt;/p>
&lt;pre>&lt;code>GET /
&lt;/code>&lt;/pre>
&lt;p>（请注意这里没有版本号，并不代表 HTTP 协议没有版本号，而是 0.9 版本的协议定义的请求中就是不带有版本号，这其实是该版本的一个缺陷）&lt;/p>
&lt;p>接着，你会看到 Google 把首页 HTML 返回了：&lt;/p>
&lt;pre>&lt;code>HTTP/1.0 200 OK
...（此处省略多行 HTTP 头）
...（此处省略正文）
&lt;/code>&lt;/pre>
&lt;h2 id="http10">HTTP/1.0&lt;/h2>
&lt;p>到了 1996 年，HTTP 1.0 版本就稳定而成熟了，也是如今浏览器广泛支持的最低版本 HTTP 协议。引入了返回码，引入了 header，引入了多字符集，也终于支持多行请求了。&lt;/p>
&lt;p>当然，它的问题也还有很多，支持的特性也远没有后来的 1.1 版本多样。比如，方法只支持 GET、HEAD、POST 这几个。但是，麻雀虽小五脏俱全，这是第一个具备广泛实际应用价值的协议版本。&lt;/p>
&lt;p>你一样可以用和前面类似的方法来亲自动手实践一下，不过，HTTP 1.0 因为支持多行文本的请求，单纯使用 telnet 已经无法很好地一次发送它们了，其中一个解决办法就是使用 &lt;a href="http://netcat.sourceforge.net/">netcat&lt;/a>。&lt;/p>
&lt;p>好，我们先手写一份 HTTP/1.0 的多行请求，并保存到一个文件 request.txt 中：&lt;/p>
&lt;pre>&lt;code>GET / HTTP/1.0
User-Agent: Mozilla/1.22 (compatible; MSIE 2.0; Windows 3.1)
Accept: text/html
&lt;/code>&lt;/pre>
&lt;p>（根据协议，无论请求还是响应，在 HTTP 的头部结束后，必须增加一个额外的换行回车，因此上述代码最后这个空行是必须的，如果是 POST 请求，那么通常在这个空行之后会有正文）&lt;/p>
&lt;p>你看上面的 User-Agent，我写入了一个&lt;a href="https://developers.whatismybrowser.com/useragents/parse/2868-internet-explorer-windows-trident">假的浏览器和操作系统版本&lt;/a>，假装我穿越来自 Window 3.1 的年代，并且用的是 IE 2.0，这样一来，我想不会有人比我更&amp;quot;老&amp;quot;了吧。&lt;/p>
&lt;p>好，接着用类似的方法，使用 netcat 来发送这个请求：&lt;/p>
&lt;pre>&lt;code>netcat www.google.com 80 &amp;lt; ~/Downloads/request.txt
&lt;/code>&lt;/pre>
&lt;p>一样从 Google 收到了成功的报文。&lt;/p>
&lt;p>不知这样的几次动手是否能给你一个启示：懂一点特定的协议，使用简单的命令行和文本编辑工具，我们就已经可以做很多事情了。比如上面这样改变 UA 头的办法，可以模拟不同的浏览器，就是用来分析浏览器适配（指根据不同浏览器的兼容性返回不同的页面数据）的常用方法。&lt;/p>
&lt;h2 id="http11">HTTP/1.1&lt;/h2>
&lt;p>1999 年，著名的 RFC2616，在 1.0 的基础上，大量帮助传输效率提升的特性被加入。&lt;/p>
&lt;p>你可能知道，从网络协议分层上看， TCP 协议在 HTTP 协议的下方（TCP 是在 OSI 7 层协议的第 4 层，而 HTTP 则是在最高的第 7 层应用层，因此，前者更加&amp;quot;底层&amp;quot;一点）。&lt;/p>
&lt;p>在 HTTP 1.0 版本时，每一组请求和响应的交互，都要完成一次 TCP 的连接和关闭操作，这在曾经的互联网资源比较贫瘠的时候并没有暴露出多大的问题，但随着互联网的迅速发展，这种通讯模式显然过于低效了。&lt;/p>
&lt;p>于是这个问题的解决方案&amp;mdash;&amp;mdash;HTTP 的长连接，就自然而然地出现了，它指的是打开一次 TCP 连接，可以被连续几次报文传输重用，这样一来，我们就不需要给每次请求和响应都创建专门的连接了：&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/2e/f9/2e5a9e7cdc1560967168e96c642517f9.jpg" alt="">（上图来自 &lt;a href="https://medium.com/platform-engineer/evolution-of-http-69cfe6531ba0">Evolution of HTTP &amp;mdash; HTTP/0.9, HTTP/1.0, HTTP/1.1, Keep-Alive, Upgrade, and HTTPS&lt;/a>）&lt;/p>
&lt;p>可以看到，&lt;strong>通过建立长连接，中间的几次 TCP 连接开始和结束的握手都省掉了。&lt;/strong>&lt;/p>
&lt;p>那好，我们还是使用 netcat，这次把版本号改成 1.1，同时打开长连接：&lt;/p>
&lt;pre>&lt;code>GET / HTTP/1.1
Host: www.google.com
User-Agent: Mozilla/1.22 (compatible; MSIE 2.0; Windows 3.1)
Connection: keep-alive
Accept: text/html
&lt;/code>&lt;/pre>
&lt;p>（别忘了上面那个空行）&lt;/p>
&lt;p>相信你也注意到了上面客户端要求开启长连接的 HTTP 头：&lt;/p>
&lt;pre>&lt;code>Connection: keep-alive
&lt;/code>&lt;/pre>
&lt;p>再按老办法运行：&lt;/p>
&lt;pre>&lt;code>netcat www.google.com 80 &amp;lt; ~/Downloads/request.txt
&lt;/code>&lt;/pre>
&lt;p>我们果然得到了 Google 的响应：&lt;/p>
&lt;pre>&lt;code>HTTP/1.1 200 OK
Date: ...
Expires: -1
Cache-Control: private, max-age=0
Content-Type: text/html; charset=ISO-8859-1
Transfer-Encoding: chunked
...（此处省略多行 HTTP 头）
127a
...（此处省略 HTML）
0
&lt;/code>&lt;/pre>
&lt;p>但是在响应中，值得注意的有两点：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>在 HTTP 头部，有这样一行：&lt;/p>
&lt;p>Transfer-Encoding: chunked&lt;/p>
&lt;/li>
&lt;li>
&lt;p>正文的内容是这样的：&lt;/p>
&lt;p>127a
&amp;hellip;
0&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>同时，之前我们见到过头部的 Content-Length 不见了。这是怎么回事呢？&lt;/p>
&lt;p>事实上，如果协议头中存在上述的 chunked 头，表示将采用分块传输编码，响应的消息将由若干个块分次传输，而不是一次传回。刚才的 127a，指的是接下去这一块的大小，在这些有意义的块传输完毕后，会紧跟上一个长度为 0 的块和一个空行，表示传输结束了，这也是最后的那个 0 的含义。&lt;/p>
&lt;p>值得注意的是，实际上在这个 0 之后，协议还允许放一些额外的信息，这部分会被称作&amp;quot;&lt;a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Trailer">Trailer&lt;/a>&amp;quot;，这个额外的信息可以是用来校验正确性的 checksum，可以是数字签名，或者传输完成的状态等等。&lt;/p>
&lt;p>在长连接开启的情况下，使用 Content-Length 还是 chunked 头，必须具备其中一种。&lt;strong>分块传输编码大大地提高了 HTTP 交互的灵活性&lt;/strong> ，服务端可以在还不知道最终将传递多少数据的时候，就可以一块一块将数据传回来。在 [第 03 讲] 中，你还会看到藉由分块传输，可以实现一些模拟服务端推送的技术，比如 &lt;a href="https://en.wikipedia.org/wiki/Comet_(programming)">Comet&lt;/a>。&lt;/p>
&lt;p>事实上 HTTP/1.1 还增加了很多其它的特性，比如更全面的方法，以及更全面的返回码，对指定客户端缓存策略的支持，对 content negotiation 的支持（即通过客户端请求的以 Accept 开头的头部来告知服务端它能接受的内容类型），等等。&lt;/p>
&lt;h2 id="http2">HTTP/2&lt;/h2>
&lt;p>现在最广泛使用的 HTTP 协议还是 1.1 ，但是 HTTP/2 已经提出，在保持兼容性的基础上，包含了这样几个重要改进：&lt;/p>
&lt;ul>
&lt;li>设计了一种机制，允许客户端来选择使用的 HTTP 版本，这个机制被命名为 ALPN；&lt;/li>
&lt;li>HTTP 头的压缩，在 HTTP/2 以前，HTTP 正文支持多种方式的压缩，但是 HTTP 头部却不能；&lt;/li>
&lt;li>多路复用，允许客户端同时在一个连接中同时传输多组请求响应的方法；&lt;/li>
&lt;li>服务端的 push 机制，比方说客户端去获取一个网页的时候，下载网页，分析网页内容，得知还需要一个 js 文件和一个 css 文件，于是再分别下载，而服务端的 push 机制可以提前就把这些资源推送到客户端，而不需要客户端来索取，从而节约网页加载总时间。&lt;/li>
&lt;/ul>
&lt;p>在 HTTP/2 之后，我们展望未来，HTTP/3 已经箭在弦上。如同前面的版本更新一样，依旧围绕传输效率这个协议核心来做进一步改进，其承载协议将从 TCP 转移到基于 UDP 的 &lt;a href="https://en.wikipedia.org/wiki/QUIC">QUIC&lt;/a> 上面来。&lt;/p>
&lt;p>最后，我想说的是，&lt;strong>HTTP 协议的进化史，恰恰是互联网进化史的一个绝佳缩影&lt;/strong>，从中你可以看到互联网发展的数个特质。比方说，长连接和分块传输很大程度上增强了 HTTP 交互模型上的灵活性，使得 B/S 架构下的消息即时推送成为可能。&lt;/p>
&lt;h2 id="总结思考">总结思考&lt;/h2>
&lt;p>今天我们了解了 HTTP 协议的进化史，并且用了动手操作的方法来帮助你理解内容，还分析了其中两个重要的特性，长连接和分块传输。希望经过今天的实践，除了知识本身的学习，你还能够&lt;strong>在快速的动手验证中，强化自己的主观认识，并将这种学习知识的方式培养成一种习惯，这是学习全栈技能的一大法宝&lt;/strong>。&lt;/p>
&lt;p>现在，让我们来进一步思考这样两个问题：&lt;/p>
&lt;ul>
&lt;li>文中介绍了分块传输的 HTTP 特性，你觉得它可以应用到哪些具体场景？&lt;/li>
&lt;li>如果让你去设计一个新的网络协议，你能否举例设计的过程中需要遵循哪些原则？&lt;/li>
&lt;/ul>
&lt;p>好，今天的分享就到这里，欢迎提出你的疑问，也期待你留言与我交流！&lt;/p>
&lt;h2 id="选修课堂抓一段-http-的包">选修课堂：抓一段 HTTP 的包&lt;/h2>
&lt;p>如果你对于使用 tcpdump 进行网络抓包这个技能已经了解了，就可以跳过下面的内容。反之，推荐你动动手。因为在学习任何网络协议的时候，网络抓包是一个非常基本的实践前置技能；而在实际定位问题的时候，也时不时需要抓包分析。这也是我在第一讲就放上这堂选修课的原因。&lt;/p>
&lt;p>俗话说，耳听为虚，眼见为实，下面让我们继续动手实践。你当然可以尝试抓访问某个网站的包，但也可以在本机自己启动一个 web 服务，抓一段 HTTP GET 请求的报文。&lt;/p>
&lt;p>利用 Python，在任意目录，一行命令就可以在端口 8080 上启动一个完备的 HTTP 服务（这大概是世界上最简单的启动一个 HTTP 服务的方式了）：&lt;/p>
&lt;pre>&lt;code>python -m SimpleHTTPServer 8080
&lt;/code>&lt;/pre>
&lt;p>启动成功后，你应该能看到：&lt;/p>
&lt;pre>&lt;code>Serving HTTP on 0.0.0.0 port 8080 ...
&lt;/code>&lt;/pre>
&lt;p>接着使用 tcpdump 来抓包，注意抓的是 loopback 的包（本地发送到本地），因此执行：&lt;/p>
&lt;pre>&lt;code>sudo tcpdump -i lo0 -v 'port 8080' -w http.cap
&lt;/code>&lt;/pre>
&lt;p>这里的 -i 参数表示指定 interface，而因为客户端和服务端都在本地，因此使用 lo0（我使用的是 Mac，在某些 Linux 操作系统下可能是 lo，具体可以通过 ifconfig 查看）指定 loopback 的接口，这里我们只想捕获发往 8080 端口的数据包，结果汇总成 http.cap 文件。&lt;/p>
&lt;p>打开浏览器敲入 &lt;a href="http://localhost:8080">http://localhost:8080&lt;/a> 并回车，应该能看到启动 HTTP 服务路径下的文件（夹）列表。这时候你也应该能看到类似下面这样的文字，标志着多少包被捕获，多少包被过滤掉了：&lt;/p>
&lt;pre>&lt;code>24 packets captured
232 packets received by filter
&lt;/code>&lt;/pre>
&lt;p>好，现在我们使用 CTRL + C 结束这个抓包过程。&lt;/p>
&lt;p>抓包后使用 &lt;a href="https://www.wireshark.org/">Wireshark&lt;/a> 打开该 http.cap 文件，在 filter 里面输入 http 以过滤掉别的我们不关心的数据包，我们应该能看到请求和响应至少两条数据。于是接下去的内容就是我们非常关心的了。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/2b/d8/2bdc949865ae703a08ffd528d44e3ad8.jpeg" alt="">&lt;/p>
&lt;p>如果你看到这里，我想请你再思考下，在不设置上面的 http filter 的时候，我们会看到比这多得多的报文，它们不是 HTTP 的请求响应所以才被过滤掉了，那么，它们都有什么呢？&lt;/p>
&lt;h2 id="扩展阅读">扩展阅读&lt;/h2>
&lt;ul>
&lt;li>【基础】如果你对 HTTP 还不熟悉的话，推荐你阅读一篇系统性介绍 HTTP 的教程，比如 &lt;a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP">MDN 的这篇教程&lt;/a>。&lt;/li>
&lt;li>【基础】&lt;a href="https://www.networkworld.com/article/3239677/the-osi-model-explained-how-to-understand-and-remember-the-7-layer-network-model.html">The OSI model explained: How to understand (and remember) the 7 layer network model&lt;/a>：如果你对网络的 OSI 7 层模型还不清楚的话，建议阅读。如果你想知道那些鼎鼎大名的网络协议在这个模型中的哪个位置，那么请从 &lt;a href="https://en.wikipedia.org/wiki/List_of_network_protocols_(OSI_model)">List of network protocols (OSI model)&lt;/a> 里面找。基于聚焦主题的关系，我们在这个专栏中不会详细介绍呈现层（Presentation Layer）之下的网络协议。&lt;/li>
&lt;li>HTTP &lt;a href="https://tools.ietf.org/html/rfc1945">1.0&lt;/a>、&lt;a href="https://tools.ietf.org/html/rfc2616">1.1&lt;/a> 和 &lt;a href="https://tools.ietf.org/html/rfc7540">2.0&lt;/a>：它们是 RFC 文档，看起来似乎枯燥乏味，通常我们不需要去仔细阅读它们，但是当我们想知道对协议的理解是否正确，它们是我们最终的参考依据。&lt;/li>
&lt;li>&lt;a href="http://www.ra.ethz.ch/cdstore/www8/data/2136/pdf/pd1.pdf">Key differences between HTTP 1.0 and HTTP 1.1&lt;/a>：文中总结了从 HTTP 1.0 到 1.1 的 9 大改进；而 &lt;a href="http://qnimate.com/post-series/http2-complete-tutorial/">HTTP/2 Complete Tutorial&lt;/a> 是一篇比较系统的 HTTP/2 的介绍。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/11/8b/1181246bbd51ce348d5729696d1dc28b.jpg" alt="unpreview">&lt;/p></description></item><item><title>极客专栏: 01丨使用了并发工具类库，线程安全就高枕无忧了吗？</title><link>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/java%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF100%E4%BE%8B/01%E4%B8%A8%E4%BD%BF%E7%94%A8%E4%BA%86%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB%E5%BA%93%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%B0%B1%E9%AB%98%E6%9E%95%E6%97%A0%E5%BF%A7%E4%BA%86%E5%90%97/</link><pubDate>Sun, 29 May 2022 00:00:00 +0000</pubDate><guid>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/java%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF100%E4%BE%8B/01%E4%B8%A8%E4%BD%BF%E7%94%A8%E4%BA%86%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB%E5%BA%93%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%B0%B1%E9%AB%98%E6%9E%95%E6%97%A0%E5%BF%A7%E4%BA%86%E5%90%97/</guid><description>
&lt;p>你好，我是朱晔。作为课程的第一讲，我今天要和你聊聊使用并发工具类库相关的话题。&lt;/p>
&lt;p>在代码审核讨论的时候，我们有时会听到有关线程安全和并发工具的一些片面的观点和结论，比如&amp;quot;把 HashMap 改为 ConcurrentHashMap，就可以解决并发问题了呀&amp;quot;&amp;ldquo;要不我们试试无锁的 CopyOnWriteArrayList 吧，性能更好&amp;rdquo;。事实上，这些说法都不太准确。&lt;/p>
&lt;p>的确，为了方便开发者进行多线程编程，现代编程语言会提供各种并发工具类。但如果我们没有充分了解它们的使用场景、解决的问题，以及最佳实践的话，盲目使用就可能会导致一些坑，小则损失性能，大则无法确保多线程情况下业务逻辑的正确性。&lt;/p>
&lt;p>我需要先说明下，这里的并发工具类是指用来解决多线程环境下并发问题的工具类库。一般而言并发工具包括同步器和容器两大类，业务代码中使用并发容器的情况会多一些，我今天分享的例子也会侧重并发容器。&lt;/p>
&lt;p>接下来，我们就看看在使用并发工具时，最常遇到哪些坑，以及如何解决、避免这些坑吧。&lt;/p>
&lt;h1 id="没有意识到线程重用导致用户信息错乱的-bug">没有意识到线程重用导致用户信息错乱的 Bug&lt;/h1>
&lt;p>之前有业务同学和我反馈，在生产上遇到一个诡异的问题，有时获取到的用户信息是别人的。查看代码后，我发现他使用了 ThreadLocal 来缓存获取到的用户信息。&lt;/p>
&lt;p>我们知道，ThreadLocal 适用于变量在线程间隔离，而在方法或类间共享的场景。如果用户信息的获取比较昂贵（比如从数据库查询用户信息），那么在 ThreadLocal 中缓存数据是比较合适的做法。但，这么做为什么会出现用户信息错乱的 Bug 呢？&lt;/p>
&lt;p>我们看一个具体的案例吧。&lt;/p>
&lt;p>使用 Spring Boot 创建一个 Web 应用程序，使用 ThreadLocal 存放一个 Integer 的值，来暂且代表需要在线程中保存的用户信息，这个值初始是 null。在业务逻辑中，我先从 ThreadLocal 获取一次值，然后把外部传入的参数设置到 ThreadLocal 中，来模拟从当前上下文获取到用户信息的逻辑，随后再获取一次值，最后输出两次获得的值和线程名称。&lt;/p>
&lt;pre tabindex="0">&lt;code>private ThreadLocal&amp;lt;Integer&amp;gt; currentUser = ThreadLocal.withInitial(() -&amp;gt; null);
@GetMapping(&amp;#34;wrong&amp;#34;)
public Map wrong(@RequestParam(&amp;#34;userId&amp;#34;) Integer userId) {
//设置用户信息之前先查询一次ThreadLocal中的用户信息
String before = Thread.currentThread().getName() + &amp;#34;:&amp;#34; + currentUser.get();
//设置用户信息到ThreadLocal
currentUser.set(userId);
//设置用户信息之后再查询一次ThreadLocal中的用户信息
String after = Thread.currentThread().getName() + &amp;#34;:&amp;#34; + currentUser.get();
//汇总输出两次查询结果
Map result = new HashMap();
result.put(&amp;#34;before&amp;#34;, before);
result.put(&amp;#34;after&amp;#34;, after);
return result;
}
&lt;/code>&lt;/pre>&lt;p>按理说，在设置用户信息之前第一次获取的值始终应该是 null，但我们要意识到，程序运行在 Tomcat 中，执行程序的线程是 Tomcat 的工作线程，而 Tomcat 的工作线程是基于线程池的。&lt;/p>
&lt;p>&lt;strong>顾名思义，线程池会重用固定的几个线程，一旦线程重用，那么很可能首次从 ThreadLocal 获取的值是之前其他用户的请求遗留的值。这时，ThreadLocal 中的用户信息就是其他用户的信息。&lt;/strong>&lt;/p>
&lt;p>为了更快地重现这个问题，我在配置文件中设置一下 Tomcat 的参数，把工作线程池最大线程数设置为 1，这样始终是同一个线程在处理请求：&lt;/p>
&lt;pre tabindex="0">&lt;code>server.tomcat.max-threads=1
&lt;/code>&lt;/pre>&lt;p>运行程序后先让用户 1 来请求接口，可以看到第一和第二次获取到用户 ID 分别是 null 和 1，符合预期：&lt;br>
&lt;img src="https://static001.geekbang.org/resource/image/4b/30/4b8f38415d03423132c7a3608ebe2430.png" alt="">&lt;/p>
&lt;p>随后用户 2 来请求接口，这次就出现了 Bug，第一和第二次获取到用户 ID 分别是 1 和 2，显然第一次获取到了用户 1 的信息，原因就是 Tomcat 的线程池重用了线程。从图中可以看到，两次请求的线程都是同一个线程：http-nio-8080-exec-1。&lt;br>
&lt;img src="https://static001.geekbang.org/resource/image/a9/db/a9ccd42716d807687b3acff9a0baf2db.png" alt="">&lt;/p>
&lt;p>这个例子告诉我们，在写业务代码时，首先要理解代码会跑在什么线程上：&lt;/p>
&lt;ul>
&lt;li>我们可能会抱怨学多线程没用，因为代码里没有开启使用多线程。但其实，可能只是我们没有意识到，在 Tomcat 这种 Web 服务器下跑的业务代码，本来就运行在一个多线程环境（否则接口也不可能支持这么高的并发），&lt;strong>并不能认为没有显式开启多线程就不会有线程安全问题&lt;/strong>。&lt;/li>
&lt;li>因为线程的创建比较昂贵，所以 Web 服务器往往会使用线程池来处理请求，这就意味着线程会被重用。这时，&lt;strong>使用类似 ThreadLocal 工具来存放一些数据时，需要特别注意在代码运行完后，显式地去清空设置的数据&lt;/strong>。如果在代码中使用了自定义的线程池，也同样会遇到这个问题。&lt;/li>
&lt;/ul>
&lt;p>理解了这个知识点后，我们修正这段代码的方案是，在代码的 finally 代码块中，显式清除 ThreadLocal 中的数据。这样一来，新的请求过来即使使用了之前的线程也不会获取到错误的用户信息了。修正后的代码如下：&lt;/p>
&lt;pre tabindex="0">&lt;code>@GetMapping(&amp;#34;right&amp;#34;)
public Map right(@RequestParam(&amp;#34;userId&amp;#34;) Integer userId) {
String before = Thread.currentThread().getName() + &amp;#34;:&amp;#34; + currentUser.get();
currentUser.set(userId);
try {
String after = Thread.currentThread().getName() + &amp;#34;:&amp;#34; + currentUser.get();
Map result = new HashMap();
result.put(&amp;#34;before&amp;#34;, before);
result.put(&amp;#34;after&amp;#34;, after);
return result;
} finally {
//在finally代码块中删除ThreadLocal中的数据，确保数据不串
currentUser.remove();
}
}
&lt;/code>&lt;/pre>&lt;p>重新运行程序可以验证，再也不会出现第一次查询用户信息查询到之前用户请求的 Bug：&lt;br>
&lt;img src="https://static001.geekbang.org/resource/image/0d/cc/0dfe40fca441b58d491fc799d120a7cc.png" alt="">&lt;/p>
&lt;p>ThreadLocal 是利用独占资源的方式，来解决线程安全问题，那如果我们确实需要有资源在线程之前共享，应该怎么办呢？这时，我们可能就需要用到线程安全的容器了。&lt;/p>
&lt;h1 id="使用了线程安全的并发工具并不代表解决了所有线程安全问题">使用了线程安全的并发工具，并不代表解决了所有线程安全问题&lt;/h1>
&lt;p>JDK 1.5 后推出的 ConcurrentHashMap，是一个高性能的线程安全的哈希表容器。&amp;ldquo;线程安全&amp;quot;这四个字特别容易让人误解，因为 &lt;strong>ConcurrentHashMap 只能保证提供的原子性读写操作是线程安全的。&lt;/strong>&lt;/p>
&lt;p>我在相当多的业务代码中看到过这个误区，比如下面这个场景。有一个含 900 个元素的 Map，现在再补充 100 个元素进去，这个补充操作由 10 个线程并发进行。开发人员误以为使用了 ConcurrentHashMap 就不会有线程安全问题，于是不加思索地写出了下面的代码：在每一个线程的代码逻辑中先通过 size 方法拿到当前元素数量，计算 ConcurrentHashMap 目前还需要补充多少元素，并在日志中输出了这个值，然后通过 putAll 方法把缺少的元素添加进去。&lt;/p>
&lt;p>为方便观察问题，我们输出了这个 Map 一开始和最后的元素个数。&lt;/p>
&lt;pre tabindex="0">&lt;code>//线程个数
private static int THREAD_COUNT = 10;
//总元素数量
private static int ITEM_COUNT = 1000;
//帮助方法，用来获得一个指定元素数量模拟数据的ConcurrentHashMap
private ConcurrentHashMap&amp;lt;String, Long&amp;gt; getData(int count) {
return LongStream.rangeClosed(1, count)
.boxed()
.collect(Collectors.toConcurrentMap(i -&amp;gt; UUID.randomUUID().toString(), Function.identity(),
(o1, o2) -&amp;gt; o1, ConcurrentHashMap::new));
}
@GetMapping(&amp;#34;wrong&amp;#34;)
public String wrong() throws InterruptedException {
ConcurrentHashMap&amp;lt;String, Long&amp;gt; concurrentHashMap = getData(ITEM_COUNT - 100);
//初始900个元素
log.info(&amp;#34;init size:{}&amp;#34;, concurrentHashMap.size());
ForkJoinPool forkJoinPool = new ForkJoinPool(THREAD_COUNT);
//使用线程池并发处理逻辑
forkJoinPool.execute(() -&amp;gt; IntStream.rangeClosed(1, 10).parallel().forEach(i -&amp;gt; {
//查询还需要补充多少个元素
int gap = ITEM_COUNT - concurrentHashMap.size();
log.info(&amp;#34;gap size:{}&amp;#34;, gap);
//补充元素
concurrentHashMap.putAll(getData(gap));
}));
//等待所有任务完成
forkJoinPool.shutdown();
forkJoinPool.awaitTermination(1, TimeUnit.HOURS);
//最后元素个数会是1000吗？
log.info(&amp;#34;finish size:{}&amp;#34;, concurrentHashMap.size());
return &amp;#34;OK&amp;#34;;
}
&lt;/code>&lt;/pre>&lt;p>访问接口后程序输出的日志内容如下：&lt;br>
&lt;img src="https://static001.geekbang.org/resource/image/2e/70/2eaf5cd1b910b2678aca15fee6144070.png" alt="">&lt;/p>
&lt;p>从日志中可以看到：&lt;/p>
&lt;ul>
&lt;li>初始大小 900 符合预期，还需要填充 100 个元素。&lt;/li>
&lt;li>worker1 线程查询到当前需要填充的元素为 36，竟然还不是 100 的倍数。&lt;/li>
&lt;li>worker13 线程查询到需要填充的元素数是负的，显然已经过度填充了。&lt;/li>
&lt;li>最后 HashMap 的总项目数是 1536，显然不符合填充满 1000 的预期。&lt;/li>
&lt;/ul>
&lt;p>针对这个场景，我们可以举一个形象的例子。ConcurrentHashMap 就像是一个大篮子，现在这个篮子里有 900 个桔子，我们期望把这个篮子装满 1000 个桔子，也就是再装 100 个桔子。有 10 个工人来干这件事儿，大家先后到岗后会计算还需要补多少个桔子进去，最后把桔子装入篮子。&lt;/p>
&lt;p>ConcurrentHashMap 这个篮子本身，可以确保多个工人在装东西进去时，不会相互影响干扰，但无法确保工人 A 看到还需要装 100 个桔子但是还未装的时候，工人 B 就看不到篮子中的桔子数量。更值得注意的是，你往这个篮子装 100 个桔子的操作不是原子性的，在别人看来可能会有一个瞬间篮子里有 964 个桔子，还需要补 36 个桔子。&lt;/p>
&lt;p>回到 ConcurrentHashMap，我们需要注意 &lt;strong>ConcurrentHashMap 对外提供的方法或能力的限制&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>使用了 ConcurrentHashMap，不代表对它的多个操作之间的状态是一致的，是没有其他线程在操作它的，如果需要确保需要手动加锁。&lt;/li>
&lt;li>诸如 size、isEmpty 和 containsValue 等聚合方法，在并发情况下可能会反映 ConcurrentHashMap 的中间状态。因此在并发情况下，这些方法的返回值只能用作参考，而不能用于流程控制。显然，利用 size 方法计算差异值，是一个流程控制。&lt;/li>
&lt;li>诸如 putAll 这样的聚合方法也不能确保原子性，在 putAll 的过程中去获取数据可能会获取到部分数据。&lt;/li>
&lt;/ul>
&lt;p>代码的修改方案很简单，整段逻辑加锁即可：&lt;/p>
&lt;pre tabindex="0">&lt;code>@GetMapping(&amp;#34;right&amp;#34;)
public String right() throws InterruptedException {
ConcurrentHashMap&amp;lt;String, Long&amp;gt; concurrentHashMap = getData(ITEM_COUNT - 100);
log.info(&amp;#34;init size:{}&amp;#34;, concurrentHashMap.size());
ForkJoinPool forkJoinPool = new ForkJoinPool(THREAD_COUNT);
forkJoinPool.execute(() -&amp;gt; IntStream.rangeClosed(1, 10).parallel().forEach(i -&amp;gt; {
//下面的这段复合逻辑需要锁一下这个ConcurrentHashMap
synchronized (concurrentHashMap) {
int gap = ITEM_COUNT - concurrentHashMap.size();
log.info(&amp;#34;gap size:{}&amp;#34;, gap);
concurrentHashMap.putAll(getData(gap));
}
}));
forkJoinPool.shutdown();
forkJoinPool.awaitTermination(1, TimeUnit.HOURS);
log.info(&amp;#34;finish size:{}&amp;#34;, concurrentHashMap.size());
return &amp;#34;OK&amp;#34;;
}
&lt;/code>&lt;/pre>&lt;p>重新调用接口，程序的日志输出结果符合预期：&lt;br>
&lt;img src="https://static001.geekbang.org/resource/image/11/b8/1151b5b87f27073725060b76c56d95b8.png" alt="">&lt;/p>
&lt;p>可以看到，只有一个线程查询到了需要补 100 个元素，其他 9 个线程查询到不需要补元素，最后 Map 大小为 1000。&lt;/p>
&lt;p>到了这里，你可能又要问了，使用 ConcurrentHashMap 全程加锁，还不如使用普通的 HashMap 呢。&lt;/p>
&lt;p>其实不完全是这样。&lt;/p>
&lt;p>ConcurrentHashMap 提供了一些原子性的简单复合逻辑方法，用好这些方法就可以发挥其威力。这就引申出代码中常见的另一个问题：在使用一些类库提供的高级工具类时，开发人员可能还是按照旧的方式去使用这些新类，因为没有使用其特性，所以无法发挥其威力。&lt;/p>
&lt;h1 id="没有充分了解并发工具的特性从而无法发挥其威力">没有充分了解并发工具的特性，从而无法发挥其威力&lt;/h1>
&lt;p>我们来看一个使用 Map 来统计 Key 出现次数的场景吧，这个逻辑在业务代码中非常常见。&lt;/p>
&lt;ul>
&lt;li>使用 ConcurrentHashMap 来统计，Key 的范围是 10。&lt;/li>
&lt;li>使用最多 10 个并发，循环操作 1000 万次，每次操作累加随机的 Key。&lt;/li>
&lt;li>如果 Key 不存在的话，首次设置值为 1。&lt;/li>
&lt;/ul>
&lt;p>代码如下：&lt;/p>
&lt;pre tabindex="0">&lt;code>//循环次数
private static int LOOP_COUNT = 10000000;
//线程数量
private static int THREAD_COUNT = 10;
//元素数量
private static int ITEM_COUNT = 1000;
private Map&amp;lt;String, Long&amp;gt; normaluse() throws InterruptedException {
ConcurrentHashMap&amp;lt;String, Long&amp;gt; freqs = new ConcurrentHashMap&amp;lt;&amp;gt;(ITEM_COUNT);
ForkJoinPool forkJoinPool = new ForkJoinPool(THREAD_COUNT);
forkJoinPool.execute(() -&amp;gt; IntStream.rangeClosed(1, LOOP_COUNT).parallel().forEach(i -&amp;gt; {
//获得一个随机的Key
String key = &amp;#34;item&amp;#34; + ThreadLocalRandom.current().nextInt(ITEM_COUNT);
synchronized (freqs) {
if (freqs.containsKey(key)) {
//Key存在则+1
freqs.put(key, freqs.get(key) + 1);
} else {
//Key不存在则初始化为1
freqs.put(key, 1L);
}
}
}
));
forkJoinPool.shutdown();
forkJoinPool.awaitTermination(1, TimeUnit.HOURS);
return freqs;
}
&lt;/code>&lt;/pre>&lt;p>我们吸取之前的教训，直接通过锁的方式锁住 Map，然后做判断、读取现在的累计值、加 1、保存累加后值的逻辑。这段代码在功能上没有问题，但无法充分发挥 ConcurrentHashMap 的威力，改进后的代码如下：&lt;/p>
&lt;pre tabindex="0">&lt;code>private Map&amp;lt;String, Long&amp;gt; gooduse() throws InterruptedException {
ConcurrentHashMap&amp;lt;String, LongAdder&amp;gt; freqs = new ConcurrentHashMap&amp;lt;&amp;gt;(ITEM_COUNT);
ForkJoinPool forkJoinPool = new ForkJoinPool(THREAD_COUNT);
forkJoinPool.execute(() -&amp;gt; IntStream.rangeClosed(1, LOOP_COUNT).parallel().forEach(i -&amp;gt; {
String key = &amp;#34;item&amp;#34; + ThreadLocalRandom.current().nextInt(ITEM_COUNT);
//利用computeIfAbsent()方法来实例化LongAdder，然后利用LongAdder来进行线程安全计数
freqs.computeIfAbsent(key, k -&amp;gt; new LongAdder()).increment();
}
));
forkJoinPool.shutdown();
forkJoinPool.awaitTermination(1, TimeUnit.HOURS);
//因为我们的Value是LongAdder而不是Long，所以需要做一次转换才能返回
return freqs.entrySet().stream()
.collect(Collectors.toMap(
e -&amp;gt; e.getKey(),
e -&amp;gt; e.getValue().longValue())
);
}
&lt;/code>&lt;/pre>&lt;p>在这段改进后的代码中，我们巧妙利用了下面两点：&lt;/p>
&lt;ul>
&lt;li>使用 ConcurrentHashMap 的原子性方法 computeIfAbsent 来做复合逻辑操作，判断 Key 是否存在 Value，如果不存在则把 Lambda 表达式运行后的结果放入 Map 作为 Value，也就是新创建一个 LongAdder 对象，最后返回 Value。&lt;/li>
&lt;li>由于 computeIfAbsent 方法返回的 Value 是 LongAdder，是一个线程安全的累加器，因此可以直接调用其 increment 方法进行累加。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>这样在确保线程安全的情况下达到极致性能，把之前 7 行代码替换为了 1 行。&lt;/strong>&lt;/p>
&lt;p>我们通过一个简单的测试比较一下修改前后两段代码的性能：&lt;/p>
&lt;pre tabindex="0">&lt;code>@GetMapping(&amp;#34;good&amp;#34;)
public String good() throws InterruptedException {
StopWatch stopWatch = new StopWatch();
stopWatch.start(&amp;#34;normaluse&amp;#34;);
Map&amp;lt;String, Long&amp;gt; normaluse = normaluse();
stopWatch.stop();
//校验元素数量
Assert.isTrue(normaluse.size() == ITEM_COUNT, &amp;#34;normaluse size error&amp;#34;);
//校验累计总数
Assert.isTrue(normaluse.entrySet().stream()
.mapToLong(item -&amp;gt; item.getValue()).reduce(0, Long::sum) == LOOP_COUNT
, &amp;#34;normaluse count error&amp;#34;);
stopWatch.start(&amp;#34;gooduse&amp;#34;);
Map&amp;lt;String, Long&amp;gt; gooduse = gooduse();
stopWatch.stop();
Assert.isTrue(gooduse.size() == ITEM_COUNT, &amp;#34;gooduse size error&amp;#34;);
Assert.isTrue(gooduse.entrySet().stream()
.mapToLong(item -&amp;gt; item.getValue())
.reduce(0, Long::sum) == LOOP_COUNT
, &amp;#34;gooduse count error&amp;#34;);
log.info(stopWatch.prettyPrint());
return &amp;#34;OK&amp;#34;;
}
&lt;/code>&lt;/pre>&lt;p>这段测试代码并无特殊之处，使用 StopWatch 来测试两段代码的性能，最后跟了一个断言判断 Map 中元素的个数以及所有 Value 的和，是否符合预期来校验代码的正确性。测试结果如下：&lt;br>
&lt;img src="https://static001.geekbang.org/resource/image/75/3a/751d484ecd8c3114c15588e7fff3263a.png" alt="">&lt;/p>
&lt;p>可以看到，&lt;strong>优化后的代码，相比使用锁来操作 ConcurrentHashMap 的方式，性能提升了 10 倍&lt;/strong>。&lt;/p>
&lt;p>你可能会问，computeIfAbsent 为什么如此高效呢？&lt;/p>
&lt;p>答案就在源码最核心的部分，也就是 Java 自带的 Unsafe 实现的 CAS。它在虚拟机层面确保了写入数据的原子性，比加锁的效率高得多：&lt;/p>
&lt;pre tabindex="0">&lt;code> static final &amp;lt;K,V&amp;gt; boolean casTabAt(Node&amp;lt;K,V&amp;gt;[] tab, int i,
Node&amp;lt;K,V&amp;gt; c, Node&amp;lt;K,V&amp;gt; v) {
return U.compareAndSetObject(tab, ((long)i &amp;lt;&amp;lt; ASHIFT) + ABASE, c, v);
}
&lt;/code>&lt;/pre>&lt;p>像 ConcurrentHashMap 这样的高级并发工具的确提供了一些高级 API，只有充分了解其特性才能最大化其威力，而不能因为其足够高级、酷炫盲目使用。&lt;/p>
&lt;h1 id="没有认清并发工具的使用场景因而导致性能问题">没有认清并发工具的使用场景，因而导致性能问题&lt;/h1>
&lt;p>除了 ConcurrentHashMap 这样通用的并发工具类之外，我们的工具包中还有些针对特殊场景实现的生面孔。一般来说，针对通用场景的通用解决方案，在所有场景下性能都还可以，属于&amp;quot;万金油&amp;rdquo;；而针对特殊场景的特殊实现，会有比通用解决方案更高的性能，但一定要在它针对的场景下使用，否则可能会产生性能问题甚至是 Bug。&lt;/p>
&lt;p>之前在排查一个生产性能问题时，我们发现一段简单的非数据库操作的业务逻辑，消耗了超出预期的时间，在修改数据时操作本地缓存比回写数据库慢许多。查看代码发现，开发同学使用了 CopyOnWriteArrayList 来缓存大量的数据，而数据变化又比较频繁。&lt;/p>
&lt;p>CopyOnWrite 是一个时髦的技术，不管是 Linux 还是 Redis 都会用到。&lt;strong>在 Java 中，CopyOnWriteArrayList 虽然是一个线程安全的 ArrayList，但因为其实现方式是，每次修改数据时都会复制一份数据出来，所以有明显的适用场景，即读多写少或者说希望无锁读的场景。&lt;/strong>&lt;/p>
&lt;p>如果我们要使用 CopyOnWriteArrayList，那一定是因为场景需要而不是因为足够酷炫。如果读写比例均衡或者有大量写操作的话，使用 CopyOnWriteArrayList 的性能会非常糟糕。&lt;/p>
&lt;p>我们写一段测试代码，来比较下使用 CopyOnWriteArrayList 和普通加锁方式 ArrayList 的读写性能吧。在这段代码中我们针对并发读和并发写分别写了一个测试方法，测试两者一定次数的写或读操作的耗时。&lt;/p>
&lt;pre tabindex="0">&lt;code>//测试并发写的性能
@GetMapping(&amp;#34;write&amp;#34;)
public Map testWrite() {
List&amp;lt;Integer&amp;gt; copyOnWriteArrayList = new CopyOnWriteArrayList&amp;lt;&amp;gt;();
List&amp;lt;Integer&amp;gt; synchronizedList = Collections.synchronizedList(new ArrayList&amp;lt;&amp;gt;());
StopWatch stopWatch = new StopWatch();
int loopCount = 100000;
stopWatch.start(&amp;#34;Write:copyOnWriteArrayList&amp;#34;);
//循环100000次并发往CopyOnWriteArrayList写入随机元素
IntStream.rangeClosed(1, loopCount).parallel().forEach(__ -&amp;gt; copyOnWriteArrayList.add(ThreadLocalRandom.current().nextInt(loopCount)));
stopWatch.stop();
stopWatch.start(&amp;#34;Write:synchronizedList&amp;#34;);
//循环100000次并发往加锁的ArrayList写入随机元素
IntStream.rangeClosed(1, loopCount).parallel().forEach(__ -&amp;gt; synchronizedList.add(ThreadLocalRandom.current().nextInt(loopCount)));
stopWatch.stop();
log.info(stopWatch.prettyPrint());
Map result = new HashMap();
result.put(&amp;#34;copyOnWriteArrayList&amp;#34;, copyOnWriteArrayList.size());
result.put(&amp;#34;synchronizedList&amp;#34;, synchronizedList.size());
return result;
}
//帮助方法用来填充List
private void addAll(List&amp;lt;Integer&amp;gt; list) {
list.addAll(IntStream.rangeClosed(1, 1000000).boxed().collect(Collectors.toList()));
}
//测试并发读的性能
@GetMapping(&amp;#34;read&amp;#34;)
public Map testRead() {
//创建两个测试对象
List&amp;lt;Integer&amp;gt; copyOnWriteArrayList = new CopyOnWriteArrayList&amp;lt;&amp;gt;();
List&amp;lt;Integer&amp;gt; synchronizedList = Collections.synchronizedList(new ArrayList&amp;lt;&amp;gt;());
//填充数据
addAll(copyOnWriteArrayList);
addAll(synchronizedList);
StopWatch stopWatch = new StopWatch();
int loopCount = 1000000;
int count = copyOnWriteArrayList.size();
stopWatch.start(&amp;#34;Read:copyOnWriteArrayList&amp;#34;);
//循环1000000次并发从CopyOnWriteArrayList随机查询元素
IntStream.rangeClosed(1, loopCount).parallel().forEach(__ -&amp;gt; copyOnWriteArrayList.get(ThreadLocalRandom.current().nextInt(count)));
stopWatch.stop();
stopWatch.start(&amp;#34;Read:synchronizedList&amp;#34;);
//循环1000000次并发从加锁的ArrayList随机查询元素
IntStream.range(0, loopCount).parallel().forEach(__ -&amp;gt; synchronizedList.get(ThreadLocalRandom.current().nextInt(count)));
stopWatch.stop();
log.info(stopWatch.prettyPrint());
Map result = new HashMap();
result.put(&amp;#34;copyOnWriteArrayList&amp;#34;, copyOnWriteArrayList.size());
result.put(&amp;#34;synchronizedList&amp;#34;, synchronizedList.size());
return result;
}
&lt;/code>&lt;/pre>&lt;p>运行程序可以看到，**大量写的场景（10 万次 add 操作），**&lt;strong>CopyOnWriteArray 几乎比同步的 ArrayList 慢一百倍&lt;/strong>：&lt;br>
&lt;img src="https://static001.geekbang.org/resource/image/97/b4/9789fe2019a1267b7883606b60e498b4.png" alt="">&lt;/p>
&lt;p>而在大量读的场景下（100 万次 get 操作），CopyOnWriteArray 又比同步的 ArrayList 快五倍以上：&lt;br>
&lt;img src="https://static001.geekbang.org/resource/image/30/36/30ba652fb3295c58b03f51de0a132436.png" alt="">&lt;/p>
&lt;p>你可能会问，为何在大量写的场景下，CopyOnWriteArrayList 会这么慢呢？&lt;/p>
&lt;p>答案就在源码中。以 add 方法为例，每次 add 时，都会用 Arrays.copyOf 创建一个新数组，频繁 add 时内存的申请释放消耗会很大：&lt;/p>
&lt;pre tabindex="0">&lt;code> /**
* Appends the specified element to the end of this list.
*
* @param e element to be appended to this list
* @return {@code true} (as specified by {@link Collection#add})
*/
public boolean add(E e) {
synchronized (lock) {
Object[] elements = getArray();
int len = elements.length;
Object[] newElements = Arrays.copyOf(elements, len + 1);
newElements[len] = e;
setArray(newElements);
return true;
}
}
&lt;/code>&lt;/pre>&lt;h1 id="重点回顾">重点回顾&lt;/h1>
&lt;p>今天，我主要与你分享了，开发人员使用并发工具来解决线程安全问题时容易犯的四类错。&lt;/p>
&lt;p>一是，只知道使用并发工具，但并不清楚当前线程的来龙去脉，解决多线程问题却不了解线程。比如，使用 ThreadLocal 来缓存数据，以为 ThreadLocal 在线程之间做了隔离不会有线程安全问题，没想到线程重用导致数据串了。请务必记得，在业务逻辑结束之前清理 ThreadLocal 中的数据。&lt;/p>
&lt;p>二是，误以为使用了并发工具就可以解决一切线程安全问题，期望通过把线程不安全的类替换为线程安全的类来一键解决问题。比如，认为使用了 ConcurrentHashMap 就可以解决线程安全问题，没对复合逻辑加锁导致业务逻辑错误。如果你希望在一整段业务逻辑中，对容器的操作都保持整体一致性的话，需要加锁处理。&lt;/p>
&lt;p>三是，没有充分了解并发工具的特性，还是按照老方式使用新工具导致无法发挥其性能。比如，使用了 ConcurrentHashMap，但没有充分利用其提供的基于 CAS 安全的方法，还是使用锁的方式来实现逻辑。你可以阅读一下ConcurrentHashMap 的文档，看一下相关原子性操作 API 是否可以满足业务需求，如果可以则优先考虑使用。&lt;/p>
&lt;p>四是，没有了解清楚工具的适用场景，在不合适的场景下使用了错误的工具导致性能更差。比如，没有理解 CopyOnWriteArrayList 的适用场景，把它用在了读写均衡或者大量写操作的场景下，导致性能问题。对于这种场景，你可以考虑是用普通的 List。&lt;/p>
&lt;p>其实，这四类坑之所以容易踩到，原因可以归结为，我们在使用并发工具的时候，并没有充分理解其可能存在的问题、适用场景等。所以最后，&lt;strong>我还要和你分享两点建议&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>一定要认真阅读官方文档（比如 Oracle JDK 文档）。充分阅读官方文档，理解工具的适用场景及其 API 的用法，并做一些小实验。了解之后再去使用，就可以避免大部分坑。&lt;/li>
&lt;li>如果你的代码运行在多线程环境下，那么就会有并发问题，并发问题不那么容易重现，可能需要使用压力测试模拟并发场景，来发现其中的 Bug 或性能问题。&lt;/li>
&lt;/ul>
&lt;p>今天用到的代码，我都放在了 GitHub 上，你可以点击这个链接查看。&lt;/p>
&lt;h1 id="思考与讨论">思考与讨论&lt;/h1>
&lt;ul>
&lt;li>今天我们多次用到了 ThreadLocalRandom，你觉得是否可以把它的实例设置到静态变量中，在多线程情况下重用呢？&lt;/li>
&lt;li>ConcurrentHashMap 还提供了 putIfAbsent 方法，你能否通过查阅JDK 文档，说说 computeIfAbsent 和 putIfAbsent 方法的区别？&lt;/li>
&lt;/ul>
&lt;p>你在使用并发工具时，还遇到过其他坑吗？我是朱晔，欢迎在评论区与我留言分享你的想法，也欢迎你把这篇文章分享给你的朋友或同事，一起交流。&lt;/p></description></item><item><title>极客专栏: 01丨可见性、原子性和有序性问题：并发编程Bug的源头</title><link>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/01%E4%B8%A8%E5%8F%AF%E8%A7%81%E6%80%A7%E5%8E%9F%E5%AD%90%E6%80%A7%E5%92%8C%E6%9C%89%E5%BA%8F%E6%80%A7%E9%97%AE%E9%A2%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8Bbug%E7%9A%84%E6%BA%90%E5%A4%B4/</link><pubDate>Sun, 29 May 2022 00:00:00 +0000</pubDate><guid>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/01%E4%B8%A8%E5%8F%AF%E8%A7%81%E6%80%A7%E5%8E%9F%E5%AD%90%E6%80%A7%E5%92%8C%E6%9C%89%E5%BA%8F%E6%80%A7%E9%97%AE%E9%A2%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8Bbug%E7%9A%84%E6%BA%90%E5%A4%B4/</guid><description>
&lt;p>如果你细心观察的话，你会发现，不管是哪一门编程语言，并发类的知识都是在高级篇里。换句话说，这块知识点其实对于程序员来说，是比较进阶的知识。我自己这么多年学习过来，也确实觉得并发是比较难的，因为它会涉及到很多的底层知识，比如若你对操作系统相关的知识一无所知的话，那去理解一些原理就会费些力气。这是我们整个专栏的第一篇文章，我说这些话的意思是如果你在中间遇到自己没想通的问题，可以去查阅资料，也可以在评论区找我，以保证你能够跟上学习进度。&lt;/p>
&lt;p>你我都知道，编写正确的并发程序是一件极困难的事情，并发程序的 Bug 往往会诡异地出现，然后又诡异地消失，很难重现，也很难追踪，很多时候都让人很抓狂。但要快速而又精准地解决&amp;quot;并发&amp;quot;类的疑难杂症，你就要理解这件事情的本质，追本溯源，深入分析这些 Bug 的源头在哪里。&lt;/p>
&lt;p>那为什么并发编程容易出问题呢？它是怎么出问题的？今天我们就重点聊聊这些 Bug 的源头。&lt;/p>
&lt;h2 id="并发程序幕后的故事">并发程序幕后的故事&lt;/h2>
&lt;p>这些年，我们的 CPU、内存、I/O 设备都在不断迭代，不断朝着更快的方向努力。但是，在这个快速发展的过程中，有一个&lt;strong>核心矛盾一直存在，就是这三者的速度差异&lt;/strong>。CPU 和内存的速度差异可以形象地描述为：CPU 是天上一天，内存是地上一年（假设 CPU 执行一条普通指令需要一天，那么 CPU 读写内存得等待一年的时间）。内存和 I/O 设备的速度差异就更大了，内存是天上一天，I/O 设备是地上十年。&lt;/p>
&lt;p>程序里大部分语句都要访问内存，有些还要访问 I/O，根据木桶理论（一只水桶能装多少水取决于它最短的那块木板），程序整体的性能取决于最慢的操作&amp;mdash;&amp;mdash;读写 I/O 设备，也就是说单方面提高 CPU 性能是无效的。&lt;/p>
&lt;p>为了合理利用 CPU 的高性能，平衡这三者的速度差异，计算机体系机构、操作系统、编译程序都做出了贡献，主要体现为：&lt;/p>
&lt;ol>
&lt;li>CPU 增加了缓存，以均衡与内存的速度差异；&lt;/li>
&lt;li>操作系统增加了进程、线程，以分时复用 CPU，进而均衡 CPU 与 I/O 设备的速度差异；&lt;/li>
&lt;li>编译程序优化指令执行次序，使得缓存能够得到更加合理地利用。&lt;/li>
&lt;/ol>
&lt;p>现在我们几乎所有的程序都默默地享受着这些成果，但是天下没有免费的午餐，并发程序很多诡异问题的根源也在这里。&lt;/p>
&lt;h2 id="源头之一缓存导致的可见性问题">源头之一：缓存导致的可见性问题&lt;/h2>
&lt;p>在单核时代，所有的线程都是在一颗 CPU 上执行，CPU 缓存与内存的数据一致性容易解决。因为所有线程都是操作同一个 CPU 的缓存，一个线程对缓存的写，对另外一个线程来说一定是可见的。例如在下面的图中，线程 A 和线程 B 都是操作同一个 CPU 里面的缓存，所以线程 A 更新了变量 V 的值，那么线程 B 之后再访问变量 V，得到的一定是 V 的最新值（线程 A 写过的值）。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/a0/da/a07e8182819e2b260ce85b2167d446da.png" alt="">
CPU 缓存与内存的关系图&lt;/p>
&lt;p>一个线程对共享变量的修改，另外一个线程能够立刻看到，我们称为&lt;strong>可见性&lt;/strong>。&lt;/p>
&lt;p>多核时代，每颗 CPU 都有自己的缓存，这时 CPU 缓存与内存的数据一致性就没那么容易解决了，当多个线程在不同的 CPU 上执行时，这些线程操作的是不同的 CPU 缓存。比如下图中，线程 A 操作的是 CPU-1 上的缓存，而线程 B 操作的是 CPU-2 上的缓存，很明显，这个时候线程 A 对变量 V 的操作对于线程 B 而言就不具备可见性了。这个就属于硬件程序员给软件程序员挖的&amp;quot;坑&amp;quot;。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/e2/ea/e2aa76928b2bc135e08e7590ca36e0ea.png" alt="">
多核 CPU 的缓存与内存关系图&lt;/p>
&lt;p>下面我们再用一段代码来验证一下多核场景下的可见性问题。下面的代码，每执行一次 add10K() 方法，都会循环 10000 次 count+=1 操作。在 calc() 方法中我们创建了两个线程，每个线程调用一次 add10K() 方法，我们来想一想执行 calc() 方法得到的结果应该是多少呢？&lt;/p>
&lt;pre>&lt;code>public class Test {
private long count = 0;
private void add10K() {
int idx = 0;
while(idx++ &amp;lt; 10000) {
count += 1;
}
}
public static long calc() {
final Test test = new Test();
// 创建两个线程，执行 add() 操作
Thread th1 = new Thread(()-&amp;gt;{
test.add10K();
});
Thread th2 = new Thread(()-&amp;gt;{
test.add10K();
});
// 启动两个线程
th1.start();
th2.start();
// 等待两个线程执行结束
th1.join();
th2.join();
return count;
}
}
&lt;/code>&lt;/pre>
&lt;p>直觉告诉我们应该是 20000，因为在单线程里调用两次 add10K() 方法，count 的值就是 20000，但实际上 calc() 的执行结果是个 10000 到 20000 之间的随机数。为什么呢？&lt;/p>
&lt;p>我们假设线程 A 和线程 B 同时开始执行，那么第一次都会将 count=0 读到各自的 CPU 缓存里，执行完 count+=1 之后，各自 CPU 缓存里的值都是 1，同时写入内存后，我们会发现内存中是 1，而不是我们期望的 2。之后由于各自的 CPU 缓存里都有了 count 的值，两个线程都是基于 CPU 缓存里的 count 值来计算，所以导致最终 count 的值都是小于 20000 的。这就是缓存的可见性问题。&lt;/p>
&lt;p>循环 10000 次 count+=1 操作如果改为循环 1 亿次，你会发现效果更明显，最终 count 的值接近 1 亿，而不是 2 亿。如果循环 10000 次，count 的值接近 20000，原因是两个线程不是同时启动的，有一个时差。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/ec/79/ec6743e74ccf9a3c6d6c819a41e52279.png" alt="">
变量 count 在 CPU 缓存和内存的分布图&lt;/p>
&lt;h2 id="源头之二线程切换带来的原子性问题">源头之二：线程切换带来的原子性问题&lt;/h2>
&lt;p>由于 IO 太慢，早期的操作系统就发明了多进程，即便在单核的 CPU 上我们也可以一边听着歌，一边写 Bug，这个就是多进程的功劳。&lt;/p>
&lt;p>操作系统允许某个进程执行一小段时间，例如 50 毫秒，过了 50 毫秒操作系统就会重新选择一个进程来执行（我们称为&amp;quot;任务切换&amp;quot;），这个 50 毫秒称为&amp;quot;&lt;strong>时间片&lt;/strong>&amp;quot;。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/25/fb/254b129b145d80e9bb74123d6e620efb.png" alt="">
线程切换示意图&lt;/p>
&lt;p>在一个时间片内，如果一个进程进行一个 IO 操作，例如读个文件，这个时候该进程可以把自己标记为&amp;quot;休眠状态&amp;quot;并出让 CPU 的使用权，待文件读进内存，操作系统会把这个休眠的进程唤醒，唤醒后的进程就有机会重新获得 CPU 的使用权了。&lt;/p>
&lt;p>这里的进程在等待 IO 时之所以会释放 CPU 使用权，是为了让 CPU 在这段等待时间里可以做别的事情，这样一来 CPU 的使用率就上来了；此外，如果这时有另外一个进程也读文件，读文件的操作就会排队，磁盘驱动在完成一个进程的读操作后，发现有排队的任务，就会立即启动下一个读操作，这样 IO 的使用率也上来了。&lt;/p>
&lt;p>是不是很简单的逻辑？但是，虽然看似简单，支持多进程分时复用在操作系统的发展史上却具有里程碑意义，Unix 就是因为解决了这个问题而名噪天下的。&lt;/p>
&lt;p>早期的操作系统基于进程来调度 CPU，不同进程间是不共享内存空间的，所以进程要做任务切换就要切换内存映射地址，而一个进程创建的所有线程，都是共享一个内存空间的，所以线程做任务切换成本就很低了。现代的操作系统都基于更轻量的线程来调度，现在我们提到的&amp;quot;任务切换&amp;quot;都是指&amp;quot;线程切换&amp;quot;。&lt;/p>
&lt;p>Java 并发程序都是基于多线程的，自然也会涉及到任务切换，也许你想不到，任务切换竟然也是并发编程里诡异 Bug 的源头之一。任务切换的时机大多数是在时间片结束的时候，我们现在基本都使用高级语言编程，高级语言里一条语句往往需要多条 CPU 指令完成，例如上面代码中的&lt;code>count += 1&lt;/code>，至少需要三条 CPU 指令。&lt;/p>
&lt;ul>
&lt;li>指令 1：首先，需要把变量 count 从内存加载到 CPU 的寄存器；&lt;/li>
&lt;li>指令 2：之后，在寄存器中执行 +1 操作；&lt;/li>
&lt;li>指令 3：最后，将结果写入内存（缓存机制导致可能写入的是 CPU 缓存而不是内存）。&lt;/li>
&lt;/ul>
&lt;p>操作系统做任务切换，可以发生在任何一条&lt;strong>CPU 指令&lt;/strong>执行完，是的，是 CPU 指令，而不是高级语言里的一条语句。对于上面的三条指令来说，我们假设 count=0，如果线程 A 在指令 1 执行完后做线程切换，线程 A 和线程 B 按照下图的序列执行，那么我们会发现两个线程都执行了 count+=1 的操作，但是得到的结果不是我们期望的 2，而是 1。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/33/63/33777c468872cb9a99b3cdc1ff597063.png" alt="">
非原子操作的执行路径示意图&lt;/p>
&lt;p>我们潜意识里面觉得 count+=1 这个操作是一个不可分割的整体，就像一个原子一样，线程的切换可以发生在 count+=1 之前，也可以发生在 count+=1 之后，但就是不会发生在中间。&lt;strong>我们把一个或者多个操作在 CPU 执行的过程中不被中断的特性称为原子性&lt;/strong>。CPU 能保证的原子操作是 CPU 指令级别的，而不是高级语言的操作符，这是违背我们直觉的地方。因此，很多时候我们需要在高级语言层面保证操作的原子性。&lt;/p>
&lt;h2 id="源头之三编译优化带来的有序性问题">源头之三：编译优化带来的有序性问题&lt;/h2>
&lt;p>那并发编程里还有没有其他有违直觉容易导致诡异 Bug 的技术呢？有的，就是有序性。顾名思义，有序性指的是程序按照代码的先后顺序执行。编译器为了优化性能，有时候会改变程序中语句的先后顺序，例如程序中：&amp;ldquo;a=6；b=7；&amp;ldquo;编译器优化后可能变成&amp;quot;b=7；a=6；&amp;quot;，在这个例子中，编译器调整了语句的顺序，但是不影响程序的最终结果。不过有时候编译器及解释器的优化可能导致意想不到的 Bug。&lt;/p>
&lt;p>在 Java 领域一个经典的案例就是利用双重检查创建单例对象，例如下面的代码：在获取实例 getInstance() 的方法中，我们首先判断 instance 是否为空，如果为空，则锁定 Singleton.class 并再次检查 instance 是否为空，如果还为空则创建 Singleton 的一个实例。&lt;/p>
&lt;pre>&lt;code>public class Singleton {
static Singleton instance;
static Singleton getInstance(){
if (instance == null) {
synchronized(Singleton.class) {
if (instance == null)
instance = new Singleton();
}
}
return instance;
}
}
&lt;/code>&lt;/pre>
&lt;p>假设有两个线程 A、B 同时调用 getInstance() 方法，他们会同时发现 &lt;code>instance == null&lt;/code> ，于是同时对 Singleton.class 加锁，此时 JVM 保证只有一个线程能够加锁成功（假设是线程 A），另外一个线程则会处于等待状态（假设是线程 B）；线程 A 会创建一个 Singleton 实例，之后释放锁，锁释放后，线程 B 被唤醒，线程 B 再次尝试加锁，此时是可以加锁成功的，加锁成功后，线程 B 检查 &lt;code>instance == null&lt;/code> 时会发现，已经创建过 Singleton 实例了，所以线程 B 不会再创建一个 Singleton 实例。&lt;/p>
&lt;p>这看上去一切都很完美，无懈可击，但实际上这个 getInstance() 方法并不完美。问题出在哪里呢？出在 new 操作上，我们以为的 new 操作应该是：&lt;/p>
&lt;ol>
&lt;li>分配一块内存 M；&lt;/li>
&lt;li>在内存 M 上初始化 Singleton 对象；&lt;/li>
&lt;li>然后 M 的地址赋值给 instance 变量。&lt;/li>
&lt;/ol>
&lt;p>但是实际上优化后的执行路径却是这样的：&lt;/p>
&lt;ol>
&lt;li>分配一块内存 M；&lt;/li>
&lt;li>将 M 的地址赋值给 instance 变量；&lt;/li>
&lt;li>最后在内存 M 上初始化 Singleton 对象。&lt;/li>
&lt;/ol>
&lt;p>优化后会导致什么问题呢？我们假设线程 A 先执行 getInstance() 方法，当执行完指令 2 时恰好发生了线程切换，切换到了线程 B 上；如果此时线程 B 也执行 getInstance() 方法，那么线程 B 在执行第一个判断时会发现 &lt;code>instance != null&lt;/code> ，所以直接返回 instance，而此时的 instance 是没有初始化过的，如果我们这个时候访问 instance 的成员变量就可能触发空指针异常。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/64/d8/64c955c65010aae3902ec918412827d8.png" alt="">
双重检查创建单例的异常执行路径&lt;/p>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>要写好并发程序，首先要知道并发程序的问题在哪里，只有确定了&amp;quot;靶子&amp;rdquo;，才有可能把问题解决，毕竟所有的解决方案都是针对问题的。并发程序经常出现的诡异问题看上去非常无厘头，但是深究的话，无外乎就是直觉欺骗了我们，&lt;strong>只要我们能够深刻理解可见性、原子性、有序性在并发场景下的原理，很多并发 Bug 都是可以理解、可以诊断的&lt;/strong>。&lt;/p>
&lt;p>在介绍可见性、原子性、有序性的时候，特意提到&lt;strong>缓存&lt;/strong> 导致的可见性问题，&lt;strong>线程切换&lt;/strong> 带来的原子性问题，&lt;strong>编译优化&lt;/strong> 带来的有序性问题，其实缓存、线程、编译优化的目的和我们写并发程序的目的是相同的，都是提高程序性能。但是技术在解决一个问题的同时，必然会带来另外一个问题，所以&lt;strong>在采用一项技术的同时，一定要清楚它带来的问题是什么，以及如何规避&lt;/strong>。&lt;/p>
&lt;p>我们这个专栏在讲解每项技术的时候，都会尽量将每项技术解决的问题以及产生的问题讲清楚，也希望你能够在这方面多思考、多总结。&lt;/p>
&lt;h2 id="课后思考">课后思考&lt;/h2>
&lt;p>常听人说，在 32 位的机器上对 long 型变量进行加减操作存在并发隐患，到底是不是这样呢？现在相信你一定能分析出来。&lt;/p>
&lt;p>欢迎在留言区与我分享你的想法，也欢迎你在留言区记录你的思考过程。感谢阅读，如果你觉得这篇文章对你有帮助的话，也欢迎把它分享给更多的朋友。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/cf/aa/cf393cd748a4f0e6451807c4b61843aa.jpg" alt="">&lt;/p></description></item><item><title>极客专栏: 01丨工作区和GOPATH</title><link>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/go-%E8%AF%AD%E8%A8%80%E6%A0%B8%E5%BF%83-36-%E8%AE%B2/01%E4%B8%A8%E5%B7%A5%E4%BD%9C%E5%8C%BA%E5%92%8Cgopath/</link><pubDate>Sun, 29 May 2022 00:00:00 +0000</pubDate><guid>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/go-%E8%AF%AD%E8%A8%80%E6%A0%B8%E5%BF%83-36-%E8%AE%B2/01%E4%B8%A8%E5%B7%A5%E4%BD%9C%E5%8C%BA%E5%92%8Cgopath/</guid><description>
&lt;h3 id="go-语言代码较多建议配合文章收听音频">【Go 语言代码较多，建议配合文章收听音频。】&lt;/h3>
&lt;p>你好，我是郝林。从今天开始，我将和你一起梳理 Go 语言的整个知识体系。&lt;/p>
&lt;p>在过去的几年里，我与广大爱好者一起见证了 Go 语言的崛起。&lt;/p>
&lt;p>从 Go 1.5 版本的自举（即用 Go 语言编写程序来实现 Go 语言自身），到 Go 1.7 版本的极速 GC（也称垃圾回收器），再到 2018 年 2 月发布的 Go 1.10 版本对其自带工具的全面升级，以及可预见的后续版本关键特性（比如用来做程序依赖管理的&lt;code>go mod&lt;/code>命令），这一切都令我们欢欣鼓舞。Go 语言在一步步走向辉煌的同时，显然已经成为软件工程师们最喜爱的编程语言之一。&lt;/p>
&lt;p>我开办这个专栏的主要目的，是要与你一起探索 Go 语言的奥秘，并帮助你在学习和实践的过程中获取更多。&lt;/p>
&lt;p>我假设本专栏的读者已经具备了一定的计算机基础，比如，你要知道操作系统是什么、环境变量怎么设置、怎样正确使用命令行，等等。&lt;/p>
&lt;p>当然了，如果你已经有了编程经验，尤其是一点点 Go 语言编程经验，那就更好了，毕竟我想教给你的，都是 Go 语言中非常核心的技术。&lt;/p>
&lt;p>如果你对 Go 语言中最基本的概念和语法还不够了解，那么可能需要在学习本专栏的过程中去查阅&lt;a href="https://golang.google.cn/ref/spec">Go 语言规范文档&lt;/a>，也可以把预习篇的基础知识图拿出来好好研究一下。&lt;/p>
&lt;p>最后，我来说一下专栏的讲述模式。我总会以一道 Go 语言的面试题开始，针对它进行解答，我会告诉你为什么我要关注这道题，这道题的背后隐藏着哪些知识，并且，我会对这部分的内容，进行相关的知识扩展。&lt;/p>
&lt;p>好了，准备就绪，我们一起开始。&lt;/p>
&lt;hr>
&lt;p>我们学习 Go 语言时，要做的第一件事，都是根据自己电脑的计算架构（比如，是 32 位的计算机还是 64 位的计算机）以及操作系统（比如，是 Windows 还是 Linux），从&lt;a href="https://golang.google.cn">Go 语言官网&lt;/a>下载对应的二进制包，也就是可以拿来即用的安装包。&lt;/p>
&lt;p>随后，我们会解压缩安装包、放置到某个目录、配置环境变量，并通过在命令行中输入&lt;code>go version&lt;/code>来验证是否安装成功。&lt;/p>
&lt;p>在这个过程中，我们还需要配置 3 个环境变量，也就是 GOROOT、GOPATH 和 GOBIN。这里我可以简单介绍一下。&lt;/p>
&lt;ul>
&lt;li>GOROOT：Go 语言安装根目录的路径，也就是 GO 语言的安装路径。&lt;/li>
&lt;li>GOPATH：若干工作区目录的路径。是我们自己定义的工作空间。&lt;/li>
&lt;li>GOBIN：GO 程序生成的可执行文件（executable file）的路径。&lt;/li>
&lt;/ul>
&lt;p>其中，GOPATH 背后的概念是最多的，也是最重要的。那么，&lt;strong>今天我们的面试问题是：你知道设置 GOPATH 有什么意义吗？&lt;/strong>&lt;/p>
&lt;p>关于这个问题，它的&lt;strong>典型回答&lt;/strong>是这样的：&lt;/p>
&lt;p>你可以把 GOPATH 简单理解成 Go 语言的工作目录，它的值是一个目录的路径，也可以是多个目录路径，每个目录都代表 Go 语言的一个工作区（workspace）。&lt;/p>
&lt;p>我们需要利于这些工作区，去放置 Go 语言的源码文件（source file），以及安装（install）后的归档文件（archive file，也就是以&amp;quot;.a&amp;quot;为扩展名的文件）和可执行文件（executable file）。&lt;/p>
&lt;p>事实上，由于 Go 语言项目在其生命周期内的所有操作（编码、依赖管理、构建、测试、安装等）基本上都是围绕着 GOPATH 和工作区进行的。所以，它的背后至少有 3 个知识点，分别是：&lt;/p>
&lt;p>&lt;strong>1. Go 语言源码的组织方式是怎样的；&lt;/strong>&lt;/p>
&lt;p>&lt;strong>2. 你是否了解源码安装后的结果（只有在安装后，Go 语言源码才能被我们或其他代码使用）；&lt;/strong>&lt;/p>
&lt;p>&lt;strong>3. 你是否理解构建和安装 Go 程序的过程（这在开发程序以及查找程序问题的时候都很有用，否则你很可能会走弯路）。&lt;/strong>&lt;/p>
&lt;p>下面我就重点来聊一聊这些内容。&lt;/p>
&lt;h2 id="知识扩展">知识扩展&lt;/h2>
&lt;ol>
&lt;li>Go 语言源码的组织方式&lt;/li>
&lt;/ol>
&lt;hr>
&lt;p>与许多编程语言一样，Go 语言的源码也是以代码包为基本组织单位的。在文件系统中，这些代码包其实是与目录一一对应的。由于目录可以有子目录，所以代码包也可以有子包。&lt;/p>
&lt;p>一个代码包中可以包含任意个以.go 为扩展名的源码文件，这些源码文件都需要被声明属于同一个代码包。&lt;/p>
&lt;p>代码包的名称一般会与源码文件所在的目录同名。如果不同名，那么在构建、安装的过程中会以代码包名称为准。&lt;/p>
&lt;p>每个代码包都会有导入路径。代码包的导入路径是其他代码在使用该包中的程序实体时，需要引入的路径。在实际使用程序实体之前，我们必须先导入其所在的代码包。具体的方式就是&lt;code>import&lt;/code>该代码包的导入路径。就像这样：&lt;/p>
&lt;pre>&lt;code>import &amp;quot;github.com/labstack/echo&amp;quot;
&lt;/code>&lt;/pre>
&lt;p>在工作区中，一个代码包的导入路径实际上就是从 src 子目录，到该包的实际存储位置的相对路径。&lt;/p>
&lt;p>所以说，Go 语言源码的组织方式就是以环境变量 GOPATH、工作区、src 目录和代码包为主线的。一般情况下，Go 语言的源码文件都需要被存放在环境变量 GOPATH 包含的某个工作区（目录）中的 src 目录下的某个代码包（目录）中。&lt;/p>
&lt;ol start="2">
&lt;li>了解源码安装后的结果&lt;/li>
&lt;/ol>
&lt;hr>
&lt;p>了解了 Go 语言源码的组织方式后，我们很有必要知道 Go 语言源码在安装后会产生怎样的结果。&lt;/p>
&lt;p>源码文件以及安装后的结果文件都会放到哪里呢？我们都知道，源码文件通常会被放在某个工作区的 src 子目录下。&lt;/p>
&lt;p>那么在安装后如果产生了归档文件（以&amp;quot;.a&amp;quot;为扩展名的文件），就会放进该工作区的 pkg 子目录；如果产生了可执行文件，就可能会放进该工作区的 bin 子目录。&lt;/p>
&lt;p>我再讲一下归档文件存放的具体位置和规则。&lt;/p>
&lt;p>源码文件会以代码包的形式组织起来，一个代码包其实就对应一个目录。安装某个代码包而产生的归档文件是与这个代码包同名的。&lt;/p>
&lt;p>放置它的相对目录就是该代码包的导入路径的直接父级。比如，一个已存在的代码包的导入路径是&lt;/p>
&lt;pre>&lt;code>github.com/labstack/echo，
&lt;/code>&lt;/pre>
&lt;p>那么执行命令&lt;/p>
&lt;pre>&lt;code>go install github.com/labstack/echo
&lt;/code>&lt;/pre>
&lt;p>生成的归档文件的相对目录就是 &lt;a href="http://github.com/labstack%EF%BC%8C">github.com/labstack，&lt;/a> 文件名为 echo.a。&lt;/p>
&lt;p>顺便说一下，上面这个代码包导入路径还有另外一层含义，那就是：该代码包的源码文件存在于 GitHub 网站的 labstack 组的代码仓库 echo 中。&lt;/p>
&lt;p>再说回来，归档文件的相对目录与 pkg 目录之间还有一级目录，叫做平台相关目录。平台相关目录的名称是由 build（也称&amp;quot;构建&amp;quot;）的目标操作系统、下划线和目标计算架构的代号组成的。&lt;/p>
&lt;p>比如，构建某个代码包时的目标操作系统是 Linux，目标计算架构是 64 位的，那么对应的平台相关目录就是 linux_amd64。&lt;/p>
&lt;p>因此，上述代码包的归档文件就会被放置在当前工作区的子目录 pkg/linux_amd64/github.com/labstack 中。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/2f/3c/2fdfb5620e072d864907870e61ae5f3c.png" alt="">&lt;br>
（GOPATH 与工作区）&lt;/p>
&lt;p>总之，你需要记住的是，某个工作区的 src 子目录下的源码文件在安装后一般会被放置到当前工作区的 pkg 子目录下对应的目录中，或者被直接放置到该工作区的 bin 子目录中。&lt;/p>
&lt;ol start="3">
&lt;li>理解构建和安装 Go 程序的过程&lt;/li>
&lt;/ol>
&lt;hr>
&lt;p>我们再来说说构建和安装 Go 程序的过程都是怎样的，以及它们的异同点。&lt;/p>
&lt;p>构建使用命令&lt;code>go build&lt;/code>，安装使用命令&lt;code>go install&lt;/code>。构建和安装代码包的时候都会执行编译、打包等操作，并且，这些操作生成的任何文件都会先被保存到某个临时的目录中。&lt;/p>
&lt;p>如果构建的是库源码文件，那么操作后产生的结果文件只会存在于临时目录中。这里的构建的主要意义在于检查和验证。&lt;/p>
&lt;p>如果构建的是命令源码文件，那么操作的结果文件会被搬运到源码文件所在的目录中。（这里讲到的两种源码文件我在&lt;a href="https://time.geekbang.org/column/article/13540?utm_source=weibo&amp;amp;utm_medium=xuxiaoping&amp;amp;utm_campaign=promotion&amp;amp;utm_content=columns">&amp;ldquo;预习篇&amp;quot;的基础知识图&lt;/a>中提到过，在后面的文章中我也会带你详细了解。）&lt;/p>
&lt;p>安装操作会先执行构建，然后还会进行链接操作，并且把结果文件搬运到指定目录。&lt;/p>
&lt;p>进一步说，如果安装的是库源码文件，那么结果文件会被搬运到它所在工作区的 pkg 目录下的某个子目录中。&lt;/p>
&lt;p>如果安装的是命令源码文件，那么结果文件会被搬运到它所在工作区的 bin 目录中，或者环境变量&lt;code>GOBIN&lt;/code>指向的目录中。&lt;/p>
&lt;p>这里你需要记住的是，构建和安装的不同之处，以及执行相应命令后得到的结果文件都会出现在哪里。&lt;/p>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>工作区和 GOPATH 的概念和含义是每个 Go 工程师都需要了解的。虽然它们都比较简单，但是说它们是 Go 程序开发的核心知识并不为过。&lt;/p>
&lt;p>然而，我在招聘面试的过程中仍然发现有人忽略掉了它们。Go 语言提供的很多工具都是在 GOPATH 和工作区的基础上运行的，比如上面提到的&lt;code>go build&lt;/code>、&lt;code>go install&lt;/code>和&lt;code>go get&lt;/code>，这三个命令也是我们最常用到的。&lt;/p>
&lt;h2 id="思考题">思考题&lt;/h2>
&lt;p>说到 Go 程序中的依赖管理，其实还有很多问题值得我们探索。我在这里留下两个问题供你进一步思考。&lt;/p>
&lt;ol>
&lt;li>Go 语言在多个工作区中查找依赖包的时候是以怎样的顺序进行的？&lt;/li>
&lt;li>如果在多个工作区中都存在导入路径相同的代码包会产生冲突吗？&lt;/li>
&lt;/ol>
&lt;p>这两个问题之间其实是有一些关联的。答案并不复杂，你做几个试验几乎就可以找到它了。你也可以看一下 Go 语言标准库中&lt;code>go build&lt;/code>包及其子包的源码。那里面的宝藏也很多，可以助你深刻理解 Go 程序的构建过程。&lt;/p>
&lt;hr>
&lt;h2 id="补充阅读">补充阅读&lt;/h2>
&lt;h2 id="go-build-命令一些可选项的用途和用法">go build 命令一些可选项的用途和用法&lt;/h2>
&lt;p>在运行&lt;code>go build&lt;/code>命令的时候，默认不会编译目标代码包所依赖的那些代码包。当然，如果被依赖的代码包的归档文件不存在，或者源码文件有了变化，那它还是会被编译。&lt;/p>
&lt;p>如果要强制编译它们，可以在执行命令的时候加入标记&lt;code>-a&lt;/code>。此时，不但目标代码包总是会被编译，它依赖的代码包也总会被编译，即使依赖的是标准库中的代码包也是如此。&lt;/p>
&lt;p>另外，如果不但要编译依赖的代码包，还要安装它们的归档文件，那么可以加入标记&lt;code>-i&lt;/code>。&lt;/p>
&lt;p>那么我们怎么确定哪些代码包被编译了呢？有两种方法。&lt;/p>
&lt;ol>
&lt;li>运行&lt;code>go build&lt;/code>命令时加入标记&lt;code>-x&lt;/code>，这样可以看到&lt;code>go build&lt;/code>命令具体都执行了哪些操作。另外也可以加入标记&lt;code>-n&lt;/code>，这样可以只查看具体操作而不执行它们。&lt;/li>
&lt;li>运行&lt;code>go build&lt;/code>命令时加入标记&lt;code>-v&lt;/code>，这样可以看到&lt;code>go build&lt;/code>命令编译的代码包的名称。它在与&lt;code>-a&lt;/code>标记搭配使用时很有用。&lt;/li>
&lt;/ol>
&lt;p>下面再说一说与 Go 源码的安装联系很紧密的一个命令：&lt;code>go get&lt;/code>。&lt;/p>
&lt;p>命令&lt;code>go get&lt;/code>会自动从一些主流公用代码仓库（比如 GitHub）下载目标代码包，并把它们安装到环境变量&lt;code>GOPATH&lt;/code>包含的第 1 工作区的相应目录中。如果存在环境变量&lt;code>GOBIN&lt;/code>，那么仅包含命令源码文件的代码包会被安装到&lt;code>GOBIN&lt;/code>指向的那个目录。&lt;/p>
&lt;p>最常用的几个标记有下面几种。&lt;/p>
&lt;ul>
&lt;li>&lt;code>-u&lt;/code>：下载并安装代码包，不论工作区中是否已存在它们。&lt;/li>
&lt;li>&lt;code>-d&lt;/code>：只下载代码包，不安装代码包。&lt;/li>
&lt;li>&lt;code>-fix&lt;/code>：在下载代码包后先运行一个用于根据当前 Go 语言版本修正代码的工具，然后再安装代码包。&lt;/li>
&lt;li>&lt;code>-t&lt;/code>：同时下载测试所需的代码包。&lt;/li>
&lt;li>&lt;code>-insecure&lt;/code>：允许通过非安全的网络协议下载和安装代码包。HTTP 就是这样的协议。&lt;/li>
&lt;/ul>
&lt;p>Go 语言官方提供的&lt;code>go get&lt;/code>命令是比较基础的，其中并没有提供依赖管理的功能。目前 GitHub 上有很多提供这类功能的第三方工具，比如&lt;code>glide&lt;/code>、&lt;code>gb&lt;/code>以及官方出品的&lt;code>dep&lt;/code>、&lt;code>vgo&lt;/code>等等，它们在内部大都会直接使用&lt;code>go get&lt;/code>。&lt;/p>
&lt;p>有时候，我们可能会出于某种目的变更存储源码的代码仓库或者代码包的相对路径。这时，为了让代码包的远程导入路径不受此类变更的影响，我们会使用自定义的代码包导入路径。&lt;/p>
&lt;p>对代码包的远程导入路径进行自定义的方法是：在该代码包中的库源码文件的包声明语句的右边加入导入注释，像这样：&lt;/p>
&lt;pre>&lt;code>package semaphore // import &amp;quot;golang.org/x/sync/semaphore&amp;quot;
&lt;/code>&lt;/pre>
&lt;p>这个代码包原本的完整导入路径是&lt;code>github.com/golang/sync/semaphore&lt;/code>。这与实际存储它的网络地址对应的。该代码包的源码实际存在 GitHub 网站的 golang 组的 sync 代码仓库的 semaphore 目录下。而加入导入注释之后，用以下命令即可下载并安装该代码包了：&lt;/p>
&lt;pre>&lt;code>go get golang.org/x/sync/semaphore
&lt;/code>&lt;/pre>
&lt;p>而 Go 语言官网 golang.org 下的路径 /x/sync/semaphore 并不是存放&lt;code>semaphore&lt;/code>包的真实地址。我们称之为代码包的自定义导入路径。&lt;/p>
&lt;p>不过，这还需要在 golang.org 这个域名背后的服务端程序上，添加一些支持才能使这条命令成功。&lt;/p>
&lt;p>关于自定义代码包导入路径的完整说明可以参看&lt;a href="https://github.com/hyper0x/go_command_tutorial/blob/master/0.3.md">这里&lt;/a>。&lt;/p>
&lt;p>好了，对于&lt;code>go build&lt;/code>命令和&lt;code>go get&lt;/code>命令的简短介绍就到这里。如果你想查阅更详细的文档，那么可以访问 Go 语言官方的&lt;a href="https://golang.google.cn/cmd/go">命令文档页面&lt;/a>，或者在命令行下输入诸如&lt;code>go help build&lt;/code>这类的命令。&lt;/p>
&lt;p>&lt;a href="https://github.com/hyper0x/Golang_Puzzlers">戳此查看 Go 语言专栏文章配套详细代码。&lt;/a>&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/35/48/358e4e8578a706598e18a7dfed3ed648.jpg" alt="">&lt;/p></description></item><item><title>极客专栏: 01丨核心原理：能否画张图解释下RPC的通信流程？</title><link>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/rpc%E5%AE%9E%E6%88%98%E4%B8%8E%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/01%E4%B8%A8%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E8%83%BD%E5%90%A6%E7%94%BB%E5%BC%A0%E5%9B%BE%E8%A7%A3%E9%87%8A%E4%B8%8Brpc%E7%9A%84%E9%80%9A%E4%BF%A1%E6%B5%81%E7%A8%8B/</link><pubDate>Sat, 28 May 2022 00:00:00 +0000</pubDate><guid>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/rpc%E5%AE%9E%E6%88%98%E4%B8%8E%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/01%E4%B8%A8%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E8%83%BD%E5%90%A6%E7%94%BB%E5%BC%A0%E5%9B%BE%E8%A7%A3%E9%87%8A%E4%B8%8Brpc%E7%9A%84%E9%80%9A%E4%BF%A1%E6%B5%81%E7%A8%8B/</guid><description>
&lt;p>你好，我是何小锋。只要你做过几年开发，那我相信 RPC 这个词你肯定是不陌生了。写专栏之前，我还特意查了下 RPC 的百度指数，发现这些年 RPC 的搜索趋势都是稳步上升的，这也侧面说明了这项技术正在逐步渗透到我们的日常开发中。作为专栏的第一讲，我想只围绕&amp;quot;RPC&amp;quot;这个词，和你聊聊它的定义，它要解决的问题，以及工作原理。&lt;/p>
&lt;p>在前些年，我面试工程师的时候，最喜欢问候选人一个问题，&amp;ldquo;你能否给我解释下 RPC 的通信流程&amp;rdquo;。这问题其实并不难，不过因为很多工程师平时都在用各种框架，他们可能并未停下来思考过框架的原理，所以，问完这问题，有的人就犹豫了，吱唔了半天也没说出所以然来。&lt;/p>
&lt;p>紧接着，我会引导他说，&amp;ldquo;你想想，如果没有 RPC 框架，那你要怎么调用另外一台服务器上的接口呢&amp;rdquo;。你看，这问题可深可浅，也特别考验候选人的基本功。如果你是候选人，你会怎么回答呢？今天我就来试着回答你这个问题。&lt;/p>
&lt;h1 id="什么是-rpc">什么是 RPC？&lt;/h1>
&lt;p>我知道你肯定不喜欢听概念，我也是这样，看书的时候一看到概念就直接略过。不过，到后来，我才发现，&amp;ldquo;定义&amp;quot;是一件多么伟大的事情。当我们能够用一句话把一个东西给定义出来的时候，侧面也说明你已经彻底理解这事了，不仅知道它要解决什么问题，还要知道它的边界。所以，你可以先停下来想想，什么是 RPC。&lt;/p>
&lt;p>RPC 的全称是 Remote Procedure Call，即远程过程调用。简单解读字面上的意思，远程肯定是指要跨机器而非本机，所以需要用到网络编程才能实现，但是不是只要通过网络通信访问到另一台机器的应用程序，就可以称之为 RPC 调用了？显然并不够。&lt;/p>
&lt;p>我理解的 RPC 是帮助我们屏蔽网络编程细节，实现调用远程方法就跟调用本地（同一个项目中的方法）一样的体验，我们不需要因为这个方法是远程调用就需要编写很多与业务无关的代码。&lt;/p>
&lt;p>这就好比建在小河上的桥一样连接着河的两岸，如果没有小桥，我们需要通过划船、绕道等其他方式才能到达对面，但是有了小桥之后，我们就能像在路面上一样行走到达对面，并且跟在路面上行走的体验没有区别。所以&lt;strong>我认为，RPC 的作用就是体现在这样两个方面：&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>屏蔽远程调用跟本地调用的区别，让我们感觉就是调用项目内的方法；&lt;/li>
&lt;li>隐藏底层网络通信的复杂性，让我们更专注于业务逻辑。&lt;/li>
&lt;/ul>
&lt;h1 id="rpc-通信流程">RPC 通信流程&lt;/h1>
&lt;p>理解了什么是 RPC，接下来我们讲下 RPC 框架的通信流程，方便我们进一步理解 RPC。&lt;/p>
&lt;p>如前面所讲，RPC 能帮助我们的应用透明地完成远程调用，发起调用请求的那一方叫做调用方，被调用的一方叫做服务提供方。为了实现这个的目标，我们就需要在 RPC 框架里面对整个通信细节进行封装，&lt;strong>那一个完整的 RPC 会涉及到哪些步骤呢？&lt;/strong>&lt;/p>
&lt;p>我们已经知道 RPC 是一个远程调用，那肯定就需要通过网络来传输数据，并且 RPC 常用于业务系统之间的数据交互，需要保证其可靠性，所以 RPC 一般默认采用 TCP 来传输。我们常用的 HTTP 协议也是建立在 TCP 之上的。&lt;/p>
&lt;p>网络传输的数据必须是二进制数据，但调用方请求的出入参数都是对象。对象是肯定没法直接在网络中传输的，需要提前把它转成可传输的二进制，并且要求转换算法是可逆的，这个过程我们一般叫做&amp;quot;序列化&amp;rdquo;。&lt;/p>
&lt;p>调用方持续地把请求参数序列化成二进制后，经过 TCP 传输给了服务提供方。服务提供方从 TCP 通道里面收到二进制数据，那如何知道一个请求的数据到哪里结束，是一个什么类型的请求呢？&lt;/p>
&lt;p>在这里我们可以想想高速公路，它上面有很多出口，为了让司机清楚地知道从哪里出去，管理部门会在路上建立很多指示牌，并在指示牌上标明下一个出口是哪里、还有多远。那回到数据包识别这个场景，我们是不是也可以建立一些&amp;quot;指示牌&amp;quot;，并在上面标明数据包的类型和长度，这样就可以正确的解析数据了。确实可以，并且我们把数据格式的约定内容叫做&amp;quot;协议&amp;quot;。大多数的协议会分成两部分，分别是数据头和消息体。数据头一般用于身份识别，包括协议标识、数据大小、请求类型、序列化类型等信息；消息体主要是请求的业务参数信息和扩展属性等。&lt;/p>
&lt;p>根据协议格式，服务提供方就可以正确地从二进制数据中分割出不同的请求来，同时根据请求类型和序列化类型，把二进制的消息体逆向还原成请求对象。这个过程叫作&amp;quot;反序列化&amp;quot;。&lt;/p>
&lt;p>服务提供方再根据反序列化出来的请求对象找到对应的实现类，完成真正的方法调用，然后把执行结果序列化后，回写到对应的 TCP 通道里面。调用方获取到应答的数据包后，再反序列化成应答对象，这样调用方就完成了一次 RPC 调用。&lt;/p>
&lt;p>&lt;strong>那上述几个流程就组成了一个完整的 RPC 吗？&lt;/strong>&lt;/p>
&lt;p>在我看来，还缺点东西。因为对于研发人员来说，这样做要掌握太多的 RPC 底层细节，需要手动写代码去构造请求、调用序列化，并进行网络调用，整个 API 非常不友好。&lt;/p>
&lt;p>那我们有什么办法来简化 API，屏蔽掉 RPC 细节，让使用方只需要关注业务接口，像调用本地一样来调用远程呢？&lt;/p>
&lt;p>如果你了解 Spring，一定对其 AOP 技术很佩服，其核心是采用动态代理的技术，通过字节码增强对方法进行拦截增强，以便于增加需要的额外处理逻辑。其实这个技术也可以应用到 RPC 场景来解决我们刚才面临的问题。&lt;/p>
&lt;p>由服务提供者给出业务接口声明，在调用方的程序里面，RPC 框架根据调用的服务接口提前生成动态代理实现类，并通过依赖注入等技术注入到声明了该接口的相关业务逻辑里面。该代理实现类会拦截所有的方法调用，在提供的方法处理逻辑里面完成一整套的远程调用，并把远程调用结果返回给调用方，这样调用方在调用远程方法的时候就获得了像调用本地接口一样的体验。&lt;/p>
&lt;p>到这里，一个简单版本的 RPC 框架就实现了。我把整个流程都画出来了，供你参考：&lt;br>
&lt;img src="https://static001.geekbang.org/resource/image/ac/fa/acf53138659f4982bbef02acdd30f1fa.jpg" alt="">&lt;/p>
&lt;h1 id="rpc-在架构中的位置">RPC 在架构中的位置&lt;/h1>
&lt;p>围绕 RPC 我们讲了这么多，那 RPC 在架构中究竟处于什么位置呢？&lt;/p>
&lt;p>如刚才所讲，RPC 是解决应用间通信的一种方式，而无论是在一个大型的分布式应用系统还是中小型系统中，应用架构最终都会从&amp;quot;单体&amp;quot;演进成&amp;quot;微服务化&amp;quot;，整个应用系统会被拆分为多个不同功能的应用，并将它们部署在不同的服务器中，而应用之间会通过 RPC 进行通信，可以说 RPC 对应的是整个分布式应用系统，就像是&amp;quot;经络&amp;quot;一样的存在。&lt;/p>
&lt;p>那么如果没有 RPC，我们现实中的开发过程是怎样的一个体验呢？&lt;/p>
&lt;p>所有的功能代码都会被我们堆砌在一个大项目中，开发过程中你可能要改一行代码，但改完后编译会花掉你 2 分钟，编译完想运行起来验证下结果可能要 5 分钟，是不是很酸爽？更难受的是在人数比较多的团队里面，多人协同开发的时候，如果团队其他人把接口定义改了，你连编译通过的机会都没有，系统直接报错，从而导致整个团队的开发效率都会非常低下。而且当我们准备要上线发版本的时候，QA 也很难评估这次的测试范围，为了保险起见我们只能把所有的功能进行回归测试，这样会导致我们上线新功能的整体周期都特别长。&lt;/p>
&lt;p>无论你是研发还是架构师，我相信这种系统架构我们肯定都不能接受，那怎么才能解决这个问题呢？&lt;/p>
&lt;p>我们首先都会想到可以采用&amp;quot;分而治之&amp;quot;的思想来进行拆分，但是拆分完的系统怎么保持跟未拆分前的调用方式一样呢？我们总不能因为架构升级，就把所有的代码都推倒重写一遍吧。&lt;/p>
&lt;p>**RPC 框架能够帮助我们解决系统拆分后的通信问题，并且能让我们像调用本地一样去调用远程方法。**利用 RPC 我们不仅可以很方便地将应用架构从&amp;quot;单体&amp;quot;演进成&amp;quot;微服务化&amp;quot;，而且还能解决实际开发过程中的效率低下、系统耦合等问题，这样可以使得我们的系统架构整体清晰、健壮，应用可运维度增强。&lt;/p>
&lt;p>当然 RPC 不仅可以用来解决通信问题，它还被用在了很多其他场景，比如：发 MQ、分布式缓存、数据库等。下图是我之前开发的一个应用架构图：&lt;br>
&lt;img src="https://static001.geekbang.org/resource/image/50/be/506e902e06e91663334672c29bfbc2be.jpg" alt="">&lt;/p>
&lt;p>在这个应用中，我使用了 MQ 来处理异步流程、Redis 缓存热点数据、MySQL 持久化数据，还有就是在系统中调用另外一个业务系统的接口，对我的应用来说这些都是属于 RPC 调用，而 MQ、MySQL 持久化的数据也会存在于一个分布式文件系统中，他们之间的调用也是需要用 RPC 来完成数据交互的。&lt;/p>
&lt;p>由此可见，RPC 确实是我们日常开发中经常接触的东西，只是被包装成了各种框架，导致我们很少意识到这就是 RPC，让 RPC 变成了我们最&amp;quot;熟悉的陌生人&amp;quot;。现在，回过头想想，我说 RPC 是整个应用系统的&amp;quot;经络&amp;quot;，这不为过吧？我们真的很有必要学好 RPC，不仅因为 RPC 是构建复杂系统的基石，还是提升自身认知的利器。&lt;/p>
&lt;h1 id="总结">总结&lt;/h1>
&lt;p>本讲我主要讲了下 RPC 的原理，RPC 就是提供一种透明调用机制，让使用者不必显式地区分本地调用和远程调用。RPC 虽然可以帮助开发者屏蔽远程调用跟本地调用的区别，但毕竟涉及到远程网络通信，所以这里还是有很多使用上的区别，比如：&lt;/p>
&lt;ul>
&lt;li>调用过程中超时了怎么处理业务？&lt;/li>
&lt;li>什么场景下最适合使用 RPC？&lt;/li>
&lt;li>什么时候才需要考虑开启压缩？&lt;/li>
&lt;/ul>
&lt;p>无论你是一个初级开发者还是高级开发者，RPC 都应该是你日常开发过程中绕不开的一个话题，所以作为软件开发者的我们，真的很有必要详细地了解 RPC 实现细节。只有这样，才能帮助我们更好地在日常工作中使用 RPC。&lt;/p>
&lt;h1 id="课后思考">课后思考&lt;/h1>
&lt;ul>
&lt;li>你应用中有哪些地方用到了 RPC？&lt;/li>
&lt;li>你认为，RPC 使用过程中需要注意哪些问题？&lt;/li>
&lt;/ul>
&lt;p>欢迎留言和我分享你的思考和疑惑，也欢迎你把文章分享给你的朋友，邀请他加入学习。我们下节课再见！&lt;/p></description></item><item><title>极客专栏: 01丨缺乏业务含义的命名：如何精准命名？</title><link>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E4%BB%A3%E7%A0%81%E4%B9%8B%E4%B8%91/01%E4%B8%A8%E7%BC%BA%E4%B9%8F%E4%B8%9A%E5%8A%A1%E5%90%AB%E4%B9%89%E7%9A%84%E5%91%BD%E5%90%8D%E5%A6%82%E4%BD%95%E7%B2%BE%E5%87%86%E5%91%BD%E5%90%8D/</link><pubDate>Sat, 28 May 2022 00:00:00 +0000</pubDate><guid>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E4%BB%A3%E7%A0%81%E4%B9%8B%E4%B8%91/01%E4%B8%A8%E7%BC%BA%E4%B9%8F%E4%B8%9A%E5%8A%A1%E5%90%AB%E4%B9%89%E7%9A%84%E5%91%BD%E5%90%8D%E5%A6%82%E4%BD%95%E7%B2%BE%E5%87%86%E5%91%BD%E5%90%8D/</guid><description>
&lt;p>你好，我是郑晔。&lt;/p>
&lt;p>讲写代码的书通常都会从命名开始讲，《程序设计实践》如此，《代码整洁之道》亦然。所以，我们这个讲代码坏味道的专栏，也遵循传统，从命名开始讲。&lt;/p>
&lt;p>不过，也许你会说：&amp;ldquo;我知道，命名不就是不能用 abcxyz 命名，名字要有意义嘛，这有什么好讲的。&amp;ldquo;然而，即便懂得了名字要有意义这个道理，很多程序员依然无法从命名的泥潭中挣脱出来。&lt;/p>
&lt;h1 id="不精准的命名">不精准的命名&lt;/h1>
&lt;p>我们先来看一段代码：&lt;/p>
&lt;pre tabindex="0">&lt;code>public void processChapter(long chapterId) {
Chapter chapter = this.repository.findByChapterId(chapterId);
if (chapter == null) {
throw new IllegalArgumentException(&amp;#34;Unknown chapter [&amp;#34; + chapterId + &amp;#34;]&amp;#34;);
}
chapter.setTranslationState(TranslationState.TRANSLATING);
this.repository.save(chapter);
}
&lt;/code>&lt;/pre>&lt;p>这是一段看上去还挺正常的代码，甚至以很多团队的标准来看，这段代码写得还不错。但如果我问你，这段代码是做什么的。你就需要调动全部注意力，去认真阅读这段代码，找出其中的逻辑。经过阅读我们发现，这段代码做的就是把一个章节的翻译状态改成翻译中。&lt;/p>
&lt;p>问题来了，为什么你需要阅读这段代码的细节，才能知道这段代码是做什么的？&lt;/p>
&lt;p>问题就出在函数名上。这个函数的名字叫 processChapter（处理章节），这个函数确实是在处理章节，但是，这个名字太过宽泛。如果说&amp;quot;将章节的翻译状态改成翻译中&amp;quot;叫做处理章节，那么&amp;quot;将章节的翻译状态改成翻译完&amp;quot;是不是也叫处理章节呢？&amp;ldquo;修改章节内容&amp;quot;是不是也叫处理章节呢？换句话说，如果各种场景都能够叫处理章节，那么处理章节就是一个过于宽泛的名字，没有错，但不精准。&lt;/p>
&lt;p>这就是一类典型的命名问题，从表面上看，这个名字是有含义的，但实际上，它并不能有效地反映这段代码的含义。如果说我在做的是一个信息处理系统，你根本无法判断，我做是一个电商平台，还是一个图书管理系统，从沟通的角度看，这就不是一个有效的沟通。要想理解它，你需要消耗大量认知成本，无论是时间，还是精力。&lt;/p>
&lt;p>&lt;strong>命名过于宽泛，不能精准描述，这是很多代码在命名上存在的严重问题，也是代码难以理解的根源所在&lt;/strong>。&lt;/p>
&lt;p>或许这么说你的印象还是不深刻，我们看看下面这些词是不是经常出现在你的代码里：data、info、flag、process、handle、build、maintain、manage、modify 等等。这些名字都属于典型的过于宽泛的名字，当这些名字出现在你的代码里，多半是写代码的人当时没有想好用什么名字，就开始写代码了。我相信，只要稍微仔细想想，类似的名字你一定还能想出不少来。&lt;/p>
&lt;p>回到前面那段代码上，如果它不叫&amp;quot;处理章节&amp;rdquo;，那应该叫什么呢？首先，&lt;strong>命名要能够描述出这段代码在做的事情&lt;/strong>。这段代码在做的事情就是&amp;quot;将章节修改为翻译中&amp;rdquo;。那是不是它就应该叫 changeChapterToTranlsating 呢？&lt;/p>
&lt;p>不可否认，相比于&amp;quot;处理章节&amp;rdquo;，changeChapterToTranlsating 这个名字已经进了一步，然而，它也不算是一个好名字，因为它更多的是在描述这段代码在做的细节。我们之所以要将一段代码封装起来，一个重要的原因就是，我们不想知道那么多的细节。如果把细节平铺开来，那本质上和直接阅读代码细节差别并不大。&lt;/p>
&lt;p>所以，&lt;strong>一个好的名字应该描述意图，而非细节。&lt;/strong>&lt;/p>
&lt;p>就这段代码而言， 我们为什么要把翻译状态修改成翻译中，这一定是有原因的，也就是意图。具体到这里的业务，我们把翻译状态修改成翻译中，是因为我们在这里开启了一个翻译的过程。所以，这段函数应该命名 startTranslation。&lt;/p>
&lt;pre tabindex="0">&lt;code>public void startTranslation(long chapterId) {
Chapter chapter = this.repository.findByChapterId(chapterId);
if (chapter == null) {
throw new IllegalArgumentException(&amp;#34;Unknown chapter [&amp;#34; + chapterId + &amp;#34;]&amp;#34;);
}
chapter.setTranslationState(TranslationState.TRANSLATING);
this.repository.save(chapter);
}
&lt;/code>&lt;/pre>&lt;h1 id="用技术术语命名">用技术术语命名&lt;/h1>
&lt;p>我们再来看一段代码：&lt;/p>
&lt;pre tabindex="0">&lt;code>List&amp;lt;Book&amp;gt; bookList = service.getBooks();
&lt;/code>&lt;/pre>&lt;p>可以说这是一段常见得不能再常见的代码了，但这段代码却隐藏另外一个典型得不能再典型的问题：&lt;strong>用技术术语命名。&lt;/strong>&lt;/p>
&lt;p>这个 bookList 变量之所以叫 bookList，原因就是它声明的类型是 List。这种命名在代码中几乎是随处可见的，比如 xxxMap、xxxSet。&lt;/p>
&lt;p>这是一种不费脑子的命名方式，但是，这种命名却会带来很多问题，因为它是一种基于实现细节的命名方式。&lt;/p>
&lt;p>我们都知道，编程有一个重要的原则是面向接口编程，这个原则从另外一个角度理解，就是不要面向实现编程，&lt;strong>因为接口是稳定的，而实现是易变的&lt;/strong>。虽然在大多数人的理解里，这个原则是针对类型的，但在命名上，我们也应该遵循同样的原则。为什么？我举个例子你就知道了。&lt;/p>
&lt;p>比如，如果我发现，我现在需要的是一个不重复的作品集合，也就是说，我需要把这个变量的类型从 List 改成 Set。变量类型你一定会改，但变量名你会改吗？这还真不一定，一旦出现遗忘，就会出现一个奇特的现象，一个叫 bookList 的变量，它的类型是一个 Set。这样，一个新的混淆就此产生了。&lt;/p>
&lt;p>那有什么更好的名字吗？我们需要一个更面向意图的名字。其实，我们在这段代码里真正要表达的是拿到了一堆书，所以，这个名字可以命名成 books。&lt;/p>
&lt;pre tabindex="0">&lt;code>List&amp;lt;Book&amp;gt; books = service.getBooks();
&lt;/code>&lt;/pre>&lt;p>也许你发现了，这个名字其实更简单，但从表意的程度上来说，它却是一个更有效的名字。&lt;/p>
&lt;p>虽然这里我们只是以变量为例说明了以技术术语命名存在的问题，事实上，**在实际的代码中，技术名词的出现，**&lt;strong>往往就代表着它缺少了一个应有的模型。&lt;/strong>&lt;/p>
&lt;p>比如，在业务代码里如果直接出现了 Redis：&lt;/p>
&lt;pre tabindex="0">&lt;code>public Book getByIsbn(String isbn) {
Book cachedBook = redisBookStore.get(isbn);
if (cachedBook != null) {
return cachedBook;
}
Book book = doGetByIsbn(isbn);
redisBookStore.put(isbn, book);
return book;
}
&lt;/code>&lt;/pre>&lt;p>通常来说，这里真正需要的是一个缓存。Redis 是缓存这个模型的一个实现：&lt;/p>
&lt;pre tabindex="0">&lt;code>public Book getByIsbn(String isbn) {
Book cachedBook = cache.get(isbn);
if (cachedBook != null) {
return cachedBook;
}
Book book = doGetByIsbn(isbn);
cache.put(isbn, book);
return book;
}
&lt;/code>&lt;/pre>&lt;p>再进一步，缓存这个概念其实也是一个技术术语，从某种意义上说，它也不应该出现在业务代码中。这方面做得比较好的是 Spring。使用 Spring 框架时，如果需要缓存，我们通常是加上一个 Annotation（注解）：&lt;/p>
&lt;pre tabindex="0">&lt;code>@Cacheable(&amp;#34;books&amp;#34;)
public Book getByIsbn(String isbn) {
...
}
&lt;/code>&lt;/pre>&lt;p>程序员之所以喜欢用技术名词去命名，一方面是因为，这是大家习惯的语言，另一方面也是因为程序员学习写代码，很大程度上是参考别人的代码，而行业里面优秀的代码常常是一些开源项目，而这些开源项目往往是技术类的项目。&lt;strong>在一个技术类的项目中，这些技术术语其实就是它的业务语言。但对于业务项目，这个说法就必须重新审视了。&lt;/strong>&lt;/p>
&lt;p>如果这个部分的代码确实就是处理一些技术，使用技术术语无可厚非，但如果是在处理业务，就要尽可能把技术术语隔离开来。&lt;/p>
&lt;h1 id="用业务语言写代码">用业务语言写代码&lt;/h1>
&lt;p>无论是不精准的命名也好，技术名词也罢，归根结底，体现的是同一个问题：对业务理解不到位。&lt;/p>
&lt;p>我在《10x 程序员工作法》专栏中曾经说过，&lt;strong>编写可维护的代码要使用业务语言&lt;/strong>。怎么才知道自己的命名是否用的是业务语言呢？一种简单的做法就是，把这个词讲给产品经理，看他知不知道是怎么回事。&lt;/p>
&lt;p>从团队的角度看，让每个人根据自己的理解来命名，确实就有可能出现千奇百怪的名字，所以，一个良好的团队实践是，&lt;strong>建立团队的词汇表&lt;/strong>，让团队成员有信息可以参考。&lt;/p>
&lt;p>团队对于业务有了共同理解，我们也许就可以发现一些更高级的坏味道，比如说下面这个函数声明：&lt;/p>
&lt;pre tabindex="0">&lt;code>public void approveChapter(long chapterId, long userId) {
...
}
&lt;/code>&lt;/pre>&lt;p>这个函数的意图是，确认章节内容审核通过。这里有一个问题，chapterId 是审核章节的 ID，这个没问题，但 userId 是什么呢？了解了一下背景，我们才知道，之所以这里要有一个 userId，是因为这里需要记录一下审核人的信息，这个 userId 就是审核人的 userId。&lt;/p>
&lt;p>你看，通过业务的分析，我们会发现，这个 userId 并不是一个好的命名，因为它还需要更多的解释，更好的命名是 reviewerUserId，之所以起这个名字，因为这个用户在这个场景下扮演的角色是审核人（Reviewer）。&lt;/p>
&lt;pre tabindex="0">&lt;code>public void approveChapter(long chapterId, long reviewerUserId) {
...
}
&lt;/code>&lt;/pre>&lt;p>从某种意义上来说，这个坏味道也是一种不精准的命名，但它不是那种一眼可见的坏味道，&lt;strong>而是需要在业务层面上再进行讨论&lt;/strong>，所以，它是一种更高级的坏味道。&lt;/p>
&lt;p>我初入职场的时候，有一次为一个名字陷入了沉思，一个工作经验丰富的同事对此的评价是：你开始进阶了。确实，能够意识到自己的命名有问题，是程序员进阶的第一步。&lt;/p>
&lt;h1 id="总结时刻">总结时刻&lt;/h1>
&lt;p>我们今天讲了两个典型的命名坏味道：&lt;/p>
&lt;ul>
&lt;li>不精准的命名；&lt;/li>
&lt;li>用技术术语命名。&lt;/li>
&lt;/ul>
&lt;p>命名是软件开发中两件难事之一（另一个难事是缓存失效），不好的命名本质上是增加我们的认知成本，同样也增加了后来人（包括我们自己）维护代码的成本。&lt;/p>
&lt;p>好的命名要体现出这段代码在做的事情，而无需展开代码了解其中的细节，这是最低的要求。再进一步，好的命名要准确地体现意图，而不是实现细节。更高的要求是，用业务语言写代码。&lt;/p>
&lt;p>至此，我们已经对命名有了一个更深入的认识。下一讲，我们来说说国外那些经典的讲编码的书都不曾覆盖到的一个话题：英文命名。&lt;/p>
&lt;p>如果今天的内容你只能记住一件事，那请记住：&lt;strong>好的命名，是体现业务含义的命名&lt;/strong>。&lt;br>
&lt;img src="https://static001.geekbang.org/resource/image/4e/66/4e725dfea2eeb16ef0f654813ca42066.jpg" alt="">&lt;/p>
&lt;h1 id="思考题">思考题&lt;/h1>
&lt;p>前面我们提到了一些代码中常见的不精准的命名所用的词汇，你还能想到哪些词呢？欢迎在留言区分享你的想法。也欢迎你把这节课分享给你身边对命名问题感到困惑的朋友。&lt;/p>
&lt;p>感谢阅读，我们下一讲再见！&lt;/p>
&lt;p>参考资料: 你的代码为谁而写？&lt;/p></description></item><item><title>极客专栏: 01丨课前热身丨这些需求给到你，你会怎么写代码？</title><link>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E4%BB%A3%E7%A0%81%E4%B9%8B%E4%B8%91/01%E4%B8%A8%E8%AF%BE%E5%89%8D%E7%83%AD%E8%BA%AB%E4%B8%A8%E8%BF%99%E4%BA%9B%E9%9C%80%E6%B1%82%E7%BB%99%E5%88%B0%E4%BD%A0%E4%BD%A0%E4%BC%9A%E6%80%8E%E4%B9%88%E5%86%99%E4%BB%A3%E7%A0%81/</link><pubDate>Sat, 28 May 2022 00:00:00 +0000</pubDate><guid>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E4%BB%A3%E7%A0%81%E4%B9%8B%E4%B8%91/01%E4%B8%A8%E8%AF%BE%E5%89%8D%E7%83%AD%E8%BA%AB%E4%B8%A8%E8%BF%99%E4%BA%9B%E9%9C%80%E6%B1%82%E7%BB%99%E5%88%B0%E4%BD%A0%E4%BD%A0%E4%BC%9A%E6%80%8E%E4%B9%88%E5%86%99%E4%BB%A3%E7%A0%81/</guid><description>
&lt;p>你好，我是郑晔。&lt;/p>
&lt;p>我在开篇词中提到，缺乏识别代码坏味道的感觉，这才让很多问题代码堂而皇之地留在了自己的眼皮底下。识别坏味道，单纯学理论是不够的，你得结合具体问题进行分析，所以我才在课程中加入了大量真实的代码案例，帮助你理解坏味道。当然，除此之外，你还要有足够多的练习。&lt;/p>
&lt;p>为了让你能够深度地参与到这个专栏的学习中，代码能力得到有效提升，我准备了一个课前热身的环节：大家一起来写代码。&lt;/p>
&lt;p>我们要编写一个待办事项管理的软件，你可以看我下面给出的需求，它是以&lt;strong>命令行应用&lt;/strong>的方式存在的。&lt;/p>
&lt;h1 id="第一阶段基本功能">第一阶段：基本功能&lt;/h1>
&lt;ul>
&lt;li>添加 Todo 项。&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>todo add &amp;lt;item&amp;gt;
1. &amp;lt;item&amp;gt;
Item &amp;lt;itemIndex&amp;gt; added
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>完成 Todo 项。&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>todo done &amp;lt;itemIndex&amp;gt;
Item &amp;lt;itemIndex&amp;gt; done.
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>查看 Todo 列表，缺省情况下，只列出未完成的 Todo 项。&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>todo list
1. &amp;lt;item1&amp;gt;
2. &amp;lt;item2&amp;gt;
Total: 2 items
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>使用 all 参数，查看所有的 Todo 项。&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>todo list --all
1. &amp;lt;item1&amp;gt;
2. &amp;lt;item2&amp;gt;
3. [Done] &amp;lt;item3&amp;gt;
Total: 3 items, 1 item done
&lt;/code>&lt;/pre>&lt;p>要求：&lt;/p>
&lt;ul>
&lt;li>Todo 项存储在本地文件中；&lt;/li>
&lt;li>Todo 项索引逐一递增。&lt;/li>
&lt;/ul>
&lt;h1 id="第二阶段支持多用户">第二阶段：支持多用户&lt;/h1>
&lt;ul>
&lt;li>用户登录。&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>todo login -u user
Password:
Login success!
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>用户退出。&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>todo logout
Logout success!
&lt;/code>&lt;/pre>&lt;p>要求：&lt;/p>
&lt;ul>
&lt;li>只能看到当前用户的 Todo 列表；&lt;/li>
&lt;li>同一个用户的 Todo 项索引逐一递增；&lt;/li>
&lt;li>当前用户信息存储在配置文件中 ~/.todo-config。&lt;/li>
&lt;/ul>
&lt;h1 id="第三阶段支持-todo-列表导入和导出">第三阶段：支持 Todo 列表导入和导出&lt;/h1>
&lt;ul>
&lt;li>Todo 列表导出。&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>todo export &amp;gt; todolist
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>Todo 列表导入。&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>todo import -f todolist
&lt;/code>&lt;/pre>&lt;h1 id="第四阶段支持数据库持久化">第四阶段：支持数据库持久化&lt;/h1>
&lt;p>在配置文件中，配置数据库连接信息。&lt;/p>
&lt;ul>
&lt;li>初始化数据库。&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>todo init
&lt;/code>&lt;/pre>&lt;p>要求：&lt;/p>
&lt;ul>
&lt;li>没有数据库的情况下，使用本地文件；&lt;/li>
&lt;li>在有数据库的情况下，使用数据库；&lt;/li>
&lt;li>在本地文件已经存在的情况，将本地信息导入到数据库中。&lt;/li>
&lt;/ul>
&lt;p>以上我给出的是最基本的需求，你可以根据自己的实际编码情况，适当补充一些细节，比如，相应的错误提示。&lt;/p>
&lt;p>你可以用自己最熟悉的程序设计语言、按照自己最习惯的方式编写代码，并在 Github 上以公开仓库的方式提交自己的代码，将仓库链接贴在这节课的留言区下，我会顺着链接找到你的仓库，去查看你写的代码。&lt;/p>
&lt;p>为了方便代码的阅读，请你按如下要求编写你的代码：&lt;/p>
&lt;ul>
&lt;li>在项目的 README 文件中，写出如何构建和执行你的应用；&lt;/li>
&lt;li>需求分成四个阶段，请你按顺序依次完成每个阶段的需求；&lt;/li>
&lt;li>每完成一个阶段的代码，创建一个 tag，tag 名称分别为 todo-phase-1、todo-phase-2、todo-phase-3、todo-phase-4。&lt;/li>
&lt;/ul>
&lt;p>之所以要把需求分阶段，主要是方便大家参与，即便你时间有限，只写第一个阶段的代码，依然是一个完整的需求。学过《10x 程序员工作法》的同学都知道，任务分解是一个重要的工作原则，分阶段需求其实就是一种需求层面上的任务分解。&lt;/p>
&lt;p>在专栏结束之前，我会专门制作一期加餐，点评大家的代码；同时，我也会选出代码写的最整洁的 3 位同学，送出价值149 元的华为智能体脂电子称。&lt;br>
&lt;img src="https://static001.geekbang.org/resource/image/5d/6b/5d6600a2769c6924d732d80eb365206b.jpg" alt="">&lt;/p>
&lt;p>欢迎加入这次编码的训练中，期待你在留言区分享你的代码。&lt;/p></description></item><item><title>极客专栏: 01丨Java代码是怎么运行的？</title><link>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E6%B7%B1%E5%85%A5%E6%8B%86%E8%A7%A3jvm%E8%99%9A%E6%8B%9F%E6%9C%BA/01%E4%B8%A8java%E4%BB%A3%E7%A0%81%E6%98%AF%E6%80%8E%E4%B9%88%E8%BF%90%E8%A1%8C%E7%9A%84/</link><pubDate>Fri, 27 May 2022 00:00:00 +0000</pubDate><guid>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E6%B7%B1%E5%85%A5%E6%8B%86%E8%A7%A3jvm%E8%99%9A%E6%8B%9F%E6%9C%BA/01%E4%B8%A8java%E4%BB%A3%E7%A0%81%E6%98%AF%E6%80%8E%E4%B9%88%E8%BF%90%E8%A1%8C%E7%9A%84/</guid><description>
&lt;p>我们学院的一位教授之前去美国开会，入境的时候海关官员就问他：既然你会计算机，那你说说你用的都是什么语言吧？&lt;/p>
&lt;p>教授随口就答了个 Java。海关一看是懂行的，也就放行了，边敲章还边说他们上学那会学的是 C+。我还特意去查了下，真有叫 C+ 的语言，但是这里海关官员应该指的是 C++。&lt;/p>
&lt;p>事后教授告诉我们，他当时差点就问海关，是否知道 Java 和 C++ 在运行方式上的区别。但是又担心海关官员拿他的问题来考别人，也就没问出口。那么，下次你去美国，不幸地被海关官员问这个问题，你懂得如何回答吗？&lt;/p>
&lt;p>作为一名 Java 程序员，你应该知道，Java 代码有很多种不同的运行方式。比如说可以在开发工具中运行，可以双击执行 jar 文件运行，也可以在命令行中运行，甚至可以在网页中运行。当然，这些执行方式都离不开 JRE，也就是 Java 运行时环境。&lt;/p>
&lt;p>实际上，JRE 仅包含运行 Java 程序的必需组件，包括 Java 虚拟机以及 Java 核心类库等。我们 Java 程序员经常接触到的 JDK（Java 开发工具包）同样包含了 JRE，并且还附带了一系列开发、诊断工具。&lt;/p>
&lt;p>然而，运行 C++ 代码则无需额外的运行时。我们往往把这些代码直接编译成 CPU 所能理解的代码格式，也就是机器码。&lt;/p>
&lt;p>比如下图的中间列，就是用 C 语言写的 Helloworld 程序的编译结果。可以看到，C 程序编译而成的机器码就是一个个的字节，它们是给机器读的。那么为了让开发人员也能够理解，我们可以用反汇编器将其转换成汇编代码（如下图的最右列所示）。&lt;/p>
&lt;pre>&lt;code>; 最左列是偏移；中间列是给机器读的机器码；最右列是给人读的汇编代码
0x00: 55 push rbp
0x01: 48 89 e5 mov rbp,rsp
0x04: 48 83 ec 10 sub rsp,0x10
0x08: 48 8d 3d 3b 00 00 00 lea rdi,[rip+0x3b]
; 加载 &amp;quot;Hello, World!\n&amp;quot;
0x0f: c7 45 fc 00 00 00 00 mov DWORD PTR [rbp-0x4],0x0
0x16: b0 00 mov al,0x0
0x18: e8 0d 00 00 00 call 0x12
; 调用 printf 方法
0x1d: 31 c9 xor ecx,ecx
0x1f: 89 45 f8 mov DWORD PTR [rbp-0x8],eax
0x22: 89 c8 mov eax,ecx
0x24: 48 83 c4 10 add rsp,0x10
0x28: 5d pop rbp
0x29: c3 ret
&lt;/code>&lt;/pre>
&lt;p>既然 C++ 的运行方式如此成熟，那么你有没有想过，为什么 Java 要在虚拟机中运行呢，Java 虚拟机具体又是怎样运行 Java 代码的呢，它的运行效率又如何呢？&lt;/p>
&lt;p>今天我便从这几个问题入手，和你探讨一下，Java 执行系统的主流实现以及设计决策。&lt;/p>
&lt;h2 id="为什么-java-要在虚拟机里运行">为什么 Java 要在虚拟机里运行？&lt;/h2>
&lt;p>Java 作为一门高级程序语言，它的语法非常复杂，抽象程度也很高。因此，直接在硬件上运行这种复杂的程序并不现实。所以呢，在运行 Java 程序之前，我们需要对其进行一番转换。&lt;/p>
&lt;p>这个转换具体是怎么操作的呢？当前的主流思路是这样子的，设计一个面向 Java 语言特性的虚拟机，并通过编译器将 Java 程序转换成该虚拟机所能识别的指令序列，也称 Java 字节码。这里顺便说一句，之所以这么取名，是因为 Java 字节码指令的操作码（opcode）被固定为一个字节。&lt;/p>
&lt;p>举例来说，下图的中间列，正是用 Java 写的 Helloworld 程序编译而成的字节码。可以看到，它与 C 版本的编译结果一样，都是由一个个字节组成的。&lt;/p>
&lt;p>并且，我们同样可以将其反汇编为人类可读的代码格式（如下图的最右列所示）。不同的是，Java 版本的编译结果相对精简一些。这是因为 Java 虚拟机相对于物理机而言，抽象程度更高。&lt;/p>
&lt;pre>&lt;code># 最左列是偏移；中间列是给虚拟机读的机器码；最右列是给人读的代码
0x00: b2 00 02 getstatic java.lang.System.out
0x03: 12 03 ldc &amp;quot;Hello, World!&amp;quot;
0x05: b6 00 04 invokevirtual java.io.PrintStream.println
0x08: b1 return
&lt;/code>&lt;/pre>
&lt;p>Java 虚拟机可以由硬件实现 [1]，但更为常见的是在各个现有平台（如 Windows_x64、Linux_aarch64）上提供软件实现。这么做的意义在于，一旦一个程序被转换成 Java 字节码，那么它便可以在不同平台上的虚拟机实现里运行。这也就是我们经常说的&amp;quot;一次编写，到处运行&amp;quot;。&lt;/p>
&lt;p>虚拟机的另外一个好处是它带来了一个托管环境（Managed Runtime）。这个托管环境能够代替我们处理一些代码中冗长而且容易出错的部分。其中最广为人知的当属自动内存管理与垃圾回收，这部分内容甚至催生了一波垃圾回收调优的业务。&lt;/p>
&lt;p>除此之外，托管环境还提供了诸如数组越界、动态类型、安全权限等等的动态检测，使我们免于书写这些无关业务逻辑的代码。&lt;/p>
&lt;h2 id="java-虚拟机具体是怎样运行-java-字节码的">Java 虚拟机具体是怎样运行 Java 字节码的？&lt;/h2>
&lt;p>下面我将以标准 JDK 中的 HotSpot 虚拟机为例，从虚拟机以及底层硬件两个角度，给你讲一讲 Java 虚拟机具体是怎么运行 Java 字节码的。&lt;/p>
&lt;p>从虚拟机视角来看，执行 Java 代码首先需要将它编译而成的 class 文件加载到 Java 虚拟机中。加载后的 Java 类会被存放于方法区（Method Area）中。实际运行时，虚拟机会执行方法区内的代码。&lt;/p>
&lt;p>如果你熟悉 X86 的话，你会发现这和段式内存管理中的代码段类似。而且，Java 虚拟机同样也在内存中划分出堆和栈来存储运行时数据。&lt;/p>
&lt;p>不同的是，Java 虚拟机会将栈细分为面向 Java 方法的 Java 方法栈，面向本地方法（用 C++ 写的 native 方法）的本地方法栈，以及存放各个线程执行位置的 PC 寄存器。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/ab/77/ab5c3523af08e0bf2f689c1d6033ef77.png" alt="">&lt;/p>
&lt;p>在运行过程中，每当调用进入一个 Java 方法，Java 虚拟机会在当前线程的 Java 方法栈中生成一个栈帧，用以存放局部变量以及字节码的操作数。这个栈帧的大小是提前计算好的，而且 Java 虚拟机不要求栈帧在内存空间里连续分布。&lt;/p>
&lt;p>当退出当前执行的方法时，不管是正常返回还是异常返回，Java 虚拟机均会弹出当前线程的当前栈帧，并将之舍弃。&lt;/p>
&lt;p>从硬件视角来看，Java 字节码无法直接执行。因此，Java 虚拟机需要将字节码翻译成机器码。&lt;/p>
&lt;p>在 HotSpot 里面，上述翻译过程有两种形式：第一种是解释执行，即逐条将字节码翻译成机器码并执行；第二种是即时编译（Just-In-Time compilation，JIT），即将一个方法中包含的所有字节码编译成机器码后再执行。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/5e/3b/5ee351091464de78eed75438b6f9183b.png" alt="">&lt;/p>
&lt;p>前者的优势在于无需等待编译，而后者的优势在于实际运行速度更快。HotSpot 默认采用混合模式，综合了解释执行和即时编译两者的优点。它会先解释执行字节码，而后将其中反复执行的热点代码，以方法为单位进行即时编译。&lt;/p>
&lt;h2 id="java-虚拟机的运行效率究竟是怎么样的">Java 虚拟机的运行效率究竟是怎么样的？&lt;/h2>
&lt;p>HotSpot 采用了多种技术来提升启动性能以及峰值性能，刚刚提到的即时编译便是其中最重要的技术之一。&lt;/p>
&lt;p>即时编译建立在程序符合二八定律的假设上，也就是百分之二十的代码占据了百分之八十的计算资源。&lt;/p>
&lt;p>对于占据大部分的不常用的代码，我们无需耗费时间将其编译成机器码，而是采取解释执行的方式运行；另一方面，对于仅占据小部分的热点代码，我们则可以将其编译成机器码，以达到理想的运行速度。&lt;/p>
&lt;p>理论上讲，即时编译后的 Java 程序的执行效率，是可能超过 C++ 程序的。这是因为与静态编译相比，即时编译拥有程序的运行时信息，并且能够根据这个信息做出相应的优化。&lt;/p>
&lt;p>举个例子，我们知道虚方法是用来实现面向对象语言多态性的。对于一个虚方法调用，尽管它有很多个目标方法，但在实际运行过程中它可能只调用其中的一个。&lt;/p>
&lt;p>这个信息便可以被即时编译器所利用，来规避虚方法调用的开销，从而达到比静态编译的 C++ 程序更高的性能。&lt;/p>
&lt;p>为了满足不同用户场景的需要，HotSpot 内置了多个即时编译器：C1、C2 和 Graal。Graal 是 Java 10 正式引入的实验性即时编译器，在专栏的第四部分我会详细介绍，这里暂不做讨论。&lt;/p>
&lt;p>之所以引入多个即时编译器，是为了在编译时间和生成代码的执行效率之间进行取舍。C1 又叫做 Client 编译器，面向的是对启动性能有要求的客户端 GUI 程序，采用的优化手段相对简单，因此编译时间较短。&lt;/p>
&lt;p>C2 又叫做 Server 编译器，面向的是对峰值性能有要求的服务器端程序，采用的优化手段相对复杂，因此编译时间较长，但同时生成代码的执行效率较高。&lt;/p>
&lt;p>从 Java 7 开始，HotSpot 默认采用分层编译的方式：热点方法首先会被 C1 编译，而后热点方法中的热点会进一步被 C2 编译。&lt;/p>
&lt;p>为了不干扰应用的正常运行，HotSpot 的即时编译是放在额外的编译线程中进行的。HotSpot 会根据 CPU 的数量设置编译线程的数目，并且按 1:2 的比例配置给 C1 及 C2 编译器。&lt;/p>
&lt;p>在计算资源充足的情况下，字节码的解释执行和即时编译可同时进行。编译完成后的机器码会在下次调用该方法时启用，以替换原本的解释执行。&lt;/p>
&lt;h2 id="总结与实践">总结与实践&lt;/h2>
&lt;p>今天我简单介绍了 Java 代码为何在虚拟机中运行，以及如何在虚拟机中运行。&lt;/p>
&lt;p>之所以要在虚拟机中运行，是因为它提供了可移植性。一旦 Java 代码被编译为 Java 字节码，便可以在不同平台上的 Java 虚拟机实现上运行。此外，虚拟机还提供了一个代码托管的环境，代替我们处理部分冗长而且容易出错的事务，例如内存管理。&lt;/p>
&lt;p>Java 虚拟机将运行时内存区域划分为五个部分，分别为方法区、堆、PC 寄存器、Java 方法栈和本地方法栈。Java 程序编译而成的 class 文件，需要先加载至方法区中，方能在 Java 虚拟机中运行。&lt;/p>
&lt;p>为了提高运行效率，标准 JDK 中的 HotSpot 虚拟机采用的是一种混合执行的策略。&lt;/p>
&lt;p>它会解释执行 Java 字节码，然后会将其中反复执行的热点代码，以方法为单位进行即时编译，翻译成机器码后直接运行在底层硬件之上。&lt;/p>
&lt;p>HotSpot 装载了多个不同的即时编译器，以便在编译时间和生成代码的执行效率之间做取舍。&lt;/p>
&lt;p>下面我给你留一个小作业，通过观察两个条件判断语句的运行结果，来思考 Java 语言和 Java 虚拟机看待 boolean 类型的方式是否不同。&lt;/p>
&lt;p>下载 asmtools.jar [2] ，并在命令行中运行下述指令（不包含提示符 $）：&lt;/p>
&lt;pre>&lt;code>$ echo '
public class Foo {
public static void main(String[] args) {
boolean flag = true;
if (flag) System.out.println(&amp;quot;Hello, Java!&amp;quot;);
if (flag == true) System.out.println(&amp;quot;Hello, JVM!&amp;quot;);
}
}' &amp;gt; Foo.java
$ javac Foo.java
$ java Foo
$ java -cp /path/to/asmtools.jar org.openjdk.asmtools.jdis.Main Foo.class &amp;gt; Foo.jasm.1
$ awk 'NR==1,/iconst_1/{sub(/iconst_1/, &amp;quot;iconst_2&amp;quot;)} 1' Foo.jasm.1 &amp;gt; Foo.jasm
$ java -cp /path/to/asmtools.jar org.openjdk.asmtools.jasm.Main Foo.jasm
$ java Foo
&lt;/code>&lt;/pre>
&lt;p>[1] : &lt;a href="https://en.wikipedia.org/wiki/Java_processor">https://en.wikipedia.org/wiki/Java_processor&lt;/a>&lt;br>
[2]: &lt;a href="https://wiki.openjdk.java.net/display/CodeTools/asmtools">https://wiki.openjdk.java.net/display/CodeTools/asmtools&lt;/a>&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/2a/d5/2a62e58cbdf56a5dc40748567d346fd5.jpg" alt="">&lt;/p></description></item><item><title>极客专栏: 01丨为什么要学习数据结构和算法？</title><link>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/01%E4%B8%A8%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%AD%A6%E4%B9%A0%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/</link><pubDate>Fri, 27 May 2022 00:00:00 +0000</pubDate><guid>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/01%E4%B8%A8%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%AD%A6%E4%B9%A0%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/</guid><description>
&lt;p>你是不是觉得数据结构和算法，跟操作系统、计算机网络一样，是脱离实际工作的知识？可能除了面试，这辈子也用不着？&lt;/p>
&lt;p>尽管计算机相关专业的同学在大学都学过这门课程，甚至很多培训机构也会培训这方面的知识，但是据我了解，很多程序员对数据结构和算法依旧一窍不通。还有一些人也只听说过数组、链表、快排这些最最基本的数据结构和算法，稍微复杂一点的就完全没概念。&lt;/p>
&lt;p>当然，也有很多人说，自己实际工作中根本用不到数据结构和算法。所以，就算不懂这块知识，只要 Java API、开发框架用得熟练，照样可以把代码写得&amp;quot;飞&amp;quot;起来。事实真的是这样吗？&lt;/p>
&lt;p>今天我们就来详细聊一聊，为什么要学习数据结构和算法。&lt;/p>
&lt;h2 id="想要通关大厂面试千万别让数据结构和算法拖了后腿">想要通关大厂面试，千万别让数据结构和算法拖了后腿&lt;/h2>
&lt;p>很多大公司，比如 BAT、Google、Facebook，面试的时候都喜欢考算法、让人现场写代码。有些人虽然技术不错，但每次去面试都会&amp;quot;跪&amp;quot;在算法上，很是可惜。那你有没有想过，为什么这些大公司都喜欢考算法呢？&lt;/p>
&lt;p>校招的时候，参加面试的学生通常没有实际项目经验，公司只能考察他们的基础知识是否牢固。社招就更不用说了，越是厉害的公司，越是注重考察数据结构与算法这类基础知识。相比短期能力，他们更看中你的长期潜力。&lt;/p>
&lt;p>你可能要说了，我不懂数据结构与算法，照样找到了好工作啊。那我是不是就不用学数据结构和算法呢？当然不是，你别忘了，&lt;strong>我们学任何知识都是为了&amp;quot;用&amp;quot;的，是为了解决实际工作问题的&lt;/strong>，学习数据结构和算法自然也不例外。&lt;/p>
&lt;h2 id="业务开发工程师你真的愿意做一辈子-crud-boy-吗">业务开发工程师，你真的愿意做一辈子 CRUD boy 吗？&lt;/h2>
&lt;p>如果你是一名业务开发工程师，你可能要说，我整天就是做数据库 CRUD（增删改查），哪里用得到数据结构和算法啊？&lt;/p>
&lt;p>是的，对于大部分业务开发来说，我们平时可能更多的是利用已经封装好的现成的接口、类库来堆砌、翻译业务逻辑，很少需要自己实现数据结构和算法。但是，&lt;strong>不需要自己实现，并不代表什么都不需要了解&lt;/strong>。&lt;/p>
&lt;p>如果不知道这些类库背后的原理，不懂得时间、空间复杂度分析，你如何能用好、用对它们？存储某个业务数据的时候，你如何知道应该用 ArrayList，还是 Linked List 呢？调用了某个函数之后，你又该如何评估代码的性能和资源的消耗呢？&lt;/p>
&lt;p>作为业务开发，我们会用到各种框架、中间件和底层系统，比如 Spring、RPC 框架、消息中间件、Redis 等等。&lt;strong>在这些基础框架中，一般都揉和了很多基础数据结构和算法的设计思想。&lt;/strong>&lt;/p>
&lt;p>比如，我们常用的 Key-Value 数据库 Redis 中，里面的有序集合是用什么数据结构来实现的呢？为什么要用跳表来实现呢？为什么不用二叉树呢？&lt;/p>
&lt;p>如果你能弄明白这些底层原理，你就能更好地使用它们。即便出现问题，也很容易就能定位。因此，&lt;strong>掌握数据结构和算法，不管对于阅读框架源码，还是理解其背后的设计思想，都是非常有用的。&lt;/strong>&lt;/p>
&lt;p>在平时的工作中，数据结构和算法的应用到处可见。我来举一个你非常熟悉的例子：如何实时地统计业务接口的 99% 响应时间？&lt;/p>
&lt;p>你可能最先想到，每次查询时，从小到大排序所有的响应时间，如果总共有 1200 个数据，那第 1188 个数据就是 99% 的响应时间。很显然，每次用这个方法查询的话都要排序，效率是非常低的。但是，如果你知道&amp;quot;堆&amp;quot;这个数据结构，用两个堆可以非常高效地解决这个问题。&lt;/p>
&lt;h2 id="基础架构研发工程师写出达到开源水平的框架才是你的目标">基础架构研发工程师，写出达到开源水平的框架才是你的目标！&lt;/h2>
&lt;p>现在互联网上的技术文章、架构分享、开源项目满天飞，照猫画虎做一套基础框架并不难。我就拿 RPC 框架举例。&lt;/p>
&lt;p>不同的公司、不同的人做出的 RPC 框架，架构设计思路都差不多，最后实现的功能也都差不多。但是有的人做出来的框架，Bug 很多、性能一般、扩展性也不好，只能在自己公司仅有的几个项目里面用一下。而有的人做的框架可以开源到 GitHub 上给很多人用，甚至被 Apache 收录。为什么会有这么大的差距呢？&lt;/p>
&lt;p>我觉得，高手之间的竞争其实就在细节。这些细节包括：你用的算法是不是够优化，数据存取的效率是不是够高，内存是不是够节省等等。这些累积起来，决定了一个框架是不是优秀。所以，如果你还不懂数据结构和算法，没听说过大 O 复杂度分析，不知道怎么分析代码的时间复杂度和空间复杂度，那肯定说不过去了，赶紧来补一补吧！&lt;/p>
&lt;h2 id="对编程还有追求不想被行业淘汰那就不要只会写凑合能用的代码">对编程还有追求？不想被行业淘汰？那就不要只会写凑合能用的代码！&lt;/h2>
&lt;p>何为编程能力强？是代码的可读性好、健壮？还是扩展性好？我觉得没法列，也列不全。但是，在我看来，&lt;strong>性能好坏起码是其中一个非常重要的评判标准&lt;/strong>。但是，如果你连代码的时间复杂度、空间复杂度都不知道怎么分析，怎么写出高性能的代码呢？&lt;/p>
&lt;p>你可能会说，我在小公司工作，用户量很少，需要处理的数据量也很少，开发中不需要考虑那么多性能的问题，完成功能就可以，用什么数据结构和算法，差别根本不大。但是你真的想&amp;quot;十年如一日&amp;quot;地做一样的工作吗？&lt;/p>
&lt;p>经常有人说，程序员 35 岁之后很容易陷入瓶颈，被行业淘汰，我觉得原因其实就在此。有的人写代码的时候，从来都不考虑非功能性的需求，只是完成功能，凑合能用就好；做事情的时候，也从来没有长远规划，只把眼前事情做好就满足了。&lt;/p>
&lt;p>我曾经面试过很多大龄候选人，简历能写十几页，经历的项目有几十个，但是细看下来，每个项目都是重复地堆砌业务逻辑而已，完全没有难度递进，看不出有能力提升。久而久之，十年的积累可能跟一年的积累没有任何区别。这样的人，怎么不会被行业淘汰呢？&lt;/p>
&lt;p>如果你在一家成熟的公司，或者 BAT 这样的大公司，面对的是千万级甚至亿级的用户，开发的是 TB、PB 级别数据的处理系统。性能几乎是开发过程中时刻都要考虑的问题。一个简单的 ArrayList、Linked List 的选择问题，就可能会产生成千上万倍的性能差别。这个时候，数据结构和算法的意义就完全凸显出来了。&lt;/p>
&lt;p>其实，我觉得，数据结构和算法这个东西，如果你不去学，可能真的这辈子都用不到，也感受不到它的好。但是一旦掌握，你就会常常被它的强大威力所折服。之前你可能需要费很大劲儿来优化的代码，需要花很多心思来设计的架构，用了数据结构和算法之后，很容易就可以解决了。&lt;/p>
&lt;h2 id="内容小结">内容小结&lt;/h2>
&lt;p>我们学习数据结构和算法，并不是为了死记硬背几个知识点。我们的目的是建立时间复杂度、空间复杂度意识，写出高质量的代码，能够设计基础架构，提升编程技能，训练逻辑思维，积攒人生经验，以此获得工作回报，实现你的价值，完善你的人生。&lt;/p>
&lt;p>所以，不管你是业务开发工程师，还是基础架构工程师；不管你是初入职场的初级工程师，还是工作多年的资深架构师，又或者是想转人工智能、区块链这些热门领域的程序员，数据结构与算法作为计算机的基础知识、核心知识，都是必须要掌握的。&lt;/p>
&lt;p>&lt;strong>掌握了数据结构与算法，你看待问题的深度，解决问题的角度就会完全不一样&lt;/strong>。因为这样的你，就像是站在巨人的肩膀上，拿着生存利器行走世界。数据结构与算法，会为你的编程之路，甚至人生之路打开一扇通往新世界的大门。&lt;/p>
&lt;h2 id="课后思考">课后思考&lt;/h2>
&lt;p>你为什么要学习数据结构和算法呢？在过去的软件开发中，数据结构和算法在哪些地方帮到了你？&lt;/p>
&lt;p>欢迎留言和我分享，我会第一时间给你反馈。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/8e/d3/8e603e3d795fc0ab2698f6f5eabf14d3.jpg" alt="">&lt;/p></description></item><item><title>极客专栏: 01丨基础架构：一条SQL查询语句是如何执行的？</title><link>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/mysql-%E5%AE%9E%E6%88%98-45-%E8%AE%B2/01%E4%B8%A8%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84%E4%B8%80%E6%9D%A1sql%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84/</link><pubDate>Fri, 27 May 2022 00:00:00 +0000</pubDate><guid>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/mysql-%E5%AE%9E%E6%88%98-45-%E8%AE%B2/01%E4%B8%A8%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84%E4%B8%80%E6%9D%A1sql%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84/</guid><description>
&lt;p>你好，我是林晓斌。&lt;/p>
&lt;p>这是专栏的第一篇文章，我想来跟你聊聊 MySQL 的基础架构。我们经常说，看一个事儿千万不要直接陷入细节里，你应该先鸟瞰其全貌，这样能够帮助你从高维度理解问题。同样，对于 MySQL 的学习也是这样。平时我们使用数据库，看到的通常都是一个整体。比如，你有个最简单的表，表里只有一个 ID 字段，在执行下面这个查询语句时：&lt;/p>
&lt;pre>&lt;code>mysql&amp;gt; select * from T where ID=10；
&lt;/code>&lt;/pre>
&lt;p>我们看到的只是输入一条语句，返回一个结果，却不知道这条语句在 MySQL 内部的执行过程。&lt;/p>
&lt;p>所以今天我想和你一起把 MySQL 拆解一下，看看里面都有哪些&amp;quot;零件&amp;quot;，希望借由这个拆解过程，让你对 MySQL 有更深入的理解。这样当我们碰到 MySQL 的一些异常或者问题时，就能够直戳本质，更为快速地定位并解决问题。&lt;/p>
&lt;p>下面我给出的是 MySQL 的基本架构示意图，从中你可以清楚地看到 SQL 语句在 MySQL 的各个功能模块中的执行过程。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/0d/d9/0d2070e8f84c4801adbfa03bda1f98d9.png" alt="">
MySQL 的逻辑架构图&lt;/p>
&lt;p>大体来说，MySQL 可以分为 Server 层和存储引擎层两部分。&lt;/p>
&lt;p>Server 层包括连接器、查询缓存、分析器、优化器、执行器等，涵盖 MySQL 的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。&lt;/p>
&lt;p>而存储引擎层负责数据的存储和提取。其架构模式是插件式的，支持 InnoDB、MyISAM、Memory 等多个存储引擎。现在最常用的存储引擎是 InnoDB，它从 MySQL 5.5.5 版本开始成为了默认存储引擎。&lt;/p>
&lt;p>也就是说，你执行 create table 建表的时候，如果不指定引擎类型，默认使用的就是 InnoDB。不过，你也可以通过指定存储引擎的类型来选择别的引擎，比如在 create table 语句中使用 engine=memory, 来指定使用内存引擎创建表。不同存储引擎的表数据存取方式不同，支持的功能也不同，在后面的文章中，我们会讨论到引擎的选择。&lt;/p>
&lt;p>从图中不难看出，不同的存储引擎共用一个&lt;strong>Server 层&lt;/strong>，也就是从连接器到执行器的部分。你可以先对每个组件的名字有个印象，接下来我会结合开头提到的那条 SQL 语句，带你走一遍整个执行流程，依次看下每个组件的作用。&lt;/p>
&lt;h1 id="连接器">连接器&lt;/h1>
&lt;p>第一步，你会先连接到这个数据库上，这时候接待你的就是连接器。连接器负责跟客户端建立连接、获取权限、维持和管理连接。连接命令一般是这么写的：&lt;/p>
&lt;pre>&lt;code>mysql -h$ip -P$port -u$user -p
&lt;/code>&lt;/pre>
&lt;p>输完命令之后，你就需要在交互对话里面输入密码。虽然密码也可以直接跟在 -p 后面写在命令行中，但这样可能会导致你的密码泄露。如果你连的是生产服务器，强烈建议你不要这么做。&lt;/p>
&lt;p>连接命令中的 mysql 是客户端工具，用来跟服务端建立连接。在完成经典的 TCP 握手后，连接器就要开始认证你的身份，这个时候用的就是你输入的用户名和密码。&lt;/p>
&lt;ul>
&lt;li>如果用户名或密码不对，你就会收到一个&amp;quot;Access denied for user&amp;quot;的错误，然后客户端程序结束执行。&lt;/li>
&lt;li>如果用户名密码认证通过，连接器会到权限表里面查出你拥有的权限。之后，这个连接里面的权限判断逻辑，都将依赖于此时读到的权限。&lt;/li>
&lt;/ul>
&lt;p>这就意味着，一个用户成功建立连接后，即使你用管理员账号对这个用户的权限做了修改，也不会影响已经存在连接的权限。修改完成后，只有再新建的连接才会使用新的权限设置。&lt;/p>
&lt;p>连接完成后，如果你没有后续的动作，这个连接就处于空闲状态，你可以在 show processlist 命令中看到它。文本中这个图是 show processlist 的结果，其中的 Command 列显示为&amp;quot;Sleep&amp;quot;的这一行，就表示现在系统里面有一个空闲连接。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/f2/ed/f2da4aa3a672d48ec05df97b9f992fed.png" alt="">&lt;br>
客户端如果太长时间没动静，连接器就会自动将它断开。这个时间是由参数 wait_timeout 控制的，默认值是 8 小时。&lt;/p>
&lt;p>如果在连接被断开之后，客户端再次发送请求的话，就会收到一个错误提醒： Lost connection to MySQL server during query。这时候如果你要继续，就需要重连，然后再执行请求了。&lt;/p>
&lt;p>数据库里面，长连接是指连接成功后，如果客户端持续有请求，则一直使用同一个连接。短连接则是指每次执行完很少的几次查询就断开连接，下次查询再重新建立一个。&lt;/p>
&lt;p>建立连接的过程通常是比较复杂的，所以我建议你在使用中要尽量减少建立连接的动作，也就是尽量使用长连接。&lt;/p>
&lt;p>但是全部使用长连接后，你可能会发现，有些时候 MySQL 占用内存涨得特别快，这是因为 MySQL 在执行过程中临时使用的内存是管理在连接对象里面的。这些资源会在连接断开的时候才释放。所以如果长连接累积下来，可能导致内存占用太大，被系统强行杀掉（OOM），从现象看就是 MySQL 异常重启了。&lt;/p>
&lt;p>怎么解决这个问题呢？你可以考虑以下两种方案。&lt;/p>
&lt;ol>
&lt;li>
&lt;p>定期断开长连接。使用一段时间，或者程序里面判断执行过一个占用内存的大查询后，断开连接，之后要查询再重连。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>如果你用的是 MySQL 5.7 或更新版本，可以在每次执行一个比较大的操作后，通过执行 mysql_reset_connection 来重新初始化连接资源。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h1 id="查询缓存">查询缓存&lt;/h1>
&lt;p>连接建立完成后，你就可以执行 select 语句了。执行逻辑就会来到第二步：查询缓存。&lt;/p>
&lt;p>MySQL 拿到一个查询请求后，会先到查询缓存看看，之前是不是执行过这条语句。之前执行过的语句及其结果可能会以 key-value 对的形式，被直接缓存在内存中。key 是查询的语句，value 是查询的结果。如果你的查询能够直接在这个缓存中找到 key，那么这个 value 就会被直接返回给客户端。&lt;/p>
&lt;p>如果语句不在查询缓存中，就会继续后面的执行阶段。执行完成后，执行结果会被存入查询缓存中。你可以看到，如果查询命中缓存，MySQL 不需要执行后面的复杂操作，就可以直接返回结果，这个效率会很高。&lt;/p>
&lt;p>&lt;strong>但是大多数情况下我会建议你不要使用查询缓存，为什么呢？因为查询缓存往往弊大于利。&lt;/strong>&lt;/p>
&lt;p>查询缓存的失效非常频繁，只要有对一个表的更新，这个表上所有的查询缓存都会被清空。因此很可能你费劲地把结果存起来，还没使用呢，就被一个更新全清空了。对于更新压力大的数据库来说，查询缓存的命中率会非常低。除非你的业务就是有一张静态表，很长时间才会更新一次。比如，一个系统配置表，那这张表上的查询才适合使用查询缓存。&lt;/p>
&lt;p>好在 MySQL 也提供了这种&amp;quot;按需使用&amp;quot;的方式。你可以将参数 query_cache_type 设置成 DEMAND，这样对于默认的 SQL 语句都不使用查询缓存。而对于你确定要使用查询缓存的语句，可以用 SQL_CACHE 显式指定，像下面这个语句一样：&lt;/p>
&lt;pre>&lt;code>mysql&amp;gt; select SQL_CACHE * from T where ID=10；
&lt;/code>&lt;/pre>
&lt;p>需要注意的是，MySQL 8.0 版本直接将查询缓存的整块功能删掉了，也就是说 8.0 开始彻底没有这个功能了。&lt;/p>
&lt;h1 id="分析器">分析器&lt;/h1>
&lt;p>如果没有命中查询缓存，就要开始真正执行语句了。首先，MySQL 需要知道你要做什么，因此需要对 SQL 语句做解析。&lt;/p>
&lt;p>分析器先会做&amp;quot;词法分析&amp;quot;。你输入的是由多个字符串和空格组成的一条 SQL 语句，MySQL 需要识别出里面的字符串分别是什么，代表什么。&lt;/p>
&lt;p>MySQL 从你输入的&amp;quot;select&amp;quot;这个关键字识别出来，这是一个查询语句。它也要把字符串&amp;quot;T&amp;quot;识别成&amp;quot;表名 T&amp;quot;，把字符串&amp;quot;ID&amp;quot;识别成&amp;quot;列 ID&amp;quot;。&lt;/p>
&lt;p>做完了这些识别以后，就要做&amp;quot;语法分析&amp;quot;。根据词法分析的结果，语法分析器会根据语法规则，判断你输入的这个 SQL 语句是否满足 MySQL 语法。&lt;/p>
&lt;p>如果你的语句不对，就会收到&amp;quot;You have an error in your SQL syntax&amp;quot;的错误提醒，比如下面这个语句 select 少打了开头的字母&amp;quot;s&amp;quot;。&lt;/p>
&lt;pre>&lt;code>mysql&amp;gt; elect * from t where ID=1;
ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near 'elect * from t where ID=1' at line 1
&lt;/code>&lt;/pre>
&lt;p>一般语法错误会提示第一个出现错误的位置，所以你要关注的是紧接&amp;quot;use near&amp;quot;的内容。&lt;/p>
&lt;h1 id="优化器">优化器&lt;/h1>
&lt;p>经过了分析器，MySQL 就知道你要做什么了。在开始执行之前，还要先经过优化器的处理。&lt;/p>
&lt;p>优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序。比如你执行下面这样的语句，这个语句是执行两个表的 join：&lt;/p>
&lt;pre>&lt;code>mysql&amp;gt; select * from t1 join t2 using(ID) where t1.c=10 and t2.d=20;
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>既可以先从表 t1 里面取出 c=10 的记录的 ID 值，再根据 ID 值关联到表 t2，再判断 t2 里面 d 的值是否等于 20。&lt;/li>
&lt;li>也可以先从表 t2 里面取出 d=20 的记录的 ID 值，再根据 ID 值关联到 t1，再判断 t1 里面 c 的值是否等于 10。&lt;/li>
&lt;/ul>
&lt;p>这两种执行方法的逻辑结果是一样的，但是执行的效率会有不同，而优化器的作用就是决定选择使用哪一个方案。&lt;/p>
&lt;p>优化器阶段完成后，这个语句的执行方案就确定下来了，然后进入执行器阶段。如果你还有一些疑问，比如优化器是怎么选择索引的，有没有可能选择错等等，没关系，我会在后面的文章中单独展开说明优化器的内容。&lt;/p>
&lt;h1 id="执行器">执行器&lt;/h1>
&lt;p>MySQL 通过分析器知道了你要做什么，通过优化器知道了该怎么做，于是就进入了执行器阶段，开始执行语句。&lt;/p>
&lt;p>开始执行的时候，要先判断一下你对这个表 T 有没有执行查询的权限，如果没有，就会返回没有权限的错误，如下所示 (在工程实现上，如果命中查询缓存，会在查询缓存返回结果的时候，做权限验证。查询也会在优化器之前调用 precheck 验证权限)。&lt;/p>
&lt;pre>&lt;code>mysql&amp;gt; select * from T where ID=10;
ERROR 1142 (42000): SELECT command denied to user 'b'@'localhost' for table 'T'
&lt;/code>&lt;/pre>
&lt;p>如果有权限，就打开表继续执行。打开表的时候，执行器就会根据表的引擎定义，去使用这个引擎提供的接口。&lt;/p>
&lt;p>比如我们这个例子中的表 T 中，ID 字段没有索引，那么执行器的执行流程是这样的：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>调用 InnoDB 引擎接口取这个表的第一行，判断 ID 值是不是 10，如果不是则跳过，如果是则将这行存在结果集中；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>调用引擎接口取&amp;quot;下一行&amp;quot;，重复相同的判断逻辑，直到取到这个表的最后一行。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>至此，这个语句就执行完成了。&lt;/p>
&lt;p>对于有索引的表，执行的逻辑也差不多。第一次调用的是&amp;quot;取满足条件的第一行&amp;quot;这个接口，之后循环取&amp;quot;满足条件的下一行&amp;quot;这个接口，这些接口都是引擎中已经定义好的。&lt;/p>
&lt;p>你会在数据库的慢查询日志中看到一个 rows_examined 的字段，表示这个语句执行过程中扫描了多少行。这个值就是在执行器每次调用引擎获取数据行的时候累加的。&lt;/p>
&lt;p>在有些场景下，执行器调用一次，在引擎内部则扫描了多行，因此**引擎扫描行数跟 rows_examined 并不是完全相同的。**我们后面会专门有一篇文章来讲存储引擎的内部机制，里面会有详细的说明。&lt;/p>
&lt;h1 id="小结">小结&lt;/h1>
&lt;p>今天我给你介绍了 MySQL 的逻辑架构，希望你对一个 SQL 语句完整执行流程的各个阶段有了一个初步的印象。由于篇幅的限制，我只是用一个查询的例子将各个环节过了一遍。如果你还对每个环节的展开细节存有疑问，也不用担心，后续在实战章节中我还会再提到它们。&lt;/p>
&lt;p>我给你留一个问题吧，如果表 T 中没有字段 k，而你执行了这个语句 select * from T where k=1, 那肯定是会报&amp;quot;不存在这个列&amp;quot;的错误： &amp;ldquo;Unknown column &amp;lsquo;k&amp;rsquo; in &amp;lsquo;where clause&amp;rsquo;&amp;quot;。你觉得这个错误是在我们上面提到的哪个阶段报出来的呢？&lt;/p>
&lt;p>感谢你的收听，欢迎你给我留言，也欢迎分享给更多的朋友一起阅读。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/ce/d9/ce7f4e35916ed1aa49206a53a0547bd9.jpg" alt="">&lt;/p></description></item><item><title>极客专栏: 01丨是什么推动了单体应用到微服务架构的演进？</title><link>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/springclouod%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/01%E4%B8%A8%E6%98%AF%E4%BB%80%E4%B9%88%E6%8E%A8%E5%8A%A8%E4%BA%86%E5%8D%95%E4%BD%93%E5%BA%94%E7%94%A8%E5%88%B0%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%9A%84%E6%BC%94%E8%BF%9B/</link><pubDate>Fri, 27 May 2022 00:00:00 +0000</pubDate><guid>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/springclouod%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/01%E4%B8%A8%E6%98%AF%E4%BB%80%E4%B9%88%E6%8E%A8%E5%8A%A8%E4%BA%86%E5%8D%95%E4%BD%93%E5%BA%94%E7%94%A8%E5%88%B0%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%9A%84%E6%BC%94%E8%BF%9B/</guid><description>
&lt;p>你好，我是姚秋辰。&lt;/p>
&lt;p>&amp;ldquo;微服务&amp;quot;是近些年在大型应用架构领域的一个热门话题，从实践领域来看，我们身边的一二线大厂也纷纷选择全面拥抱微服务。就拿国内 Java 系的一线大厂来说，如阿里系、美团点评、PDD 等，它们都将自己的核心业务系统构建在微服务架构之上。&lt;/p>
&lt;p>即便你是刚参加工作的萌新，也一定从铺天盖地的&amp;quot;微服务&amp;quot;相关信息流中了解到了这个名词的热度。谷歌搜索指数显示，自 2014 年起，微服务的搜索热度一路上升。&lt;br>
&lt;img src="https://static001.geekbang.org/resource/image/61/2a/61efecb5f468ab50c767804cc8ea172a.jpg?wh=2284x1213" alt="">&lt;br>
&amp;ldquo;微服务&amp;quot;的谷歌搜索指数&lt;/p>
&lt;p>其实，微服务并不是一个新兴的技术概念，很早之前它就已经进入了公众视野。&lt;/p>
&lt;p>早在 2012 年，一位叫做 Fred George 的技术专家就在一次大会上分享了自己的微服务落地经验，讲述他是如何带领团队将一个极度庞大的 J2EE 巨无霸程序，分解成 20 多个小服务的。作为微服务领域的先驱，他是这样描述微服务架构的：&lt;/p>
&lt;blockquote>
&lt;p>Micro Services Architecture - small, short lived services rather than SOA.&lt;/p>
&lt;/blockquote>
&lt;p>如果你在工作中没有接触过微服务架构的系统，那么此时一定非常蒙圈，不明白大佬所说的微服务架构到底是什么。没关系，就让我带你去回顾微服务的发展历史，了解微服务解决了什么痛点；然后我们一道来分析微服务架构的优势，让你明白为什么如今一线大厂会采用微服务架构。&lt;/p>
&lt;p>那么，我们就从微服务架构的前世今生聊起吧。&lt;/p>
&lt;h1 id="单体应用之殇">单体应用之殇&lt;/h1>
&lt;p>在互联网技术发展的早期阶段，我们采用&amp;quot;单体应用&amp;quot;的方式来构建网络系统。你没看错，即便是如今的各大老牌互联网大厂，在当年也是从单体应用小作坊成长起来的。&lt;/p>
&lt;p>以 Java 单体应用为例，我们将业务逻辑打包在一起，做成一个 WAR 包部署到 Tomcat、JBoss 之类的容器中，对外提供服务。业务上了一定规模之后，再通过集群化水平扩展的方式，将单体应用部署到一个集群中，承接更大的用户访问量。&lt;/p>
&lt;p>然而，随着业务复杂度的进一步提升，单体应用在生产力和高可用性层面就面临了巨大的挑战。我在参加工作之初做过近五年的单体应用开发，深知其中的痛处。&lt;/p>
&lt;p>我刚毕业的时候，参与了一个巨无霸的电商套件的开发，那是一个标准的单体应用。整个开发加测试团队有 100 多号人，所有人的代码都提交到一个主干分支，每次 merge 代码都要面对各种代码冲突，开发过程中&lt;strong>耗费了大量的沟通成本&lt;/strong>。不仅如此，由于庞大的业务体系都部署在一个 WAR 包中，每一次提交代码都要执行 3 个小时的回归测试，不出错还好，一旦出错就要回炉重造。周而复始执行这套繁重的流程，研发效率非常低下，完全&lt;strong>无法达到&amp;quot;快速迭代&amp;quot;的目的&lt;/strong>。&lt;/p>
&lt;p>在上线阶段我们也经常碰到各类问题。我参与的这个单体应用的发布周期是 2 个月一次（这在单体应用中已经算是很快的发布节奏了），每次发布一旦出现 Bug，&lt;strong>无法单独回滚&lt;/strong>这个小改动，我必须将整个发布里所有的功能全部回滚，待问题修复之后再重新发布。更可悲的是，整个 WAR 包的服务经常因为一个小 Bug 导致团灭，曾经有一次，我提交了一个&amp;quot;数据批量导入导出&amp;quot;的代码改动，把一个隐蔽 Bug 发布到了线上，业务持续运行一段时间之后，JVM 内存发生了泄露，导致集群各节点的 HEALTHCHECK 失败服务被重启，进而影响到了所有服务。&lt;/p>
&lt;p>上面这些问题是不是很让人头痛？想要解决它们，我们就要用到一句老话，叫&amp;quot;大事化小，小事化了&amp;rdquo;。&lt;/p>
&lt;p>在架构领域，我的经验是&amp;quot;一切看似大到无法解决的问题，都可以通过逐一拆解、各个击破的方式来解决&amp;rdquo;。在&amp;quot;单体应用&amp;quot;这个问题上，我们可以采取&amp;quot;微服务&amp;quot;化的方式，通过将这个巨无霸应用拆分成各个独立的小型微服务应用，分而治之！&lt;/p>
&lt;h1 id="微服务架构的优势">微服务架构的优势&lt;/h1>
&lt;p>微服务架构是在 SOA（面向服务架构）之上做的进一步扩展。在一线实践中，我们通过领域建模等理论将一个大型应用拆分成了更细粒度且边界清晰的服务模块。而且，每个微服务都能被独立测试、独立部署，并借助 Docker 和 CI/CD（持续集成环境）完成快速上线，不必像单体应用一样经历繁琐的 release 流程和漫长的发布窗口。&lt;/p>
&lt;p>每个微服务就像一个&amp;quot;麻雀虽小、五脏俱全&amp;quot;的小王国，&lt;strong>它拥有独立的代码库和数据库 Schema，通常由一个小规模的微服务技术团队全权负责，这个团队汇聚了产品、技术、架构等人员，采用 Scrum 之类的敏捷开发流程做快速迭代&lt;/strong>。基于此，微服务具备了&amp;quot;独立演进&amp;quot;能力。&lt;/p>
&lt;p>如果你对微服务拆分比较感兴趣，我推荐你去了解&amp;quot;领域建模&amp;quot;和&amp;quot;领域模型驱动（DDD）&amp;ldquo;的相关知识，后续我也会在这个课程中写一篇扩展阅读，跟你分享互联网公司常用的服务拆分规划理论：主链路规划。&lt;/p>
&lt;p>你现在肯定在好奇，为什么能独立开发部署的&amp;quot;微服务&amp;quot;可以解决单体应用的痛点呢？从我自己的经验来说，我认为微服务架构有这样几个天然的优势：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>快速迭代 + 快速回滚&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>细粒度的可独立部署的小型服务，再加上敏捷开发模式的加持，可以让你对产品功能实现快速迭代。在互联网公司中，微服务团队通常以周甚至 0.5 周为时间单位进行快速迭代。如果迭代过程中发现线上 Bug，也可以在最短的时间内做线上回滚，并且不会影响到其他应用的正常发布。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>资源利用大大提高&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>你可以将硬件等资源定向分配给需要用到资源的微服务，实现差异化的资源利用。在大厂的微服务体系中，我们会统计每个服务集群的线上压力水位，应用弹性计算技术在各个服务之间调配计算资源。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>大幅降低协作成本&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>代码库、数据库、编译打包从&amp;quot;共享&amp;quot;变为了&amp;quot;独享&amp;rdquo;，微服务团队也保持了小规模特战队的模式，进一步降低了组内组外的沟通协作成本。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>高可用&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>高可用是系统设计的第一目标，关于这一点，我想和你多介绍一些大厂微服务架构中的实践经验。通过这些介绍，让你对微服务化的必要性有更加深刻的认识。&lt;/p>
&lt;p>相比前牵一发而动全身的单体应用来说，我们可以通过很多技术手段对微服务施加个性化的保护措施，比如弹性机房水位调拨、流量整形、熔断降级。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>弹性机房水位调拨&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>弹性机房实现了计算资源的自动分配，这种弹性伸缩能力必须建立在微服务化的基础上。它可以根据每个微服务的重要程度（核心服务 vs 边缘业务）以及当前承接的用户访问压力，动态地将计算资源（如虚机、云存储）分配给需要资源的服务。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>流量整形&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>根据每个微服务承载能力的不同，控制外部流量抵达服务的速率。&amp;ldquo;限流&amp;quot;其实只是流量整形的一个场景，大型微服务的流量整形有很多种方式，比如匀速排队、流量预热、削峰填谷等等。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>熔断降级&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>在流量高峰的时候，我们可以对边缘服务做人工降级，把计算资源腾挪给核心应用，降低核心服务的访问压力。除了人工降级以外，我们还可以为每个服务设置自动降级和熔断指标，比如当调用失败率达到某个阈值之后，开启自动降级措施，降低对下游业务的访问压力。&lt;/p>
&lt;p>我们只有把应用微服务化之后，才能更好地使用上面这些技术手段对业务系统做精细力度的保护，从而实现高可用的目标。&lt;/p>
&lt;p>到这里，相信你已经对微服务架构有了更深一步的认识。不过，任何事物都有其两面性，微服务不光有好的一面，也有很多问题等着我们去解决。比如集群环境下的服务治理、数据一致性、以及高并发场景下的服务容错等等。不过呢，你大可放心，这些问题都不算事儿，在实战环节我会教你如何使用 Spring Cloud 组件将其一一攻破。下节课，我们正式开启 Spring Cloud 的大门。&lt;/p>
&lt;h1 id="总结">总结&lt;/h1>
&lt;p>今天我带你了解了微服务架构，我们将单体应用和微服务架构做了个比较，分析了单体应用无法适应互联网快速迭代的痛点，以及微服务架构是如何利用灵巧敏捷的小规模服务，很好地适应了互联网行业的快速迭代和高可用保障的要求。&lt;/p>
&lt;p>总结来说，微服务架构是通过应用领域模型等理论，将庞大的单体应用拆分为更细粒度的小型服务，每个服务都可以独立部署、测试和发布，加之敏捷开发的推广，使得微服务很好地迎合了如今互联网行业快速试错、快速迭代的节奏，同时也保证了系统的可用性。&lt;/p>
&lt;h1 id="思考题">思考题&lt;/h1>
&lt;p>你的公司是否也采用了微服务架构呢？你能从技术角度分享一下公司项目的技术选型方案吗？欢迎你和我分享，我在留言区等你。&lt;/p>
&lt;p>好啦，这节课就结束啦，也欢迎你把这节课分享给更多对 Spring Cloud 感兴趣的朋友。我是姚秋辰，我们下节课再见！&lt;/p></description></item><item><title>极客专栏: 01丨程序员如何用技术变现（上）</title><link>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E/01%E4%B8%A8%E7%A8%8B%E5%BA%8F%E5%91%98%E5%A6%82%E4%BD%95%E7%94%A8%E6%8A%80%E6%9C%AF%E5%8F%98%E7%8E%B0%E4%B8%8A/</link><pubDate>Fri, 27 May 2022 00:00:00 +0000</pubDate><guid>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E/01%E4%B8%A8%E7%A8%8B%E5%BA%8F%E5%91%98%E5%A6%82%E4%BD%95%E7%94%A8%E6%8A%80%E6%9C%AF%E5%8F%98%E7%8E%B0%E4%B8%8A/</guid><description>
&lt;p>程序员用自己的技术变现，其实是一件天经地义的事儿。写程序是一门&amp;quot;手艺活儿&amp;quot;，那么作为手艺人，程序员当然可以做到靠自己的手艺和技能养活自己。&lt;/p>
&lt;p>然而，现在很多手艺人程序员却说自己是&amp;quot;码农&amp;quot;，编码的农民工，在工作上被各种使唤，各种加班，累得像个牲口。在职业发展上各种迷茫和彷徨，完全看不到未来的希望，更别说可以成为一个手艺人用自己的技能变现了。&lt;/p>
&lt;p>从大学时代帮人打字挣点零花钱，到逐渐通过自己的技能帮助别人，由此获得相对丰厚的收入，我在很早就意识到，从事编程这个事可以做到，完全靠自己的手艺、不依赖任何人或公司去生活的。&lt;/p>
&lt;p>这对于程序员来说，本就应该是件天经地义的事，只是好像并不是所有的程序员都能意识到自己的价值。这里，我想结合我的一些经历来跟你聊聊。当然，我的经历有限，也不一定全对，只希望能给你一个参考。&lt;/p>
&lt;h1 id="学生时代">学生时代&lt;/h1>
&lt;p>我是 1994 年上的大学，计算机科学软件专业。在 1996 年上大二的时候，因为五笔学得好打字很快，我应征到教务处帮忙，把一些文档录入到电脑里。打了三个月的字，学校按照每千字 10 元，给了我 1000 元钱。&lt;/p>
&lt;p>由于我的五笔越打越快，还会用 CCED 和 WPS 排版，于是引起了别人的注意，叫我帮忙去他的打字工作室，一个月收入 400 元。我的大学是在昆明上的，这相当于那会当地收入的中上水平了。&lt;/p>
&lt;p>后来，1997 年的时候，我帮一个开公司的老师写一些 MIS 软件，用 Delphi 和 PowerBuilder 写一些办公自动化和酒店管理的软件。一年后，老师给了我 2000 元钱。&lt;/p>
&lt;p>因为动手能力比较强，当时系上的老师要干个什么事都让我帮忙。而且，因为当时的计算机人才太少太少了，所以一些社会上的人需要开发软件或是解决技术问题也都会到大学来。基本上老师们也都推荐给我。&lt;/p>
&lt;p>还记得 1997 年老师推荐一个人来找我，问我会不会做网页？5 个静态页，10000 元钱。当时学校没教怎样做网页，我去书店找书看，结果发现书店里一本讲 HTML 的书都没有，只好回绝说&amp;quot;不会做&amp;quot;。一年后，我才发现原来这事简单得要命。&lt;/p>
&lt;h1 id="初入职场">初入职场&lt;/h1>
&lt;p>到了 1998 年，我毕业参加工作，在工商银行网络科。由于可以拨号上网，于是我做了一个个人主页，那时超级流行个人主页或个人网站。我一边收集网上的一些知识，一边学着做些花哨的东西，比如网页上的菜单什么的。&lt;/p>
&lt;p>在 2000 年时，机缘巧合我的网站被《电脑报》的编辑看到了，他写来邮件约我投稿。我就写了一些如何在网页上做菜单之类的小技术文章，每个月写个两三篇，这样每个月就有 300 元左右的稿费，当时我的月工资是 600 元。&lt;/p>
&lt;p>现在通过文章标题还能找到一两篇，比如《&lt;a href="http://www.yesky.com/251/142751all.shtml">抽屉式菜单的设计&lt;/a>》，已经是乱码一堆了。&lt;/p>
&lt;p>大学时代被人请去做事的经历对我影响很大，甚至在潜意识里完全影响了我如何规划自己的人生。虽然当时我还说不清楚，只是一种强烈的感觉&amp;mdash;&amp;mdash;我完全可以靠自己的手艺、不依赖任何人或公司去生活。&lt;/p>
&lt;p>我想这种感觉，我现在可以说清楚了，这种潜意识就是&amp;mdash;&amp;mdash;&lt;strong>我完全没有必要通过打工听人安排而活着，而是反过来通过在公司工作提高自己的技能，让自己可以更为独立和自由地生活&lt;/strong>。&lt;/p>
&lt;p>因而，在工作当中，对于那些没什么技术含量的工作，我基本上就像是在学生时代那样交作业就好了。我想尽一切方法提高交作业的效率，比如，提高代码的重用度，能自动化的就自动化，和需求人员谈需求，简化掉需求，这样我就可以少干一些活了&amp;hellip;&amp;hellip;&lt;/p>
&lt;p>这样一来，&lt;strong>我就可以有更多的时间，去研究公司里外那些更为核心更有技术含量的技术了&lt;/strong>。&lt;/p>
&lt;p>在工作中，我总是能被别人和领导注意到，总是有比别人更多的时间去读书，去玩一些高技术含量的技术。当然，这种被&amp;quot;注意&amp;quot;，也不全然是一种好事。&lt;/p>
&lt;p>2002 年，我被外包到银行里做业务开发时，因为我完成项目的速度太快，所以，没事干，整天在用户那边看书，写别的代码练手，而被用户投诉&amp;quot;不务正业&amp;quot;。我当然对这样的投诉置之不理，还是我行我素，因为我的作业已交了，所以用户也就是说说罢了。&lt;/p>
&lt;p>同年，我到了一家新的很有技术含量的公司，他们在用 C 语言写一个可以把一堆 PC 机组成一个超级计算机，进行并行计算的公司项目。&lt;/p>
&lt;p>当我做完第一个项目时，有个公司里的牛人和我说，你用 Purify 测试一下你的代码有没有内存问题。Purify 是以前一个叫 Rational 的公司（后来被 IBM 收购）做的一个神器，有点像 Linux 开源的 Valgrind。&lt;/p>
&lt;p>用完以后，我觉得 Purify 太厉害了，于是把它的英文技术文档通读了一遍。经理看我很喜欢这个东西，就让我给公司里的人做个分享。我认真地准备了个 PPT，结果只来了一个 QA。&lt;/p>
&lt;p>我在一个大会议室就对着她一个人讲了一个半小时。这个 QA 对我说，&amp;ldquo;你的分享做得真好，条理性很强，也很清楚，我学到了很多东西&amp;rdquo;。&lt;/p>
&lt;p>有了这个正向反馈，我就把关于 Purify 的文章分享到了我的 CSDN 博客上，标题为《&lt;a href="http://blog.csdn.net/haoel/article/details/2900">C/C++ 内存问题检查利器&amp;mdash;Purify&lt;/a>》。可能因为这个软件是收费的，用的人不多，这篇文章的读者反响并不大。&lt;/p>
&lt;p>但是，2003 年的一天我很意外地接到了一个电话，是一个公司请我帮忙去给客户培训 Purify 这个软件。IBM 的培训太贵了，所以代理这个软件的公司为了成本问题，想找一个便宜的讲师。&lt;/p>
&lt;p>他们搜遍整个中国的互联网，只看到我的这篇文章，便通过 CSDN 找到我的联系方式，给我打了电话。最终，两天的培训价格税后一共 10000 元，而我当时的月薪只有 6000 元，还是税前。&lt;/p>
&lt;p>这件事儿让我在入行的时候就明白了一些道理。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>要去经历大多数人经历不到的，要把学习时间花在那些比较难的地方。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>要写文章就要写没有人写过的，或是别人写过，但我能写得更好的。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>更重要的是，技术和知识完全是可以变现的。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>现在回想一下，技术和知识变现这件事儿，在 15 年前我就明白了，哈哈。&lt;/p>
&lt;p>随后，我在 CSDN 博客上发表了很多文章，有谈 C 语言编程修养的文章，也有一些 makefile/gdb 手册性的文章，还有在工作中遇到的各种坑。&lt;/p>
&lt;p>因为我分享的东西比较系统，也是独一份，所以，搜索引擎自然是最优化的（最好的 SEO 就是独一份）。我的文章经常因为访问量大被推到 CSDN 首页。因此，引来了各种培训公司和出版社，还有一些别的公司主动发来的招聘，以及其他一些程序员想伙同创业的各种信息。&lt;/p>
&lt;p>紧接着我了解到，出书作者收入太低（作者的收入有两种：一种是稿费，一页 30 元；一种是版税，也就 5% 左右），而培训公司的投入产出比明显高很多后，于是我开始接一些培训的事（频率不高），一年有个七八次。当时需求比较强的培训主要是在这几个技术方面，C/C++/Java、Unix 系统编程、多层软件架构、软件测试、软件工程等。&lt;/p>
&lt;p>我喜欢做企业内训，还有一个主要原因是，可以走到内部去了解各个企业在做的事和他们遇到的技术痛点，以及身在其中的工程师的想法。这极大地增加了我对社会的了解和认识。而同时，让我这个原本不善表达的技术人员，在语言组织和表达方面有了极大的提升。&lt;/p>
&lt;p>其间也有一些软件开发的私活儿，但我基本全部拒绝了。最主要的原因是，这些软件开发基本上都是功能性的开发，我从中无法得到成长。而且后期会有很多维护工作，虽然一个小项目可以挣十几万，但为此花费的时间都是我人生中最宝贵的时光，得不偿失。&lt;/p>
&lt;p>&lt;strong>25~35 岁是每个人最宝贵的时光，应该用在刀刃上&lt;/strong>。&lt;/p>
&lt;h1 id="职业上升期">职业上升期&lt;/h1>
&lt;p>因为有了这些经历，我感受到了一个人知识和技能的价值。我开始把我的时间投在一些主流、高级和比较有挑战性的技术上，这可以让我保持两件事儿：一个是技术和技能的领先，二是对技术本质和趋势的敏感度。&lt;/p>
&lt;p>因此，我有强烈的意愿去前沿的公司经历和学习这些东西。比如，我在汤森路透学到了人员团队管理上的各种知识和技巧，而亚马逊是让我提升最快的公司。虽说，亚马逊也有很多不好的东西，但是它的一些理念，的确让我的思维方式和思考问题的角度有了质的飞跃。&lt;/p>
&lt;p>所以后来，我开始对外输出的不仅仅是技术了，还有一些技术价值观上的东西。&lt;/p>
&lt;p>而从亚马逊到阿里巴巴是我在互联网行业的工作经历，这两段经历让我对这两家看似类似但内部完全不同的成功大公司，有了更为全面的了解和看法。&lt;/p>
&lt;p>这两种完全不一样甚至有些矛盾的玩法让我时常在思考着，大脑里就像两个小人在扳手腕一样，这可能是我从小被灌输的&amp;quot;标准答案&amp;quot;的思维方式所致。其实，这个世界本来就没什么标准答案，或是说，一个题目本来就可以有若干个正确答案，而且这些&amp;quot;正确答案&amp;quot;还很矛盾。&lt;/p>
&lt;p>于是，在我把一些价值观和思考记录下来的同时，我自然又被很多人关注到了，还吸引很多不同的思路在其中交织讨论。而从另外一方面来说，这对我来说是一个很好地补充，无论别人骂我也好，教育我也罢，他们都对我有帮助，大大地丰富了我思考问题的角度。&lt;/p>
&lt;p>这些经历从质上改善了我的思考方式，让我思考技术问题的角度都随之有了一个比较大的转变。而这个转变让我有了更高的思维高度和更为开阔的视野。&lt;/p>
&lt;p>可能是因为我有一些&amp;quot;独特&amp;quot;的想法，而且经历比较丰富，基础也比较扎实，使得我对技术人的认识和理解会更为透彻和深入。所以，也有了一些小名气。来找我做咨询和帮助解决问题的人越来越多，而我也开始收费收得越来越贵了。这里需要注意的是，我完全是被动收费高的。&lt;/p>
&lt;p>因为父亲的身体原因，我没有办法全职，所以成了一个自由人。而也正因如此，我才得以有机会可以为更多公司解决技术问题。2015 年，有家公司的后端系统一推广就挂，性能有问题，请我去看。&lt;/p>
&lt;p>我花了两天时间跟他们的工程师一起简单处理了一下，直接在生产线上重构，性能翻了 10 倍。虽然这么做有点 low，但当时完全是为了救急。公司老板很高兴，觉得他投的几百万推广费用有救了，一下给了我 10 万元。我说不用这么多的，1 万元就好了，结果他说就是这么多。&lt;strong>我欣然接受了，当时心里有一种技术被尊重的感动&lt;/strong>。&lt;/p>
&lt;p>2016 年，某个公司需要做一个高并发方案，大概需要 2000 万 QPS，但是他们只能实现到 1200 万 QPS 左右。&lt;/p>
&lt;p>我花了两天时间做调研，分析性能原因，然后一天写了 700 多行代码。因为不想进入业务，所以我主要是优化了网络数据传输，让数据包尽量小，确保一个请求的响应在一个 MTU 内就传完。&lt;/p>
&lt;p>测试的时候，达到了 2500 万 QPS。于是老板给了我 20 万。&lt;/p>
&lt;p>这样的例子还有很多。上面的例子，我连钱都没谈就去做了，本来想着，也就最多 1 万元左右，没想到给我的酬劳大大超出了我的期望。&lt;/p>
&lt;p>这里，我想说的是，&lt;strong>并不是社会不尊重程序员，只要你能帮上大忙，就一定会赢得别人的尊重&lt;/strong>。&lt;/p>
&lt;p>所以，我和一些人开玩笑说，&lt;strong>我们可能都是在写一样的 for(int i=0; i&amp;lt;n; i++) 语句，但是，你写在那个地方一文不值，而我写在这个地方，这行代码就值 2000 元&lt;/strong>。不要误会，我只是想用这种&amp;quot;鲜明的对比方式&amp;quot;来加强我的观点。&lt;/p>
&lt;p>上面就是我这 20 年来的经历。相信这类经历你也有过，或者你正在经历中，欢迎你也分享一下自己的经历和心得。&lt;/p>
&lt;p>那么，怎样能让自己的技术被尊重？如何通过技术和技能赚钱？下一篇文章中，我将对此做一些总结，希望对你有帮助。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/fc/e9/fcc761001867c60f526665e237f831e9.jpg" alt="">&lt;/p></description></item><item><title>极客专栏: 01丨预习篇·小鲸鱼大事记（一）：初出茅庐</title><link>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90-kubernetes/01%E4%B8%A8%E9%A2%84%E4%B9%A0%E7%AF%87%E5%B0%8F%E9%B2%B8%E9%B1%BC%E5%A4%A7%E4%BA%8B%E8%AE%B0%E4%B8%80%E5%88%9D%E5%87%BA%E8%8C%85%E5%BA%90/</link><pubDate>Fri, 27 May 2022 00:00:00 +0000</pubDate><guid>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90-kubernetes/01%E4%B8%A8%E9%A2%84%E4%B9%A0%E7%AF%87%E5%B0%8F%E9%B2%B8%E9%B1%BC%E5%A4%A7%E4%BA%8B%E8%AE%B0%E4%B8%80%E5%88%9D%E5%87%BA%E8%8C%85%E5%BA%90/</guid><description>
&lt;p>你好，我是张磊。我今天分享的主题是：小鲸鱼大事记之初出茅庐。&lt;/p>
&lt;p>&lt;strong>如果我问你，现今最热门的服务器端技术是什么？想必你不假思索就能回答上来：当然是容器！可是，如果现在不是 2018 年而是 2013 年，你的回答还能这么斩钉截铁么？&lt;/strong>&lt;/p>
&lt;p>现在就让我们把时间拨回到五年前去看看吧。&lt;/p>
&lt;p>2013 年的后端技术领域，已经太久没有出现过令人兴奋的东西了。曾经被人们寄予厚望的云计算技术，也已经从当初虚无缥缈的概念蜕变成了实实在在的虚拟机和账单。而相比于的如日中天 AWS 和盛极一时的 OpenStack，以 Cloud Foundry 为代表的开源 PaaS 项目，却成为了当时云计算技术中的一股清流。&lt;/p>
&lt;p>这时，Cloud Foundry 项目已经基本度过了最艰难的概念普及和用户教育阶段，吸引了包括百度、京东、华为、IBM 等一大批国内外技术厂商，开启了以开源 PaaS 为核心构建平台层服务能力的变革。如果你有机会问问当时的云计算从业者们，他们十有八九都会告诉你：PaaS 的时代就要来了！&lt;/p>
&lt;p>这个说法其实一点儿没错，如果不是后来一个叫 Docker 的开源项目突然冒出来的话。&lt;/p>
&lt;p>事实上，当时还名叫 dotCloud 的 Docker 公司，也是这股 PaaS 热潮中的一份子。只不过相比于 Heroku、Pivotal、Red Hat 等 PaaS 弄潮儿们，dotCloud 公司实在是太微不足道了，而它的主打产品由于跟主流的 Cloud Foundry 社区脱节，长期以来也无人问津。眼看就要被如火如荼的 PaaS 风潮抛弃，dotCloud 公司却做出了这样一个决定：开源自己的容器项目 Docker。&lt;/p>
&lt;p>显然，这个决定在当时根本没人在乎。&lt;/p>
&lt;p>&amp;ldquo;容器&amp;quot;这个概念从来就不是什么新鲜的东西，也不是 Docker 公司发明的。即使在当时最热门的 PaaS 项目 Cloud Foundry 中，容器也只是其最底层、最没人关注的那一部分。说到这里，我正好以当时的事实标准 Cloud Foundry 为例，来解说一下 PaaS 技术。&lt;/p>
&lt;p>&lt;strong>PaaS 项目被大家接纳的一个主要原因，就是它提供了一种名叫&amp;quot;应用托管&amp;quot;的能力。&lt;/strong> 在当时，虚拟机和云计算已经是比较普遍的技术和服务了，那时主流用户的普遍用法，就是租一批 AWS 或者 OpenStack 的虚拟机，然后像以前管理物理服务器那样，用脚本或者手工的方式在这些机器上部署应用。&lt;/p>
&lt;p>当然，这个部署过程难免会碰到云端虚拟机和本地环境不一致的问题，所以当时的云计算服务，比的就是谁能更好地模拟本地服务器环境，能带来更好的&amp;quot;上云&amp;quot;体验。而 PaaS 开源项目的出现，就是当时解决这个问题的一个最佳方案。&lt;/p>
&lt;p>举个例子，虚拟机创建好之后，运维人员只需要在这些机器上部署一个 Cloud Foundry 项目，然后开发者只要执行一条命令就能把本地的应用部署到云上，这条命令就是：&lt;/p>
&lt;pre>&lt;code>$ cf push &amp;quot; 我的应用 &amp;quot;
&lt;/code>&lt;/pre>
&lt;p>是不是很神奇？&lt;/p>
&lt;p>事实上，&lt;strong>像 Cloud Foundry 这样的 PaaS 项目，最核心的组件就是一套应用的打包和分发机制。&lt;/strong> Cloud Foundry 为每种主流编程语言都定义了一种打包格式，而&amp;quot;cf push&amp;quot;的作用，基本上等同于用户把应用的可执行文件和启动脚本打进一个压缩包内，上传到云上 Cloud Foundry 的存储中。接着，Cloud Foundry 会通过调度器选择一个可以运行这个应用的虚拟机，然后通知这个机器上的 Agent 把应用压缩包下载下来启动。&lt;/p>
&lt;p>这时候关键来了，由于需要在一个虚拟机上启动很多个来自不同用户的应用，Cloud Foundry 会调用操作系统的 Cgroups 和 Namespace 机制为每一个应用单独创建一个称作&amp;quot;沙盒&amp;quot;的隔离环境，然后在&amp;quot;沙盒&amp;quot;中启动这些应用进程。这样，就实现了把多个用户的应用互不干涉地在虚拟机里批量地、自动地运行起来的目的。&lt;/p>
&lt;p>&lt;strong>这，正是 PaaS 项目最核心的能力。&lt;/strong> 而这些 Cloud Foundry 用来运行应用的隔离环境，或者说&amp;quot;沙盒&amp;rdquo;，就是所谓的&amp;quot;容器&amp;quot;。&lt;/p>
&lt;p>而 Docker 项目，实际上跟 Cloud Foundry 的容器并没有太大不同，所以在它发布后不久，Cloud Foundry 的首席产品经理 James Bayer 就在社区里做了一次详细对比，告诉用户 Docker 实际上只是一个同样使用 Cgroups 和 Namespace 实现的&amp;quot;沙盒&amp;quot;而已，没有什么特别的黑科技，也不需要特别关注。&lt;/p>
&lt;p>然而，短短几个月，Docker 项目就迅速崛起了。它的崛起速度如此之快，以至于 Cloud Foundry 以及所有的 PaaS 社区还没来得及成为它的竞争对手，就直接被宣告出局了。那时候，一位多年的 PaaS 从业者曾经如此感慨道：这简直就是一场&amp;quot;降维打击&amp;quot;啊。&lt;/p>
&lt;p>难道这一次，连闯荡多年的&amp;quot;老江湖&amp;quot;James Bayer 也看走眼了么？&lt;/p>
&lt;p>并没有。&lt;/p>
&lt;p>事实上，Docker 项目确实与 Cloud Foundry 的容器在大部分功能和实现原理上都是一样的，可偏偏就是这剩下的一小部分不一样的功能，成了 Docker 项目接下来&amp;quot;呼风唤雨&amp;quot;的不二法宝。&lt;/p>
&lt;p>&lt;strong>这个功能，就是 Docker 镜像。&lt;/strong>&lt;/p>
&lt;p>恐怕连 Docker 项目的作者 Solomon Hykes 自己当时都没想到，这个小小的创新，在短短几年内就如此迅速地改变了整个云计算领域的发展历程。&lt;/p>
&lt;p>我前面已经介绍过，PaaS 之所以能够帮助用户大规模部署应用到集群里，是因为它提供了一套应用打包的功能。可偏偏就是这个打包功能，却成了 PaaS 日后不断遭到用户诟病的一个&amp;quot;软肋&amp;quot;。&lt;/p>
&lt;p>出现这个问题的根本原因是，一旦用上了 PaaS，用户就必须为每种语言、每种框架，甚至每个版本的应用维护一个打好的包。这个打包过程，没有任何章法可循，更麻烦的是，明明在本地运行得好好的应用，却需要做很多修改和配置工作才能在 PaaS 里运行起来。而这些修改和配置，并没有什么经验可以借鉴，基本上得靠不断试错，直到你摸清楚了本地应用和远端 PaaS 匹配的&amp;quot;脾气&amp;quot;才能够搞定。&lt;/p>
&lt;p>最后结局就是，&amp;ldquo;cf push&amp;quot;确实是能一键部署了，但是为了实现这个一键部署，用户为每个应用打包的工作可谓一波三折，费尽心机。&lt;/p>
&lt;p>而&lt;strong>Docker 镜像解决的，恰恰就是打包这个根本性的问题。&lt;/strong> 所谓 Docker 镜像，其实就是一个压缩包。但是这个压缩包里的内容，比 PaaS 的应用可执行文件 + 启停脚本的组合就要丰富多了。实际上，大多数 Docker 镜像是直接由一个完整操作系统的所有文件和目录构成的，所以这个压缩包里的内容跟你本地开发和测试环境用的操作系统是完全一样的。&lt;/p>
&lt;p>这就有意思了：假设你的应用在本地运行时，能看见的环境是 CentOS 7.2 操作系统的所有文件和目录，那么只要用 CentOS 7.2 的 ISO 做一个压缩包，再把你的应用可执行文件也压缩进去，那么无论在哪里解压这个压缩包，都可以得到与你本地测试时一样的环境。当然，你的应用也在里面！&lt;/p>
&lt;p>这就是 Docker 镜像最厉害的地方：只要有这个压缩包在手，你就可以使用某种技术创建一个&amp;quot;沙盒&amp;rdquo;，在&amp;quot;沙盒&amp;quot;中解压这个压缩包，然后就可以运行你的程序了。&lt;/p>
&lt;p>更重要的是，这个压缩包包含了完整的操作系统文件和目录，也就是包含了这个应用运行所需要的所有依赖，所以你可以先用这个压缩包在本地进行开发和测试，完成之后，再把这个压缩包上传到云端运行。&lt;/p>
&lt;p>在这个过程中，你完全不需要进行任何配置或者修改，因为这个压缩包赋予了你一种极其宝贵的能力：本地环境和云端环境的高度一致！&lt;/p>
&lt;p>这，&lt;strong>正是 Docker 镜像的精髓。&lt;/strong>&lt;/p>
&lt;p>那么，有了 Docker 镜像这个利器，PaaS 里最核心的打包系统一下子就没了用武之地，最让用户抓狂的打包过程也随之消失了。相比之下，在当今的互联网里，Docker 镜像需要的操作系统文件和目录，可谓唾手可得。&lt;/p>
&lt;p>所以，你只需要提供一个下载好的操作系统文件与目录，然后使用它制作一个压缩包即可，这个命令就是：&lt;/p>
&lt;pre>&lt;code>$ docker build &amp;quot; 我的镜像 &amp;quot;
&lt;/code>&lt;/pre>
&lt;p>一旦镜像制作完成，用户就可以让 Docker 创建一个&amp;quot;沙盒&amp;quot;来解压这个镜像，然后在&amp;quot;沙盒&amp;quot;中运行自己的应用，这个命令就是：&lt;/p>
&lt;pre>&lt;code>$ docker run &amp;quot; 我的镜像 &amp;quot;
&lt;/code>&lt;/pre>
&lt;p>当然，docker run 创建的&amp;quot;沙盒&amp;quot;，也是使用 Cgroups 和 Namespace 机制创建出来的隔离环境。我会在后面的文章中，详细介绍这个机制的实现原理。&lt;/p>
&lt;p>所以，&lt;strong>Docker 项目给 PaaS 世界带来的&amp;quot;降维打击&amp;quot;，其实是提供了一种非常便利的打包机制。这种机制直接打包了应用运行所需要的整个操作系统，从而保证了本地环境和云端环境的高度一致，避免了用户通过&amp;quot;试错&amp;quot;来匹配两种不同运行环境之间差异的痛苦过程。&lt;/strong>&lt;/p>
&lt;p>而对于开发者们来说，在终于体验到了生产力解放所带来的痛快之后，他们自然选择了用脚投票，直接宣告了 PaaS 时代的结束。&lt;/p>
&lt;p>不过，Docker 项目固然解决了应用打包的难题，但正如前面所介绍的那样，它并不能代替 PaaS 完成大规模部署应用的职责。&lt;/p>
&lt;p>遗憾的是，考虑到 Docker 公司是一个与自己有潜在竞争关系的商业实体，再加上对 Docker 项目普及程度的错误判断，Cloud Foundry 项目并没有第一时间使用 Docker 作为自己的核心依赖，去替换自己那套饱受诟病的打包流程。&lt;/p>
&lt;p>反倒是一些机敏的创业公司，纷纷在第一时间推出了 Docker 容器集群管理的开源项目（比如 Deis 和 Flynn），它们一般称自己为 CaaS，即 Container-as-a-Service，用来跟&amp;quot;过时&amp;quot;的 PaaS 们划清界限。&lt;/p>
&lt;p>而在 2014 年底的 DockerCon 上，Docker 公司雄心勃勃地对外发布了自家研发的&amp;quot;Docker 原生&amp;quot;容器集群管理项目 Swarm，不仅将这波&amp;quot;CaaS&amp;quot;热推向了一个前所未有的高潮，更是寄托了整个 Docker 公司重新定义 PaaS 的宏伟愿望。&lt;/p>
&lt;p>在 2014 年的这段巅峰岁月里，Docker 公司离自己的理想真的只有一步之遥。&lt;/p>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>2013~2014 年，以 Cloud Foundry 为代表的 PaaS 项目，逐渐完成了教育用户和开拓市场的艰巨任务，也正是在这个将概念逐渐落地的过程中，应用&amp;quot;打包&amp;quot;困难这个问题，成了整个后端技术圈子的一块心病。&lt;/p>
&lt;p>Docker 项目的出现，则为这个根本性的问题提供了一个近乎完美的解决方案。这正是 Docker 项目刚刚开源不久，就能够带领一家原本默默无闻的 PaaS 创业公司脱颖而出，然后迅速占领了所有云计算领域头条的技术原因。&lt;/p>
&lt;p>而在成为了基础设施领域近十年难得一见的技术明星之后，dotCloud 公司则在 2013 年底大胆改名为 Docker 公司。不过，这个在当时就颇具争议的改名举动，也成为了日后容器技术圈风云变幻的一个关键伏笔。&lt;/p>
&lt;h2 id="思考题">思考题&lt;/h2>
&lt;p>你是否曾经研发过类似 PaaS 的项目？你碰到过应用打包的问题吗，又是如何解决的呢？&lt;/p>
&lt;p>感谢收听，欢迎你给我留言，也欢迎分享给更多的朋友一起阅读。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/47/55/47a6f3bf6b92d58512d5a2ed0a556f55.jpg" alt="">&lt;/p></description></item><item><title>极客专栏: 02 _ 理解进程（1）：为什么我在容器中不能kill 1号进程？</title><link>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E5%AE%B9%E5%99%A8%E9%AB%98%E6%89%8B%E5%AE%9E%E6%88%98%E8%AF%BE/02%E4%B8%A8%E7%90%86%E8%A7%A3%E8%BF%9B%E7%A8%8B1%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E5%9C%A8%E5%AE%B9%E5%99%A8%E4%B8%AD%E4%B8%8D%E8%83%BDkill-1%E5%8F%B7%E8%BF%9B%E7%A8%8B/</link><pubDate>Fri, 08 Jul 2022 00:00:00 +0000</pubDate><guid>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E5%AE%B9%E5%99%A8%E9%AB%98%E6%89%8B%E5%AE%9E%E6%88%98%E8%AF%BE/02%E4%B8%A8%E7%90%86%E8%A7%A3%E8%BF%9B%E7%A8%8B1%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E5%9C%A8%E5%AE%B9%E5%99%A8%E4%B8%AD%E4%B8%8D%E8%83%BDkill-1%E5%8F%B7%E8%BF%9B%E7%A8%8B/</guid><description>
&lt;p>你好，我是程远。&lt;/p>
&lt;p>今天，我们正式进入理解进程的模块。我会通过 3 讲内容，带你了解容器 init 进程的特殊之处，还有它需要具备哪些功能，才能保证容器在运行过程中不会出现类似僵尸进程，或者应用程序无法 graceful shutdown 的问题。&lt;/p>
&lt;p>那么通过这一讲，我会带你掌握 init 进程和 Linux 信号的核心概念。&lt;/p>
&lt;h1 id="问题再现">问题再现&lt;/h1>
&lt;p>接下来，我们一起再现用 kill 1 命令重启容器的问题。&lt;/p>
&lt;p>我猜你肯定想问，为什么要在容器中执行 kill 1 或者 kill -9 1 的命令呢？其实这是我们团队里的一位同学提出的问题。&lt;/p>
&lt;p>这位同学当时遇到的情况是这样的，他想修改容器镜像里的一个 bug，但因为网路配置的问题，这个同学又不想为了重建 pod 去改变 pod IP。&lt;/p>
&lt;p>如果你用过 Kubernetes 的话，你也肯定知道，Kubernetes 上是没有 restart pod 这个命令的。这样看来，他似乎只能让 pod 做个原地重启了。&lt;strong>当时我首先想到的，就是在容器中使用 kill pid 1 的方式重启容器。&lt;/strong>&lt;/p>
&lt;p>为了模拟这个过程，我们可以进行下面的这段操作。&lt;/p>
&lt;p>如果你没有在容器中做过 kill 1 ，你可以下载我在 GitHub 上的这个例子，运行 make image 来做一个容器镜像。&lt;/p>
&lt;p>然后，我们用 Docker 构建一个容器，用例子中的 &lt;strong>init.sh 脚本&lt;/strong>作为这个容器的 init 进程。&lt;/p>
&lt;p>最后，我们在容器中运行 kill 1 和 kill -9 1 ，看看会发生什么。&lt;/p>
&lt;pre tabindex="0">&lt;code># docker stop sig-proc;docker rm sig-proc
# docker run --name sig-proc -d registry/sig-proc:v1 /init.sh
# docker exec -it sig-proc bash
[root@5cc69036b7b2 /]# ps -ef
UID PID PPID C STIME TTY TIME CMD
root 1 0 0 07:23 ? 00:00:00 /bin/bash /init.sh
root 8 1 0 07:25 ? 00:00:00 /usr/bin/coreutils --coreutils-prog-shebang=sleep /usr/bin/sleep 100
root 9 0 6 07:27 pts/0 00:00:00 bash
root 22 9 0 07:27 pts/0 00:00:00 ps -ef
[root@5cc69036b7b2 /]# kill 1
[root@5cc69036b7b2 /]# kill -9 1
[root@5cc69036b7b2 /]# ps -ef
UID PID PPID C STIME TTY TIME CMD
root 1 0 0 07:23 ? 00:00:00 /bin/bash /init.sh
root 9 0 0 07:27 pts/0 00:00:00 bash
root 23 1 0 07:27 ? 00:00:00 /usr/bin/coreutils --coreutils-prog-shebang=sleep /usr/bin/sleep 100
root 24 9 0 07:27 pts/0 00:00:00 ps -ef
&lt;/code>&lt;/pre>&lt;p>当我们完成前面的操作，就会发现无论运行 kill 1 （对应 Linux 中的 SIGTERM 信号）还是 kill -9 1（对应 Linux 中的 SIGKILL 信号），都无法让进程终止。&lt;/p>
&lt;p>那么问题来了，这两个常常用来终止进程的信号，都对容器中的 init 进程不起作用，这是怎么回事呢？&lt;/p>
&lt;p>要解释这个问题，我们就要回到容器的两个最基本概念&amp;mdash;&amp;mdash;init 进程和 Linux 信号中寻找答案。&lt;/p>
&lt;h1 id="知识详解">知识详解&lt;/h1>
&lt;h1 id="如何理解-init-进程">如何理解 init 进程？&lt;/h1>
&lt;p>init 进程的意思并不难理解，你只要认真听我讲完，这块内容基本就不会有问题了。我们下面来看一看。&lt;/p>
&lt;p>使用容器的理想境界是&lt;strong>一个容器只启动一个进程&lt;/strong>，但这在现实应用中有时是做不到的。&lt;/p>
&lt;p>比如说，在一个容器中除了主进程之外，我们可能还会启动辅助进程，做监控或者 rotate logs；再比如说，我们需要把原来运行在虚拟机（VM）的程序移到容器里，这些原来跑在虚拟机上的程序本身就是多进程的。&lt;/p>
&lt;p>一旦我们启动了多个进程，那么容器里就会出现一个 pid 1，也就是我们常说的 1 号进程或者 init 进程，然后&lt;strong>由这个进程创建出其他的子进程。&lt;/strong>&lt;/p>
&lt;p>接下来，我带你梳理一下 init 进程是怎么来的。&lt;/p>
&lt;p>一个 Linux 操作系统，在系统打开电源，执行 BIOS/boot-loader 之后，就会由 boot-loader 负责加载 Linux 内核。&lt;/p>
&lt;p>Linux 内核执行文件一般会放在 /boot 目录下，文件名类似 vmlinuz*。在内核完成了操作系统的各种初始化之后，&lt;strong>这个程序需要执行的第一个用户态程就是 init 进程。&lt;/strong>&lt;/p>
&lt;p>内核代码启动 1 号进程的时候，在没有外面参数指定程序路径的情况下，一般会从几个缺省路径尝试执行 1 号进程的代码。这几个路径都是 Unix 常用的可执行代码路径。&lt;/p>
&lt;p>系统启动的时候先是执行内核态的代码，然后在内核中调用 1 号进程的代码，从内核态切换到用户态。&lt;/p>
&lt;p>目前主流的 Linux 发行版，无论是 RedHat 系的还是 Debian 系的，都会把 /sbin/init 作为符号链接指向 Systemd。Systemd 是目前最流行的 Linux init 进程，在它之前还有 SysVinit、UpStart 等 Linux init 进程。&lt;/p>
&lt;p>**但无论是哪种 Linux init 进程，它最基本的功能都是创建出 Linux 系统中其他所有的进程，并且管理这些进程。**具体在 kernel 里的代码实现如下：&lt;/p>
&lt;pre tabindex="0">&lt;code>init/main.c
/*
* We try each of these until one succeeds.
*
* The Bourne shell can be used instead of init if we are
* trying to recover a really broken machine.
*/
if (execute_command) {
ret = run_init_process(execute_command);
if (!ret)
return 0;
panic(&amp;#34;Requested init %s failed (error %d).&amp;#34;,
execute_command, ret);
}
if (!try_to_run_init_process(&amp;#34;/sbin/init&amp;#34;) ||
!try_to_run_init_process(&amp;#34;/etc/init&amp;#34;) ||
!try_to_run_init_process(&amp;#34;/bin/init&amp;#34;) ||
!try_to_run_init_process(&amp;#34;/bin/sh&amp;#34;))
return 0;
panic(&amp;#34;No working init found. Try passing init= option to kernel. &amp;#34;
&amp;#34;See Linux Documentation/admin-guide/init.rst for guidance.&amp;#34;);
&lt;/code>&lt;/pre>&lt;pre tabindex="0">&lt;code>$ ls -l /sbin/init
lrwxrwxrwx 1 root root 20 Feb 5 01:07 /sbin/init -&amp;gt; /lib/systemd/systemd
&lt;/code>&lt;/pre>&lt;p>在 Linux 上有了容器的概念之后，一旦容器建立了自己的 Pid Namespace（进程命名空间），这个 Namespace 里的进程号也是从 1 开始标记的。所以，容器的 init 进程也被称为 1 号进程。&lt;/p>
&lt;p>怎么样，1 号进程是不是不难理解？关于这个知识点，你只需要记住： &lt;strong>1 号进程是第一个用户态的进程，由它直接或者间接创建了 Namespace 中的其他进程。&lt;/strong>&lt;/p>
&lt;h1 id="如何理解-linux-信号">如何理解 Linux 信号？&lt;/h1>
&lt;p>刚才我给你讲了什么是 1 号进程，要想解决&amp;quot;为什么我在容器中不能 kill 1 号进程&amp;quot;这个问题，我们还得看看 kill 命令起到的作用。&lt;/p>
&lt;p>我们运行 kill 命令，其实在 Linux 里就是发送一个信号，那么信号到底是什么呢？这就涉及到 Linux 信号的概念了。&lt;/p>
&lt;p>其实信号这个概念在很早期的 Unix 系统上就有了。它一般会从 1 开始编号，通常来说，信号编号是 1 到 31，这个编号在所有的 Unix 系统上都是一样的。&lt;/p>
&lt;p>在 Linux 上我们可以用 kill -l 来看这些信号的编号和名字，具体的编号和名字我给你列在了下面，你可以看一看。&lt;/p>
&lt;pre tabindex="0">&lt;code>$ kill -l
1) SIGHUP 2) SIGINT 3) SIGQUIT 4) SIGILL 5) SIGTRAP
6) SIGABRT 7) SIGBUS 8) SIGFPE 9) SIGKILL 10) SIGUSR1
11) SIGSEGV 12) SIGUSR2 13) SIGPIPE 14) SIGALRM 15) SIGTERM
16) SIGSTKFLT 17) SIGCHLD 18) SIGCONT 19) SIGSTOP 20) SIGTSTP
21) SIGTTIN 22) SIGTTOU 23) SIGURG 24) SIGXCPU 25) SIGXFSZ
26) SIGVTALRM 27) SIGPROF 28) SIGWINCH 29) SIGIO 30) SIGPWR
31) SIGSYS
&lt;/code>&lt;/pre>&lt;p>用一句话来概括，**信号（Signal）其实就是 Linux 进程收到的一个通知。**这些通知产生的源头有很多种，通知的类型也有很多种。&lt;/p>
&lt;p>比如下面这几个典型的场景，你可以看一下：&lt;/p>
&lt;ul>
&lt;li>如果我们按下键盘&amp;quot;Ctrl+C&amp;quot;，当前运行的进程就会收到一个信号 SIGINT 而退出；&lt;/li>
&lt;li>如果我们的代码写得有问题，导致内存访问出错了，当前的进程就会收到另一个信号 SIGSEGV；&lt;/li>
&lt;li>我们也可以通过命令 kill &amp;lt;pid&amp;gt;，直接向一个进程发送一个信号，缺省情况下不指定信号的类型，那么这个信号就是 SIGTERM。也可以指定信号类型，比如命令 &amp;ldquo;kill -9 &amp;lt;pid&amp;gt;&amp;rdquo;, 这里的 9，就是编号为 9 的信号，SIGKILL 信号。&lt;/li>
&lt;/ul>
&lt;p>在这一讲中，我们主要用到&lt;strong>SIGTERM（15）和 SIGKILL（9）这两个信号&lt;/strong>，所以这里你主要了解这两个信号就可以了，其他信号以后用到时再做介绍。&lt;/p>
&lt;p>进程在收到信号后，就会去做相应的处理。怎么处理呢？对于每一个信号，进程对它的处理都有下面三个选择。&lt;/p>
&lt;p>第一个选择是&lt;strong>忽略（Ignore）&lt;/strong>，就是对这个信号不做任何处理，但是有两个信号例外，对于 SIGKILL 和 SIGSTOP 这个两个信号，进程是不能忽略的。这是因为它们的主要作用是为 Linux kernel 和超级用户提供删除任意进程的特权。&lt;/p>
&lt;p>第二个选择，就是&lt;strong>捕获（Catch）&lt;/strong>，这个是指让用户进程可以注册自己针对这个信号的 handler。具体怎么做我们目前暂时涉及不到，你先知道就行，我们在后面课程会进行详细介绍。&lt;/p>
&lt;p>&lt;strong>对于捕获，SIGKILL 和 SIGSTOP 这两个信号也同样例外，这两个信号不能有用户自己的处理代码，只能执行系统的缺省行为。&lt;/strong>&lt;/p>
&lt;p>还有一个选择是&lt;strong>缺省行为（Default）&lt;/strong>，Linux 为每个信号都定义了一个缺省的行为，你可以在 Linux 系统中运行 man 7 signal来查看每个信号的缺省行为。&lt;/p>
&lt;p>对于大部分的信号而言，应用程序不需要注册自己的 handler，使用系统缺省定义行为就可以了。&lt;br>
&lt;img src="https://static001.geekbang.org/resource/image/da/0d/dae0e2bdfb4bae2d900e58cb3490dc0d.jpeg" alt="">&lt;/p>
&lt;p>我刚才说了，SIGTERM（15）和 SIGKILL（9）这两个信号是我们重点掌握的。现在我们已经讲解了信号的概念和处理方式，我就拿这两个信号为例，再带你具体分析一下。&lt;/p>
&lt;p>首先我们来看 SIGTERM（15），这个信号是 Linux 命令 kill 缺省发出的。前面例子里的命令 kill 1 ，就是通过 kill 向 1 号进程发送一个信号，在没有别的参数时，这个信号类型就默认为 SIGTERM。&lt;/p>
&lt;p>SIGTERM 这个信号是可以被捕获的，这里的&amp;quot;捕获&amp;quot;指的就是用户进程可以为这个信号注册自己的 handler，而这个 handler，我们后面会看到，它可以处理进程的 graceful-shutdown 问题。&lt;/p>
&lt;p>我们再来了解一下 SIGKILL (9)，这个信号是 Linux 里两个&lt;strong>特权信号&lt;/strong>之一。什么是特权信号呢？&lt;/p>
&lt;p>前面我们已经提到过了，**特权信号就是 Linux 为 kernel 和超级用户去删除任意进程所保留的，不能被忽略也不能被捕获。**那么进程一旦收到 SIGKILL，就要退出。&lt;/p>
&lt;p>在前面的例子里，我们运行的命令 kill -9 1 里的参数&amp;quot;-9&amp;quot;，其实就是指发送编号为 9 的这个 SIGKILL 信号给 1 号进程。&lt;/p>
&lt;h1 id="现象解释">现象解释&lt;/h1>
&lt;p>现在，你应该理解 init 进程和 Linux 信号这两个概念了，让我们回到开头的问题上来：&amp;ldquo;为什么我在容器中不能 kill 1 号进程，甚至 SIGKILL 信号也不行？&amp;rdquo;&lt;/p>
&lt;p>你还记得么，在课程的最开始，我们已经尝试过用 bash 作为容器 1 号进程，这样是无法把 1 号进程杀掉的。那么我们再一起来看一看，用别的编程语言写的 1 号进程是否也杀不掉。&lt;/p>
&lt;p>我们现在&lt;strong>用 C 程序作为 init 进程&lt;/strong>，尝试一下杀掉 1 号进程。和 bash init 进程一样，无论 SIGTERM 信号还是 SIGKILL 信号，在容器里都不能杀死这个 1 号进程。&lt;/p>
&lt;pre tabindex="0">&lt;code># cat c-init-nosig.c
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
int main(int argc, char *argv[])
{
printf(&amp;#34;Process is sleeping\n&amp;#34;);
while (1) {
sleep(100);
}
return 0;
}
&lt;/code>&lt;/pre>&lt;pre tabindex="0">&lt;code># docker stop sig-proc;docker rm sig-proc
# docker run --name sig-proc -d registry/sig-proc:v1 /c-init-nosig
# docker exec -it sig-proc bash
[root@5d3d42a031b1 /]# ps -ef
UID PID PPID C STIME TTY TIME CMD
root 1 0 0 07:48 ? 00:00:00 /c-init-nosig
root 6 0 5 07:48 pts/0 00:00:00 bash
root 19 6 0 07:48 pts/0 00:00:00 ps -ef
[root@5d3d42a031b1 /]# kill 1
[root@5d3d42a031b1 /]# kill -9 1
[root@5d3d42a031b1 /]# ps -ef
UID PID PPID C STIME TTY TIME CMD
root 1 0 0 07:48 ? 00:00:00 /c-init-nosig
root 6 0 0 07:48 pts/0 00:00:00 bash
root 20 6 0 07:49 pts/0 00:00:00 ps -ef
&lt;/code>&lt;/pre>&lt;p>我们是不是这样就可以得出结论&amp;mdash;&amp;mdash;&amp;ldquo;容器里的 1 号进程，完全忽略了 SIGTERM 和 SIGKILL 信号了&amp;quot;呢？你先别着急，我们再拿其他语言试试。&lt;/p>
&lt;p>接下来，我们用&lt;strong>Golang 程序作为 1 号进程&lt;/strong>，我们再在容器中执行 kill -9 1 和 kill 1 。&lt;/p>
&lt;p>这次，我们发现 kill -9 1 这个命令仍然不能杀死 1 号进程，也就是说，SIGKILL 信号和之前的两个测试一样不起作用。&lt;/p>
&lt;p>&lt;strong>但是，我们执行&lt;strong>&lt;strong>kill 1&lt;/strong>&lt;/strong>以后，SIGTERM 这个信号把 init 进程给杀了，容器退出了。&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code># cat go-init.go
package main
import (
&amp;#34;fmt&amp;#34;
&amp;#34;time&amp;#34;
)
func main() {
fmt.Println(&amp;#34;Start app\n&amp;#34;)
time.Sleep(time.Duration(100000) * time.Millisecond)
}
&lt;/code>&lt;/pre>&lt;pre tabindex="0">&lt;code># docker stop sig-proc;docker rm sig-proc
# docker run --name sig-proc -d registry/sig-proc:v1 /go-init
# docker exec -it sig-proc bash
[root@234a23aa597b /]# ps -ef
UID PID PPID C STIME TTY TIME CMD
root 1 0 1 08:04 ? 00:00:00 /go-init
root 10 0 9 08:04 pts/0 00:00:00 bash
root 23 10 0 08:04 pts/0 00:00:00 ps -ef
[root@234a23aa597b /]# kill -9 1
[root@234a23aa597b /]# kill 1
[root@234a23aa597b /]# [~]# docker ps
CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES
&lt;/code>&lt;/pre>&lt;p>对于这个测试结果，你是不是反而觉得更加困惑了？&lt;/p>
&lt;p>为什么使用不同程序，结果就不一样呢？接下来我们就看看 kill 命令下达之后，Linux 里究竟发生了什么事，我给你系统地梳理一下整个过程。&lt;/p>
&lt;p>在我们运行 kill 1 这个命令的时候，希望把 SIGTERM 这个信号发送给 1 号进程，就像下面图里的&lt;strong>带箭头虚线&lt;/strong>。&lt;/p>
&lt;p>在 Linux 实现里，kill 命令调用了 &lt;strong>kill() 的这个系统调用&lt;/strong>（所谓系统调用就是内核的调用接口）而进入到了内核函数 sys_kill()， 也就是下图里的&lt;strong>实线箭头&lt;/strong>。&lt;/p>
&lt;p>而内核在决定把信号发送给 1 号进程的时候，会调用 sig_task_ignored() 这个函数来做个判断，这个判断有什么用呢？&lt;/p>
&lt;p>它会决定内核在哪些情况下会把发送的这个信号给忽略掉。如果信号被忽略了，那么 init 进程就不能收到指令了。&lt;/p>
&lt;p>所以，我们想要知道 init 进程为什么收到或者收不到信号，都要去看看 &lt;strong>sig_task_ignored() 的这个内核函数的实现。&lt;/strong>&lt;br>
&lt;img src="https://static001.geekbang.org/resource/image/ce/7f/cec445b6af1c0f678cc1b538bb03d67f.jpeg" alt="">&lt;br>
sig_task_ignored()内核函数实现示意图&lt;/p>
&lt;p>在 sig_task_ignored() 这个函数中有三个 if{}判断，第一个和第三个 if{}判断和我们的问题没有关系，并且代码有注释，我们就不讨论了。&lt;/p>
&lt;p>我们重点来看第二个 if{}。我来给你分析一下，在容器中执行 kill 1 或者 kill -9 1 的时候，这第二个 if{}里的三个子条件是否可以被满足呢？&lt;/p>
&lt;p>我们来看下面这串代码，这里表示&lt;strong>一旦这三个子条件都被满足，那么这个信号就不会发送给进程。&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code>kernel/signal.c
static bool sig_task_ignored(struct task_struct *t, int sig, bool force)
{
void __user *handler;
handler = sig_handler(t, sig);
/* SIGKILL and SIGSTOP may not be sent to the global init */
if (unlikely(is_global_init(t) &amp;amp;&amp;amp; sig_kernel_only(sig)))
return true;
if (unlikely(t-&amp;gt;signal-&amp;gt;flags &amp;amp; SIGNAL_UNKILLABLE) &amp;amp;&amp;amp;
handler == SIG_DFL &amp;amp;&amp;amp; !(force &amp;amp;&amp;amp; sig_kernel_only(sig)))
return true;
/* Only allow kernel generated signals to this kthread */
if (unlikely((t-&amp;gt;flags &amp;amp; PF_KTHREAD) &amp;amp;&amp;amp;
(handler == SIG_KTHREAD_KERNEL) &amp;amp;&amp;amp; !force))
return true;
return sig_handler_ignored(handler, sig);
}
&lt;/code>&lt;/pre>&lt;p>接下来，我们就逐一分析一下这三个子条件，我们来说说这个&amp;rdquo;!(force &amp;amp;&amp;amp; sig_kernel_only(sig))&amp;quot; 。&lt;/p>
&lt;p>第一个条件里 force 的值，对于同一个 Namespace 里发出的信号来说，调用值是 0，所以这个条件总是满足的。&lt;/p>
&lt;p>我们再来看一下第二个条件 &amp;ldquo;handler == SIG_DFL&amp;rdquo;，第二个条件判断信号的 handler 是否是 SIG_DFL。&lt;/p>
&lt;p>那么什么是 SIG_DFL 呢？&lt;strong>对于每个信号，用户进程如果不注册一个自己的 handler，就会有一个系统缺省的 handler，这个缺省的 handler 就叫作 SIG_DFL。&lt;/strong>&lt;/p>
&lt;p>对于 SIGKILL，我们前面介绍过它是特权信号，是不允许被捕获的，所以它的 handler 就一直是 SIG_DFL。这第二个条件对 SIGKILL 来说总是满足的。&lt;/p>
&lt;p>对于 SIGTERM，它是可以被捕获的。也就是说如果用户不注册 handler，那么这个条件对 SIGTERM 也是满足的。&lt;/p>
&lt;p>最后再来看一下第三个条件，&amp;ldquo;t-&amp;gt;signal-&amp;gt;flags &amp;amp; SIGNAL_UNKILLABLE&amp;rdquo;，这里的条件判断是这样的，进程必须是 SIGNAL_UNKILLABLE 的。&lt;/p>
&lt;p>这个 SIGNAL_UNKILLABLE flag 是在哪里置位的呢？&lt;/p>
&lt;p>可以参考我们下面的这段代码，在每个 Namespace 的 init 进程建立的时候，就会打上 &lt;strong>SIGNAL_UNKILLABLE&lt;/strong> 这个标签，也就是说只要是 1 号进程，就会有这个 flag，这个条件也是满足的。&lt;/p>
&lt;pre tabindex="0">&lt;code>kernel/fork.c
if (is_child_reaper(pid)) {
ns_of_pid(pid)-&amp;gt;child_reaper = p;
p-&amp;gt;signal-&amp;gt;flags |= SIGNAL_UNKILLABLE;
}
/*
* is_child_reaper returns true if the pid is the init process
* of the current namespace. As this one could be checked before
* pid_ns-&amp;gt;child_reaper is assigned in copy_process, we check
* with the pid number.
*/
static inline bool is_child_reaper(struct pid *pid)
{
return pid-&amp;gt;numbers[pid-&amp;gt;level].nr == 1;
}
&lt;/code>&lt;/pre>&lt;p>我们可以看出来，其实&lt;strong>最关键的一点就是&lt;strong>&lt;strong>handler == SIG_DFL&lt;/strong>&lt;/strong>。Linux 内核针对每个 Nnamespace 里的 init 进程，把只有 default handler 的信号都给忽略了。&lt;/strong>&lt;/p>
&lt;p>如果我们自己注册了信号的 handler（应用程序注册信号 handler 被称作&amp;quot;Catch the Signal&amp;quot;），那么这个信号 handler 就不再是 SIG_DFL 。即使是 init 进程在接收到 SIGTERM 之后也是可以退出的。&lt;/p>
&lt;p>不过，由于 SIGKILL 是一个特例，因为 SIGKILL 是不允许被注册用户 handler 的（还有一个不允许注册用户 handler 的信号是 SIGSTOP），那么它只有 SIG_DFL handler。&lt;/p>
&lt;p>所以 init 进程是永远不能被 SIGKILL 所杀，但是可以被 SIGTERM 杀死。&lt;/p>
&lt;p>说到这里，我们该怎么证实这一点呢？我们可以做下面两件事来验证。&lt;/p>
&lt;p>&lt;strong>第一件事，你可以查看 1 号进程状态中 SigCgt Bitmap。&lt;/strong>&lt;/p>
&lt;p>我们可以看到，在 Golang 程序里，很多信号都注册了自己的 handler，当然也包括了 SIGTERM(15)，也就是 bit 15。&lt;/p>
&lt;p>而 C 程序里，缺省状态下，一个信号 handler 都没有注册；bash 程序里注册了两个 handler，bit 2 和 bit 17，也就是 SIGINT 和 SIGCHLD，但是没有注册 SIGTERM。&lt;/p>
&lt;p>所以，C 程序和 bash 程序里 SIGTERM 的 handler 是 SIG_DFL（系统缺省行为），那么它们就不能被 SIGTERM 所杀。&lt;/p>
&lt;p>具体我们可以看一下这段 /proc 系统的进程状态：&lt;/p>
&lt;pre tabindex="0">&lt;code>### golang init
# cat /proc/1/status | grep -i SigCgt
SigCgt: fffffffe7fc1feff
### C init
# cat /proc/1/status | grep -i SigCgt
SigCgt: 0000000000000000
### bash init
# cat /proc/1/status | grep -i SigCgt
SigCgt: 0000000000010002
&lt;/code>&lt;/pre>&lt;p>&lt;strong>第二件事，给 C 程序注册一下 SIGTERM handler，捕获 SIGTERM。&lt;/strong>&lt;/p>
&lt;p>我们调用 signal() 系统调用注册 SIGTERM 的 handler，在 handler 里主动退出，再看看容器中 kill 1 的结果。&lt;/p>
&lt;p>这次我们就可以看到，&lt;strong>在进程状态的 SigCgt bitmap 里，bit 15 (SIGTERM) 已经置位了。同时，运行&lt;strong>&lt;strong>kill 1&lt;/strong>&lt;/strong>也可以把这个 C 程序的 init 进程给杀死了。&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code>#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;sys/wait.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
void sig_handler(int signo)
{
if (signo == SIGTERM) {
printf(&amp;#34;received SIGTERM\n&amp;#34;);
exit(0);
}
}
int main(int argc, char *argv[])
{
signal(SIGTERM, sig_handler);
printf(&amp;#34;Process is sleeping\n&amp;#34;);
while (1) {
sleep(100);
}
return 0;
}
&lt;/code>&lt;/pre>&lt;pre tabindex="0">&lt;code># docker stop sig-proc;docker rm sig-proc
# docker run --name sig-proc -d registry/sig-proc:v1 /c-init-sig
# docker exec -it sig-proc bash
[root@043f4f717cb5 /]# ps -ef
UID PID PPID C STIME TTY TIME CMD
root 1 0 0 09:05 ? 00:00:00 /c-init-sig
root 6 0 18 09:06 pts/0 00:00:00 bash
root 19 6 0 09:06 pts/0 00:00:00 ps -ef
[root@043f4f717cb5 /]# cat /proc/1/status | grep SigCgt
SigCgt: 0000000000004000
[root@043f4f717cb5 /]# kill 1
# docker ps
CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES
&lt;/code>&lt;/pre>&lt;p>好了，到这里我们可以确定这两点：&lt;/p>
&lt;ul>
&lt;li>kill -9 1 在容器中是不工作的，内核阻止了 1 号进程对 SIGKILL 特权信号的响应。&lt;/li>
&lt;li>kill 1 分两种情况，如果 1 号进程没有注册 SIGTERM 的 handler，那么对 SIGTERM 信号也不响应，如果注册了 handler，那么就可以响应 SIGTERM 信号。&lt;/li>
&lt;/ul>
&lt;h1 id="重点总结">重点总结&lt;/h1>
&lt;p>好了，今天的内容讲完了。我们来总结一下。&lt;/p>
&lt;p>这一讲我们主要讲了 init 进程。围绕这个知识点，我提出了一个真实发生的问题：&amp;ldquo;为什么我在容器中不能 kill 1 号进程?&amp;quot;。&lt;/p>
&lt;p>想要解决这个问题，我们需要掌握两个基本概念。&lt;/p>
&lt;p>第一个概念是 Linux 1 号进程。&lt;strong>它是第一个用户态的进程。它直接或者间接创建了 Namespace 中的其他进程。&lt;/strong>&lt;/p>
&lt;p>第二个概念是 Linux 信号。Linux 有 31 个基本信号，进程在处理大部分信号时有三个选择：&lt;strong>忽略、捕获和缺省行为。其中两个特权信号 SIGKILL 和 SIGSTOP 不能被忽略或者捕获。&lt;/strong>&lt;/p>
&lt;p>只知道基本概念还不行，我们还要去解决问题。我带你尝试了用 bash, C 语言还有 Golang 程序作为容器 init 进程，发现它们对 kill 1 的反应是不同的。&lt;/p>
&lt;p>因为信号的最终处理都是在 Linux 内核中进行的，因此，我们需要对 Linux 内核代码进行分析。&lt;/p>
&lt;p>容器里 1 号进程对信号处理的两个要点，这也是这一讲里我想让你记住的两句话：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>在容器中，1 号进程永远不会响应 SIGKILL 和 SIGSTOP 这两个特权信号；&lt;/strong>&lt;/li>
&lt;li>&lt;strong>对于其他的信号，如果用户自己注册了 handler，1 号进程可以响应。&lt;/strong>&lt;/li>
&lt;/ul>
&lt;h1 id="思考题">思考题&lt;/h1>
&lt;p>这一讲的最开始，有这样一个 C 语言的 init 进程，它没有注册任何信号的 handler。如果我们从 Host Namespace 向它发送 SIGTERM，会发生什么情况呢？&lt;/p>
&lt;p>欢迎留言和我分享你的想法。如果你的朋友也对 1 号进程有困惑，欢迎你把这篇文章分享给他，说不定就帮他解决了一个难题。&lt;/p></description></item><item><title>极客专栏: 02｜基本概念和基础命令：应对简单的编辑任务</title><link>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/vim-%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/02%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%92%8C%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4%E5%BA%94%E5%AF%B9%E7%AE%80%E5%8D%95%E7%9A%84%E7%BC%96%E8%BE%91%E4%BB%BB%E5%8A%A1/</link><pubDate>Fri, 08 Jul 2022 00:00:00 +0000</pubDate><guid>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/vim-%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/02%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%92%8C%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4%E5%BA%94%E5%AF%B9%E7%AE%80%E5%8D%95%E7%9A%84%E7%BC%96%E8%BE%91%E4%BB%BB%E5%8A%A1/</guid><description>
&lt;p>你好，我是吴咏炜。&lt;/p>
&lt;p>这一讲，我们会讨论 Vim 的基本概念和配置。先强调一下，请务必确保你在学习这一讲之前，已经通过 Vim 教程熟悉了 Vim 的基本用法。&lt;/p>
&lt;h1 id="vim-教程的内容概要">Vim 教程的内容概要&lt;/h1>
&lt;p>上节课我给你留的作业，就是花时间学习一下 Vim 教程，下面我们就来检验一下。只有你自己先对照着教程操作了一遍，今天我再带着你过一遍里面的基本概念和配置，你才能查漏补缺，发现自己遇到的问题，明确自己需要多加练习的地方。&lt;/p>
&lt;p>好，现在请查看下面的键盘图。简单说明一下，这张图上展示了一个键盘。图中的&amp;quot;•&amp;ldquo;表示，单个字母不是完整的命令，必须再有进一步的输入。比如，单个&amp;quot;g&amp;quot;没有意义，而&amp;quot;gg&amp;quot;表示跳转到文件开头。（对于命令后面明确跟一个动作的，如&amp;quot;c&amp;rdquo;，我们不使用&amp;quot;•&amp;quot;。）一个键最多有三排内容：最底下是直接按键的结果，中间是按下 Shift 的结果（变大写），上面偏右的小字是按下 Ctrl 的结果。我们还用了一些特殊符号来表示操作的位置，如果你已经了解了这些命令的功能，你也自然就明白它们的意义了。&lt;br>
&lt;img src="https://static001.geekbang.org/resource/image/76/a1/76910d1a16ed737c42078dd1255124a1.png" alt="">&lt;br>
Vim 命令速查（教程版）&lt;/p>
&lt;p>请检查一下有颜色的那些键，看看你是否有任何不熟悉的地方。如果看下来有让你感到陌生的内容，请复习 Vim 教程。&lt;/p>
&lt;p>这张图里没有写出 Vim 的命令行命令。你现在应该已经掌握了以下这些：&lt;/p>
&lt;ul>
&lt;li>&amp;ldquo;:q!&amp;quot;：退出 Vim&lt;/li>
&lt;li>&amp;ldquo;:wq&amp;rdquo;：存盘退出&lt;/li>
&lt;li>&amp;ldquo;:s&amp;rdquo;：执行替换&lt;/li>
&lt;li>&amp;ldquo;:!&amp;quot;：执行外部命令&lt;/li>
&lt;li>&amp;ldquo;:edit&amp;rdquo;（一般缩写为 &amp;ldquo;:e&amp;rdquo;）：编辑文件&lt;/li>
&lt;li>&amp;ldquo;:w&amp;rdquo;：写文件&lt;/li>
&lt;li>&amp;ldquo;:r&amp;rdquo;：读文件&lt;/li>
&lt;li>&amp;ldquo;:help&amp;rdquo;：查看帮助&lt;/li>
&lt;li>使用键 Ctrl-D 和 Tab 来进行命令行补全&lt;/li>
&lt;/ul>
&lt;p>同样，如果你发现上面列举的命令有你不熟悉的，也请重新打开 Vim 教程复习一下&amp;mdash;&amp;mdash;这些属于 Vim 的最基本功能，一定要能熟练运用才行。&lt;/p>
&lt;h1 id="vim-的模式">Vim 的模式&lt;/h1>
&lt;p>接下来我们进入本讲的正题，讲述 Vim 的四种主要模式、键描述的体例和 Vim 需要的基本配置选项。掌握了这些内容之后，我们就能应对基本的编辑任务了。下面我们一一来看。&lt;/p>
&lt;p>Vim 最特别的地方就是它的模式了。与其他大部分编辑器不同，进入 Vim 后，缺省状态下键入的字符并不会插入到所编辑的文件之中。 Vim 的模式（mode，可以简单地理解为&amp;quot;状态&amp;rdquo;）是它的麻烦所在，但同时也是它的威力所在。&lt;/p>
&lt;p>我们需要知道，Vim 有以下四种主要模式:&lt;/p>
&lt;ul>
&lt;li>正常（normal）模式（也称为普通模式），缺省的编辑模式；如果不加特殊说明，一般提到的命令都直接在正常模式下输入；在任何其他模式中，都可以通过键盘上的 Esc 键回到正常模式。&lt;/li>
&lt;li>插入（insert）模式，输入文本时使用；比如在正常模式下键入 i（insert）或 a（append）即可进入插入模式。&lt;/li>
&lt;li>可视（visual）模式，用于选定文本块；教程中已经提到可以用键 v（小写）来按字符选定，Vim 里也提供其他不同的选定方法，包括按行和按列块。&lt;/li>
&lt;li>命令行（command-line）模式，用于执行较长、较复杂的命令；在正常模式下键入冒号（:）即可进入该模式；使用斜杠（/）和问号（?）开始搜索也算作命令行模式。命令行模式下的命令要输入回车键（Enter）才算完成。&lt;/li>
&lt;/ul>
&lt;p>此外，Vim 也有个选择（select）模式，与普通的 Windows 编辑器行为较为接近，选择内容后再输入任何内容，将会替换选择的内容。在以可视模式和选择模式之一选定文本块之后，可以使用 Ctrl-G 切换到另一模式。这个模式主要是为了模拟 Windows 编辑器的行为，并不是 Vim 的主要用法，使用它反而会给 Vim 里的自动化带来麻烦，所以我们也就不多作介绍了。&lt;/p>
&lt;p>关于 Vim 的模式，我们重点掌握正常模式就可以了，刚刚也说过，Vim 里的大部分操作会在正常模式下完成。如果你做编辑工作时有超过几秒的停顿，就应当考虑按下 Esc 键，回到正常模式。记住，正常模式就是正常情况下你应当处于的模式。😄&lt;/p>
&lt;h1 id="vim-的键描述体例">Vim 的键描述体例&lt;/h1>
&lt;p>清楚了 Vim 模式之后，我们来对 Vim 里的按键作一下清晰的体例描述，毕竟，Vim 里的键真的有点多。&lt;/p>
&lt;p>从现在开始，我会使用 Vim 里的标准键描述方式来讲解。根据 Vim 的一般习惯，我们使用尖括号来描述特殊的输入序列。下面我会提供一个列表，给出常用键的表示方式及在动图中的显示方式。这部分内容不需要记住，你用的时候作为参考就行。&lt;/p>
&lt;ul>
&lt;li>&amp;lt;Esc&amp;gt; 表示 Esc 键；显示为&amp;quot;⎋&amp;rdquo;&lt;/li>
&lt;li>&amp;lt;CR&amp;gt; 表示回车键；显示为&amp;quot;↩&amp;quot;&lt;/li>
&lt;li>&amp;lt;Space&amp;gt; 表示空格键；显示为&amp;quot;␣&amp;quot;&lt;/li>
&lt;li>&amp;lt;Tab&amp;gt; 表示 Tab 键；显示为&amp;quot;⇥&amp;quot;&lt;/li>
&lt;li>&amp;lt;BS&amp;gt; 表示退格键；显示为&amp;quot;⌫&amp;quot;&lt;/li>
&lt;li>&amp;lt;Del&amp;gt; 表示删除键；显示为&amp;quot;⌦&amp;quot;&lt;/li>
&lt;li>&amp;lt;lt&amp;gt; 表示 &amp;lt; 键；显示为&amp;quot;&amp;lt;&amp;quot;&lt;/li>
&lt;li>&amp;lt;Up&amp;gt; 表示光标上移键；显示为&amp;quot;⇡&amp;quot;&lt;/li>
&lt;li>&amp;lt;Down&amp;gt; 表示光标下移键；显示为&amp;quot;⇣&amp;quot;&lt;/li>
&lt;li>&amp;lt;Left&amp;gt; 表示光标左移键；显示为&amp;quot;⇠&amp;quot;&lt;/li>
&lt;li>&amp;lt;Right&amp;gt; 表示光标右移键；显示为&amp;quot;⇢&amp;quot;&lt;/li>
&lt;li>&amp;lt;PageUp&amp;gt; 表示 Page Up 键；显示为&amp;quot;⇞&amp;quot;&lt;/li>
&lt;li>&amp;lt;PageDown&amp;gt; 表示 Page Down 键；显示为&amp;quot;⇟&amp;quot;&lt;/li>
&lt;li>&amp;lt;Home&amp;gt; 表示 Home 键；显示为&amp;quot;↖&amp;quot;&lt;/li>
&lt;li>&amp;lt;End&amp;gt; 表示 End 键；显示为&amp;quot;↘&amp;quot;&lt;/li>
&lt;li>&amp;lt;F1&amp;gt; - &amp;lt;F12&amp;gt; 表示功能键 1 到 12；显示为&amp;quot;F1&amp;quot;到&amp;quot;F12&amp;quot;&lt;/li>
&lt;li>&amp;lt;S-&amp;hellip;&amp;gt; Shift 组合键；显示为&amp;quot;⇧&amp;quot;（较少使用，因为我们需要写 ! 而不是 &amp;lt;S-1&amp;gt;；和特殊键组合时仍然有用）&lt;/li>
&lt;li>&amp;lt;C-&amp;hellip;&amp;gt; Control 组合键；显示为&amp;quot;⌃&amp;quot;&lt;/li>
&lt;li>&amp;lt;M-&amp;hellip;&amp;gt; Alt 组合键；显示为&amp;quot;⌥&amp;quot;（对于大部分用户，它的原始键名 Meta 应该只具有历史意义）&lt;/li>
&lt;li>&amp;lt;D-&amp;hellip;&amp;gt; Command 组合键；显示为&amp;quot;⌘&amp;quot;（Mac 键盘）&lt;/li>
&lt;/ul>
&lt;p>现在回到前面的模式部分，我们提到的 Esc、Enter、v、V 和 Ctrl-V，按我们现在的描述惯例，以后就会写成 &amp;lt;Esc&amp;gt;、&amp;lt;CR&amp;gt;、v、V 和 &amp;lt;C-V&amp;gt;。这也是以后在 Vim 里对键进行重映射的写法&amp;mdash;&amp;mdash;如果你还不了解重映射是什么也没关系，我们很快就会讨论到。&lt;/p>
&lt;p>这里我要强调一下，对&amp;quot;&amp;lt;&amp;ldquo;的特殊解释仅在描述输入时生效。在描述命令行和代码时，我们写&amp;rdquo;&amp;lt;CR&amp;gt;&amp;ldquo;仍表示四个字符，而非回车键。特别是，如果我们描述的命令行首是&amp;rdquo;:&amp;quot;，表示这是一个输入 : 开始的 Vim 命令行模式命令（以回车键结束）；如果行首是&amp;quot;/&amp;ldquo;或&amp;rdquo;?&amp;quot;，表示这是一个输入 / 或 ? 开始的搜索命令（以回车键结束）；如果行首是&amp;quot;$&amp;quot;，表示这是一个在 shell 命令行上输入的命令（以回车键结束），&amp;quot;$&amp;quot;（和后面的空格）不是命令的一部分，通常后续行也不是命令的一部分，除非行尾有&amp;quot;\&amp;ldquo;或&amp;rdquo;^&amp;ldquo;字符，或行首有&amp;rdquo;$&amp;ldquo;字符。&lt;/p>
&lt;p>也就是说，下面的命令是在 Vim 里输入&amp;rdquo;:set ft?&amp;lt;CR&amp;gt;&amp;quot;（用来显示当前编辑文件的文件类型）：&lt;/p>
&lt;pre tabindex="0">&lt;code>:set ft?
&lt;/code>&lt;/pre>&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/41/81/411b4byyfbd7717f2b52246ccyy5b481.gif" alt="">&lt;br>
Vim 命令示例&lt;/p>
&lt;p>下面的命令则是在 shell 里输入&amp;quot;which vim&amp;lt;CR&amp;gt;&amp;quot;（用来检查 vim 命令的位置）：&lt;/p>
&lt;pre tabindex="0">&lt;code>$ which vim
/usr/bin/vim
&lt;/code>&lt;/pre>&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/80/f3/80c1875197457b86f94f1216e334dcf3.gif" alt="">&lt;br>
Shell 命令示例&lt;/p>
&lt;p>此外，当我用&amp;quot;:help&amp;quot;描述帮助命令时，你不仅可以在 Vim 里输入这个命令来得到帮助，也可以点击这个帮助的链接，直接在线查看相应的中文帮助页面。&lt;br>
&lt;img src="https://static001.geekbang.org/resource/image/f5/cc/f58469ab7dbf281bb72896a7a7d8e0cc.jpeg" alt="">&lt;br>
Vim 的内置帮助功能&lt;/p>
&lt;p>这节内容不需要死记。建议使用&amp;quot;收藏&amp;quot;功能，这样，你可以在以后碰到不认识的符号标记的时候，返回来查看这一节的内容。&lt;/p>
&lt;h1 id="vim-的选项和配置">Vim 的选项和配置&lt;/h1>
&lt;p>了解了 Vim 模式和键描述，我们对 Vim 的认识又多了一些，第一步的学习成就达成。要想更好地使用 Vim，下一个关键点就是配置了，接下来我就带你看看 Vim 配置都有哪些需要注意的点。&lt;/p>
&lt;p>作为一个可以越用越顺手的应用程序，Vim 是需要配置的。我们才刚开始学习，所以目前我们的配置文件是相当简单的，但随着课程的进展和你使用 Vim 越来越多，你的 Vim 配置文件必然会越变越复杂。我们今天就先来做一些初步的讨论，看看能实际使用的一个最基本 Vim 配置文件是什么样子。&lt;/p>
&lt;p>我们上节课已经讨论过，根据 Unix 下的惯例，Vim 的配置文件放在用户的主目录下，文件名通常是 .vimrc；而它在 Windows 下名字是 _vimrc。我们前面给出最基本的配置文件是这个样子的：&lt;/p>
&lt;pre tabindex="0">&lt;code>set enc=utf-8
set nocompatible
source $VIMRUNTIME/vimrc_example.vim
&lt;/code>&lt;/pre>&lt;p>如果你熟悉 shell 语法，你肯定能看到不少熟悉的影子在里面。这三行完成了下列功能：&lt;/p>
&lt;ul>
&lt;li>设置编辑文件的内码是 UTF-8（非所有平台缺省，但为编辑多语言文件所必需）&lt;/li>
&lt;li>设置 Vim 不需要和 vi 兼容（仅为万一起见，目前大部分情况下这是缺省情况）&lt;/li>
&lt;li>导入 Vim 的示例配置（这会打开一些有用的选项，如语法加亮、搜索加亮、命令历史、记住上次的文件位置，等等）&lt;/li>
&lt;/ul>
&lt;p>对于现代 Unix 系统上的 Vim 8，实际上只需要最后一句就足够了。对于现代 Windows 系统上的 Vim 8，中间的这句 set nocompatible 也可以删除。如果你在较老的 Vim 版本上进行配置，那么把这三行全放进去会比较安全。&lt;/p>
&lt;p>接下来，我会讲一些基本的配置项，保证你的日常工作流顺畅。它们是：备份和跨会话撤销、鼠标支持、中文支持及图形界面的字体支持。除了字体支持主要牵涉到美观性，其他三项都是对编辑至关重要的基本功能。我们一一来看。&lt;/p>
&lt;h1 id="备份和撤销文件">备份和撤销文件&lt;/h1>
&lt;p>上面的基本设置会产生一个有人喜欢、但也有很多人感到困惑的结果：你修改文件时会出现结尾为&amp;quot;~&amp;ldquo;的文件，有文件名后面直接加&amp;rdquo;~&amp;ldquo;的，还有前面加&amp;rdquo;.&amp;ldquo;后面加&amp;rdquo;.un~&amp;ldquo;的。这是因为在示例配置里，Vim 自动设置了下面两个选项：&lt;/p>
&lt;pre tabindex="0">&lt;code>set backup
set undofile
&lt;/code>&lt;/pre>&lt;p>前一个选项使得我们每次编辑会保留上一次的备份文件，后一个选项使得 Vim 在重新打开一个文件时，仍然能够撤销之前的编辑（undo），这就会产生一个保留编辑历史的&amp;quot;撤销文件&amp;rdquo;（undofile）了。&lt;br>
&lt;img src="https://static001.geekbang.org/resource/image/a2/5e/a2ae45ebdf188cfbe11e9dfd0fb1245e.gif" alt="">&lt;br>
有撤销文件时，再次打开文件时仍然可以撤销上次的编辑&lt;/p>
&lt;p>我的通常做法是，不产生备份文件，但保留跨会话撤销编辑的能力；因为有了撤销文件，备份其实也就没有必要了。同时，把撤销文件放在用户个人的特定目录下，既保证了安全，又免去了其他目录下出现不必要文件的麻烦。&lt;/p>
&lt;p>要达到这个目的，我在 Linux/macOS 下会这么写：&lt;/p>
&lt;pre tabindex="0">&lt;code>set nobackup
set undodir=~/.vim/undodir
&lt;/code>&lt;/pre>&lt;p>在 Windows 下这么写：&lt;/p>
&lt;pre tabindex="0">&lt;code>set nobackup
set undodir=~\vimfiles\undodir
&lt;/code>&lt;/pre>&lt;p>无论哪种环境，你都需要创建这个目录。我们可以用下面的命令来让 Vim 在启动时自动创建这个目录：&lt;/p>
&lt;pre tabindex="0">&lt;code>if !isdirectory(&amp;amp;undodir)
call mkdir(&amp;amp;undodir, &amp;#39;p&amp;#39;, 0700)
endif
&lt;/code>&lt;/pre>&lt;p>如果我告诉你， &amp;amp;undodir 代表 undodir 这个选项的值，那么其他代码的基本作用，相信你也一定能看出来了吧？我们暂时就不做进一步分析了。如果你好奇的话，可以提前看一下下面各项的 Vim 帮助文档：&lt;/p>
&lt;ul>
&lt;li>:help isdirectory()&lt;/li>
&lt;li>:help mkdir()&lt;/li>
&lt;li>:help :call&lt;/li>
&lt;/ul>
&lt;p>这个跨会话撤销的能力，我还真不知道其他哪个编辑器也有。更妙的是，Vim 还有撤销树的概念，可以帮助你回到任一历史状态。这个我们以后会和相关的插件一起讨论。&lt;/p>
&lt;h1 id="鼠标支持">鼠标支持&lt;/h1>
&lt;p>我不知道你会不会像某些资深 Vim 用户一样，只用键盘不用鼠标。我反正是做不到的，也没有动力去那样做&amp;mdash;&amp;mdash;毕竟，浪费计算机界一项伟大的发明并不那么有必要😂。手一直在键盘上的本位排（home row）打字当然会更快，但一个程序员看代码的时间比写代码的时间要多得多，而在非线性的跳转任务上，鼠标比键盘更加快，也更加有效。&lt;/p>
&lt;p>在 Vim 的终端使用场景下，鼠标的选择有一定的歧义：你希望是使用 Vim 的可视模式选择内容，并且只能在 Vim 里使用呢，还是产生 Vim 外的操作系统的文本选择，用于跟其他应用程序的交互呢？这是一个基本的使用问题，两种情况都可能发生，都需要照顾。&lt;/p>
&lt;p>如果你使用 xterm 兼容终端的话，通常的建议是：&lt;/p>
&lt;ul>
&lt;li>在不按下修饰键时，鼠标选择产生 Vim 内部的可视选择。&lt;/li>
&lt;li>在按下 Shift 时，鼠标选择产生操作系统的文本选择。&lt;/li>
&lt;/ul>
&lt;p>对于不兼容 xterm、不支持对 Shift 键做这样特殊处理的终端，我们一般会采用一种&amp;quot;绕过&amp;quot;方式，让 Vim 在某种情况下暂时不接管鼠标事件。通常的选择是在命令行模式下不使用鼠标。下面，我们就分这两种情况来配置。&lt;/p>
&lt;p>虽然最新的 Vim 缺省配置文件（示例配置文件会包含缺省配置），在大部分情况下已经可以自动设置合适的鼠标选项了，不过为照顾我们课程的三种不同平台，我们还是手工设置一下：&lt;/p>
&lt;pre tabindex="0">&lt;code>if has(&amp;#39;mouse&amp;#39;)
if has(&amp;#39;gui_running&amp;#39;) || (&amp;amp;term =~ &amp;#39;xterm&amp;#39; &amp;amp;&amp;amp; !has(&amp;#39;mac&amp;#39;))
set mouse=a
else
set mouse=nvi
endif
endif
&lt;/code>&lt;/pre>&lt;p>上面代码说的是，如果 Vim 有鼠标支持的话，那在以下任一条件满足时：&lt;/p>
&lt;ul>
&lt;li>图形界面正在运行&lt;/li>
&lt;li>终端是 xterm 兼容，并且不是 Mac（Mac 上的终端声称自己是 xterm，但行为并不完全相同）&lt;/li>
&lt;/ul>
&lt;p>我们将启用完全的鼠标支持（mouse=a）。特别是，此时鼠标拖拽就会在 Vim 里使用可视模式选择内容（只能在 Vim 里使用）。而当用户按下 Shift 键时，窗口系统接管鼠标事件，用户可以使用鼠标复制 Vim 窗口里的内容供其他应用程序使用。&lt;/p>
&lt;p>否则（非图形界面的的终端，且终端类型不是 xterm），就只在正常模式（n）、可视模式（v）、插入模式（i）中使用鼠标。这意味着，当用户按下 : 键进入命令行模式时，Vim 将不对鼠标进行响应，这时，用户就可以使用鼠标复制 Vim 窗口里的内容到其他应用程序里去了。&lt;br>
&lt;img src="https://static001.geekbang.org/resource/image/e6/df/e6d582405e3c7e4cbf26f3821yy242df.gif" alt="">&lt;br>
可视模式的选取和按&amp;quot;:&amp;ldquo;后的选取&lt;/p>
&lt;p>非 xterm 的鼠标支持在 macOS 和 Windows 下都有效。但在 Windows 下需要注意的一点是，如果使用非图形界面的 Vim 的话，应当在命令提示符（Command Prompt）的属性里关闭&amp;quot;快速编辑模式&amp;rdquo;（QuickEdit Mode），否则 Vim 在运行时将无法对鼠标事件进行响应。&lt;/p>
&lt;p>鉴于命令提示符的行为有很多怪异和不一致之处，强烈建议你在 Windows 下，要么使用图形界面的 Vim，要么使用 Cygwin/MSYS2 里、运行在 mintty 下的 Vim。&lt;/p>
&lt;h1 id="中文支持">中文支持&lt;/h1>
&lt;p>接下来我和你讲讲中文支持的问题。如果你一直在 UTF-8 下使用中文的话，那这一小节的内容可以跳过。对于大部分在 Unix 下工作的人员，应该是这样的情况。而如果你在 Windows 上工作，或者有需要跟别人交换 GB2312、GBK、GB18030 编码的文本文件，那这部分的内容还是需要看一下的。&lt;/p>
&lt;p>完整的 Unicode 历史和原理可以讲上整整一讲，但从实用的角度，我们就简化成下面几条吧：&lt;/p>
&lt;ul>
&lt;li>整个世界基本上在向 UTF-8 编码靠拢。&lt;/li>
&lt;li>微软由于历史原因，内部使用 UTF-16；UTF-16 可以跟 UTF-8 无损转换。&lt;/li>
&lt;li>GB2312、GBK、GB18030 是一系列向后兼容的中文标准编码方式，GB2312 编码的文件是合法的 GBK 文件，GBK 编码的文件是合法的 GB18030 文件。但除了 GB18030，都不能做到跟 UTF-8 无损转换；目前非 UTF-8 的简体中文文本基本上都用 GBK/GB18030 编码（繁体中文文本则以 Big5 居多）。鉴于 GB18030 是国家标准，其他两种编码也和 GB18030 兼容，我们就重点讲如何在 Vim 中支持 GB18030 了。&lt;/li>
&lt;/ul>
&lt;p>举一个具体的例子，&amp;ldquo;你好😄&amp;quot;这个字符串，在 UTF-8 编码下是下面 10 个字节（我按字符进行了分组）：&lt;/p>
&lt;p>e4bda0 e5a5bd f09f9884&lt;/p>
&lt;p>如果使用 GB18030 编码（GB2312/GBK 不能支持表情字符）的话，会编码成 8 个字节：&lt;/p>
&lt;p>c4e3 bac3 9439fd30&lt;/p>
&lt;p>这么看起来，GB18030 处理中文在存储效率上是优势的。但它也有缺点：&lt;/p>
&lt;ul>
&lt;li>GBK 外的 Unicode 字符一般需要四字节编码（非中文情况会劣化）&lt;/li>
&lt;li>GBK 外的 Unicode 字符跟 Unicode 码点需要查表才能转换（UTF-8 则可以用非常简单的条件判断、移位、与、或操作来转换）&lt;/li>
&lt;li>一旦出现文件中有单字节发生损毁，后续的所有中文字符都可能发生紊乱（而 UTF-8 可以在一个字符之后恢复）&lt;/li>
&lt;/ul>
&lt;p>因此，GB18030 在国际化的软件中不会作为内码来使用，只会是读取 / 写入文件时使用的转换编码。我们要让 Vim 支持 GB18030 也同样是如此。由于 UTF-8 编码是有明显规律的，并非任意文件都能成功地当成 UTF-8 来解码，我们一般使用的解码顺序是：&lt;/p>
&lt;ul>
&lt;li>首先，检查文件是不是有 Unicode 的 BOM（字节顺序标记）字符，有的话按照 BOM 字符来转换文件内容。&lt;/li>
&lt;li>其次，检查文件能不能当作 UTF-8 来解码；如果可以，就当作 UTF-8 来解释。&lt;/li>
&lt;li>否则，尝试用 GB18030 来解码；如果能成功，就当作 GB18030 来转换文件内容。&lt;/li>
&lt;li>最后，如果上面的解码都不成功，就按 Latin1 字符集来解码；由于这是单字节的编码，转换必定成功。&lt;/li>
&lt;/ul>
&lt;p>事实上，Vim 缺省差不多就是按这样的顺序，但第三步使用何种编码跟系统配置有关。如果你明确需要处理中文，那在配置文件里最好明确写下下面的选项设定：&lt;/p>
&lt;pre tabindex="0">&lt;code>set fileencodings=ucs-bom,utf-8,gb18030,latin1
&lt;/code>&lt;/pre>&lt;h1 id="图形界面的字体配置">图形界面的字体配置&lt;/h1>
&lt;p>图形界面的 Vim 可以自行配置使用的字体，但在大部分环境里，这只是起到美化作用，而非必需项。不过，对于高分辨率屏幕的 Windows，这是一个必需项：Vim 在 Windows 下缺省使用的不是 TrueType 字体，不进行配置的话，字体会小得没法看。&lt;br>
&lt;img src="https://static001.geekbang.org/resource/image/0a/98/0a8f9854d5d4ca317b10e9b1753f3c98.png" alt="">&lt;br>
高分辨率屏下的 Windows 图形界面 Vim&lt;/p>
&lt;p>在 Windows 的缺省字体里，一般而言，Consolas 和 Courier New 还比较合适。以 Courier New 为例，在 &lt;em>vimrc 里可以这样配置（Windows 上的基本写法是字体名称加冒号、&amp;ldquo;h&amp;quot;加字号；用&amp;rdquo;&lt;/em>&amp;ldquo;取代空格，否则空格需要用&amp;rdquo;\&amp;ldquo;转义）：&lt;/p>
&lt;pre tabindex="0">&lt;code>if has(&amp;#39;gui_running&amp;#39;)
set guifont=Courier_New:h10
endif
&lt;/code>&lt;/pre>&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/b9/82/b9c3a28656a45260a94b4099eab96282.png" alt="">&lt;br>
设置了 10 磅 Consolas 字体的 Vim&lt;/p>
&lt;p>字体名称如何写是件平台相关的事（可参见帮助文档&amp;rdquo;:help gui-font&amp;rdquo;）。如果你不确定怎么写出你需要的字体配置，或者你怎么写都写不对的话，可以先使用图形界面的菜单来选择（通常是&amp;quot;编辑 &amp;gt; 选择字体&amp;quot;；在 MacVim 里是&amp;quot;Edit &amp;gt; Font &amp;gt; Show Fonts&amp;quot;），然后使用命令&amp;quot;:set guifont?&amp;ldquo;来查看。&lt;/p>
&lt;p>注意，Vim 在设置选项时，空格需要用&amp;rdquo;\&amp;ldquo;进行转义。比如，如果我们要在 Ubuntu 下把字体设成 10 磅的 DejaVu Sans Mono，就需要写：&lt;/p>
&lt;pre tabindex="0">&lt;code> &amp;#34; Linux 和 Windows 不同，不能用 &amp;#39;_&amp;#39; 取代空格
set guifont=DejaVu\ Sans\ Mono\ 10
&lt;/code>&lt;/pre>&lt;p>此外，宽字符字体（对我们来讲，就是中文字体了）是可以单独配置的。这可能就更是一件仁者见仁、智者见智的事了。对于纯中文的操作系统，这一般反而是不需要配置的；但如果你的语言设定里，中文不是第一选择的话，就有可能在显示中文时出现操作系统误用日文字体的情况。这时你会想要手工选择一个中文字体，比如在 Ubuntu 下，可以用：&lt;/p>
&lt;pre tabindex="0">&lt;code> set guifontwide=Noto\ Sans\ Mono\ CJK\ SC\ 11
&lt;/code>&lt;/pre>&lt;p>注意，在不同的中英文字体搭配时，并不需要字号相同。事实上，在 Windows 和 Linux 上我通常都是使用不同字号的中英文字体的。&lt;br>
&lt;img src="https://static001.geekbang.org/resource/image/07/b5/0794053ac4fa28bf9595bfee8a202cb5.gif" alt="">&lt;br>
Ubuntu 下的 gvim 设置中文字体&lt;/p>
&lt;p>在上面的动图中，你可以观察到设了中文字体之后，不仅中文字变大，更美观了，&amp;ldquo;将&amp;rdquo;、&amp;ldquo;适&amp;rdquo;、&amp;ldquo;关&amp;rdquo;、&amp;ldquo;复&amp;rdquo;、&amp;ldquo;启&amp;quot;等字的字形也同时发生了变化。&lt;/p>
&lt;p>由于字体在各平台上差异较大，字体配置我就不写到 Vim 的参考配置中去了，只把如何选择和配置的方法写出来供你参考。&lt;/p>
&lt;h1 id="内容小结">内容小结&lt;/h1>
&lt;p>好了，这一讲我就讲到这里，我们来做个内容小结。&lt;/p>
&lt;p>今天我给出了一张键盘图，带你复习了 Vim 教程的内容，这里我要再强调一遍，这部分的内容如果你还有不熟悉的，一定要再去学习一下 Vim 教程，这段时间我们一定要多花点时间和精力来练习，把这一步跨过去。&lt;/p>
&lt;p>掌握了 Vim 教程里的基础信息还远远不够，我们还得了解 Vim 的四种主要模式，你只要记住最重要的就是正常模式就可以了。&lt;/p>
&lt;p>最后我带你学习了 Vim 的几个基本配置选项，包括对撤销、鼠标、中文和字体的支持，来满足最基本的编辑需要。最终的 Vim 配置文件可以在 GitHub 上找到：&lt;/p>
&lt;p>&lt;a href="https://github.com/adah1972/geek_time_vim">https://github.com/adah1972/geek_time_vim&lt;/a>&lt;/p>
&lt;p>关于这个配置文件，我这里做个备注说明：主（master）分支可以用在类 Unix 平台上，windows 分支则用在 Windows 上。适用于今天这一讲的内容标签是 l2-unix 和 l2-windows：你可以用 git checkout l2-unix 或 git checkout l2-windows 来得到相应平台对应本讲的配置文件。&lt;/p>
&lt;p>好了，掌握了今天的内容，你就可以用 Vim 做最基本的编辑了。&lt;/p>
&lt;h1 id="课后练习">课后练习&lt;/h1>
&lt;p>请使用本讲的配置文件，并尝试以下操作：&lt;/p>
&lt;ul>
&lt;li>退出 Vim 然后重新打开文件，仍然可以撤销上次的编辑。&lt;/li>
&lt;li>使用终端的 Vim，在终端里用鼠标复制 Vim 里的文本到另外一个文本编辑器中（仅 Unix 下，可选）。&lt;/li>
&lt;li>在 Vim 中使用&amp;rdquo;:help&amp;quot;命令（大部分环境下也可以使用 &amp;lt;F1&amp;gt; 功能键），尝试查看命令说明，以及使用键盘和鼠标在帮助主题中跳转。&lt;/li>
&lt;/ul>
&lt;p>如果遇到任何问题，欢迎留言和我讨论。我们下一讲见。&lt;/p></description></item><item><title>极客专栏: 02丨如何制定性能调优策略？</title><link>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98/02%E4%B8%A8%E5%A6%82%E4%BD%95%E5%88%B6%E5%AE%9A%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E7%AD%96%E7%95%A5/</link><pubDate>Fri, 08 Jul 2022 00:00:00 +0000</pubDate><guid>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98/02%E4%B8%A8%E5%A6%82%E4%BD%95%E5%88%B6%E5%AE%9A%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E7%AD%96%E7%95%A5/</guid><description>
&lt;p>你好，我是刘超。&lt;/p>
&lt;p>上一讲，我在介绍性能调优重要性的时候，提到了性能测试。面对日渐复杂的系统，制定合理的性能测试，可以提前发现性能瓶颈，然后有针对性地制定调优策略。总结一下就是&amp;quot;测试 - 分析 - 调优&amp;quot;三步走。&lt;/p>
&lt;p>今天，我们就在这个基础上，好好聊一聊&amp;quot;如何制定系统的性能调优策略&amp;quot;。&lt;/p>
&lt;h2 id="性能测试攻略">性能测试攻略&lt;/h2>
&lt;p>性能测试是提前发现性能瓶颈，保障系统性能稳定的必要措施。下面我先给你介绍两种常用的测试方法，帮助你从点到面地测试系统性能。&lt;/p>
&lt;h3 id="1-微基准性能测试">&lt;strong>1. 微基准性能测试&lt;/strong>&lt;/h3>
&lt;p>微基准性能测试可以精准定位到某个模块或者某个方法的性能问题，特别适合做一个功能模块或者一个方法在不同实现方式下的性能对比。例如，对比一个方法使用同步实现和非同步实现的性能。&lt;/p>
&lt;h3 id="2-宏基准性能测试">&lt;strong>2. 宏基准性能测试&lt;/strong>&lt;/h3>
&lt;p>宏基准性能测试是一个综合测试，需要考虑到测试环境、测试场景和测试目标。&lt;/p>
&lt;p>首先看测试环境，我们需要模拟线上的真实环境。&lt;/p>
&lt;p>然后看测试场景。我们需要确定在测试某个接口时，是否有其他业务接口同时也在平行运行，造成干扰。如果有，请重视，因为你一旦忽视了这种干扰，测试结果就会出现偏差。&lt;/p>
&lt;p>最后看测试目标。我们的性能测试是要有目标的，这里可以通过吞吐量以及响应时间来衡量系统是否达标。不达标，就进行优化；达标，就继续加大测试的并发数，探底接口的 TPS（最大每秒事务处理量），这样做，可以深入了解到接口的性能。除了测试接口的吞吐量和响应时间以外，我们还需要循环测试可能导致性能问题的接口，观察各个服务器的 CPU、内存以及 I/O 使用率的变化。&lt;/p>
&lt;p>以上就是两种测试方法的详解。其中值得注意的是，性能测试存在干扰因子，会使测试结果不准确。所以，&lt;strong>我们在做性能测试时，还要注意一些问题。&lt;/strong>&lt;/p>
&lt;h3 id="1-热身问题">&lt;strong>1. 热身问题&lt;/strong>&lt;/h3>
&lt;p>当我们做性能测试时，我们的系统会运行得越来越快，后面的访问速度要比我们第一次访问的速度快上几倍。这是怎么回事呢？&lt;/p>
&lt;p>在 Java 编程语言和环境中，.java 文件编译成为 .class 文件后，机器还是无法直接运行 .class 文件中的字节码，需要通过解释器将字节码转换成本地机器码才能运行。为了节约内存和执行效率，代码最初被执行时，解释器会率先解释执行这段代码。&lt;/p>
&lt;p>随着代码被执行的次数增多，当虚拟机发现某个方法或代码块运行得特别频繁时，就会把这些代码认定为热点代码（Hot Spot Code）。为了提高热点代码的执行效率，在运行时，虚拟机将会通过即时编译器（JIT compiler，just-in-time compiler）把这些代码编译成与本地平台相关的机器码，并进行各层次的优化，然后存储在内存中，之后每次运行代码时，直接从内存中获取即可。&lt;/p>
&lt;p>所以在刚开始运行的阶段，虚拟机会花费很长的时间来全面优化代码，后面就能以最高性能执行了。&lt;/p>
&lt;p>这就是热身过程，如果在进行性能测试时，热身时间过长，就会导致第一次访问速度过慢，你就可以考虑先优化，再进行测试。&lt;/p>
&lt;h3 id="2-性能测试结果不稳定">&lt;strong>2. 性能测试结果不稳定&lt;/strong>&lt;/h3>
&lt;p>我们在做性能测试时发现，每次测试处理的数据集都是一样的，但测试结果却有差异。这是因为测试时，伴随着很多不稳定因素，比如机器其他进程的影响、网络波动以及每个阶段 JVM 垃圾回收的不同等等。&lt;/p>
&lt;p>我们可以通过多次测试，将测试结果求平均，或者统计一个曲线图，只要保证我们的平均值是在合理范围之内，而且波动不是很大，这种情况下，性能测试就是通过的。&lt;/p>
&lt;h3 id="3-多-jvm-情况下的影响">&lt;strong>3. 多 JVM 情况下的影响&lt;/strong>&lt;/h3>
&lt;p>如果我们的服务器有多个 Java 应用服务，部署在不同的 Tomcat 下，这就意味着我们的服务器会有多个 JVM。任意一个 JVM 都拥有整个系统的资源使用权。如果一台机器上只部署单独的一个 JVM，在做性能测试时，测试结果很好，或者你调优的效果很好，但在一台机器多个 JVM 的情况下就不一定了。所以我们应该尽量避免线上环境中一台机器部署多个 JVM 的情况。&lt;/p>
&lt;h2 id="合理分析结果制定调优策略">合理分析结果，制定调优策略&lt;/h2>
&lt;p>这里我将&amp;quot;三步走&amp;quot;中的分析和调优结合在一起讲。&lt;/p>
&lt;p>我们在完成性能测试之后，需要输出一份性能测试报告，帮我们分析系统性能测试的情况。其中测试结果需要包含测试接口的平均、最大和最小吞吐量，响应时间，服务器的 CPU、内存、I/O、网络 IO 使用率，JVM 的 GC 频率等。&lt;/p>
&lt;p>通过观察这些调优标准，可以发现性能瓶颈，我们再通过自下而上的方式分析查找问题。首先从操作系统层面，查看系统的 CPU、内存、I/O、网络的使用率是否存在异常，再通过命令查找异常日志，最后通过分析日志，找到导致瓶颈的原因；还可以从 Java 应用的 JVM 层面，查看 JVM 的垃圾回收频率以及内存分配情况是否存在异常，分析日志，找到导致瓶颈的原因。&lt;/p>
&lt;p>如果系统和 JVM 层面都没有出现异常情况，我们可以查看应用服务业务层是否存在性能瓶颈，例如 Java 编程的问题、读写数据瓶颈等等。&lt;/p>
&lt;p>分析查找问题是一个复杂而又细致的过程，某个性能问题可能是一个原因导致的，也可能是几个原因共同导致的结果。我们分析查找问题可以采用自下而上的方式，而我们解决系统性能问题，则可以采用自上而下的方式逐级优化。下面我来介绍下从应用层到操作系统层的几种调优策略。&lt;/p>
&lt;h3 id="1-优化代码">&lt;strong>1. 优化代码&lt;/strong>&lt;/h3>
&lt;p>应用层的问题代码往往会因为耗尽系统资源而暴露出来。例如，我们某段代码导致内存溢出，往往是将 JVM 中的内存用完了，这个时候系统的内存资源消耗殆尽了，同时也会引发 JVM 频繁地发生垃圾回收，导致 CPU 100% 以上居高不下，这个时候又消耗了系统的 CPU 资源。&lt;/p>
&lt;p>还有一些是非问题代码导致的性能问题，这种往往是比较难发现的，需要依靠我们的经验来优化。例如，我们经常使用的 LinkedList 集合，如果使用 for 循环遍历该容器，将大大降低读的效率，但这种效率的降低很难导致系统性能参数异常。&lt;/p>
&lt;p>这时有经验的同学，就会改用 Iterator （迭代器）迭代循环该集合，这是因为 LinkedList 是链表实现的，如果使用 for 循环获取元素，在每次循环获取元素时，都会去遍历一次 List，这样会降低读的效率。&lt;/p>
&lt;h3 id="2-优化设计">&lt;strong>2. 优化设计&lt;/strong>&lt;/h3>
&lt;p>面向对象有很多设计模式，可以帮助我们优化业务层以及中间件层的代码设计。优化后，不仅可以精简代码，还能提高整体性能。例如，单例模式在频繁调用创建对象的场景中，可以共享一个创建对象，这样可以减少频繁地创建和销毁对象所带来的性能消耗。&lt;/p>
&lt;h3 id="3-优化算法">&lt;strong>3. 优化算法&lt;/strong>&lt;/h3>
&lt;p>好的算法可以帮助我们大大地提升系统性能。例如，在不同的场景中，使用合适的查找算法可以降低时间复杂度。&lt;/p>
&lt;h3 id="4-时间换空间">&lt;strong>4. 时间换空间&lt;/strong>&lt;/h3>
&lt;p>有时候系统对查询时的速度并没有很高的要求，反而对存储空间要求苛刻，这个时候我们可以考虑用时间来换取空间。&lt;/p>
&lt;p>例如，我在 03 讲就会详解的用 String 对象的 intern 方法，可以将重复率比较高的数据集存储在常量池，重复使用一个相同的对象，这样可以大大节省内存存储空间。但由于常量池使用的是 HashMap 数据结构类型，如果我们存储数据过多，查询的性能就会下降。所以在这种对存储容量要求比较苛刻，而对查询速度不作要求的场景，我们就可以考虑用时间换空间。&lt;/p>
&lt;h3 id="5-空间换时间">&lt;strong>5. 空间换时间&lt;/strong>&lt;/h3>
&lt;p>这种方法是使用存储空间来提升访问速度。现在很多系统都是使用的 MySQL 数据库，较为常见的分表分库是典型的使用空间换时间的案例。&lt;/p>
&lt;p>因为 MySQL 单表在存储千万数据以上时，读写性能会明显下降，这个时候我们需要将表数据通过某个字段 Hash 值或者其他方式分拆，系统查询数据时，会根据条件的 Hash 值判断找到对应的表，因为表数据量减小了，查询性能也就提升了。&lt;/p>
&lt;h3 id="6-参数调优">&lt;strong>6. 参数调优&lt;/strong>&lt;/h3>
&lt;p>以上都是业务层代码的优化，除此之外，JVM、Web 容器以及操作系统的优化也是非常关键的。&lt;/p>
&lt;p>根据自己的业务场景，合理地设置 JVM 的内存空间以及垃圾回收算法可以提升系统性能。例如，如果我们业务中会创建大量的大对象，我们可以通过设置，将这些大对象直接放进老年代。这样可以减少年轻代频繁发生小的垃圾回收（Minor GC），减少 CPU 占用时间，提升系统性能。&lt;/p>
&lt;p>Web 容器线程池的设置以及 Linux 操作系统的内核参数设置不合理也有可能导致系统性能瓶颈，根据自己的业务场景优化这两部分，可以提升系统性能。&lt;/p>
&lt;h2 id="兜底策略确保系统稳定性">兜底策略，确保系统稳定性&lt;/h2>
&lt;p>上边讲到的所有的性能调优策略，都是提高系统性能的手段，但在互联网飞速发展的时代，产品的用户量是瞬息万变的，无论我们的系统优化得有多好，还是会存在承受极限，所以为了保证系统的稳定性，我们还需要采用一些兜底策略。&lt;/p>
&lt;h3 id="什么是兜底策略">&lt;strong>什么是兜底策略？&lt;/strong>&lt;/h3>
&lt;p>第一，限流，对系统的入口设置最大访问限制。这里可以参考性能测试中探底接口的 TPS 。同时采取熔断措施，友好地返回没有成功的请求。&lt;/p>
&lt;p>第二，实现智能化横向扩容。智能化横向扩容可以保证当访问量超过某一个阈值时，系统可以根据需求自动横向新增服务。&lt;/p>
&lt;p>第三，提前扩容。这种方法通常应用于高并发系统，例如，瞬时抢购业务系统。这是因为横向扩容无法满足大量发生在瞬间的请求，即使成功了，抢购也结束了。&lt;/p>
&lt;p>目前很多公司使用 Docker 容器来部署应用服务。这是因为 Docker 容器是使用 Kubernetes 作为容器管理系统，而 Kubernetes 可以实现智能化横向扩容和提前扩容 Docker 服务。&lt;/p>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>学完这讲，你应该对性能测试以及性能调优有所认识了。我们再通过一张图来回顾下今天的内容。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/f8/b8/f8460bb16b56e8c8897c7cf4c9f99eb8.jpg" alt="">&lt;/p>
&lt;p>我们将性能测试分为微基准性能测试和宏基准性能测试，前者可以精准地调优小单元的业务功能，后者可以结合内外因素，综合模拟线上环境来测试系统性能。两种方法结合，可以更立体地测试系统性能。&lt;/p>
&lt;p>测试结果可以帮助我们制定性能调优策略，调优方法很多，这里就不一一赘述了。但有一个共同点就是，调优策略千变万化，但思路和核心都是一样的，都是从业务调优到编程调优，再到系统调优。&lt;/p>
&lt;p>最后，给你提个醒，任何调优都需要结合场景明确已知问题和性能目标，不能为了调优而调优，以免引入新的 Bug，带来风险和弊端。&lt;/p>
&lt;h2 id="思考题">思考题&lt;/h2>
&lt;p>假设你现在负责一个电商系统，马上就有新品上线了，还要有抢购活动，那么你会将哪些功能做微基准性能测试，哪些功能做宏基准性能测试呢？&lt;/p>
&lt;p>期待在留言区看到你的答案。也欢迎你点击&amp;quot;请朋友读&amp;quot;，把今天的内容分享给身边的朋友，邀请他一起讨论。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/bb/67/bbe343640d6b708832c4133ec53ed967.jpg" alt="unpreview">&lt;/p></description></item><item><title>极客专栏: 02丨网络分层的真实含义是什么？</title><link>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E8%B6%A3%E8%B0%88%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/02%E4%B8%A8%E7%BD%91%E7%BB%9C%E5%88%86%E5%B1%82%E7%9A%84%E7%9C%9F%E5%AE%9E%E5%90%AB%E4%B9%89%E6%98%AF%E4%BB%80%E4%B9%88/</link><pubDate>Fri, 08 Jul 2022 00:00:00 +0000</pubDate><guid>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E8%B6%A3%E8%B0%88%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/02%E4%B8%A8%E7%BD%91%E7%BB%9C%E5%88%86%E5%B1%82%E7%9A%84%E7%9C%9F%E5%AE%9E%E5%90%AB%E4%B9%89%E6%98%AF%E4%BB%80%E4%B9%88/</guid><description>
&lt;p>长时间从事计算机网络相关的工作，我发现，计算机网络有一个显著的特点，就是这是一个不仅需要背诵，而且特别需要将原理烂熟于胸的学科。很多问题看起来懂了，但是就怕往细里问，一问就发现你懂得没有那么透彻。&lt;/p>
&lt;p>我们上一节列了之后要讲的网络协议。这些协议本来没什么稀奇，每一本教科书都会讲，并且都要求你背下来。因为考试会考，面试会问。可以这么说，毕业了去找工作还答不出这类题目的，那你的笔试基本上也就挂了。&lt;/p>
&lt;p>当你听到什么二层设备、三层设备、四层 LB 和七层 LB 中层的时候，是否有点一头雾水，不知道这些所谓的层，对应的各种协议具体要做什么&amp;quot;工作&amp;quot;？&lt;/p>
&lt;h2 id="-">这四个问题你真的懂了吗？&lt;/h2>
&lt;p>因为教科书或者老师往往会打一个十分不恰当的比喻：为什么网络要分层呀？因为不同的层次之间有不同的沟通方式，这个叫作协议。例如，一家公司也是分&amp;quot;层次&amp;quot;的，分总经理、经理、组长、员工。总经理之间有他们的沟通方式，经理和经理之间也有沟通方式，同理组长和员工。有没有听过类似的比喻？&lt;/p>
&lt;p>那么&lt;strong>第一个问题&lt;/strong> 来了。请问经理在握手的时候，员工在干什么？很多人听过 TCP 建立连接的&lt;strong>三次握手协议&lt;/strong>，也会把它当知识点背诵。同理问你，TCP 在进行三次握手的时候，IP 层和 MAC 层对应都有什么操作呢？&lt;/p>
&lt;p>除了上面这个不恰当的比喻，教科书还会列出每个层次所包含的协议，然后开始逐层地去讲这些协议。但是这些协议之间的关系呢？却很少有教科书会讲。&lt;/p>
&lt;p>学习第三层的时候会提到，IP 协议里面包含&lt;strong>目标地址&lt;/strong> 和&lt;strong>源地址。&lt;/strong> 第三层里往往还会学习&lt;strong>路由协议&lt;/strong>。路由就像中转站，我们从原始地址 A 到目标地址 D，中间经过两个中转站 A-&amp;gt;B-&amp;gt;C-&amp;gt;D，是通过路由转发的。&lt;/p>
&lt;p>那么&lt;strong>第二个问题&lt;/strong>来了。A 知道自己的下一个中转站是 B，那从 A 发出来的包，应该把 B 的 IP 地址放在哪里呢？B 知道自己的下一个中转站是 C，从 B 发出来的包，应该把 C 的 IP 地址放在哪里呢？如果放在 IP 协议中的目标地址，那包到了中转站，怎么知道最终的目的地址是 D 呢？&lt;/p>
&lt;p>教科书不会通过场景化的例子，将网络包的生命周期讲出来，所以你就会很困惑，不知道这些协议实际的应用场景是什么。&lt;/p>
&lt;p>我&lt;strong>再问你一个问题&lt;/strong>。你一定经常听说二层设备、三层设备。二层设备处理的通常是 MAC 层的东西。那我发送一个 HTTP 的包，是在第七层工作的，那是不是不需要经过二层设备？或者即便经过了，二层设备也不处理呢？或者换一种问法，二层设备处理的包里，有没有 HTTP 层的内容呢？&lt;/p>
&lt;p>最终，我想问你&lt;strong>一个综合的问题&lt;/strong>。从你的电脑，通过 SSH 登录到公有云主机里面，都需要经历哪些过程？或者说你打开一个电商网站，都需要经历哪些过程？说得越详细越好。&lt;/p>
&lt;p>实际情况可能是，很多人会答不上来。尽管对每一层都很熟悉，但是知识点却串不起来。&lt;/p>
&lt;p>上面的这些问题，有的在这一节就会有一个解释，有的则会贯穿我们整个课程。好在后面一节中我会举一个贯穿的例子，将很多层的细节讲过后，你很容易就能把这些知识点串起来。&lt;/p>
&lt;h2 id="-">网络为什么要分层？&lt;/h2>
&lt;p>这里我们先探讨第一个问题，网络为什么要分层？因为，是个复杂的程序都要分层。&lt;/p>
&lt;p>理解计算机网络中的概念，一个很好的角度是，想象网络包就是一段 Buffer，或者一块内存，是有格式的。同时，想象自己是一个处理网络包的程序，而且这个程序可以跑在电脑上，可以跑在服务器上，可以跑在交换机上，也可以跑在路由器上。你想象自己有很多的网口，从某个口拿进一个网络包来，用自己的程序处理一下，再从另一个网口发送出去。&lt;/p>
&lt;p>当然网络包的格式很复杂，这个程序也很复杂。**复杂的程序都要分层，这是程序设计的要求。**比如，复杂的电商还会分数据库层、缓存层、Compose 层、Controller 层和接入层，每一层专注做本层的事情。&lt;/p>
&lt;h2 id="-">程序是如何工作的？&lt;/h2>
&lt;p>我们可以简单地想象&amp;quot;你&amp;quot;这个程序的工作过程。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/06/ea/06b355394f525c54f200d8a1af63ddea.jpg" alt="">&lt;/p>
&lt;p>当一个网络包从一个网口经过的时候，你看到了，首先先看看要不要请进来，处理一把。有的网口配置了混杂模式，凡是经过的，全部拿进来。&lt;/p>
&lt;p>拿进来以后，就要交给一段程序来处理。于是，你调用&lt;strong>process_layer2(buffer)&lt;/strong>。当然，这是一个假的函数。但是你明白其中的意思，知道肯定是有这么个函数的。那这个函数是干什么的呢？从 Buffer 中，摘掉二层的头，看一看，应该根据头里面的内容做什么操作。&lt;/p>
&lt;p>假设你发现这个包的 MAC 地址和你的相符，那说明就是发给你的，于是需要调用&lt;strong>process_layer3(buffer)&lt;/strong>。这个时候，Buffer 里面往往就没有二层的头了，因为已经在上一个函数的处理过程中拿掉了，或者将开始的偏移量移动了一下。在这个函数里面，摘掉三层的头，看看到底是发送给自己的，还是希望自己转发出去的。&lt;/p>
&lt;p>如何判断呢？如果 IP 地址不是自己的，那就应该转发出去；如果 IP 地址是自己的，那就是发给自己的。根据 IP 头里面的标示，拿掉三层的头，进行下一层的处理，到底是调用 process_tcp(buffer) 呢，还是调用 process_udp(buffer) 呢？&lt;/p>
&lt;p>假设这个地址是 TCP 的，则会调用&lt;strong>process_tcp(buffer)&lt;/strong>。这时候，Buffer 里面没有三层的头，就需要查看四层的头，看这是一个发起，还是一个应答，又或者是一个正常的数据包，然后分别由不同的逻辑进行处理。如果是发起或者应答，接下来可能要发送一个回复包；如果是一个正常的数据包，就需要交给上层了。交给谁呢？是不是有 process_http(buffer) 函数呢？&lt;/p>
&lt;p>没有的，如果你是一个网络包处理程序，你不需要有 process_http(buffer)，而是应该交给应用去处理。交给哪个应用呢？在四层的头里面有端口号，不同的应用监听不同的端口号。如果发现浏览器应用在监听这个端口，那你发给浏览器就行了。至于浏览器怎么处理，和你没有关系。&lt;/p>
&lt;p>浏览器自然是解析 HTML，显示出页面来。电脑的主人看到页面很开心，就点了鼠标。点击鼠标的动作被浏览器捕获。浏览器知道，又要发起另一个 HTTP 请求了，于是使用端口号，将请求发给了你。&lt;/p>
&lt;p>你应该调用&lt;strong>send_tcp(buffer)&lt;/strong>。不用说，Buffer 里面就是 HTTP 请求的内容。这个函数里面加一个 TCP 的头，记录下源端口号。浏览器会给你目的端口号，一般为 80 端口。&lt;/p>
&lt;p>然后调用&lt;strong>send_layer3(buffer)&lt;/strong>。Buffer 里面已经有了 HTTP 的头和内容，以及 TCP 的头。在这个函数里面加一个 IP 的头，记录下源 IP 的地址和目标 IP 的地址。&lt;/p>
&lt;p>然后调用&lt;strong>send_layer2(buffer)&lt;/strong>。Buffer 里面已经有了 HTTP 的头和内容、TCP 的头，以及 IP 的头。这个函数里面要加一下 MAC 的头，记录下源 MAC 地址，得到的就是本机器的 MAC 地址和目标的 MAC 地址。不过，这个还要看当前知道不知道，知道就直接加上；不知道的话，就要通过一定的协议处理过程，找到 MAC 地址。反正要填一个，不能空着。&lt;/p>
&lt;p>万事俱备，只要 Buffer 里面的内容完整，就可以从网口发出去了，你作为一个程序的任务就算告一段落了。&lt;/p>
&lt;h2 id="-">揭秘层与层之间的关系&lt;/h2>
&lt;p>知道了这个过程之后，我们再来看一下原来困惑的问题。&lt;/p>
&lt;p>首先是分层的比喻。**所有不能表示出层层封装含义的比喻，都是不恰当的。**总经理握手，不需要员工在吧，总经理之间谈什么，不需要员工参与吧，但是网络世界不是这样的。正确的应该是，总经理之间沟通的时候，经理将总经理放在自己兜里，然后组长把经理放自己兜里，员工把组长放自己兜里，像套娃娃一样。那员工直接沟通，不带上总经理，就不恰当了。&lt;/p>
&lt;p>现实生活中，往往是员工说一句，组长补充两句，然后经理补充两句，最后总经理再补充两句。但是在网络世界，应该是总经理说话，经理补充两句，组长补充两句，员工再补充两句。&lt;/p>
&lt;p>那 TCP 在三次握手的时候，IP 层和 MAC 层在做什么呢？当然是 TCP 发送每一个消息，都会带着 IP 层和 MAC 层了。因为，TCP 每发送一个消息，IP 层和 MAC 层的所有机制都要运行一遍。而你只看到 TCP 三次握手了，其实，IP 层和 MAC 层为此也忙活好久了。&lt;/p>
&lt;p>这里要记住一点：&lt;strong>只要是在网络上跑的包，都是完整的。可以有下层没上层，绝对不可能有上层没下层。&lt;/strong>&lt;/p>
&lt;p>所以，&lt;strong>对 TCP 协议来说，三次握手也好，重试也好，只要想发出去包，就要有 IP 层和 MAC 层，不然是发不出去的。&lt;/strong>&lt;/p>
&lt;p>经常有人会问这样一个问题，我都知道那台机器的 IP 地址了，直接发给他消息呗，要 MAC 地址干啥？这里的关键就是，没有 MAC 地址消息是发不出去的。&lt;/p>
&lt;p>所以如果一个 HTTP 协议的包跑在网络上，它一定是完整的。无论这个包经过哪些设备，它都是完整的。&lt;/p>
&lt;p>所谓的二层设备、三层设备，都是这些设备上跑的程序不同而已。一个 HTTP 协议的包经过一个二层设备，二层设备收进去的是整个网络包。这里面 HTTP、TCP、 IP、 MAC 都有。什么叫二层设备呀，就是只把 MAC 头摘下来，看看到底是丢弃、转发，还是自己留着。那什么叫三层设备呢？就是把 MAC 头摘下来之后，再把 IP 头摘下来，看看到底是丢弃、转发，还是自己留着。&lt;/p>
&lt;h2 id="-">小结&lt;/h2>
&lt;p>总结一下今天的内容，理解网络协议的工作模式，有两个小窍门：&lt;/p>
&lt;ul>
&lt;li>始终想象自己是一个处理网络包的程序：如何拿到网络包，如何根据规则进行处理，如何发出去；&lt;/li>
&lt;li>始终牢记一个原则：只要是在网络上跑的包，都是完整的。可以有下层没上层，绝对不可能有上层没下层。&lt;/li>
&lt;/ul>
&lt;p>最后，给你留两个思考题吧。&lt;/p>
&lt;ol>
&lt;li>如果你也觉得总经理和员工的比喻不恰当，你有更恰当的比喻吗？&lt;/li>
&lt;li>要想学习网络协议，IP 这个概念是最最基本的，那你知道如何查看 IP 地址吗？&lt;/li>
&lt;/ol>
&lt;p>欢迎你留言和我讨论。趣谈网络协议，我们下期见！&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/b5/fb/b5bc14cb81d3630919fee94a512cc3fb.jpg" alt="">&lt;/p></description></item><item><title>极客专栏: 02丨“老周，我想知道”丨律师就在你身边（二）</title><link>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E7%99%BD%E8%AF%9D%E6%B3%95%E5%BE%8B/02%E4%B8%A8%E8%80%81%E5%91%A8%E6%88%91%E6%83%B3%E7%9F%A5%E9%81%93%E4%B8%A8%E5%BE%8B%E5%B8%88%E5%B0%B1%E5%9C%A8%E4%BD%A0%E8%BA%AB%E8%BE%B9%E4%BA%8C/</link><pubDate>Tue, 07 Jun 2022 00:00:00 +0000</pubDate><guid>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E7%99%BD%E8%AF%9D%E6%B3%95%E5%BE%8B/02%E4%B8%A8%E8%80%81%E5%91%A8%E6%88%91%E6%83%B3%E7%9F%A5%E9%81%93%E4%B8%A8%E5%BE%8B%E5%B8%88%E5%B0%B1%E5%9C%A8%E4%BD%A0%E8%BA%AB%E8%BE%B9%E4%BA%8C/</guid><description>
&lt;p>今天是我们&amp;quot;法律咨询&amp;quot;的第二期。我选取了专栏留言频次最高的十一个问题，并给出了相应的解答。接下来我们来看这些问答。&lt;/p>
&lt;p>&lt;strong>第一问：公司配备的电脑，上面能不能存我的个人数据呢？等到离职时，我是否可以删除电脑上的个人数据，像是照片这类？重装系统可以吗？&lt;/strong>&lt;/p>
&lt;p>老周答：如果公司没有特殊约定，在不影响工作的情况下，在公司配备的电脑上存储个人数据或照片，并没有什么问题，删除也是同样的道理。不过，想要重装系统的话，按照通常理解，需要经过你们公司的同意，并且要提前备份好重要数据。&lt;/p>
&lt;p>&lt;strong>第二问：下班时我忘了打卡，结果被公司算成了旷工，公司这样做是否违法呢？&lt;/strong>&lt;/p>
&lt;p>老周答：如果你能证明你确实上班了（比如照片、聊天记录等证据），只是忘记下班打卡了，那就不能算旷工。即使你的公司明确规定了，下班没打卡就算旷工，这在法律上也是不合理的规定，公司应该按照实际情况来执行。&lt;/p>
&lt;p>不过，记住一点，证明你确实上班，是你自己的责任，公司不需要为这个证据负责。&lt;/p>
&lt;p>&lt;strong>第三问：自己画画，自己开淘宝店来卖，算不算非法经营罪？&lt;/strong>&lt;/p>
&lt;p>老周答： 根据《电子商务法》第十条的规定，电子商务经营者应该依法办理市场主体登记。但是，下面两种行为不需要登记。&lt;/p>
&lt;ul>
&lt;li>个人销售自己生产的农副产品、家庭手工业产品。&lt;/li>
&lt;li>个人利用自己的技能，从事法律上规定的不用获得许可的便民劳务活动、零星小额交易活动。&lt;/li>
&lt;/ul>
&lt;p>因此，你这种行为不属于非法经营行为，更不构成非法经营罪。&lt;/p>
&lt;p>&lt;strong>第四问：实践中，往往是法不责众，三个人砸售楼处会被拘留，但是如果三百人砸售楼处呢？&lt;/strong>&lt;/p>
&lt;p>老周答：法不责众是一个社会上广为流传的谚语，但在法律规定中其实并不存在。法律面前人人平等，违法必究，才是基本法律原则。&lt;/p>
&lt;p>三人砸售楼处会被拘留，而三百人砸售楼处，至少领头人肯定会被拘留，其他的具体破坏者也同样会有惩罚。事实上，在群体事件中，个人很容易失去理智，失去主观判断，盲目跟风去做。但是，一旦行为过激或是直接造成重大损失、人身伤害，一样会受到法律的严惩。&lt;/p>
&lt;p>法不责众从来不是违法犯罪的保护伞，试图以此脱身，属于侥幸心理，现实结果往往会打脸。&lt;/p>
&lt;p>&lt;strong>第五问：公司给我交的社保，并有没有按实际工资的标准，以前的我并不知道这一点，所以合同里没写清楚也没在意，可是现在公司在裁员，裁员时我是不是可以要求公司给补上呢？&lt;/strong>&lt;/p>
&lt;p>老周答：缴纳社保应以实际工资为基数，这是法律的规定，不需要在合同里约定。即使合同里约定，按照低于实际工资的基数也是违法的，属于无效约定。&lt;/p>
&lt;p>一般来说，对于未缴部分，你可以要求公司进行补偿。另外，以前我也提到过的，2019 年 1 月 1 日起，社保将由税务机关统一征收，因为政策发生变化，具体要怎么处理还有待观察。&lt;/p>
&lt;p>&lt;strong>第六问：我和几个同事在一家公司工作 10 年以上了，一直没合同没社保。去年，老板把我们挪到另一家公司来管理，老板变成了新公司的股东，我们的工作内容也没有变化。那么，现在我们可以要求签无固定期限劳动合同了吗？如果老板不愿意签，我们又该怎么办呢？&lt;/strong>&lt;/p>
&lt;p>老周答：在公司连续工作 10 年以上，如果员工提出签订无固定期限劳动合同，公司应当同意并签订。&lt;/p>
&lt;p>你在公司工作了 10 年以上，虽然没有签订合同，但根据法律规定，用人单位自用工之日起满一年，还没有和劳动者签订书面劳动合同的话，就可以看作法律上的无固定期限劳动合同关系。&lt;/p>
&lt;p>所以，你们本身已经是无固定期限劳动合同关系。不过，老板给你们换公司的行为，还是要提高警惕。为了防止老板不认账，你最好尽早通过劳动合同，把以前的工作年限、工作关系都明确下来。&lt;/p>
&lt;p>&lt;strong>第七问：农民工没有签劳动合同，也没有交工伤保险，一旦发生工伤，应该怎么要求赔偿呢？&lt;/strong>&lt;/p>
&lt;p>老周答：工伤保险属于用人单位的法定义务，公司必须为建立劳动关系的员工进行缴纳。如果没有交保险的情况下，发生工伤事故，责任自然应该由公司承担。&lt;/p>
&lt;p>&lt;strong>第八问：代购算不算非法经营罪？&lt;/strong>&lt;/p>
&lt;p>老周答：这个问题，需要具体情况具体分析，不能一概而论。&lt;/p>
&lt;p>比如，你帮亲朋好友代购一些日常用品，不以营利为目的，也就不存在非法经营的问题，只涉及需不需要纳税的问题。&lt;/p>
&lt;p>但是，如果你代购的目的，本身就是为了营利，那就需要格外注意，也是需要依法报税的，否则就属于违法行为。而一旦达到一定的数额，就可能涉嫌走私普通货物罪，或者非法经营罪。&lt;/p>
&lt;p>&lt;strong>第九问：公司在 A 城，我的个人所得税也在 A 城缴纳。不过我的常住城市是 B 城，五险一金也被公司委托给了 B 城的人力资源机构代缴。另外，在入职时，公司跟我签了两份劳动合同，一个是本公司的，一个是人力资源机构的。这种情况下，如果我申请劳动仲裁，或者去法院起诉，应该去 A 城还是 B 城呢？&lt;/strong>&lt;/p>
&lt;p>老周答：公司这种行为其实是违法的，社保必须在本公司办理。你这种情况，本身应该在 A 城公司办理并缴纳社保。在人力资源机构办理的社保，不符合法律规定，属于虚假用工。&lt;/p>
&lt;p>所以，回到最重要的问题，如果想要申请劳动仲裁，或者起诉，自然应该在 A 城。&lt;/p>
&lt;p>&lt;strong>第十问：公司逼我签降薪协议，不签的话就要辞退我。我目前还不想辞职，如果先签下降薪协议的话，以后还能以公司这个行为为由，申请离职吗？如果可以的话，能拿到赔偿吗？&lt;/strong>&lt;/p>
&lt;p>老周答：公司这种行为显然不符合法律规定，属于违法辞退。这种所谓的降薪协议，通常也会约定很多对员工不利的内容。&lt;/p>
&lt;p>所以，如果你真的签了降薪协议，再想推翻就难了。以此为由，基本上也拿不到补偿。&lt;/p>
&lt;p>&lt;strong>第十一问：公司最近在讨论，给核心员工分一部分股权的事，形式是赠送股权。那什么是赠送股权呢？与公司签订股权协议，要注意什么呢？&lt;/strong>&lt;/p>
&lt;p>老周答：赠与股权，意思就是不需要支付对价，免费获得，通常是对公司有核心价值员工的一种激励措施。赠与股权也是股权转让的一种方式，需要公司其他股东同意。&lt;/p>
&lt;p>如果签订协议，一定要记得看赠与股权的附加条件，有很多赠与，名义上是赠与，其实加了很多的限制性条款，也规定了行权的具体条件，这一点需要特别注意。&lt;/p>
&lt;p>今天主要回答这十一个问题。那么，你还有什么疑惑想问我，或者有什么心得想要和我分享的吗？欢迎留言告诉我，也欢迎点击右下方的&amp;quot;请朋友读&amp;quot;，把今天所学分享给你的家人、朋友。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/cc/ff/cc229a6309f93017826a07452f3250ff.jpg" alt="">&lt;/p></description></item><item><title>极客专栏: 02丨为HTTP穿上盔甲：HTTPS</title><link>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E5%85%A8%E6%A0%88%E5%B7%A5%E7%A8%8B%E5%B8%88%E4%BF%AE%E7%82%BC%E6%8C%87%E5%8D%97/02%E4%B8%A8%E4%B8%BAhttp%E7%A9%BF%E4%B8%8A%E7%9B%94%E7%94%B2https/</link><pubDate>Tue, 07 Jun 2022 00:00:00 +0000</pubDate><guid>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E5%85%A8%E6%A0%88%E5%B7%A5%E7%A8%8B%E5%B8%88%E4%BF%AE%E7%82%BC%E6%8C%87%E5%8D%97/02%E4%B8%A8%E4%B8%BAhttp%E7%A9%BF%E4%B8%8A%E7%9B%94%E7%94%B2https/</guid><description>
&lt;p>你好，我是四火。&lt;/p>
&lt;p>在上一讲中，我介绍了互联网最重要的 HTTP 协议。可是随着互联网的发展，你会发现 HTTP 越来越无法满足复杂的需求，比如数据加密传输的安全性需求，再比如服务器消息即时推送的交互模式的需求，而这些不适性是由 HTTP 的基本特性所造成的。&lt;/p>
&lt;p>因此，我们需要在传统 HTTP 领域以外开疆拓土，这就包括要引入其它的网络协议，或增强、或填补 HTTP 协议所不擅长的空白领域，这也是今天这一讲和下一讲的核心内容。今天我们重点学习 SSL/TLS ，看看它是如何让 HTTP 传输变得安全可靠的。&lt;/p>
&lt;h2 id="httpssltls-和-https">HTTP，SSL/TLS 和 HTTPS&lt;/h2>
&lt;p>在一开始的时候，HTTP 的设计者并没有把专门的加密安全传输放进协议设计里面。因此单独使用 HTTP 进行明文的数据传输，一定存在着许多的安全问题。比方说，现在有一份数据需要使用 HTTP 协议从客户端 A 发送到服务端 B，而第三方 C 尝试来做点坏事，于是就可能产生如下四大类安全问题：&lt;/p>
&lt;ul>
&lt;li>Interception：拦截。传输的消息可以被中间人 C 截获，并泄露数据。&lt;/li>
&lt;li>Spoofing：伪装。A 和 B 都可能被 C 冒名顶替，因此消息传输变成了 C 发送到 B，或者 A 发送到 C。&lt;/li>
&lt;li>Falsification：篡改。C 改写了传输的消息，因此 B 收到了一条被篡改的消息而不知情。&lt;/li>
&lt;li>Repudiation：否认。这一类没有 C 什么事，而是由于 A 或 B 不安好心。A 把消息成功发送了，但之后 A 否认这件事发生过；或者 B 其实收到了消息，但是否认他收到过。&lt;/li>
&lt;/ul>
&lt;p>但是，与其重新设计一套安全传输方案，倒不如发挥一点拿来主义的精神，把已有的和成熟的安全协议直接拿过来套用，最好它位于呈现层（Presentation Layer），因此正好加塞在 HTTP 所在的应用层（Application Layer）下面，&lt;strong>这样这个过程对于 HTTP 本身透明，也不影响原本 HTTP 以下的协议（例如 TCP）&lt;/strong>。&lt;/p>
&lt;p>这个协议就是 SSL/TLS，它使得上面四大问题中，和传输本身密切相关的前三大问题都可以得到解决（第四个问题还需要引入数字签名来解决）。于是，HTTP 摇身一变成了 HTTPS：&lt;/p>
&lt;blockquote>
&lt;p>HTTP + SSL/TLS = HTTPS&lt;/p>
&lt;/blockquote>
&lt;p>这里涉及到的两个安全协议，SSL 和 TLS，下面简要说明下二者关系。&lt;/p>
&lt;p>SSL 指的是 Secure Socket Layer，而 TLS 指的是 Transport Layer Security，事实上，一开始只有 SSL，但是在 3.0 版本之后，SSL 被标准化并通过 &lt;a href="https://tools.ietf.org/html/rfc2246">RFC 2246&lt;/a> 以 SSL 为基础建立了 TLS 的第一个版本，因此可以简单地认为 SSL 和 TLS 是具备父子衍生关系的同一类安全协议。&lt;/p>
&lt;h2 id="动手捕获-tls-报文">动手捕获 TLS 报文&lt;/h2>
&lt;p>介绍了最基本的概念，我们再来看看 HTTPS 是怎样安全工作，让客户端和服务端相互信任的， TLS 连接又是怎样建立起来的。还记得上一讲的选修课堂吗？我们学了怎样抓包。今天我们就能让所学派上用场！自己动手，我们抓 TLS 连接握手的报文来分析。&lt;/p>
&lt;p>命令行执行抓包命令，指明要抓 &lt;a href="https://www.google.com">https://www.google.com&lt;/a> 的包（当然，你也可以使用其他 HTTPS 网站地址），注意 HTTPS 的默认端口是 443（-i 指定的 interface 可能因为不同的操作系统有所区别，在我的 Mac 上是 en0）：&lt;/p>
&lt;pre>&lt;code>sudo tcpdump -i en0 -v 'host www.google.com and port 443' -w https.cap
&lt;/code>&lt;/pre>
&lt;p>再新建一个命令行窗口，使用 curl 命令来访问 Google 主页：&lt;/p>
&lt;pre>&lt;code>curl https://www.google.com
&lt;/code>&lt;/pre>
&lt;p>于是在看到类似如下抓包后 CTRL + C 停止：&lt;/p>
&lt;pre>&lt;code>tcpdump: listening on en0, link-type EN10MB (Ethernet), capture size 262144 bytes
^C49 packets captured
719 packets received by filter
0 packets dropped by kernel
&lt;/code>&lt;/pre>
&lt;p>接着使用 Wireshark 打开刚才抓的 https.cap，在 filter 中输入 tls，得到如下请求和响应报文：&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/6a/3b/6a0269e1c2cdc7c768fc11c8bcc20e3b.jpg" alt="">&lt;/p>
&lt;p>可以看到，这里有五个重要的握手消息，在它们之后的所有消息都是用于承载实际数据的&amp;quot;Application Data&amp;quot;了。握手的过程略复杂，接下来我会尽可能用通俗的语言把最主要的流程讲清楚。&lt;/p>
&lt;h2 id="对称性和非对称性加密">对称性和非对称性加密&lt;/h2>
&lt;p>这里我先介绍两个概念，&amp;ldquo;对称性加密&amp;quot;和&amp;quot;非对称性加密&amp;rdquo;，这是学习后面内容的重要基础。&lt;/p>
&lt;p>对称性加密（Symmetric Cryptography），指的是加密和解密使用相同的密钥。这种方式相对简单，加密解密速度快，但是由于加密和解密需要使用相同的密钥，如何安全地传递密钥，往往成为一个难题。&lt;/p>
&lt;p>非对称性加密（Asymmetric Cryptography），指的是数据加密和解密需要使用不同的密钥。通常一个被称为公钥（Public Key），另一个被称为私钥（Private Key），二者一般同时生成，但是&lt;strong>公钥往往可以公开和传播，而私钥不能。经过公钥加密的数据，需要用私钥才能解密&lt;/strong>；反之亦然。这种方法较为复杂，且性能较差，好处就是由于加密和解密的密钥具有相对独立性，公钥可以放心地传播出去，不用担心安全性问题。&lt;/p>
&lt;blockquote>
&lt;p>原始数据 + 公钥 → 加密数据&lt;br>
加密数据 + 私钥 → 原始数据&lt;/p>
&lt;/blockquote>
&lt;h2 id="tls-连接建立原理">TLS 连接建立原理&lt;/h2>
&lt;p>有了上述基础，下面我们就可以结合图示，看看整个连接建立的握手过程了。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/94/63/941574c15cea2cc2d66c66ab492fea63.jpeg" alt="">&lt;/p>
&lt;p>&lt;strong>Step 1: Client Hello.&lt;/strong> 客户端很有礼貌，先向服务端打了个招呼，并携带以下信息：&lt;/p>
&lt;ul>
&lt;li>客户端产生的随机数 A；&lt;/li>
&lt;li>客户端支持的加密方法列表。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Step 2: Server Hello.&lt;/strong> 服务端也很有礼貌，向客户端回了个招呼：&lt;/p>
&lt;ul>
&lt;li>服务端产生的随机数 B；&lt;/li>
&lt;li>服务端根据客户端的支持情况确定出的加密方法组合（Cipher Suite）。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Step 3: Certificate, Server Key Exchange, Server Hello Done.&lt;/strong> 服务端在招呼之后也紧跟着告知：&lt;/p>
&lt;ul>
&lt;li>Certificate，证书信息，证书包含了服务端生成的公钥。这个公钥有什么用呢？别急，后面会说到。&lt;/li>
&lt;/ul>
&lt;p>客户端收到消息后，验证确认证书真实有效，那么这个证书里面的公钥也就是可信的了。&lt;/p>
&lt;p>接着客户端再生成一个随机数 C（Pre-master Secret），于是现在共有随机数 A、B 和 C，根据约好的加密方法组合，三者可生成新的密钥 X（Master Secret），而由 X 可继续生成真正用于后续数据进行加密和解密的对称密钥。因为它是在本次 TLS 会话中生成的，所以也被称为会话密钥（Session Secret）。简言之：&lt;/p>
&lt;blockquote>
&lt;p>客户端随机数 A + 服务端随机数 B + 客户端 Pre-master Secret C → 会话密钥&lt;/p>
&lt;/blockquote>
&lt;p>需要注意的是，实际这个 Pre-master Secret 的生成方法不是固定的，而会根据加密的具体算法不同而不同：&lt;/p>
&lt;ul>
&lt;li>上述我介绍的是传统 RSA 方式，即 Pre-master Secret 由客户端独立生成，加密后再通过 Client Key Exchange 发回服务端。&lt;/li>
&lt;li>还有一种是 &lt;a href="https://zh.wikipedia.org/wiki/%E6%A9%A2%E5%9C%93%E6%9B%B2%E7%B7%9A%E8%BF%AA%E8%8F%B2-%E8%B5%AB%E7%88%BE%E6%9B%BC%E9%87%91%E9%91%B0%E4%BA%A4%E6%8F%9B">ECDHE&lt;/a> 方式，这种方式下无论在客户端还是服务端，Pre-master Secret 需要通过 Client Key Exchange 和 Server Key Exchange 两者承载的参数联合生成。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Step 4: Client Key Exchange, Change Cipher Spec, Encrypted Handshake Message.&lt;/strong> 接着客户端告诉服务端：&lt;/p>
&lt;ul>
&lt;li>Client Key Exchange，本质上它就是上面说的这个 C，但使用了服务端通过证书发来的公钥加密；&lt;/li>
&lt;li>Change Cipher Spec，客户端同意正式启用约好的加密方法和密钥了，后面的数据传输全部都使用密钥 X 来加密；&lt;/li>
&lt;li>Encrypted Handshake Message，快速验证：这是客户端对于整个对话进行摘要并加密得到的串，如果经过服务端解密，和原串相等，就证明整个握手过程是成功的。&lt;/li>
&lt;/ul>
&lt;p>服务端收到消息后，用自己私钥解密上面的 Client Key Exchange，得到了 C，这样它和客户端一样，也得到了 A、B 和 C，继而到 X，以及最终的会话密钥。&lt;/p>
&lt;p>于是，客户端和服务端都得到了能够加密解密传输数据的对称密钥&amp;mdash;&amp;mdash;会话密钥。&lt;/p>
&lt;p>因此，我们可以看到：&lt;strong>TLS 是通过非对称加密技术来保证握手过程中的可靠性（公钥加密，私钥解密），再通过对称加密技术来保证数据传输过程中的可靠性的&lt;/strong>。&lt;/p>
&lt;p>这种通过较严格、较复杂的方式建立起消息交换渠道，再通过相对简单且性能更高的方式来实际完成主体的数据传输，并且前者具有长效性（即公钥和私钥相对稳定），后者具有一过性（密钥是临时生成的），这样的模式，我们还将在全栈的知识体系中，继续见到。&lt;/p>
&lt;p>&lt;strong>Step 5: Change Cipher Spec, Encrypted Handshake Message.&lt;/strong> 服务端最后也告知客户端：&lt;/p>
&lt;ul>
&lt;li>Change Cipher Spec，服务端也同意要正式启用约好的加密方法和密钥，后面的数据传输全部都使用 X 来加密。&lt;/li>
&lt;li>Encrypted Handshake Message，快速验证：这是服务端对于整个对话进行摘要并加密得到的串，如果经过客户端解密，和原串相等，就证明整个握手过程是成功的。&lt;/li>
&lt;/ul>
&lt;h2 id="总结思考">总结思考&lt;/h2>
&lt;p>今天我们了解了关于数据传输的四大类安全问题，了解了 HTTPS 和 SSL/TLS 的概念和它们之间的关系，还通过自己动手抓包的方式，详细学习了 TLS 连接建立的步骤。&lt;/p>
&lt;p>TLS 连接的步骤是今天的重点，也是比较难理解的部分，希望你能牢牢地掌握它。现在就来检验一下今天的学习成果吧！请你思考这样两个问题：&lt;/p>
&lt;ul>
&lt;li>有位程序员朋友注意到，自己在使用在线支付功能时，网站访问是使用 HTTPS 加密的，因此他觉得，支付的过程中是不可能出现安全问题的，你觉得这种想法对吗？&lt;/li>
&lt;li>在介绍 TLS/SSL 连接建立的过程当中，我提到了，握手过程是使用非对称加密实现的，而真正后续的数据传输部分却是由对称加密实现的。为什么要这么麻烦，全部都使用对称或非对称加密一种不好吗？&lt;/li>
&lt;/ul>
&lt;p>你能回答上面的问题吗？如果可以，我相信你已经理解了 HTTPS 安全机制建立的原理。&lt;/p>
&lt;h2 id="选修课堂证书有效验证的原理">选修课堂：证书有效验证的原理&lt;/h2>
&lt;p>在讲解&amp;quot;握手过程&amp;quot;的 step 3 时，我提到了客户端在收到服务端发送过来的证书时，需要校验证书的有效性。这个过程其实也是至关重要的，因为只有确认了证书的有效性，客户端才能放心地使用其中的公钥。如果你对它的理解比较模糊，那就一定要看看今天的选修课堂了。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/2e/a4/2e5095cb129d58b5bfa325c5e0d9b9a4.jpg" alt="">&lt;/p>
&lt;p>这就是我们抓包中，服务器发来的证书部分的截图。我们可以看到，这不是单个证书，而是一个证书链，包含了两个证书，每个证书都包含版本、发布机构、有效期、数字签名等基本内容，以及一个公钥。实际上，这两个服务端传回来的证书，和浏览器内置的根证书联合起来，组成了一个单向、完整的证书链：&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/1f/29/1f8d1f510e83084b2161d8e07b43b629.jpeg" alt="">&lt;/p>
&lt;p>上图中的第三行，就是携带着服务器公钥的证书，它是从证书发布机构（CA, Certificate Authority）申请得来的，也就是图中第二行的 GTS CA 1O1。证书在申请的时候，我们提到的服务器公钥就已经是该证书的一部分了，因此我们才说，如果证书是有效的，那么它携带的公钥就是有效的。&lt;/p>
&lt;p>在当时申请的时候，&lt;strong>证书发布机构对证书做摘要生成指纹，并使用它自己的私钥为该指纹加密，生成数字签名（Digital Signature），而这个数字签名也随证书一起发布&lt;/strong>。这个发布机构的私钥是它内部自己管理的，不会外泄。&lt;/p>
&lt;blockquote>
&lt;p>指纹 + 私钥 → 数字签名&lt;/p>
&lt;/blockquote>
&lt;p>验证过程则正好是发布过程的反向，即在客户端要对这个被检测证书做两件事：&lt;/p>
&lt;ul>
&lt;li>对它用指定算法进行摘要，得到指纹 P1；&lt;/li>
&lt;li>使用证书发布机构的公钥对它的数字签名进行解密，得到指纹 P2。&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>数字签名 + 公钥 → 指纹&lt;/p>
&lt;/blockquote>
&lt;p>如果 P1 和 P2 一致，就说明证书未被篡改过，也说明这个服务端发来的证书是真实有效的，而不是仿冒的。&lt;/p>
&lt;p>好，问题来了，证书发布机构使用非对称性加密和数字签名保证了证书的有效性，那么谁来保证证书发布机构的有效性？&lt;/p>
&lt;p>答案就是它的上一级证书发布机构。&lt;/p>
&lt;p>CA 是分级管理的，每一级 CA 都根据上述同样的原理，由它的上一级 CA 来加密证书和生成数字签名，来保证其真实性，从而形成一个单向的信任链。同时，标志着最高级别 CA 的根证书数量非常少，且一般在浏览器或操作系统安装的时候就被预置在里面了，因此它们是被我们完全信任的，这就使得真实性的鉴别递归有了最终出口。也就是说，递归自下而上验证的过程，如果一直正确，直至抵达了顶端&amp;mdash;&amp;mdash;浏览器内置的根证书，就说明服务端送过来的证书是安全有效的。&lt;/p>
&lt;p>总结一下今天选修课堂的内容。证书有效性的验证，需要使用依赖于证书发布机构的公钥去解密被检测证书的数字签名，如果顺利解密，并且得到的指纹和被检测证书做摘要得到的指纹一致，就说明证书真实有效。&lt;/p>
&lt;h2 id="扩展阅读">扩展阅读&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://howhttps.works/">HOW HTTPS WORKS&lt;/a>：漫画版介绍 HTTPS 前前后后，很有趣。&lt;/li>
&lt;li>&lt;a href="http://www.moserware.com/2009/06/first-few-milliseconds-of-https.html">The First Few Milliseconds of an HTTPS Connection&lt;/a>：如果你想深究你抓到的 TLS 连接建立的包中每一段报文的意思，这篇文章是一个很好的参考。&lt;/li>
&lt;li>文中介绍了两种生成 Pre-master Secret 的方法，其中第二种的方法是 Diffie&amp;ndash;Hellman 密钥交换的变种，这里蕴含的数学原理很有意思，如果你感兴趣，请参阅&lt;a href="https://zh.wikipedia.org/wiki/%E8%BF%AA%E8%8F%B2-%E8%B5%AB%E7%88%BE%E6%9B%BC%E5%AF%86%E9%91%B0%E4%BA%A4%E6%8F%9B#%E6%8F%8F%E8%BF%B0">维基百科链接&lt;/a>。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/11/8b/1181246bbd51ce348d5729696d1dc28b.jpg" alt="unpreview">&lt;/p></description></item><item><title>极客专栏: 02丨大厦基石：无生有，有生万物</title><link>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E8%AE%B8%E5%BC%8F%E4%BC%9F%E7%9A%84%E6%9E%B6%E6%9E%84%E8%AF%BE/02%E4%B8%A8%E5%A4%A7%E5%8E%A6%E5%9F%BA%E7%9F%B3%E6%97%A0%E7%94%9F%E6%9C%89%E6%9C%89%E7%94%9F%E4%B8%87%E7%89%A9/</link><pubDate>Tue, 07 Jun 2022 00:00:00 +0000</pubDate><guid>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E8%AE%B8%E5%BC%8F%E4%BC%9F%E7%9A%84%E6%9E%B6%E6%9E%84%E8%AF%BE/02%E4%B8%A8%E5%A4%A7%E5%8E%A6%E5%9F%BA%E7%9F%B3%E6%97%A0%E7%94%9F%E6%9C%89%E6%9C%89%E7%94%9F%E4%B8%87%E7%89%A9/</guid><description>
&lt;p>你好，我是七牛云许式伟。&lt;/p>
&lt;p>在上一篇中，我们把&amp;quot;构建一个应用程序&amp;quot;类比成&amp;quot;构建一座大厦&amp;quot;，并从宏观全局的视角剖析了应用程序这座大厦的构成。今天，我们将更加近距离地去解剖这座大厦的地基：冯·诺依曼体系结构。&lt;/p>
&lt;h2 id="解剖架构的关键点是什么">解剖架构的关键点是什么？&lt;/h2>
&lt;p>在解剖之前，我想和你先谈谈&amp;quot;解剖学&amp;quot;：&lt;strong>我们应该如何去分析架构设计中涉及的每一个零部件。换一句话说，当我们设计或分析一个零部件时，我们会关心哪些问题。&lt;/strong>&lt;/p>
&lt;p>**第一个问题，是需求。**这个零部件的作用是什么？它能被用来做哪些事情？（某种意义上来说更重要的是）它不会被用来做哪些事情？&lt;/p>
&lt;p>你可能会说，呀，这个问题很简单，既然我设计了这个零部件，自然知道它是用来干嘛的。但实质上这里真正艰难的是&amp;quot;为什么&amp;quot;：为何这个零件被设计成用来干这些事情的，而不是多干一点事情，或者为什么不是少干某些事情？&lt;/p>
&lt;p>**第二个问题，是规格。**这个零部件接口是什么样的？它如何与其他零件连接在一起的？&lt;/p>
&lt;p>规格是零部件的连接需求的抽象。符合规格的零部件可以有非常多种可能的实现方案，但是，一旦规格中某个条件不能满足了，它就无法正常完成与其他零件的连接，以达到预期的需求目标。&lt;/p>
&lt;p>规格的约束条件会非常多样化，可能是外观（比如形状和颜色），可能是交互方式（比如用键盘、鼠标，或者语音和触摸屏），也可能是质量（比如硬度、耐热性等等）。&lt;/p>
&lt;p>那么，冯·诺依曼体系结构的需求和规格又是什么样的呢？&lt;/p>
&lt;h2 id="为解决一切的问题而生">为&amp;quot;解决一切的问题&amp;quot;而生&lt;/h2>
&lt;p>冯·诺依曼体系结构不但是应用程序这座大厦的地基，同时也是整个信息科技的地基。&lt;/p>
&lt;p>&lt;strong>当我们去审视整个信息科技时，仅把它形容为一座大厦显得如此不贴切，甚至你也不能用&amp;quot;一个城市&amp;quot;去形容它，事实上，它更像是一个无中生有的全新世界：在其中，有个体、有族群、有生态，还有喜怒哀乐。&lt;/strong>&lt;/p>
&lt;p>冯·诺依曼体系结构的迷人之处在于，从需求来说，它想解决一切问题。解决一切可以用&amp;quot;计算&amp;quot;来解决的问题。&lt;/p>
&lt;p>&amp;ldquo;计算&amp;quot;的边界在哪里？今天我们还没有人能够真正说得清。计算能不能解决&amp;quot;智能&amp;quot;的问题？通过计算能力，计算机是否终有一天可以获得和人类一样的智能？&lt;/p>
&lt;p>今天人工智能热潮的兴起，证明对于这个问题我们很乐观：计算终将解决智能的问题。尽管我们不能确定什么时候能够达到，但是让人欣慰的是，我们一直在进步 &amp;mdash;&amp;mdash; 如果人类智能无法完成进一步的进化，那么我们就一直一直在前进，最终无限逼近甚至超越人类智能。&lt;/p>
&lt;p>甚至有科幻小说家设想（例如在 Google 的&amp;quot;AlphaGo&amp;quot;大热后，霍炬和西乔创作的漫画&amp;quot;BetaCat&amp;rdquo;），计算机演进出超过人类的智能是生物进化的一个自然演进路径，它将取代人类成为新的食物链顶端，并最终基于其悠久的生命力，去完成人类有限生命无法实现的星际航行之路。&lt;/p>
&lt;h2 id="冯诺依曼体系的规格">冯·诺依曼体系的规格&lt;/h2>
&lt;p>为了实现&amp;quot;解决一切可以用&amp;rsquo;计算&amp;rsquo;来解决的问题&amp;quot;这个目标，冯·诺依曼引入了三类基础零部件：&lt;/p>
&lt;ul>
&lt;li>中央处理器；&lt;/li>
&lt;li>存储；&lt;/li>
&lt;li>输入输出设备。&lt;/li>
&lt;/ul>
&lt;p>首先我们来看看存储。它负责存放计算涉及的相关数据，作为计算的输入参数和输出结果。&lt;/p>
&lt;p>我们日常见到的存储设备非常的多样化。比如：中央处理器自己内置的寄存器、内存、传统机械硬盘、USB 固态硬盘、光盘等等。&lt;/p>
&lt;p>从中央处理器的角度，存储可简单分为两类：一类是内置支持的存储，通过常规的处理器指令可直接访问，比如寄存器、内存、计算机主板的 ROM。一类是外置存储，它们属于输入输出设备。中央处理器本身并不能直接读写其中的数据。&lt;/p>
&lt;p>冯·诺依曼体系中涉及的&amp;quot;存储&amp;quot;，指的是中央处理器内置支持的存储。&lt;/p>
&lt;p>我们再来看看输入输出设备。它是计算机开放性的体现，大大拓展了计算机的能力。每个设备通过一个端口与中央处理器连接。通过这个端口地址，中央处理器可以和设备进行数据交换。数据交换涉及的数据格式由设备定义，中央处理器并不理解。&lt;/p>
&lt;p>但这并不影响设备的接入。设备数据交换的发起方（设备使用方）通常理解并可以解释所接收的数据含义。为了方便使用，设备厂商或操作系统厂商通常会提供设备相关的驱动程序，把设备数据交换的细节隐藏起来，设备的使用方只需要调用相关的接口函数就可以操作设备。&lt;/p>
&lt;p>最后我们来看看中央处理器。它负责程序（指令序列）的执行。指令序列在哪里？也存放在存储里面。计算机加电启动后，中央处理器从一个固定的存储地址开始执行。&lt;/p>
&lt;p>中央处理器支持的指令大体如下（我们在第一篇文章中也曾提到过）：&lt;/p>
&lt;ul>
&lt;li>计算类，也就是支持我们大家都熟知的各类数学运算，如加减乘除、sin/cos 等等；&lt;/li>
&lt;li>I/O 类，从存储读写数据，从输入输出设备读数据、写数据；&lt;/li>
&lt;li>指令跳转类，在满足特定条件下跳转到新的当前程序执行位置、调用自定义的函数。&lt;/li>
&lt;/ul>
&lt;p>和&amp;quot;解决一切可以用&amp;rsquo;计算&amp;rsquo;来解决的问题&amp;quot;这个伟大的目标相比，冯·诺依曼体系的三类零部件的规格设计显得如此精简。&lt;/p>
&lt;p>为什么这么简洁的规格设计，居然可以解决这么复杂的需求？&lt;/p>
&lt;h2 id="需求是怎么被满足的">需求是怎么被满足的？&lt;/h2>
&lt;p>我们来设想一下：假如今天让我们从零开始设计一个叫电脑的东西，我们的目标是&amp;quot;解决一切可以用&amp;rsquo;计算&amp;rsquo;来解决的问题&amp;quot;。&lt;/p>
&lt;p>对于这么含糊的需求，如果你是&amp;quot;电脑&amp;quot;这个产品的主架构师，你会如何应对？&lt;/p>
&lt;p>让我们来分析一下。&lt;/p>
&lt;p>一方面，需求的变化点在于，要解决的问题是五花八门包罗万象的。如何以某种稳定但可扩展的架构来支持这样的变化？而另一方面，需求的稳定之处在于，电脑的核心能力是固定的，怎么表达电脑的核心能力？&lt;/p>
&lt;p>电脑的核心能力是&amp;quot;计算&amp;quot;。什么是计算？计算就是对一个数据（输入）进行变换，变为另一个数据（输出）。在数学中我们把它叫&amp;quot;函数&amp;quot;。如下：&lt;/p>
&lt;blockquote>
&lt;p>y = F(x)&lt;/p>
&lt;/blockquote>
&lt;p>这里 x、y 是数据。它们可能只是一个简单的数值，也可能是文本、图片、视频，各种我们对现实问题进行参数化建模后的测量值，当然也可能是多个输入数据。但无论它的逻辑含义为何，物理上都可以以一段连续的字节内容来表达。用 Go 的语法表达就是：&lt;/p>
&lt;pre>&lt;code>func F(x []byte) (y []byte)
&lt;/code>&lt;/pre>
&lt;p>那么 x、y 物理上在哪里？思路推理到这里，&amp;ldquo;存储&amp;rdquo; 这个概念自然就产生了：存储，就是存放计算所要操作的数据的所在。&lt;/p>
&lt;p>下面的问题是：一个具体的计算（也就是 F 函数）怎么表达？&lt;/p>
&lt;p>这里的难点在于，F 对于电脑的架构师来说是未知的。那么，怎么设计一种系统架构让用户可以表达任意复杂的计算（函数）？&lt;/p>
&lt;p>逻辑上来看，无论多复杂的自定义函数，都可以通过下面这些元素的组合来定义：&lt;/p>
&lt;ul>
&lt;li>内置函数，比如整数或小数运算（加减乘除、sin/cos 等）；&lt;/li>
&lt;li>循环和条件分支；&lt;/li>
&lt;li>子函数（也是自定义函数）。&lt;/li>
&lt;/ul>
&lt;p>这样一来，对于任意的一个具体的计算（自定义函数）来说，都可以用一组指令序列来表达。&lt;/p>
&lt;p>那么函数 F 物理上在哪里？以指令序列形式存放在存储里面。所以，存储不只存放计算所要操作的数据，也存放&amp;quot;计算&amp;quot;本身。&lt;/p>
&lt;p>只是，存储里面存放的&amp;quot;计算&amp;quot;只是数据，需要有人理解并执行这些数据背后的计算行为，才变成真正意义的&amp;quot;计算&amp;quot;。这个执行者，就是中央处理器（CPU）。它支持很多计算指令，包括执行内置函数、循环和条件分支、执行子函数等。&lt;/p>
&lt;p>所以，有了中央处理器 + 存储，就可以支持任意复杂的&amp;quot;计算&amp;quot;了。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/cf/37/cf77b8fbe8a559cecbb264c390bc7337.png" alt="">&lt;/p>
&lt;p>只是如果电脑只有&amp;quot;中央处理器 + 存储&amp;quot;，那它就如同一个人只有头脑而没有四肢五官，尽管很可能很聪明，但是这种聪明无法展现出来，因为它没法和现实世界发生交互。&lt;/p>
&lt;p>交互，抽象来看就是输入和输出。对人来说，输入靠的是五官：眼睛看、耳朵听、鼻子闻、舌头尝，以及肌肤接触产生的触觉。输出靠语言（说话）和各种动作，如微笑、眨眼、皱眉、手势等等。&lt;/p>
&lt;p>对于电脑来说，输入输出的需求就更多了，不只是四肢五官，而可能是千肢万官。&lt;/p>
&lt;p>从输入需求来说，可能采集静态图像、声音、视频；也可能采集结构化数据，如 GPS 位置、脉搏、心电图、温度、湿度等；还可能是用户控制指令如键盘按键、鼠标、触摸屏动作等。&lt;/p>
&lt;p>从输出需求来说，可能是向屏幕输出信息；也可能是播放声音；还可能是执行某项动作，如交通灯开关、汽车马达转动、打印机打印等。&lt;/p>
&lt;p>但不管是什么样交互用途的器官（设备），我们要做的只是定义好统一的数据交换协议。这个数据交换机制，和网络上两台电脑通过互联网，需要通过某种数据交换协议进行通讯，需求上没有实质性的差别。&lt;/p>
&lt;p>也就是说，除了纯正的&amp;quot;计算&amp;quot;能力外，中央处理器还要有&amp;quot;数据交换&amp;quot;能力（或者叫 IO 能力）。最终，&lt;strong>电脑可以被看做由 &amp;ldquo;中央处理器 + 存储 + 一系列的输入输出设备&amp;rdquo;&lt;/strong> 构成。如下图：&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/28/a9/28ef9c0241c5c34abb85148453379fa9.png" alt="">&lt;/p>
&lt;p>尽管输入输出设备引入的最初灵感可能是来自于&amp;quot;交互&amp;quot;，但是当我们去审视输入输出设备到底是什么的时候，我们很自然发现，它能够做的不单单是交互。&lt;/p>
&lt;p>比如常见的外置存储如机械硬盘、光盘等，它们也是输入输出设备，但并不是用于交互，而是显著提升了电脑处理的数据体量。&lt;/p>
&lt;p>输入输出设备从根本上解决的问题是什么？&lt;/p>
&lt;p>是电脑无限可能的扩展能力。&lt;/p>
&lt;p>最重要的一点，输入输出设备和电脑是完全异构的。输入输出设备对电脑来说就只是实现了某项能力的黑盒子。&lt;/p>
&lt;p>这个黑盒子内部如何？没有规定。它可以只是一个原始的数字化的元器件，也可以是另一台冯·诺依曼架构的电脑，还可以是完全不同架构的电脑，比如 GPU 电脑、量子计算机。&lt;/p>
&lt;p>你可以发现，引入了输入输出设备的电脑，不再只能做狭义上的&amp;quot;计算&amp;quot;（也就是数学意义上的计算），如果我们把交互能力也看做一种计算能力的话，电脑理论上能够解决的&amp;quot;计算&amp;quot;问题变得无所不包。&lt;/p>
&lt;h2 id="架构思维上我们学习到什么">架构思维上我们学习到什么？&lt;/h2>
&lt;p>架构的第一步是需求分析。从需求分析角度来说，关键要抓住需求的稳定点和变化点。需求的稳定点，往往是系统的核心价值点；而需求的变化点，则往往需要相应去做开放性设计。&lt;/p>
&lt;p>对于&amp;quot;电脑&amp;quot;这个产品而言，需求的稳定点是电脑的&amp;quot;计算&amp;quot;能力。需求的变化点，一是用户&amp;quot;计算&amp;quot;需求的多样性，二是用户交互方式的多样性。&lt;/p>
&lt;p>电脑的&amp;quot;计算&amp;quot;能力，最终体现为中央处理器的指令集，这是需求相对稳定的部分。&lt;/p>
&lt;p>用户&amp;quot;计算&amp;quot;需求的多样性，最终是通过在存储中的指令序列实现。计算机加电启动后，中央处理器并不是按自己固有的&amp;quot;计算&amp;quot;过程进行，而是从一个固定的存储地址加载指令序列执行。&lt;/p>
&lt;p>通常，这个固定的存储地址指向计算机主板的 ROM 上的一段启动程序（BIOS）。这段启动程序通常包含以下这些内容。&lt;/p>
&lt;ul>
&lt;li>存储设备的驱动程序，用以识别常规的外置存储设备，比如硬盘、光驱、U 盘。&lt;/li>
&lt;li>基础外部设备的驱动程序，比如键盘、鼠标、显示器（显卡）。&lt;/li>
&lt;li>设备和启动配置的基础管理能力。&lt;/li>
&lt;li>在外置存储上执行程序的能力（中央处理器只支持在内存上执行程序，当然它也为在外置存储执行程序提供了一些支持，比如内存页缺失的中断处理）。&lt;/li>
&lt;li>将执行权转移到外置存储（第一次安装操作系统的时候可能是光驱甚至是网络存储，平常通常是硬盘）上的操作系统启动程序。这样，操作系统就开始干活了。&lt;/li>
&lt;/ul>
&lt;p>这样一来，&amp;ldquo;计算&amp;quot;需求的多样性只需要通过调整计算机主板上的 BIOS 程序，乃至外置存储中的操作系统启动程序就可以实现，而不必去修改中央处理器本身。&lt;/p>
&lt;p>用户交互方式的多样性，则通过定义外部设备与中央处理器的数据交换协议实现。&lt;/p>
&lt;p>当我们把所有的变化点从电脑的最核心部件中央处理器剥离后，中央处理器的需求变得极其稳定，可独立作为产品进行其核心价值的演进。&lt;/p>
&lt;h2 id="结语">结语&lt;/h2>
&lt;p>总结一下，今天，我们近距离地去解剖了整个信息世界地基：冯·诺依曼体系结构。&lt;/p>
&lt;p>冯·诺依曼体系结构的不凡之处在于，它想&amp;quot;解决一切可以用&amp;rsquo;计算&amp;rsquo;来解决的问题&amp;rdquo;。&lt;/p>
&lt;p>为了实现这个目标，冯·诺依曼引入了三类基础零部件：中央处理器、存储、输入输出设备。所有计算机都可以看做由 &amp;ldquo;中央处理器 + 存储 + 一系列的输入输出设备&amp;rdquo; 构成。&lt;/p>
&lt;p>为了方便理解，我在尝试用 Go 语言模拟来实现冯·诺依曼架构体系的电脑：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/qiniu/arch/tree/master/von">https://github.com/qiniu/arch/tree/master/von&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>如果你对此感兴趣，欢迎 fork 并对其进行修改迭代。&lt;/p>
&lt;p>如果你对今天的内容有什么思考与解读，欢迎给我留言，我们一起讨论。如果你觉得有所收获，也欢迎把文章分享给你的朋友。感谢你的收听，我们下期再见。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/43/00/43231f3789095eb4cdb38e67ff3d7900.jpg" alt="">&lt;/p></description></item></channel></rss>