<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>技术文章摘抄 – 左耳听风</title><link>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E/</link><description>Recent content in 左耳听风 on 技术文章摘抄</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Fri, 27 May 2022 00:00:00 +0000</lastBuildDate><atom:link href="/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E/index.xml" rel="self" type="application/rss+xml"/><item><title>极客专栏: 00丨开篇词丨洞悉技术的本质，享受科技的乐趣</title><link>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E/00%E4%B8%A8%E5%BC%80%E7%AF%87%E8%AF%8D%E4%B8%A8%E6%B4%9E%E6%82%89%E6%8A%80%E6%9C%AF%E7%9A%84%E6%9C%AC%E8%B4%A8%E4%BA%AB%E5%8F%97%E7%A7%91%E6%8A%80%E7%9A%84%E4%B9%90%E8%B6%A3/</link><pubDate>Fri, 27 May 2022 00:00:00 +0000</pubDate><guid>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E/00%E4%B8%A8%E5%BC%80%E7%AF%87%E8%AF%8D%E4%B8%A8%E6%B4%9E%E6%82%89%E6%8A%80%E6%9C%AF%E7%9A%84%E6%9C%AC%E8%B4%A8%E4%BA%AB%E5%8F%97%E7%A7%91%E6%8A%80%E7%9A%84%E4%B9%90%E8%B6%A3/</guid><description>
&lt;p>你好，我是陈皓，网名左耳朵耗子。我目前在创业，MegaEase 是我的公司，致力于为企业提供高可用、高并发、高性能的分布式技术产品，同时也提供物联网（IoT）方向的技术产品。&lt;/p>
&lt;p>我之前在阿里巴巴、亚马逊、汤森路透等公司任职，职业背景是金融和电子商务行业，主要研究的技术方向是一些大规模分布式系统的基础架构。&lt;/p>
&lt;p>从大学毕业一直做技术工作，到今天有 20 年了，还在写代码，因为我对技术有很大的热情。我从 2002 年开始写技术博客，到 2009 年左右开始在独立的域名 &lt;a href="http://CoolShell.cn">CoolShell.cn&lt;/a>（酷壳）上分享我对技术的一些见解和心得。&lt;/p>
&lt;p>本来只想记录一下，没想到得到了很多人的认可，这对我来说是一个不小的鼓励。我的文章和分享始终坚持观点鲜明的特点，因为我希望可以引发大家的讨论和批评，这样分享才更有意义。&lt;/p>
&lt;p>无论我的观点是否偏激、不成熟，或者言辞犀利，在经历过大家的批评和讨论后，我都能够从中得到不在我视角内的思考和认知，这对我来说是非常重要的补充，对我的个人成长非常重要。&lt;/p>
&lt;p>我相信，看到这些文章和讨论的人，也能从中收获到更多的东西。&lt;/p>
&lt;p>坦率地讲，刚收到专栏撰写邀请的时候，我心里面是拒绝的。正如前面所说的，我分享的目的是跟大家交流和讨论，我认为，全年付费专栏这样的方式可能并不好。而且，付费专栏还有文章更新频率的 KPI，这对于像我这样一定要有想法才会写文章的人来说是很痛苦的，因为我不想为了写而写。&lt;/p>
&lt;p>所以，最初，我是非常不情愿的。&lt;/p>
&lt;p>极客邦科技的编辑跟我沟通过很多次，也问过我是否在做一些收费的咨询或是培训，并表明这个专栏就是面对这样的场景的。我想想也是。我其实从 2003 年就开始为很多企业做内部的培训和分享了。&lt;/p>
&lt;p>这些培训涵盖了很多方面，如软件团队管理、架构技术、编程语言、操作系统等，以及一些为企业量身定制的咨询或软件开发，这些都是收费的。&lt;/p>
&lt;p>而我一直以来也没有把这些内容分享在我的博客里，主要原因是我觉得这些内容是有商业价值的，是适合收费的。它们都是实实在在的，是我多年来对实战经验的深入总结和思考，非常来之不易。&lt;/p>
&lt;p>我不太舍得拿出来大范围地分享，以前基本上仅小范围地在企业内部比较封闭的环境里讲讲。所以说，我这边其实是有两种分享，一种是企业内的分享，一种则是像 CoolShell 或是大会这样的公开分享。&lt;/p>
&lt;p>前者更企业化一些，后者更通俗化一些。&lt;/p>
&lt;p>在这个付费专栏中，除了继续保持观点鲜明的行文风格，我会分享一些与个人或企业切身利益更为相关的内容，或者说更具指导性、更有商业价值的东西。而 CoolShell，我还会保持现有的风格继续写下去。&lt;/p>
&lt;p>正如这个专栏的 Slogan 所说：&amp;ldquo;洞悉技术的本质，享受科技的乐趣&amp;rdquo;，我会在这个专栏里分享包括但不限于如下这些内容。&lt;/p>
&lt;h1 id="技术">技术&lt;/h1>
&lt;p>对于技术方面，我不会写太多关于知识点的东西，因为这些知识点你可以自行 Google 可以 RTFM。我要写的一定是以体系化的，而且要能直达技术的本质。入行这 20 年来，我最擅长的就是架构和开发各种大规模的系统，所以，我会有 2-3 个和分布式系统相关的系列文章。&lt;/p>
&lt;p>我学过也用过好多编程语言，所以，也会有一系列的关于编程本质的文章。而我对一些基础知识研究得也比较多，所以，还会有一系列与基础知识相关的文章。&lt;/p>
&lt;p>当然，其中还会穿插一些其它的技术文章，比如一些热点事件，还有一些经验之谈，包括我会把我的《程序员技术练级攻略》在这个专栏里重新再写一遍。这些东西一定会让你有醍醐灌顶的感觉。&lt;/p>
&lt;h1 id="成长">成长&lt;/h1>
&lt;p>在过去这 20 年中，我感觉到，很多人都非常在意自己的成长。所以，我会分享一堆我亲身经历的，也是我自己实验的与个人发展相关的文章。&lt;/p>
&lt;p>比如，如何利用技术变现、如何面试、如何选择新的技术、如何学习、如何管理自己的时间、如何管理自己的老板和工作、如何成为一个 Leader&amp;hellip;&amp;hellip;这些东西一定会对你有用。（但是，我这里一定不会有速成的东西。一切都是要花时间和精力的。如果你想要速成，你不应该来订阅我的专栏。）&lt;/p>
&lt;h1 id="管理">管理&lt;/h1>
&lt;p>这 20 年，我觉得做好技术工作的前提是，得做好技术的管理工作。只有管理好了软件工程和技术团队，技术才能发挥出最大的潜力。大多数的技术问题都是管理上的问题。&lt;/p>
&lt;p>所以，我会写上一系列的和管理相关的文章，涵盖管理三个要素：团队、项目和管理者自己。比如，人员招聘、绩效考核、提升士气、解决冲突、面对变化、沟通说服、项目管理、任务排期、会议、远程管理，等等。&lt;/p>
&lt;p>这些内容都是我在外企工作时，接受到的世界顶级管理培训机构培训内容，我会把我的实践写出来分享给你。这其中一定少不了亚马逊相关的各种实践。这些东西，我和很多公司和大佬都讲过，到目前为止还没有人不赞的。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/7f/7b/7f428c8dd8f26668a727bd46227ec17b.jpg" alt="">&lt;/p>
&lt;p>为了对付费用户负责，保证文章能够达到收费的质量，我承诺这个专栏的每一篇文章一定是用心创作的，而且是可以让你从中受益的。&lt;/p>
&lt;p>但因为是第一次做全年专栏，收费也让我有一定的压力，所以，我非常希望你能够跟我分享你的感受和体会。&lt;/p>
&lt;p>我会根据你的反馈及时做出调整和修正，并不断努力提高文章的质量和思想高度，以满足你对有价值、有营养的文章的需求。&lt;/p></description></item><item><title>极客专栏: 01丨程序员如何用技术变现（上）</title><link>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E/01%E4%B8%A8%E7%A8%8B%E5%BA%8F%E5%91%98%E5%A6%82%E4%BD%95%E7%94%A8%E6%8A%80%E6%9C%AF%E5%8F%98%E7%8E%B0%E4%B8%8A/</link><pubDate>Fri, 27 May 2022 00:00:00 +0000</pubDate><guid>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E/01%E4%B8%A8%E7%A8%8B%E5%BA%8F%E5%91%98%E5%A6%82%E4%BD%95%E7%94%A8%E6%8A%80%E6%9C%AF%E5%8F%98%E7%8E%B0%E4%B8%8A/</guid><description>
&lt;p>程序员用自己的技术变现，其实是一件天经地义的事儿。写程序是一门&amp;quot;手艺活儿&amp;quot;，那么作为手艺人，程序员当然可以做到靠自己的手艺和技能养活自己。&lt;/p>
&lt;p>然而，现在很多手艺人程序员却说自己是&amp;quot;码农&amp;quot;，编码的农民工，在工作上被各种使唤，各种加班，累得像个牲口。在职业发展上各种迷茫和彷徨，完全看不到未来的希望，更别说可以成为一个手艺人用自己的技能变现了。&lt;/p>
&lt;p>从大学时代帮人打字挣点零花钱，到逐渐通过自己的技能帮助别人，由此获得相对丰厚的收入，我在很早就意识到，从事编程这个事可以做到，完全靠自己的手艺、不依赖任何人或公司去生活的。&lt;/p>
&lt;p>这对于程序员来说，本就应该是件天经地义的事，只是好像并不是所有的程序员都能意识到自己的价值。这里，我想结合我的一些经历来跟你聊聊。当然，我的经历有限，也不一定全对，只希望能给你一个参考。&lt;/p>
&lt;h1 id="学生时代">学生时代&lt;/h1>
&lt;p>我是 1994 年上的大学，计算机科学软件专业。在 1996 年上大二的时候，因为五笔学得好打字很快，我应征到教务处帮忙，把一些文档录入到电脑里。打了三个月的字，学校按照每千字 10 元，给了我 1000 元钱。&lt;/p>
&lt;p>由于我的五笔越打越快，还会用 CCED 和 WPS 排版，于是引起了别人的注意，叫我帮忙去他的打字工作室，一个月收入 400 元。我的大学是在昆明上的，这相当于那会当地收入的中上水平了。&lt;/p>
&lt;p>后来，1997 年的时候，我帮一个开公司的老师写一些 MIS 软件，用 Delphi 和 PowerBuilder 写一些办公自动化和酒店管理的软件。一年后，老师给了我 2000 元钱。&lt;/p>
&lt;p>因为动手能力比较强，当时系上的老师要干个什么事都让我帮忙。而且，因为当时的计算机人才太少太少了，所以一些社会上的人需要开发软件或是解决技术问题也都会到大学来。基本上老师们也都推荐给我。&lt;/p>
&lt;p>还记得 1997 年老师推荐一个人来找我，问我会不会做网页？5 个静态页，10000 元钱。当时学校没教怎样做网页，我去书店找书看，结果发现书店里一本讲 HTML 的书都没有，只好回绝说&amp;quot;不会做&amp;quot;。一年后，我才发现原来这事简单得要命。&lt;/p>
&lt;h1 id="初入职场">初入职场&lt;/h1>
&lt;p>到了 1998 年，我毕业参加工作，在工商银行网络科。由于可以拨号上网，于是我做了一个个人主页，那时超级流行个人主页或个人网站。我一边收集网上的一些知识，一边学着做些花哨的东西，比如网页上的菜单什么的。&lt;/p>
&lt;p>在 2000 年时，机缘巧合我的网站被《电脑报》的编辑看到了，他写来邮件约我投稿。我就写了一些如何在网页上做菜单之类的小技术文章，每个月写个两三篇，这样每个月就有 300 元左右的稿费，当时我的月工资是 600 元。&lt;/p>
&lt;p>现在通过文章标题还能找到一两篇，比如《&lt;a href="http://www.yesky.com/251/142751all.shtml">抽屉式菜单的设计&lt;/a>》，已经是乱码一堆了。&lt;/p>
&lt;p>大学时代被人请去做事的经历对我影响很大，甚至在潜意识里完全影响了我如何规划自己的人生。虽然当时我还说不清楚，只是一种强烈的感觉&amp;mdash;&amp;mdash;我完全可以靠自己的手艺、不依赖任何人或公司去生活。&lt;/p>
&lt;p>我想这种感觉，我现在可以说清楚了，这种潜意识就是&amp;mdash;&amp;mdash;&lt;strong>我完全没有必要通过打工听人安排而活着，而是反过来通过在公司工作提高自己的技能，让自己可以更为独立和自由地生活&lt;/strong>。&lt;/p>
&lt;p>因而，在工作当中，对于那些没什么技术含量的工作，我基本上就像是在学生时代那样交作业就好了。我想尽一切方法提高交作业的效率，比如，提高代码的重用度，能自动化的就自动化，和需求人员谈需求，简化掉需求，这样我就可以少干一些活了&amp;hellip;&amp;hellip;&lt;/p>
&lt;p>这样一来，&lt;strong>我就可以有更多的时间，去研究公司里外那些更为核心更有技术含量的技术了&lt;/strong>。&lt;/p>
&lt;p>在工作中，我总是能被别人和领导注意到，总是有比别人更多的时间去读书，去玩一些高技术含量的技术。当然，这种被&amp;quot;注意&amp;quot;，也不全然是一种好事。&lt;/p>
&lt;p>2002 年，我被外包到银行里做业务开发时，因为我完成项目的速度太快，所以，没事干，整天在用户那边看书，写别的代码练手，而被用户投诉&amp;quot;不务正业&amp;quot;。我当然对这样的投诉置之不理，还是我行我素，因为我的作业已交了，所以用户也就是说说罢了。&lt;/p>
&lt;p>同年，我到了一家新的很有技术含量的公司，他们在用 C 语言写一个可以把一堆 PC 机组成一个超级计算机，进行并行计算的公司项目。&lt;/p>
&lt;p>当我做完第一个项目时，有个公司里的牛人和我说，你用 Purify 测试一下你的代码有没有内存问题。Purify 是以前一个叫 Rational 的公司（后来被 IBM 收购）做的一个神器，有点像 Linux 开源的 Valgrind。&lt;/p>
&lt;p>用完以后，我觉得 Purify 太厉害了，于是把它的英文技术文档通读了一遍。经理看我很喜欢这个东西，就让我给公司里的人做个分享。我认真地准备了个 PPT，结果只来了一个 QA。&lt;/p>
&lt;p>我在一个大会议室就对着她一个人讲了一个半小时。这个 QA 对我说，&amp;ldquo;你的分享做得真好，条理性很强，也很清楚，我学到了很多东西&amp;rdquo;。&lt;/p>
&lt;p>有了这个正向反馈，我就把关于 Purify 的文章分享到了我的 CSDN 博客上，标题为《&lt;a href="http://blog.csdn.net/haoel/article/details/2900">C/C++ 内存问题检查利器&amp;mdash;Purify&lt;/a>》。可能因为这个软件是收费的，用的人不多，这篇文章的读者反响并不大。&lt;/p>
&lt;p>但是，2003 年的一天我很意外地接到了一个电话，是一个公司请我帮忙去给客户培训 Purify 这个软件。IBM 的培训太贵了，所以代理这个软件的公司为了成本问题，想找一个便宜的讲师。&lt;/p>
&lt;p>他们搜遍整个中国的互联网，只看到我的这篇文章，便通过 CSDN 找到我的联系方式，给我打了电话。最终，两天的培训价格税后一共 10000 元，而我当时的月薪只有 6000 元，还是税前。&lt;/p>
&lt;p>这件事儿让我在入行的时候就明白了一些道理。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>要去经历大多数人经历不到的，要把学习时间花在那些比较难的地方。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>要写文章就要写没有人写过的，或是别人写过，但我能写得更好的。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>更重要的是，技术和知识完全是可以变现的。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>现在回想一下，技术和知识变现这件事儿，在 15 年前我就明白了，哈哈。&lt;/p>
&lt;p>随后，我在 CSDN 博客上发表了很多文章，有谈 C 语言编程修养的文章，也有一些 makefile/gdb 手册性的文章，还有在工作中遇到的各种坑。&lt;/p>
&lt;p>因为我分享的东西比较系统，也是独一份，所以，搜索引擎自然是最优化的（最好的 SEO 就是独一份）。我的文章经常因为访问量大被推到 CSDN 首页。因此，引来了各种培训公司和出版社，还有一些别的公司主动发来的招聘，以及其他一些程序员想伙同创业的各种信息。&lt;/p>
&lt;p>紧接着我了解到，出书作者收入太低（作者的收入有两种：一种是稿费，一页 30 元；一种是版税，也就 5% 左右），而培训公司的投入产出比明显高很多后，于是我开始接一些培训的事（频率不高），一年有个七八次。当时需求比较强的培训主要是在这几个技术方面，C/C++/Java、Unix 系统编程、多层软件架构、软件测试、软件工程等。&lt;/p>
&lt;p>我喜欢做企业内训，还有一个主要原因是，可以走到内部去了解各个企业在做的事和他们遇到的技术痛点，以及身在其中的工程师的想法。这极大地增加了我对社会的了解和认识。而同时，让我这个原本不善表达的技术人员，在语言组织和表达方面有了极大的提升。&lt;/p>
&lt;p>其间也有一些软件开发的私活儿，但我基本全部拒绝了。最主要的原因是，这些软件开发基本上都是功能性的开发，我从中无法得到成长。而且后期会有很多维护工作，虽然一个小项目可以挣十几万，但为此花费的时间都是我人生中最宝贵的时光，得不偿失。&lt;/p>
&lt;p>&lt;strong>25~35 岁是每个人最宝贵的时光，应该用在刀刃上&lt;/strong>。&lt;/p>
&lt;h1 id="职业上升期">职业上升期&lt;/h1>
&lt;p>因为有了这些经历，我感受到了一个人知识和技能的价值。我开始把我的时间投在一些主流、高级和比较有挑战性的技术上，这可以让我保持两件事儿：一个是技术和技能的领先，二是对技术本质和趋势的敏感度。&lt;/p>
&lt;p>因此，我有强烈的意愿去前沿的公司经历和学习这些东西。比如，我在汤森路透学到了人员团队管理上的各种知识和技巧，而亚马逊是让我提升最快的公司。虽说，亚马逊也有很多不好的东西，但是它的一些理念，的确让我的思维方式和思考问题的角度有了质的飞跃。&lt;/p>
&lt;p>所以后来，我开始对外输出的不仅仅是技术了，还有一些技术价值观上的东西。&lt;/p>
&lt;p>而从亚马逊到阿里巴巴是我在互联网行业的工作经历，这两段经历让我对这两家看似类似但内部完全不同的成功大公司，有了更为全面的了解和看法。&lt;/p>
&lt;p>这两种完全不一样甚至有些矛盾的玩法让我时常在思考着，大脑里就像两个小人在扳手腕一样，这可能是我从小被灌输的&amp;quot;标准答案&amp;quot;的思维方式所致。其实，这个世界本来就没什么标准答案，或是说，一个题目本来就可以有若干个正确答案，而且这些&amp;quot;正确答案&amp;quot;还很矛盾。&lt;/p>
&lt;p>于是，在我把一些价值观和思考记录下来的同时，我自然又被很多人关注到了，还吸引很多不同的思路在其中交织讨论。而从另外一方面来说，这对我来说是一个很好地补充，无论别人骂我也好，教育我也罢，他们都对我有帮助，大大地丰富了我思考问题的角度。&lt;/p>
&lt;p>这些经历从质上改善了我的思考方式，让我思考技术问题的角度都随之有了一个比较大的转变。而这个转变让我有了更高的思维高度和更为开阔的视野。&lt;/p>
&lt;p>可能是因为我有一些&amp;quot;独特&amp;quot;的想法，而且经历比较丰富，基础也比较扎实，使得我对技术人的认识和理解会更为透彻和深入。所以，也有了一些小名气。来找我做咨询和帮助解决问题的人越来越多，而我也开始收费收得越来越贵了。这里需要注意的是，我完全是被动收费高的。&lt;/p>
&lt;p>因为父亲的身体原因，我没有办法全职，所以成了一个自由人。而也正因如此，我才得以有机会可以为更多公司解决技术问题。2015 年，有家公司的后端系统一推广就挂，性能有问题，请我去看。&lt;/p>
&lt;p>我花了两天时间跟他们的工程师一起简单处理了一下，直接在生产线上重构，性能翻了 10 倍。虽然这么做有点 low，但当时完全是为了救急。公司老板很高兴，觉得他投的几百万推广费用有救了，一下给了我 10 万元。我说不用这么多的，1 万元就好了，结果他说就是这么多。&lt;strong>我欣然接受了，当时心里有一种技术被尊重的感动&lt;/strong>。&lt;/p>
&lt;p>2016 年，某个公司需要做一个高并发方案，大概需要 2000 万 QPS，但是他们只能实现到 1200 万 QPS 左右。&lt;/p>
&lt;p>我花了两天时间做调研，分析性能原因，然后一天写了 700 多行代码。因为不想进入业务，所以我主要是优化了网络数据传输，让数据包尽量小，确保一个请求的响应在一个 MTU 内就传完。&lt;/p>
&lt;p>测试的时候，达到了 2500 万 QPS。于是老板给了我 20 万。&lt;/p>
&lt;p>这样的例子还有很多。上面的例子，我连钱都没谈就去做了，本来想着，也就最多 1 万元左右，没想到给我的酬劳大大超出了我的期望。&lt;/p>
&lt;p>这里，我想说的是，&lt;strong>并不是社会不尊重程序员，只要你能帮上大忙，就一定会赢得别人的尊重&lt;/strong>。&lt;/p>
&lt;p>所以，我和一些人开玩笑说，&lt;strong>我们可能都是在写一样的 for(int i=0; i&amp;lt;n; i++) 语句，但是，你写在那个地方一文不值，而我写在这个地方，这行代码就值 2000 元&lt;/strong>。不要误会，我只是想用这种&amp;quot;鲜明的对比方式&amp;quot;来加强我的观点。&lt;/p>
&lt;p>上面就是我这 20 年来的经历。相信这类经历你也有过，或者你正在经历中，欢迎你也分享一下自己的经历和心得。&lt;/p>
&lt;p>那么，怎样能让自己的技术被尊重？如何通过技术和技能赚钱？下一篇文章中，我将对此做一些总结，希望对你有帮助。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/fc/e9/fcc761001867c60f526665e237f831e9.jpg" alt="">&lt;/p></description></item><item><title>极客专栏: 02丨程序员如何用技术变现（下）</title><link>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E/02%E4%B8%A8%E7%A8%8B%E5%BA%8F%E5%91%98%E5%A6%82%E4%BD%95%E7%94%A8%E6%8A%80%E6%9C%AF%E5%8F%98%E7%8E%B0%E4%B8%8B/</link><pubDate>Fri, 27 May 2022 00:00:00 +0000</pubDate><guid>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E/02%E4%B8%A8%E7%A8%8B%E5%BA%8F%E5%91%98%E5%A6%82%E4%BD%95%E7%94%A8%E6%8A%80%E6%9C%AF%E5%8F%98%E7%8E%B0%E4%B8%8B/</guid><description>
&lt;p>我不算是聪明的人，经历也不算特别成功，但一步一步走来，我认为，我能做到的，你一定也能做到，而且应该还能做得比我更好。&lt;/p>
&lt;h1 id="如何让自己的技能变现">如何让自己的技能变现&lt;/h1>
&lt;p>还是那句话，本质上来说，程序员是个手艺人，有手艺的人就能做出别人做不出来的东西，而付费也是一件很自然的事了。那么，这个问题就变成如何让自己的&amp;quot;手艺&amp;quot;更为值钱的问题了。&lt;/p>
&lt;p>第一，&lt;strong>千里之行，积于跬步&lt;/strong>。任何一件成功的大事，都是通过一个一个的小成功达到的。所以，你得确保你有一个一个的小成功。&lt;/p>
&lt;p>具体说来，首先，你得让自己身边的人有求于你，或是向别人推荐你。这就需要你能够掌握大多数人不能掌握的技能或技术，需要你更多地学习，并要有更多的别人没有的经验和经历。&lt;/p>
&lt;p>一旦你身边的人开始有求于你，或是向别人推荐你，你就会被外部的人注意到，于是其他人就会付费来获取你的帮助。而一旦你的帮忙对别人来说有效果，那就会产生效益，无论是经济效益还是社会效益，都会为你开拓更大的空间。&lt;/p>
&lt;p>你也会因为这样的正向反馈而鼓励自己去学习和钻研更多的东西，从而得到一个正向的循环。而且这个正向循环，一旦开始就停不下来了。&lt;/p>
&lt;p>第二，&lt;strong>关注有价值的东西&lt;/strong>。什么是有价值的东西？价值其实是受供需关系影响的，供大于求，就没什么价值，供不应求，就有价值。这意味着你不仅要看到市场，还要看到技术的趋势，能够分辨出什么是主流技术，什么是过渡式的技术。当你比别人有更好的嗅觉时，你就能启动得更快，也就比别人有先发优势。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>关于市场需求&lt;/strong>。你要看清市场，就需要看看各个公司都在做什么，他们的难题是什么。简单来说，现在的每家公司无论大小都缺人。但是真的缺人吗？中国是人口大国，从不缺少写代码搬砖的人，真正缺的其实是有能力能够解决技术难题的人，能够提高团队人效的人。所以，从这些方面思考，你会知道哪些技能才是真正的&amp;quot;供不应求&amp;quot;，这样可以让你更有价值。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>关于技术趋势&lt;/strong>。要看清技术趋势，你需要了解历史，就像一个球运动一样，你要知道这个球未来运动的地方，是需要观察球的已经完成运动的轨迹才知道的。因此，了解技术发展轨迹是一件很重要的事。要看一个新的技术是否顺应技术发展趋势，你需要将一些老技术的本质吃得很透。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>因此，在学习技术的过程一定要多问自己两个问题：&amp;ldquo;一，这个技术解决什么问题？为什么别的同类技术做不到？二，为什么是这样解决的？有没有更好的方式？&amp;ldquo;另外，还有一个简单的判断方法，如果一个新的技术顺应技术发展趋势，那么在这个新的技术出现时，后面一定会有大型的商业公司支持，这类公司支持得越多，就说明你越需要关注。&lt;/p>
&lt;p>第三，&lt;strong>找到能体现价值的地方&lt;/strong> 。&lt;strong>在一家高速发展的公司中，技术人员的价值可以达到最大化&lt;/strong>。&lt;/p>
&lt;p>试想，在一家大公司中，技术架构和业务已经定型，基本上没有什么太多的事可以做的。而且对于已经发展起来的大公司来说，往往稳定的重要性超过了创新。此外，大公司的高级技术人员很多，多你一个不多，少你一个不少，所以你的价值很难被体现出来。&lt;/p>
&lt;p>而刚起步的公司，业务还没有跑顺，公司的主要精力会放在业务拓展上，这个时候也不太需要高精尖的技术，所以，技术人员的价值也体现不出来。&lt;/p>
&lt;p>只有那些在高速发展的公司，技术人员的价值才能被最大化地体现出来。比较好的成长路径是，先进入大公司学习大公司的技术和成功的经验方法，然后再找到高速成长的公司，这样你就可以实现自己更多的价值。当然，这里并不排除在大公司中找到高速发展的业务。&lt;/p>
&lt;p>第四，&lt;strong>动手能力很重要&lt;/strong>。成为一个手艺人，动手能力是很重要的，因为在解决任何一个具体问题的时候，有没有动手能力就成为了关键。这也是我一直在写代码的原因，代码里全是细节，细节是魔鬼，只有了解了细节，你才能提出更好或是更靠谱、可以落地的解决方案。而不是一些笼统和模糊的东西。这太重要了。&lt;/p>
&lt;p>第五，&lt;strong>关注技术付费点&lt;/strong> 。技术付费点基本体现在两个地方，&lt;strong>一个是，能帮别人&amp;quot;挣钱&amp;quot;的地方；另一个是，能帮别人&amp;quot;省钱&amp;quot;的地方&lt;/strong>。也就是说，能够帮助别人更流畅地挣钱，或是能够帮助别人提高效率，能节省更多的成本，越直接越好。而且这个技术或解决方案最好还是大多数人做不到的。&lt;/p>
&lt;p>第六，&lt;strong>提升自己的能力和经历&lt;/strong>。付费的前提是信任，只有你提升自己的能力和经历后，别人才会对你有一定的信任，才会觉得你靠谱，才会给你机会。而这个信任需要用你的能力和经历来填补。比如，你是一个很知名的开源软件的核心开发人员，或是你是某知名公司核心项目的核心开发人员，等等。&lt;/p>
&lt;p>第七，&lt;strong>找到有价值的信息源&lt;/strong>。信息社会，如果你比别人有更好的信息源，那么你就可以比别人成长得更快。对于技术人员来说，我们知道，几乎所有的技术都源自西方世界，所以，你应该走到信息的源头去。&lt;/p>
&lt;p>如果你的信息来自朋友圈、微博、知乎、百度或是今日头条，那么我觉得你完蛋了。因为这些渠道有价值的信息不多，有营养的可能只有 1%，而为了这 1%，你需要读完 99% 的信息，太不划算了。&lt;/p>
&lt;p>那么如何找到这些信息源呢？用好 Google 就是一个关键，比如你在 Google 搜索引擎里输入&amp;quot;XXX Best Practice&amp;rdquo;，或是&amp;quot;Best programming resource&amp;rdquo;&amp;hellip;&amp;hellip;你就会找到很多。而用好这个更好的信息源需要你的英文能力，因此不断提升英文能力很关键。&lt;/p>
&lt;p>第八，&lt;strong>输出观点和价值观&lt;/strong>。真正伟大的公司或是产品都是要输出价值观的。只有输出了更先进的价值观，才会获得真正的影响力。但是，你要能输出观点和价值观，并不是一件容易的事，这需要你的积累和经历，而不是一朝之功。因此，如果想要让你的技能变现，这本质上是一个厚积薄发的过程。&lt;/p>
&lt;p>第九，&lt;strong>朋友圈很重要&lt;/strong>。一个人的朋友圈很重要，你在什么样的朋友圈，就会被什么样的朋友圈所影响。如果你的朋友圈比较优质，那么给你介绍过来的事儿和活儿也会好一些。&lt;/p>
&lt;p>优质的朋友圈基本上都有这样的特性。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>这些人都比较有想法、有观点，经验也比较丰富；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>这些人涉猎的面比较广；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>这些人都有或多或少的成功；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>这些人都是喜欢折腾喜欢搞事的人；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>这些人都对现状有些不满，并想做一些改变；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>这些人都有一定的影响力。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>最后有个关键的问题是，物以类聚，人以群分。如果你不做到这些，你怎么能进入到这样的朋友圈呢？&lt;/p>
&lt;p>总之，就一句话，&lt;strong>会挣钱的人一定是会投资的人&lt;/strong> 。我一直认为，&lt;strong>最宝贵的财富并不是钱，而是你的时间，时间比钱更宝贵，因为钱你不用还在那里，而时间你不用就浪费掉了。你把你的时间投资在哪些地方，就意味着你未来会走什么样的路。所以，利用好你的时间，投到一些有意义的地方吧&lt;/strong>。&lt;/p>
&lt;p>我的经历有限，只能看到这些，还希望大家一起来讨论，分享你的经验和心得，也让我可以学习和提高。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/fc/e9/fcc761001867c60f526665e237f831e9.jpg" alt="">&lt;/p></description></item><item><title>极客专栏: 03丨Equifax信息泄露始末</title><link>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E/03%E4%B8%A8equifax%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2%E5%A7%8B%E6%9C%AB/</link><pubDate>Fri, 27 May 2022 00:00:00 +0000</pubDate><guid>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E/03%E4%B8%A8equifax%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2%E5%A7%8B%E6%9C%AB/</guid><description>
&lt;p>相信你一定有所耳闻，9 月份美国知名征信公司 Equifax 出现了大规模数据泄露事件，致使 1.43 亿美国用户及大量的英国和加拿大用户受到影响。今天，我就来跟你聊聊 Equifax 信息泄露始末，并对造成本次事件的原因进行简单的分析。&lt;/p>
&lt;h1 id="equifax-信息泄露始末">Equifax 信息泄露始末&lt;/h1>
&lt;p>Equifax 日前确认，黑客利用了其系统中未修复的 Apache Struts 漏洞（CVE-2017-5638，2017 年 3 月 6 日曝光）来发起攻击，导致了最近这次影响恶劣的大规模数据泄露事件。&lt;/p>
&lt;p>作为美国三大信用报告公司中历史最悠久的一家，Equifax 的主营业务是为客户提供美国、加拿大和其他多个国家的公民信用信息。保险公司就是其服务的主要客户之一，涉及生命、汽车、火灾、医疗保险等多个方面。&lt;/p>
&lt;p>此外，Equifax 还提供入职背景调查、保险理赔调查，以及针对企业的信用调查等服务。由于 Equifax 掌握了多个国家公民的信用档案，包括公民的学前、学校经历、婚姻、工作、健康、政治参与等大量隐私信息，所以这次的信息泄露，影响面积很大，而且性质特别恶劣。&lt;/p>
&lt;p>受这次信息泄露影响的美国消费者有 1.43 亿左右，另估计约有 4400 万的英国客户和大量加拿大客户受到影响。事件导致 Equifax 市值瞬间蒸发掉逾 30 亿美元。&lt;/p>
&lt;p>根据《华尔街日报》（The Wall Street Journal）的观察，自 Equifax 在 9 月 8 日披露黑客进入该公司部分系统以来，全美联邦法院接到的诉讼已经超过百起。针对此次事件，Equifax 首席执行官理查德·史密斯（Richard Smith）表示，公司正在对整体安全操作进行全面彻底的审查。&lt;/p>
&lt;p>事件发生之初，Equifax 在声明中指出，黑客是利用了某个&amp;quot;U.S. website application&amp;quot;中的漏洞获取文件。后经调查，黑客是利用了 Apache Struts 的 CVE-2017-5638 漏洞。&lt;/p>
&lt;p>戏剧性的是，该漏洞于今年 3 月份就已被披露，其危险系数定为最高分 10 分，Apache 随后发布的 Struts 2.3.32 和 2.5.10.1 版本特针对此漏洞进行了修复。而 Equifax 在漏洞公布后的两个月内都没有升级 Struts 版本，导致 5 月份黑客利用这个漏洞进行攻击，泄露其敏感数据。&lt;/p>
&lt;p>事实上，除了 Apache 的漏洞，黑客还使用了一些其他手段绕过 WAF（Web 应用程序防火墙）。有些管理面板居然位于 Shodan 搜索引擎上。更让人大跌眼镜的是，据研究人员分析，Equifax 所谓的&amp;quot;管理面板&amp;quot;都没有采取任何安保措施。安全专家布莱恩·克雷布斯（Brian Krebs）在其博客中爆料，Equifax 的一个管理面板使用的用户名和密码都是&amp;quot;admin&amp;quot;。&lt;/p>
&lt;p>由于管理面板能被随意访问，获取数据库密码就轻而易举了&amp;mdash;&amp;mdash;虽然管理面板会加密数据库密码之类的东西，但是密钥却和管理面板保存在了一起。虽然是如此重要的征信机构，但 Equifax 的安全意识之弱可见一斑。&lt;/p>
&lt;p>据悉，Equifax 某阿根廷员工门户也泄露了 14000 条记录，包括员工凭证和消费者投诉。本次事件发生后，好事者列举了 Equifax 系统中的一系列漏洞，包括一年以前向公司报告的未修补的跨站脚本（XSS）漏洞，更将 Equifax 推向了风口浪尖。&lt;/p>
&lt;h1 id="apache-struts-漏洞相关">Apache Struts 漏洞相关&lt;/h1>
&lt;p>Apache Struts 是世界上最流行的 Java Web 服务器框架之一，它最初是 Jakarta 项目中的一个子项目，并在 2004 年 3 月成为 Apache 基金会的顶级项目。&lt;/p>
&lt;p>Struts 通过采用 Java Servlet/JSP 技术，实现了基于 Java EE Web 应用的 MVC 设计模式的应用框架，也是当时第一个采用 MVC 模式的 Web 项目开发框架。随着技术的发展和认知的提升，Struts 的设计者意识到 Struts 的一些缺陷，于是有了重新设计的想法。&lt;/p>
&lt;p>2006 年，另外一个 MVC 框架 WebWork 的设计者与 Struts 团队一起开发了新一代的 Struts 框架，它整合了 WebWork 与 Struts 的优点，同时命名为&amp;quot;Struts 2&amp;quot;，原来的 Struts 框架改名为 Struts 1。&lt;/p>
&lt;p>因为两个框架都有强大的用户基础，所以 Struts 2 一发布就迅速流行开来。在 2013 年 4 月，Apache Struts 项目团队发布正式通知，宣告 Struts 1.x 开发框架结束其使命，并表示接下来官方将不会继续提供支持。自此 Apache Struts 1 框架正式退出历史舞台。&lt;/p>
&lt;p>同期，Struts 社区表示他们将专注于推动 Struts 2 框架的发展。从这几年的版本发布情况来看，Struts 2 的迭代速度确实不慢，仅仅在 2017 年就发布了 9 个版本，平均一个月一个。&lt;/p>
&lt;p>但从安全角度来看，Struts 2 可谓是漏洞百出，因为框架的功能基本已经健全，所以这些年 Struts 2 的更新和迭代基本也是围绕漏洞和 Bug 进行修复。仅从官方披露的安全公告中就可以看到，这些年就有 53 个漏洞预警，包括大家熟知的远程代码执行高危漏洞。&lt;/p>
&lt;p>根据网络上一份未被确认的数据显示，中国的 Struts 应用分布在全球范围内排名第一，第二是美国，然后是日本，而中国没有打补丁的 Struts 的数量几乎是其它国家的总和。特别是在浙江、北京、广东、山东、四川等地，涉及教育、金融、互联网、通信等行业。&lt;/p>
&lt;p>所以在今年 7 月，国家信息安全漏洞共享平台还发布过关于做好 Apache Struts 2 高危漏洞管理和应急工作的安全公告，大致意思是希望企业能够加强学习，提高安全认识，同时完善相关流程，协同自律。&lt;/p>
&lt;p>而这次 Equifax 中招的漏洞编号是 CVE-2017-5638，官方披露的信息见下图。简单来说，这是一个 RCE 的远程代码执行漏洞，最初是被安恒信息的 Nike Zheng 发现的，并于 3 月 7 日上报。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/00/cc/009ecfbac5741ea7ffd7fa3079a8c8cc.png" alt="">&lt;/p>
&lt;p>从介绍中可以看出，此次漏洞的原因是 Apache Struts 2 的 Jakarta Multipart parser 插件存在远程代码执行漏洞，攻击者可以在使用该插件上传文件时，修改 HTTP 请求头中的 Content-Type 值来触发漏洞，最后远程执行代码。&lt;/p>
&lt;p>说白了，就是在 Content-Type 注入 OGNL 语言，进而执行命令。代码如下（一行 Python 命令就可以执行服务器上的 shell 命令）：&lt;/p>
&lt;pre>&lt;code>import requests
requests.get(&amp;quot;https://target&amp;quot;, headers={&amp;quot;Connection&amp;quot;: &amp;quot;close&amp;quot;, &amp;quot;Accept&amp;quot;: &amp;quot;*/*&amp;quot;, &amp;quot;User-Agent&amp;quot;: &amp;quot;Mozilla/5.0&amp;quot;, &amp;quot;Content-Type&amp;quot;: &amp;quot;%{(#_='multipart/form-data').(#dm=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS).(#_memberAccess?(#_memberAccess=#dm):((#container=#context['com.opensymphony.xwork2.ActionContext.container']).(#ognlUtil=#container.getInstance(@com.opensymphony.xwork2.ognl.OgnlUtil@class)).(#ognlUtil.getExcludedPackageNames().clear()).(#ognlUtil.getExcludedClasses().clear()).(#context.setMemberAccess(#dm)))).(#cmd='dir').(#iswin=(@java.lang.System@getProperty('os.name').toLowerCase().contains('win'))).(#cmds=(#iswin?{'cmd.exe','/c',#cmd}:{'/bin/bash','-c',#cmd})).(#p=new java.lang.ProcessBuilder(#cmds)).(#p.redirectErrorStream(true)).(#process=#p.start()).(#ros=(@org.apache.struts2.ServletActionContext@getResponse().getOutputStream())).(@org.apache.commons.io.IOUtils@copy(#process.getInputStream(),#ros)).(#ros.flush())}&amp;quot;})
&lt;/code>&lt;/pre>
&lt;p>在 GitHub 上有相关的代码，链接为：&lt;a href="https://github.com/mazen160/struts-pwn">https://github.com/mazen160/struts-pwn&lt;/a> 或 &lt;a href="https://github.com/xsscx/cve-2017-5638">https://github.com/xsscx/cve-2017-5638&lt;/a>&lt;/p>
&lt;p>注入点是在 JakartaMultiPartRequest.java 的 buildErrorMessage 函数中，这个函数里的 localizedTextUtil.findText 会执行 OGNL 表达式，从而导致命令执行（注：可以参看 Struts 两个版本的补丁&amp;quot;2.5.10.1 版补丁&amp;quot;&amp;ldquo;2.3.32 版补丁&amp;rdquo;），使客户受到影响。&lt;/p>
&lt;p>因为默认情况下 Jakarta 是启用的，所以该漏洞的影响范围甚广。当时官方给出的解决方案是尽快升级到不受影响的版本，看来 Equifax 的同学并没有注意到，或者也没有认识到它的严重性。&lt;/p>
&lt;p>另外，在 9 月 5 日和 7 日，Struts 官方又接连发布了几个严重级别的安全漏洞公告，分别是 CVE-2017-9804、CVE-2017-9805、CVE-2017-9793 和 CVE-2017-12611。&lt;/p>
&lt;p>这里面最容易被利用的当属 CVE-2017-9805，它是由国外安全研究组织 lgtm.com 的安全研究人员发现的又一个远程代码执行漏洞。漏洞原因是 Struts 2 REST 插件使用带有 XStream 程序的 XStream Handler 进行未经任何代码过滤的反序列化操作，所以在反序列化 XML payloads 时就可能导致远程代码执行。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/f8/02/f8a10b42faf789018e0a5dfadbbd0c02.png" alt="">&lt;/p>
&lt;p>不过在 Apache 软件基金会的项目管理委员会的回应文章中，官方也对事故原因进行了分析和讨论。首先，依然不能确定泄露的源头是 Struts 的漏洞导致的。其次，如果确实是源于 Struts 的漏洞，那么原因&amp;quot;或是 Equifax 服务器未打补丁，使得一些更早期公布的漏洞被攻击者利用，或者是攻击者利用了一个目前尚未被发现的漏洞&amp;quot;。&lt;/p>
&lt;p>根据推测，该声明提出黑客所使用的软件漏洞可能就是 CVE-2017-9805 漏洞，该漏洞虽然是在 9 月 4 日才由官方正式公布，但早在 7 月时就有人公布在网络上了，并且这个漏洞的存在已有 9 年。&lt;/p>
&lt;p>相信通过今天的分享，你一定对 Equifax 的数据泄露始末及造成原因有了清楚的了解。欢迎您把你的收获和想法，分享给我。下篇文章中，我们将回顾一下互联网时代的! 其他大规模数据泄露事件，并结合这些事件给出应对方案和技术手段。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/fc/e9/fcc761001867c60f526665e237f831e9.jpg" alt="">&lt;/p></description></item><item><title>极客专栏: 04丨从Equifax信息泄露看数据安全</title><link>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E/04%E4%B8%A8%E4%BB%8Eequifax%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2%E7%9C%8B%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8/</link><pubDate>Fri, 27 May 2022 00:00:00 +0000</pubDate><guid>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E/04%E4%B8%A8%E4%BB%8Eequifax%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2%E7%9C%8B%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8/</guid><description>
&lt;p>上篇文章中，我们讲了 Equifax 信息泄露始末，并对造成此次事件的漏洞进行了分析。今天，我们就来回顾一下互联网时代的其他几次大规模数据泄露事件，分析背后的原因，给出解决这类安全问题的技术手段和方法。&lt;/p>
&lt;h1 id="数据泄露介绍以及历史回顾">数据泄露介绍以及历史回顾&lt;/h1>
&lt;p>类似于 Equifax 这样的大规模数据泄露事件在互联网时代时不时地会发生。上一次如此大规模的数据泄露事件主角应该是雅虎。&lt;/p>
&lt;p>继 2013 年大规模数据泄露之后，雅虎在 2014 年又遭遇攻击，泄露出 5 亿用户的密码，直到 2016 年有人在黑市公开交易这些数据时才为大众所知。雅虎股价在事件爆出的第二天就下跌了 2.4%。而此次 Equifax 的股价下跌超过 30%，市值缩水约 53 亿。这让各大企业不得不警惕。&lt;/p>
&lt;p>类似的，LinkedIn 在 2012 年也泄露了 6500 万用户名和密码。事件发生后，LinkedIn 为了亡羊补牢，及时阻止被黑账户的登录，强制被黑用户修改密码，并改进了登录措施，从单步认证增强为带短信验证的两步认证。&lt;/p>
&lt;p>国内也有类似的事件。2014 年携程网安全支付日志存在漏洞，导致大量用户信息如姓名、身份证号、银行卡类别、银行卡号、银行卡 CVV 码等信息泄露。这意味着，一旦这些信息被黑客窃取，在网络上盗刷银行卡消费将易如反掌。&lt;/p>
&lt;p>如果说网络运维安全是一道防线，那么社会工程学攻击则可能攻破另一道防线&amp;mdash;&amp;mdash;人。2011 年，RSA 公司声称他们被一种复杂的网络攻击所侵害，起因是有两个小组的员工收到一些钓鱼邮件。邮件的附件是带有恶意代码的 Excel 文件。&lt;/p>
&lt;p>当一个 RSA 员工打开该 Excel 文件时，恶意代码攻破了 Adobe Flash 中的一个漏洞。该漏洞让黑客能用 Poison Ivy 远程管理工具来取得对机器的管理权，并访问 RSA 内网中的服务器。这次攻击主要威胁的是 SecurID 系统，最终导致了其母公司 EMC 花费 6630 万美元来调查、加固系统，并最终召回和重新分发了 30000 家企业客户的 SecurID 卡片。&lt;/p>
&lt;h1 id="数据泄露攻击">数据泄露攻击&lt;/h1>
&lt;p>以这些公司为例，我们来看看这些攻击是怎样实现的。&lt;/p>
&lt;ol>
&lt;li>
&lt;p>利用程序框架或库的已知漏洞。比如这次 Equifax 被攻击，就是通过 Apache Struts 的已知漏洞。RSA 被攻击，也利用了 Adobe Flash 的已知漏洞。还有之前的&amp;quot;心脏流血&amp;quot;也是使用了 OpenSSL 的漏洞&amp;hellip;&amp;hellip;&lt;/p>
&lt;/li>
&lt;li>
&lt;p>暴力破解密码。利用密码字典库或是已经泄露的密码来&amp;quot;撞库&amp;quot;。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>代码注入。通过程序员代码的安全性问题，如 SQL 注入、XSS 攻击、CSRF 攻击等取得用户的权限。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>利用程序日志不小心泄露的信息。携程的信息泄露就是本不应该能被读取的日志没有权限保护被读到了。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>社会工程学。RSA 被攻击，第一道防线是人&amp;mdash;&amp;mdash;RSA 的员工。只有员工的安全意识增强了，才能抵御此类攻击。其它的如钓鱼攻击也属于此类。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>然后，除了表面的攻击之外，窃取到的信息也显示了一些数据管理上的问题。&lt;/p>
&lt;ol>
&lt;li>
&lt;p>只有一层安全。Equifax 只是被黑客攻破了管理面板和数据库，就造成了数据泄露。显然这样只有一层安全防护是不够的。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>弱密码。Equifax 数据泄露事件绝对是管理问题。至少，密码系统应该不能让用户设置如此简单的密码，而且还要定期更换。最好的方式是通过数据证书、VPN、双因子验证的方式来登录。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>向公网暴露了内部系统。在公司网络管理上出现了非常严重的问题。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>对系统及时打安全补丁。监控业内的安全漏洞事件，及时做出响应，这是任何一个有高价值数据的公司都需要干的事。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>安全日志被暴露。安全日志往往包含大量信息，被暴露是非常危险的。携程的 CVV 泄露就是从日志中被读到的。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>保存了不必要保存的用户数据。携程保存了用户的信用卡号、有效期、姓名和 CVV 码，这些信息足以让人在网上盗刷信用卡。其实对于临时支付来说，这些信息完全可以不保存在磁盘上，临时在内存中处理完毕立即销毁，是最安全的做法。即便是快捷支付，也没有必要保存 CVV 码。安全日志也没有必要将所有信息都保存下来，比如可以只保存卡号后四位，也同样可以用于处理程序故障。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>密码没有被合理地散列。以现代的安全观念来说，以明文方式保存密码是很不专业的做法。进一步的是只保存密码的散列值（用安全散列算法），LinkedIn 就是这样做的。但是，散列一则需要用目前公认安全的算法（比如 SHA-2 256），而已知被攻破的算法则最好不要使用（如 MD5，能人为找到碰撞，对密码验证来说问题不大），二则要加一个安全随机数作为盐（salt）。LinkedIn 的问题正在于没有加盐，导致密码可以通过预先计算的彩虹表（rainbow table）反查出明文。这些密码明文可以用来做什么事，就不好说了，撞库什么的都有可能了。对用户来说，最好是不同网站用不同密码。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h1 id="专家建议">专家建议&lt;/h1>
&lt;p>Contrast Security 是一家安全公司，其 CTO 杰夫·威廉姆斯（ Jeff Williams）在博客中表示，虽说最佳实践是确保不使用有漏洞的程序库，但是在现实中并不容易做到这一点，因为安全更新来得比较频繁。&lt;/p>
&lt;p>&amp;ldquo;经常，为了做这些安全性方面的更改，需要重新编写、测试和部署整个应用程序，而整个周期可能要花费几个月。我最近和几个大的组织机构聊过，他们在应对 CVE-2017-5638 这件事上花了至少四个月的时间。即便是在运营得最好的组织机构中，也经常在漏洞被发布和应用程序被更新之间有几个月的时间差。&amp;ldquo;威廉姆斯写道。&lt;/p>
&lt;p>Apache Struts 的副总裁雷内·吉伦（René Gielen）在 Apache 软件基金会的官方博客中写道，为了避免被攻击，对于使用了开源或闭源的支持性程序库的软件产品或服务，建议如下的 5 条最佳实践。&lt;/p>
&lt;ol>
&lt;li>
&lt;p>理解你的软件产品中使用了哪些支持性框架和库，它们的版本号分别是多少。时刻跟踪影响这些产品和版本的最新安全性声明。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>建立一个流程，来快速地部署带有安全补丁的软件产品发布版，这样一旦需要因为安全方面的原因而更新支持性框架或库，就可以快速地发布。最好能在几个小时或几天内完成，而不是几周或几个月。我们发现，绝大多数被攻破的情况是因为几个月或几年都没有更新有漏洞的软件组件而引起的。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>所有复杂的软件都有漏洞。不要基于&amp;quot;支持性软件产品没有安全性漏洞&amp;quot;这样的假设来建立安全策略。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>建立多个安全层。在一个面向公网的表示层（比如 Apache Struts 框架）后面建立多级有安全防护的层次，是一种良好的软件工程实践。就算表示层被攻破，也不会直接提供出重要（或所有）后台信息资源的访问权。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>针对公网资源，建立对异常访问模式的监控机制。现在有很多侦测这些行为模式的开源和商业化产品，一旦发现异常访问就能发出警报。作为一种良好的运维实践，我们建议针对关键业务的网页服务应用一定要有这些监控机制。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>在吉伦提的第二点中说到，理想的更新时间是在几个小时到几天。我们知道，作为企业，部署了一个版本的程序库，在更新前需要在测试系统上测试各个业务模块，确保兼容以后才能上线。否则，盲目上线一个新版本，一旦遇到不兼容的情况，业务会部分或全部停滞，给客户留下不良印象，经济损失将是不可避免的。因此，这个更新周期必须通过软件工程手段来保证。&lt;/p>
&lt;p>一个有力的解决方案是自动化测试。对以数据库为基础的程序库，设置专门的、初始时全空的测试用数据库来进行 API 级别的测试。对于 UI 框架，使用 UI 自动化测试工具进行自动化测试。测试在原则上必须覆盖上层业务模块所有需要的功能，并对其兼容性加以验证。业务模块要连同程序库一起做集成的自动化测试，同时也要有单元测试。&lt;/p>
&lt;p>升级前的人工测试也有必要，但由于安全性更新的紧迫性，覆盖主要和重要路径即可。&lt;/p>
&lt;p>如果测试发现不兼容性，无法立即升级，那么要考虑的第二点是缓解措施（mitigation）。比如，能否禁用有漏洞的部分而不影响业务？如果不可行，那么是否可以通过 WAF 的设置来把一定特征的攻击载荷挡在门外？这些都是临时解决方案，要到开发部门把业务程序更新为能用新版本库，才能上线新版本的应用程序。&lt;/p>
&lt;h1 id="技术上的安全做法">技术上的安全做法&lt;/h1>
&lt;p>除了上面所说的，那些安全防范的方法，我想在这里再加入一些我自己的经验。&lt;/p>
&lt;p>从技术上来说，安全防范最好是做到连自己内部员工都能防，因为无论是程序的 BUG 还是漏洞，都是为了取得系统的权限而获得数据。如果我们能够连内部人都能防的话，那么就可以不用担心绝大多数的系统漏洞了。所谓&amp;quot;家贼难防&amp;rdquo;，如果要做到这一点，一般来说，有如下的一些方式。&lt;/p>
&lt;p>首先，我们需要把我们的关键数据定义出来，然后把这些关键数据隔离出来，隔离到一个安全级别非常高的地方。所谓安全级别非常高的地方，即这个地方需要有各种如安全审计、安全监控、安全访问的区域。&lt;/p>
&lt;p>一般来说，在这个区域内，这些敏感数据只入不出。通过提供服务接口来让别的系统只能在这个区域内操作这些数据，而不是把数据传出去，让别的系统在外部来操作这些数据。&lt;/p>
&lt;p>举个例子，用户的手机号是敏感信息。如果有外部系统需要使用手机号，一般来说是想发个短信，那么我们这个掌管手机号数据的系统就对外提供发短信的功能，而外部系统通过 UID 或是别的抽像字段来调用这个系统的发短信的 API。信用卡也一样，提供信用卡的扣款 API 而不是把卡号返回给外部系统。&lt;/p>
&lt;p>另外，如果业务必需返回用户的数据，一般来说，最终用户可能需要读取自己的数据，那么，对于像信用卡这样的关键数据是死也不能返回全部数据的，只能返回一个被&amp;quot;马赛克&amp;quot;了的数据（隐藏掉部分信息）。就算需要返回一些数据（如用户的地址），那么也需要在传输层上加密返回。&lt;/p>
&lt;p>而用户加密的算法一定要采用非对称加密的方式，而且还要加上密钥的自动化更换，比如：在外部系统调用 100 次或是第一个小时后就自动更换加密的密钥。这样，整个系统在运行时就完全是自动化的了，而就算黑客得到了密钥，密匙也会过期，这样可以控制泄露范围。&lt;/p>
&lt;p>通过上述手段，我们可以把数据控制在一个比较小的区域内。&lt;/p>
&lt;p>而在这个区域内，我们依然会有相关的内部员工可以访问，因此，这个区域中的数据也是需要加密存放的，而加密使用的密钥则需要放在另外一个区域中。&lt;/p>
&lt;p>也就是说，被加密的数据和用于加密的密钥是由不同的人来管理的，有密钥的人没有数据，有数据的人没有密钥，这两拨人可以有访问自己系统的权限，但是没有访问对方系统的权限。这样可以让这两拨人互相审计，互相牵制，从而提高数据的安全性。比如，这两拨人是不同公司的。&lt;/p>
&lt;p>而密钥一定要做到随机生成，最好是对于不同用户的数据有不同的密钥，并且时不时地就能自动化更新一下，这样就可以做到内部防范。注明一下，按道理来说，用户自己的私钥应该由用户自己来保管，而公司的系统是不存的。而用户需要更新密钥时，需要对用户做身份鉴别，可以通过双因子认证，也可以通过更为严格的物理身份验证。例如，到银行柜台拿身份证重置密码。&lt;/p>
&lt;p>最后，每当这些关键信息传到外部系统，需要做通知，最好是通知用户和自己的管理员。并且限制外部系统的数据访问量，超过访问量后，需要报警或是拒绝访问。&lt;/p>
&lt;p>上述的这些技术手段是比较常见的做法，虽然也不能确保 100% 防止住，但基本上来说已经将安全级别提得非常高了。&lt;/p>
&lt;p>不管怎么样，安全在今天是一个非常严肃的事，能做到绝对的安全基本上是不可能的，我们只能不断提高黑客入侵的门槛。当黑客的投入和收益大大不相符时，黑客也就失去了入侵的意义。&lt;/p>
&lt;p>此外，安全还在于&amp;quot;风控&amp;rdquo;，任何系统就算你做得再完美，也会出现数据泄露的情况，只是我们可以把数据泄露的范围控制在一个什么样的比例，而这个比例就是我们的&amp;quot;风控&amp;quot;。&lt;/p>
&lt;p>所谓的安全方案基本上来说就是能够把这个风险控制在一个很小的范围。对于在这个很小范围出现的一些数据安全的泄露，我们可以通过&amp;quot;风控基金&amp;quot;来做业务上的补偿，比如赔偿用户损失，等等。因为从经济利益上来说，如果风险可以控制在一个&amp;mdash;&amp;mdash;我防范它的成本远高于我赔偿它的成本，那么，还不如赔偿了。&lt;/p>
&lt;p>最后，如果你还有什么样的问题或是心得，欢迎和我交流！&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/fc/e9/fcc761001867c60f526665e237f831e9.jpg" alt="">&lt;/p></description></item><item><title>极客专栏: 05丨何为技术领导力？</title><link>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E/05%E4%B8%A8%E4%BD%95%E4%B8%BA%E6%8A%80%E6%9C%AF%E9%A2%86%E5%AF%BC%E5%8A%9B/</link><pubDate>Fri, 27 May 2022 00:00:00 +0000</pubDate><guid>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E/05%E4%B8%A8%E4%BD%95%E4%B8%BA%E6%8A%80%E6%9C%AF%E9%A2%86%E5%AF%BC%E5%8A%9B/</guid><description>
&lt;p>我先说明一下，我们要谈的并不是&amp;quot;如何成为一名管理者&amp;quot;。我想谈的是技术上的领先，技术上的优势，而不是一个职称，一个人事组织者。另外，我不想在理论上泛泛而谈这个事，我想谈得更落地、更实际一些，所以，我需要直面一些问题。&lt;/p>
&lt;p>首先，要考虑的问题是&amp;mdash;&amp;mdash;做技术有没有前途？我们在很多场合都能听到：技术做不长，技术无用商业才有用等这样的言论。所以，在谈技术领导力前，我需要直面这个问题，否则，技术领导力就成为一个伪命题了。&lt;/p>
&lt;h1 id="技术重要吗">技术重要吗？&lt;/h1>
&lt;p>在中国，程序员把自己称做&amp;quot;码农&amp;quot;，说自己是编程的农民工，干的都是体力活，加班很严重，认为做技术没有什么前途，好多人都拼命地想转管理或是转行。这是中国技术人员的一个现实问题。&lt;/p>
&lt;p>与国外相比，似乎中国的程序员在生存上遇到的问题更多。为什么会有这样的问题？我是这么理解的，在中国，需要解决的问题很多，而且人口众多。也就是说，中国目前处于加速发展中，遍地机会，公司可以通过&amp;quot;野蛮开采&amp;quot;来实现自身业务的快速拓展和扩张。而西方发达国家人口少一些，相对成熟一些，竞争比较激烈，所以，更多的是采用&amp;quot;精耕细作&amp;quot;的方式。&lt;/p>
&lt;p>此外，中国的基础技术还正在发展中，技术能力不足，所以，目前的状态下，销售、运营、地推等简单快速的业务手段显得更为有效一些，需要比拼的是如何拿到更多的&amp;quot;地&amp;quot;。而西方的&amp;quot;精耕细作&amp;quot;需要比拼的是在同样大小的一块田里，如何才能更快更多地种出&amp;quot;粮食&amp;quot;，这完全就是在拼技术了。&lt;/p>
&lt;p>每个民族、国家、公司和个人都有自己的发展过程。而总体上来说，中国公司目前还处于&amp;quot;野蛮开采&amp;quot;阶段，所以，这就是为什么很多公司为了快速扩张，要获得更多的用户和市场 ，需要通过加班、加人、烧钱、并购、广告、运营、销售等这些相对比较&amp;quot;野蛮&amp;quot;的方式发展自己，而导致技术人员在其中跟从和被驱动。这也是为什么很多中国公司要用&amp;quot;狼性&amp;quot;、要用&amp;quot;加班&amp;quot;、要用&amp;quot;打鸡血&amp;quot;来驱动员工完成更多的工作。&lt;/p>
&lt;p>但是，这会成为常态吗？中国和中国的公司会这样一直走下去吗？我并不觉得。&lt;/p>
&lt;p>这就好像人类的发展史一样。在人类发展的初期，蛮荒民族通过野蛮地掠夺来发展自己的民族更为有效，但我们知道资源是有限的，一旦没有太多可以掠夺的资源，就需要发展&amp;quot;自给自主&amp;quot;的能力，这就是所谓的&amp;quot;发展文明&amp;quot;。所以，我们也能看到，一些比较&amp;quot;文明&amp;quot;的民族在初期搞不过&amp;quot;野蛮&amp;quot;的民族，但是，一旦&amp;quot;文明&amp;quot;发展起来，就可以从质上完全超过&amp;quot;野蛮&amp;quot;民族。&lt;/p>
&lt;p>从人类历史的发展规律中，我们可以看到，各民族基本都是通过&amp;quot;野蛮开采&amp;quot;来获得原始积累，然后有一些民族开始通过这些原始积累发展自己的&amp;quot;文明&amp;quot;，从而达到强大，吞并弱小的民族。&lt;/p>
&lt;p>所以，对于一个想要发展、想要变强大的民族或公司来说，野蛮开采绝不会是常态，否则，只能赢得一时，长期来说，一定会被那些掌握先进技术的民族或公司所淘汰。&lt;/p>
&lt;p>从人类社会的发展过程中来看，基本上可以总结为几个发展阶段。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>第一个阶段：野蛮开采&lt;/strong>。这个阶段的主要特点是资源过多，只需要开采就好了。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>第二个阶段：资源整合&lt;/strong>。在这个阶段，资源已经被不同的人给占有了，但是需要对资源整合优化，提高利用率。这时通过管理手段就能实现。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>第三个阶段：精耕细作&lt;/strong>。这个阶段基本上是对第二阶段的精细化运作，并且通过科学的手段来达到。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>第四个阶段：发明创造&lt;/strong>。 在这个阶段，人们利用已有不足的资源来创造更好的资源，并替代已有的马上要枯竭的资源。这就需要采用高科技来达到了。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>这也是为什么像亚马逊、Facebook 这样的公司，最终都会去发展自己的核心技术，提高自己的技术领导力，从早期的业务型公司转变成为技术型公司的原因。那些本来技术很好的公司，比如雅虎、百度，在发展到一定程度时，将自己定位成了一个广告公司，然后开始变味、走下坡路。&lt;/p>
&lt;p>同样，谷歌当年举公司之力不做技术做社交也是一个失败的案例。还好拉里·佩奇（Larry Page）看到苗头不对，重新掌权，把产品经理全部移到一边，让工程师重新掌权，于是才有了无人车和 AlphaGo 这样真正能够影响人类未来的惊世之作。&lt;/p>
&lt;p>微软在某段时间由一个做电视购物的销售担任 CEO，也出现了技术领导力不足的情况，导致公司走下坡路。苹果公司，在聘任了一个非技术的 CEO 后也几近破产。&lt;/p>
&lt;p>&lt;strong>尊重技术的公司和不尊重技术的公司在初期可能还不能显现，而长期来看，差距就很明显了&lt;/strong>。&lt;/p>
&lt;p>所以，无论是一个国家，一个公司，还是一个人，在今天这样技术浪潮一浪高过一浪的形势下，拥有技术不是问题，而问题是有没有拥有技术领导力。&lt;/p>
&lt;p>说的直白一点，技术领导力就是，你还在用大刀长矛打战的时候，对方已经用上了洋枪大炮；你还在赶马车的时候，对方已经开上了汽车&amp;hellip;&amp;hellip;&lt;/p>
&lt;h1 id="什么是技术领导力">什么是技术领导力？&lt;/h1>
&lt;p>但是，这么说还是很模糊，还是不能清楚地说明什么是技术领导力。我认为，技术领导力不仅仅是呈现出来的技术，而是一种可以获得绝对优势的技术能力。所以，技术领导力也有一些特征，为了说清楚这些特征，先让我们来看一下人类历史上的几次工业革命。&lt;/p>
&lt;p>&lt;strong>第一次工业革命&lt;/strong>。第一次工业革命开始于 18 世纪 60 年代，一直持续到 19 世纪 30 年代至 40 年代。在这段时间里，人类生产逐渐转向新的制造过程，出现了以机器取代人力、兽力的趋势，以大规模的工厂生产取代个体工厂手工生产的一场生产与科技革命。由于机器的发明及运用成为了这个时代的标志，因此历史学家称这个时代为机器时代（the Age of Machines）。&lt;/p>
&lt;p>这个时期的标志技术是&amp;mdash;&amp;mdash;&amp;ldquo;蒸汽机&amp;rdquo;。在瓦特改良蒸汽机之前，生产所需的动力依靠人力、畜力、水力和风力。伴随蒸汽机的发明和改进，工厂不再依河或溪流而建，很多以前依赖人力与手工完成的工作逐渐被机械化生产取代。世界被推向了一个崭新的&amp;quot;蒸汽时代&amp;quot;。&lt;/p>
&lt;p>&lt;strong>第二次工业革命&lt;/strong>。第二次工业革命指的是 1870 年至 1914 年期间的工业革命。英国、德国、法国、丹麦和美国以及 1870 年后的日本，在这段时间里，工业得到飞速发展。第二次工业革命紧跟着 18 世纪末的第一次工业革命，并且从英国向西欧和北美蔓延。&lt;/p>
&lt;p>第二次工业革命以电力的大规模应用为代表，以电灯、电报以及无线电通信的发明为标志。这些发明把人类推向了&amp;quot;电力&amp;quot;时代。电力和内燃技术的出现，让人类进入了真正的工业时代。随着这些技术的发展，工人阶级开始受到关注，并逐渐出现了有专业知识的中产阶级，而且人数众多。&lt;/p>
&lt;p>&lt;strong>第三次工业革命&lt;/strong>。第三次工业革命又名信息技术革命或者数字化革命，指第二次世界大战后，因计算机和电子数据的普及和推广而在各行各业发生的从机械和模拟电路再到数字电路的变革。第三次技术革命使传统工业更加机械化、自动化。它降低了工作成本，彻底改变了整个社会的运作模式，也创造了电脑工业这一高科技产业。&lt;/p>
&lt;p>它是人类历史上规模最大、影响最深远的科技革命，至今仍未结束。主要技术是&amp;quot;计算机&amp;quot;。计算机的发明是人类智力发展道路上的里程碑，因为它可以代替人类进行一部分脑力活动。&lt;/p>
&lt;p>而且，我们还可以看到，科学技术推动生产力的发展，转化为直接生产力的速度在加快。而科学技术密切结合，相互促进，在各个领域相互渗透。&lt;/p>
&lt;p>近代这几百年的人类发展史，从蒸汽机时代，到电力时代，再到信息时代，我们可以看到这样的一些信息。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>关键技术&lt;/strong>。蒸汽机、电、化工、原子能、炼钢、计算机，如果只看这些东西的话，似乎没什么用。但这些核心技术的突破，可以让我们建造很多更牛的工具，而这些工具能让人类干出以前干不出来的事。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>自动化&lt;/strong>。这其中最重要的事就是自动化。三次革命中最重要的事就是用机器来自动化。通信、交通、军事、教育、金融等各个领域都是在拼命地自动化，以提高效率&amp;mdash;&amp;mdash;用更低的成本来完成更多的事。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>解放生产力&lt;/strong>。把人从劳动密集型的工作中解放出来，去做更高层次的知识密集型的工作。说得难听一点，就是取代人类，让人失业。值得注意的是，今天的 AI 在开始取代人类的知识密集型的工作&amp;hellip;&amp;hellip;&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>因此，我们可以看到的技术领导力是：&lt;/p>
&lt;ul>
&lt;li>尊重技术，追求核心基础技术。&lt;/li>
&lt;li>追逐自动化的高效率的工具和技术，同时避免无效率的组织架构和管理。&lt;/li>
&lt;li>解放生产力，追逐人效的提高。&lt;/li>
&lt;li>开发抽象和高质量的可以重用的技术组件。&lt;/li>
&lt;li>坚持高于社会主流的技术标准和要求。&lt;/li>
&lt;/ul>
&lt;h1 id="如何拥有技术领导力">如何拥有技术领导力？&lt;/h1>
&lt;p>前面这些说的比较宏大，并不是所有的人都可以发明或创造这样的核心技术，但这不妨碍我们拥有技术领导力。因为，我认为，这世界的技术有两种，一种是像从马车时代到汽车时代这样的技术，也就是汽车的关键技术&amp;mdash;&amp;mdash;引擎，另一种则是工程方面的技术，而工程技术是如何让汽车更安全更有效率地行驶。对于后者来说**，我觉得所有的工程师都有机会**。&lt;/p>
&lt;p>那么作为一个软件工程师怎样才算是拥有&amp;quot;技术领导力&amp;quot;呢？我个人认为，是有下面的这些特质。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>能够发现问题&lt;/strong>。能够发现现有方案的问题。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>能够提供解决问题的思路和方案，并能比较这些方案的优缺点&lt;/strong>。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>能够做出正确的技术决定&lt;/strong>。用什么样的技术、什么解决方案、怎样实现来完成一个项目。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>能够用更优雅，更简单，更容易的方式来解决问题&lt;/strong>。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>能够提高代码或软件的扩展性、重用性和可维护性&lt;/strong>。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>能够用正确的方式管理团队&lt;/strong>。所谓正确的方式，一方面是，让正确的人做正确的事，并发挥每个人的潜力；另一方面是，可以提高团队的生产力和人效，找到最有价值的需求，用最少的成本实现之。并且，可以不断地提高自身和团队的标准。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>创新能力&lt;/strong>。能够使用新的方法新的方式解决问题，追逐新的工具和技术。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>我们可以看到，要做到这些其实并不容易，尤其，在面对不同问题的时候，这些能力也会因此不同。但是，我们不难发现，在任何一个团队中，大多数人都是在提问题，而只有少数人在回答这些人的问题，或是在提供解决问题的思路和方案。&lt;/p>
&lt;p>是的，一句话，总是在提供解决问题的思路和方案的人才是有技术领导力的人。&lt;/p>
&lt;p>那么，作为一个软件工程师，我们怎么让自己拥有技术领导力呢？总体来说，是四个方面，具体如下：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>扎实的基础技术&lt;/strong>；&lt;/li>
&lt;li>&lt;strong>非同一般的学习能力&lt;/strong>；&lt;/li>
&lt;li>&lt;strong>坚持做正确的事&lt;/strong>；&lt;/li>
&lt;li>&lt;strong>不断得高对自己的要求标准&lt;/strong>；&lt;/li>
&lt;/ul>
&lt;p>好了。今天要聊的内容就是这些，希望你能从中有所收获。而对于如何才能拥有技术领导力，你不妨结合我上面分享的四个点来思考一下，欢迎在留言区给出你的想法，下一篇文章，我也将会和你继续聊这个话题。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/fc/e9/fcc761001867c60f526665e237f831e9.jpg" alt="">&lt;/p></description></item><item><title>极客专栏: 06丨如何才能拥有技术领导力？</title><link>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E/06%E4%B8%A8%E5%A6%82%E4%BD%95%E6%89%8D%E8%83%BD%E6%8B%A5%E6%9C%89%E6%8A%80%E6%9C%AF%E9%A2%86%E5%AF%BC%E5%8A%9B/</link><pubDate>Fri, 27 May 2022 00:00:00 +0000</pubDate><guid>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E/06%E4%B8%A8%E5%A6%82%E4%BD%95%E6%89%8D%E8%83%BD%E6%8B%A5%E6%9C%89%E6%8A%80%E6%9C%AF%E9%A2%86%E5%AF%BC%E5%8A%9B/</guid><description>
&lt;p>通过上篇文章，相信你现在已经理解了&amp;quot;什么才是技术领导力&amp;quot;。今天，我就要跟你继续聊聊，怎样才能拥有技术领导力。&lt;/p>
&lt;p>**第一，你要吃透基础技术。基础技术是各种上层技术共同的基础。**吃透基础技术是为了更好地理解程序的运行原理，并基于这些基础技术进化出更优化的产品。吃透基础技术，有很多好处，具体来说，有如下几点。&lt;/p>
&lt;ol>
&lt;li>
&lt;p>万丈高楼平地起。一栋楼能盖多高，一座大桥能造多长，重要的是它们的地基。同样对于技术人员来说，基础知识越扎实，走得就会越远。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>计算机技术太多了，但是仔细分析你会发现，只是表现形式很多，而基础技术并不多。学好基础技术，能让你一通百通，更快地使用各种新技术，从而可以更轻松地与时代同行。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>很多分布式系统架构，以及高可用、高性能、高并发的解决方案基本都可以在基础技术上找到它们的身影。所以，学习基础技术能让你更好地掌握更高维度的技术。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>那么，哪些才是基础技术呢？我在下面罗列了一些。老实说，这些技术你学起来可能会感到枯燥无味，但是，我还是鼓励你能够克服人性的弱点，努力啃完。&lt;/p>
&lt;p>具体来说，可以分成两个部分：&lt;strong>编程和系统&lt;/strong>。&lt;/p>
&lt;h2 id="编程部分">编程部分&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>C 语言&lt;/strong>：相对于很多其他高级语言来说，C 语言更接近底层。在具备跨平台能力的前提下，它可以比较容易地被人工翻译成相应的汇编代码。它的内存管理更为直接，可以让我们直接和内存地址打交道。&lt;/p>
&lt;p>学习好 C 语言的好处是能掌握程序的运行情况，并能进行应用程序和操作系统编程（操作系统一般是汇编和 C 语言）。要学好 C 语言，你可以阅读 C 语言的经典书籍《C 程序设计语言（第 2 版）》，同时，肯定也要多写程序，多读一些优秀开源项目的源代码。&lt;/p>
&lt;p>除了让你更为了解操作系统之外，学习 C 语言还能让你更清楚地知道程序是怎么精细控制底层资源的，比如内存管理、文件操作、网络通信&amp;hellip;&amp;hellip;&lt;/p>
&lt;p>这里需要说明的是，我们还是需要学习汇编语言的。因为如果你想更深入地了解计算机是怎么运作的，那么你是需要了解汇编语言的。虽然我们几乎不再用汇编语言编程了，但是如果你需要写一些如 lock free 之类高并发的东西，那么了解汇编语言，就能有助于你更好地理解和思考。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>编程范式&lt;/strong>：各种编程语言都有它们各自的编程范式，用于解决各种问题。比如面向对象编程（C++、Java）、泛型编程（C++、Go、C#）、函数式编程（JavaScript、 Python、Lisp、Haskell、Erlang）等。&lt;/p>
&lt;p>学好编程范式，有助于培养你的抽象思维，同时也可以提高编程效率，提高程序的结构合理性、可读性和可维护性，降低代码的冗余度，进而提高代码的运行效率。要学习编程范式，你还可以多了解各种程序设计语言的功能特性。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>算法和数据结构&lt;/strong>：算法（及其相应的数据结构）是程序设计的有力支撑。适当地应用算法，可以有效地抽象问题，提高程序的合理性和执行效率。算法是编程中最最重要的东西，也是计算机科学中最重要的基础。&lt;/p>
&lt;p>任何有技术含量的软件中一定有高级的算法和数据结构。比如 epoll 中使用了红黑树，数据库索引使用了 B+ 树&amp;hellip;&amp;hellip;而就算是你的业务系统中，也一定使用各种排序、过滤和查找算法。学习算法不仅是为了写出运转更为高效的代码，而且更是为了能够写出可以覆盖更多场景的正确代码。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="系统部分">系统部分&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>计算机系统原理&lt;/strong>：CPU 的体系结构（指令集 [CISC/RISC]、分支预测、缓存结构、总线、DMA、中断、陷阱、多任务、虚拟内存、虚拟化等），内存的原理与性能特点（SRAM、DRAM、DDR-SDRAM 等），磁盘的原理（机械硬盘 [盘面、磁头臂、磁头、启停区、寻道等]、固态硬盘 [页映射、块的合并与回收算法、TRIM 指令等]），GPU 的原理等。&lt;/p>
&lt;p>学习计算机系统原理的价值在于，除了能够了解计算机的原理之外，你还能举一反三地反推出高维度的分布式架构和高并发高可用的架构设计。&lt;/p>
&lt;p>比如虚拟化内存就和今天云计算中的虚拟化的原理是相通的，计算机总线和分布式架构中的 ESB 也有相通之处，计算机指令调度、并发控制可以让你更好地理解并发编程和程序性能调优&amp;hellip;&amp;hellip;这里，推荐书籍《深入理解计算机系统》（Randal E. Bryant）。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>操作系统原理和基础&lt;/strong>：进程、进程管理、线程、线程调度、多核的缓存一致性、信号量、物理内存管理、虚拟内存管理、内存分配、文件系统、磁盘管理等。&lt;/p>
&lt;p>学习操作系统的价值在于理解程序是怎样被管理的，操作系统对应用程序提供了怎样的支持，抽象出怎样的编程接口（比如 POSIX/Win32 API），性能特性如何（比如控制合理的上下文切换次数），怎样进行进程间通信（如管道、套接字、内存映射等），以便让不同的软件配合一起运行等。&lt;/p>
&lt;p>要学习操作系统知识，一是要仔细观察和探索当前使用的操作系统，二是要阅读操作系统原理相关的图书，三是要阅读 API 文档（如 man pages 和 MSDN Library），并编写调用操作系统功能的程序。这里推荐三本书《UNIX 环境高级编程》、《UNIX 网络编程》和《Windows 核心编程》。&lt;/p>
&lt;p>学习操作系统基础原理的好处是，这是所有程序运行的物理世界，无论上层是像 C/C++ 这样编译成机器码的语言，还是像 Java 这样有 JVM 做中间层的语言，再或者像 Python/PHP/Perl/Node.js 这样直接在运行时解释的语言，其在底层都逃离不了操作系统这个物理世界的&amp;quot;物理定律&amp;quot;。&lt;/p>
&lt;p>所以，了解操作系统的原理，可以让你更能从本质理解各种语言或是技术的底层原理。一眼看透本质可以让你更容易地掌握和使用高阶技术。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>网络基础&lt;/strong>：计算机网络是现代计算机不可或缺的一部分。需要了解基本的网络层次结构（ISO/OSI 模型、TCP/IP 协议栈），包括物理层、数据链路层（包含错误重发机制）、网络层（包含路由机制）、传输层（包含连接保持机制）、会话层、表示层、应用层（在 TCP/IP 协议栈里，这三层可以并为一层）。&lt;/p>
&lt;p>比如，底层的 ARP 协议、中间的 TCP/UDP 协议，以及高层的 HTTP 协议。这里推荐书籍《TCP/IP 详解》，学习这些基础的网络协议，可以为我们的高维分布式架构中的一些技术问题提供很多的技术方案。比如 TCP 的滑动窗口限流，完全可以用于分布式服务中的限流方案。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>数据库原理&lt;/strong>：数据库管理系统是管理数据库的利器。通常操作系统提供文件系统来管理文件数据，而文件比较适合保存连续的信息，如一篇文章、一个图片等。但有时需要保存一个名字等较短的信息。如果单个文件只保存名字这样的几个字节的信息的话，就会浪费大量的磁盘空间，而且无法方便地查询（除非使用索引服务）。&lt;/p>
&lt;p>但数据库则更适合保存这种短的数据，而且可以方便地按字段进行查询。现代流行的数据库管理系统有两大类：SQL（基于 B+ 树，强一致性）和 NoSQL（较弱的一致性，较高的存取效率，基于哈希表或其他技术）。&lt;/p>
&lt;p>学习了数据库原理之后便能了解数据库访问性能调优的要点，以及保证并发情况下数据操作原子性的方法。要学习数据库，你可以阅读各类数据库图书，并多做数据库操作以及数据库编程，多观察分析数据库在运行时的性能。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>分布式技术架构&lt;/strong>：数据库和应用程序服务器在应对互联网上数以亿计的访问量的时候，需要能进行横向扩展，这样才能提供足够高的性能。为了做到这一点，要学习分布式技术架构，包括负载均衡、DNS 解析、多子域名、无状态应用层、缓存层、数据库分片、容错和恢复机制、Paxos、Map/Reduce 操作、分布式 SQL 数据库一致性（以 Google Cloud Spanner 为代表）等知识点。&lt;/p>
&lt;p>学习分布式技术架构的有效途径是参与到分布式项目的开发中去，并阅读相关论文。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>注意，&lt;strong>上面这些基础知识通常不是可以速成的&lt;/strong>。虽然说，你可以在一两年内看完相关的书籍或论文，但是，我想说的是，这些基础技术是需要你用一生的时间来学习的，因为基础上的技术和知识，会随着阅历和经验的增加而有不同的感悟。&lt;/p>
&lt;p>**第二，提高学习能力。所谓学习能力，就是能够很快地学习新技术，又能在关键技术上深入的能力。**只有在掌握了上述的基础原理之上，你才能拥有好的学习能力。&lt;/p>
&lt;p>下面是让你提升学习能力的一些做法。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>学习的信息源&lt;/strong>。信息源很重要，有好的信息源就可以更快速地获取有价值的信息，并提升学习效率。常见的信息源有 Google 等搜索引擎，Stack Overflow、Quora 等社区，图书，API 文档，论文和博客等。&lt;/p>
&lt;p>这么说吧，如果今天使用中文搜索就可以满足你的知识需求，那么你就远远落后于这个时代了。如果用英文搜索才能找到你想要的知识，那么你才能算跟得上这个时代。而如果说有的问题你连用英文搜索都找不到，只能到社区里去找作者或者其他人交流，那么可以说你已真正和时代同频了。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>与高手交流&lt;/strong>。程序员可以通过技术社区以及参加技术会议与高手交流，也可以通过参加开源项目来和高手切磋。常闻&amp;quot;听君一席话，胜读十年书&amp;quot;便是如此。与高手交流对程序员的学习和成长很有益处，不仅有助于了解热门的技术方向及关键的技术点，更可以通过观察和学习高手的技术思维及解决问题的方式，提高自己的技术前瞻性和技术决策力。&lt;/p>
&lt;p>我在 Amazon 的时候，就有人和我说，多和美国的 Principle SDE 以上的工程师交流，无论交流什么，你都会有收获的。其实，这里说的就是，学习这些牛人的思维方式和看问题的角度，这会让你有质的提高。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>举一反三的思考&lt;/strong>。比如，了解了操作系统的缓存和网页缓存以后，你要思考其相同点和不同点。了解了 C++ 语言的面向对象特性以后，思考 Java 面向对象的相同点和不同点。遇到故障的时候，举一反三，把同类问题一次性地处理掉。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>不怕困难的态度&lt;/strong>。遇到难点，有时不花一番力气，是不可能突破的。此时如果没有不怕困难的态度，你就容易打退堂鼓。但如果能坚持住，多思考，多下功夫，往往就能找到出路。绝大多数人是害怕困难的，所以，如果你能够不怕困难，并可以找到解决困难的方法和路径，时间一长，你就能拥有别人所不能拥有的能力。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>开放的心态&lt;/strong>。实现一个目的通常有多种办法。带有开放的心态，不拘泥于一个平台、一种语言，往往能带来更多思考，也能得到更好的结果。而且，能在不同的方法和方案间做比较，比较它们的优缺点，那么你会知道在什么样的场景下用什么样的方案，你就会比一般人能够有更全面和更完整的思路。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>第三，坚持做正确的事。做正确的事，比用正确的方式做事更重要，因为这样才始终会向目的地靠拢&lt;/strong>。哪些是正确的事呢？下面是我的观点：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>提高效率的事&lt;/strong>。你要学习和掌握良好的时间管理方式，管理好自己的时间，能显著提高自己的效率。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>自动化的事&lt;/strong>。程序员要充分利用自己的职业特质，当看见有可以自动化的步骤时，编写程序来自动化操作，可以显著提高效率。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>掌握前沿技术的事&lt;/strong>。掌握前沿的技术，有利于拓展自己的眼界，也有利于找到更好的工作。需要注意的是，有些技术虽然当下很火，但未必前沿，而是因为它比较易学易用，或者性价比高。由于学习一门技术需要花费不少时间，你应该选择自己最感兴趣的，有的放矢地去学习。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>知识密集型的事&lt;/strong>。知识密集型是相对于劳动密集型来说的。基本上，劳动密集型的事都能通过程序和机器来完成，而知识密集型的事却仍需要人来完成，所以人的价值此时就显现出来了。虽然现在人工智能似乎能做一些知识密集型的事（包括下围棋的 AlphaGo），但是在开放领域中相对于人的智能来说还是相去甚远。掌握了领域知识的人的价值依然很高。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>技术驱动的事&lt;/strong>。不仅是指用程序驱动的事，而且还包括一切技术改变生活的事。比如自动驾驶、火星登陆等。就算自己一时用不着，你也要了解这些，以便将来这些技术来临时能适应它们。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>第四，高标准要求自己。只有不断地提高标准 ，你才可能越走越高，所以，要以高标准要求自己，不断地反思、总结和审视自己，才能够提升自己&lt;/strong>。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>Google 的自我评分卡&lt;/strong>。Google 的评分卡是在面试 Google 时，要求应聘人对自己的技能做出评估的工具，它可以看出应聘人在各个领域的技术水平。我们可以参考 Google 的这个评分卡来给自己做评估，并通过它来不断地提高对自己的要求。（该评分卡见文末附录）。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>敏锐的技术嗅觉&lt;/strong>。这是一个相对综合的能力，你需要充分利用信息源，GET 到新的技术动态，并通过参与技术社区的讨论，丰富自己了解技术的角度。思考一下是否是自己感兴趣的，能解决哪些实际问题，以及其背后的原因，新技术也好，旧技术的重大版本变化也罢。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>强调实践，学以致用&lt;/strong>。学习知识，一定要实际用一用，可以是工作中的项目，也可以是自己的项目，不仅有利于吸收理解，更有利于深入到技术的本质。并可以与现有技术对比一下，同样的问题，用新技术解决有什么不同，带来了哪些优势，还有哪些有待改进的地方。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Lead by Example&lt;/strong>。永远在编程。不写代码，你就对技术细节不敏感，你无法做出可以实践的技术决策和方案。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>不要小看这些方法和习惯，坚持下来很有益处。谁说下一个改进方向或者重大修改建议，不可以是你给出的呢，尤其是在一些开源项目中。何为领导力，能力体现之一不就是指明技术未来的发展方向吗？&lt;/p>
&lt;p>吃透基础技术、提高学习能力、坚持做正确的事、高标准要求自己，不仅会让你全面提升技术技能，还能很好地锻炼自己的技术思维，培养技术前瞻性和决策力，进而形成技术领导力。&lt;/p>
&lt;p>然而，仅有技术还不够。作为一名合格的技术领导者，还需要有解决问题的各种软技能。比如，良好的沟通能力、组织能力、驱动力、团队协作能力等等。《技术领导之路》、《卓有成效的管理者》等多本经典图书中均有细致的讲解，这里不展开讲述，我后面内容也会有涉及。&lt;/p>
&lt;h2 id="附-google-评分卡">附 Google 评分卡&lt;/h2>
&lt;p>0 - you are unfamiliar with the subject area.&lt;/p>
&lt;p>1 - you can read / understand the most fundamental aspects of the subject area.&lt;/p>
&lt;p>2 - ability to implement small changes, understand basic principles and able to figure out additional details with minimal help.&lt;/p>
&lt;p>3 - basic proficiency in a subject area without relying on help.&lt;/p>
&lt;p>4 - you are comfortable with the subject area and all routine work on it:&lt;br>
For software areas - ability to develop medium programs using all basic language features w/o book, awareness of more esoteric features (with book).&lt;/p>
&lt;p>For systems areas - understanding of many fundamentals of networking and systems administration, ability to run a small network of systems including recovery, debugging and nontrivial troubleshooting that relies on the knowledge of internals.&lt;/p>
&lt;p>5 - an even lower degree of reliance on reference materials. Deeper skills in a field or specific technology in the subject area.&lt;/p>
&lt;p>6 - ability to develop large programs and systems from scratch. Understanding of low level details and internals. Ability to design / deploy most large, distributed systems from scratch.&lt;/p>
&lt;p>7 - you understand and make use of most lesser known language features, technologies, and associated internals. Ability to automate significant amounts of systems administration.&lt;/p>
&lt;p>8 - deep understanding of corner cases, esoteric features, protocols and systems including &amp;ldquo;theory of operation&amp;rdquo;. Demonstrated ability to design, deploy and own very critical or large infrastructure, build accompanying automation.&lt;/p>
&lt;p>9 - could have written the book about the subject area but didn&amp;rsquo;t; works with standards committees on defining new standards and methodologies.&lt;/p>
&lt;p>10 - wrote the book on the subject area (there actually has to be a book). Recognized industry expert in the field, might have invented it.&lt;/p>
&lt;p>&lt;strong>Subject Areas:&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>TCP/IP Networking (OSI stack, DNS etc)&lt;/li>
&lt;li>Unix/Linux internals&lt;/li>
&lt;li>Unix/Linux Systems administration&lt;/li>
&lt;li>Algorithms and Data Structures&lt;/li>
&lt;li>C&lt;/li>
&lt;li>C++&lt;/li>
&lt;li>Python&lt;/li>
&lt;li>Java&lt;/li>
&lt;li>Perl&lt;/li>
&lt;li>Go&lt;/li>
&lt;li>Shell Scripting (sh, Bash, ksh, csh)&lt;/li>
&lt;li>SQL and/or Database Admin&lt;/li>
&lt;li>Scripting language of your choice (not already mentioned)&lt;/li>
&lt;li>People Management&lt;/li>
&lt;li>Project Management&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/fc/e9/fcc761001867c60f526665e237f831e9.jpg" alt="">&lt;/p></description></item><item><title>极客专栏: 07丨推荐阅读：每个程序员都该知道的知识</title><link>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E/07%E4%B8%A8%E6%8E%A8%E8%8D%90%E9%98%85%E8%AF%BB%E6%AF%8F%E4%B8%AA%E7%A8%8B%E5%BA%8F%E5%91%98%E9%83%BD%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84%E7%9F%A5%E8%AF%86/</link><pubDate>Fri, 27 May 2022 00:00:00 +0000</pubDate><guid>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E/07%E4%B8%A8%E6%8E%A8%E8%8D%90%E9%98%85%E8%AF%BB%E6%AF%8F%E4%B8%AA%E7%A8%8B%E5%BA%8F%E5%91%98%E9%83%BD%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84%E7%9F%A5%E8%AF%86/</guid><description>
&lt;p>在整个为期一年的专栏内容中，我会逐步向你推荐一些有价值的内容，供你参考，这些内容有中文，有英文，也有视频，它们都是我认为对我非常有价值的信息，我也希望它们对你能有同样的帮助和启发。&lt;/p>
&lt;p>今天，我为你推荐的 5 篇文章，它们分别是：&lt;/p>
&lt;ul>
&lt;li>Stack Overflow 上推荐的一个经典书单；&lt;/li>
&lt;li>美国某大学教授给计算机专业学生的一些建议，其中有很多的学习资源；&lt;/li>
&lt;li>LinkedIn 的高效代码复查实践，很不错的方法，值得你一读；&lt;/li>
&lt;li>一份关于程序语言和 bug 数相关的有趣的报告，可以让你对各种语言有所了解；&lt;/li>
&lt;li>最后是一本关于 C++ 性能优化的电子书。&lt;/li>
&lt;/ul>
&lt;h4 id="每个程序员都应该要读的书">每个程序员都应该要读的书&lt;/h4>
&lt;p>在 Stack Overflow 上有用户问了一个&lt;a href="https://stackoverflow.com/questions/1711/what-is-the-single-most-influential-book-every-programmer-should-read">问题&lt;/a>，大意是想让大家推荐一些每个程序员都应该阅读的最有影响力的图书。&lt;/p>
&lt;p>虽然这个问题已经被关闭了，但这真是一个非常热门的话题。排在第一位的用户给出了一大串图书的列表，看上去着实吓人，不过都是一些相当经典相当有影响力的书，在这里我重新罗列一些我觉得你必须要看的。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>《代码大全》&lt;/strong> 虽然这本书有点过时了，而且厚到可以垫显示器，但是这绝对是一本经典的书。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>《程序员修练之道》&lt;/strong> 这本书也是相当经典，我觉得就是你的指路明灯。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>《计算机的构造和解释》&lt;/strong> 经典中的经典，必读。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>《算法导论》&lt;/strong> 美国的本科生教材，这本书应该也是中国计算机学生的教材。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>《设计模式》&lt;/strong> 这本书是面向对象设计的经典书籍。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>《重构》&lt;/strong> 代码坏味道和相应代码的最佳实践。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>《人月神话》&lt;/strong> 这本书可能也有点过时了。但还是经典书。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>《代码整洁之道》&lt;/strong> 细节之处的效率，完美和简单。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>《Effective C++》/《More Effective C++》&lt;/strong> C++ 中两本经典得不能再经典的书。也许你觉得 C++ 复杂，但这两本书中带来对代码稳定性的探索方式让人受益，因为这种思维方式同样可以用在其它地方。以至于各种模仿者，比如《Effective Java》也是一本经典书。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>**《Unix 编程艺术》、《Unix 高级环境编程》**也是相关的经典。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>还有好多，我就不在这里一一列举了。你可以看看其它的答案，我发现自己虽然读过好多书，但同样还有好些书没有读过，这个问答对我也很有帮助。&lt;/p>
&lt;h4 id="每个搞计算机专业的学生应有的知识">每个搞计算机专业的学生应有的知识&lt;/h4>
&lt;p>&lt;strong>&lt;a href="http://matt.might.net/articles/what-cs-majors-should-know/">What every computer science major should know&lt;/a>&lt;/strong>，每个搞计算机专业的学生应有的知识。&lt;/p>
&lt;p>本文作者马修·迈特（Matthew Might）是美国犹他大学计算机学院的副教授，2007 年于佐治亚理工学院取得博士学位。计算机专业的课程繁多，而且随着时代的变化，科目的课程组成也在不断变化。&lt;/p>
&lt;p>如果不经过思考，直接套用现有的计算机专业课程列表，则有可能忽略一些将来可能变得重要的知识点。为此，马修力求从四个方面来总结，得出这篇文章的内容。&lt;/p>
&lt;ol>
&lt;li>要获得一份好工作，学生需要知道什么？&lt;/li>
&lt;li>为了一辈子都有工作干，学生需要知道什么？&lt;/li>
&lt;li>学生需要知道什么，才能进入研究生院？&lt;/li>
&lt;li>学生需要知道什么，才能对社会有益？&lt;/li>
&lt;/ol>
&lt;p>这篇文章不仅仅对刚毕业的学生有用，对有工作经验的人同样有用，这里我把这篇文章的内容摘要如下。&lt;/p>
&lt;p>首先，对于我们每个人来说，作品集（Portfolio）会比简历（Resume）更有参考意义。所以，在自己的简历中应该放上自己的一些项目经历，或是一些开源软件的贡献，或是你完成的软件的网址等。最好有一个自己的个人网址，上面有一些你做的事、自己的技能、经历，以及你的一些文章和思考会比简历更好。&lt;/p>
&lt;p>其次，计算机专业工作者也要学会与人交流的技巧，包括如何写演示文稿，以及面对质疑时如何与人辩论的能力。&lt;/p>
&lt;p>最后，他就各个方面展开计算机专业人士所需要的硬技能：工程类数学、Unix 哲学和实践、系统管理、程序设计语言、离散数学、数据结构与算法、计算机体系结构、操作系统、网络、安全、密码学、软件测试、用户体验、可视化、并行计算、软件工程、形式化方法、图形学、机器人、人工智能、机器学习、数据库等等。详读本文可以了解计算机专业知识的全貌。&lt;/p>
&lt;p>这篇文章的第三部分简直就是一个知识资源向导库，给出了各个技能的方向和关键知识点，你可以跟随着这篇文章里的相关链接学到很多东西。&lt;/p>
&lt;h1 id="linkedin-高效的代码复查技巧">LinkedIn 高效的代码复查技巧&lt;/h1>
&lt;p>&lt;strong>&lt;a href="https://thenewstack.io/linkedin-code-review/">LinkedIn&amp;rsquo;s Tips for Highly Effective Code Review&lt;/a>&lt;/strong>，LinkedIn 的高效代码复查技巧。&lt;/p>
&lt;p>对于 Code Review，我曾经写过一篇文章 《&lt;a href="https://coolshell.cn/articles/11432.html">从 Code Review 谈如何做技术&lt;/a>》，讲述了为什么 Code Review 是一件很重要事情。今天推荐的这篇文章是 LinkedIn 的相关实践。&lt;/p>
&lt;p>这篇文章介绍了 LinkedIn 内部实践的 Code Review 形式。具体来说，LinkedIn 的代码复查有以下几个特点。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>从 2011 年开始，强制要求在团队成员之间做代码复查。Code Review 带来的反馈意见让团队成员能够迅速提升自己的技能水平，这解决了 LinkedIn 各个团队近年来因迅速扩张带来的技能不足的问题。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>通过建立公司范围的 Code Review 工具，这就可以做跨团队的 Code Review。既有利于消除 bug，提升质量，也有利于不同团队之间经验互通。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Code Review 的经验作为员工晋升的参考因素之一。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Code Review 的一个难点是，Reviewer 可能不了解某块代码修改的背景和目的。所以 LinkedIn 要求代码签入版本管理系统前，就对其做清晰的说明，以便复查者了解其目的，促进 Review 的进行。&lt;/p>
&lt;p>我认为，这个方法实在太赞了。因为，我看到很多时候，Reviewer 都会说不了解对方代码的背景或是代码量比较大而无法做 Code Review，然而，他们却没有找到相应的方法解决这个问题。&lt;/p>
&lt;p>LinkedIn 对提交代码写说明文档这个思路是一个非常不错的方法，因为代码提交人写文档的过程其实也是重新梳理的过程。我的个人经验是，写文档的时候通常会发现自己把事儿干复杂了，应该把代码再简化一下，于是就会回头去改代码。是的，写文档就是在写代码。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>有些 Code Review 工具所允许给出的反馈只是代码怎样修改以变得更好，但长此以往会让人觉得复查提出的意见都表示原先的代码不够好。为了提高员工积极性，LinkedIn 的代码复查工具允许提出&amp;quot;这段代码很棒&amp;quot;之类的话语，以便让好代码的作者得到鼓励。我认为，这个方法也很赞，正面鼓励的价值也不可小看。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>为 Code Review 的结果写出有目的性的注释。比如&amp;quot;消除重复代码&amp;quot;，&amp;ldquo;增加了测试覆盖率&amp;rdquo;，等等。长此以往也让团队的价值观得以明确。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Code Review 中，不但要 Review 提交者的代码，还要 Reivew 提交者做过的测试。除了一些单元测试，还有一些可能是手动的测试。提交者最好列出所有测试过的案例。这样可以让 Reviewer 可以做出更多的测试建议，从而提高质量。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>对 Code Review 有明确的期望，不过分关注细枝末节，也不要炫技，而是对要 Review 的代码有一个明确的目标。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h1 id="编程语言和代码质量的研究报告">编程语言和代码质量的研究报告&lt;/h1>
&lt;p>&lt;strong>&lt;a href="https://cacm.acm.org/magazines/2017/10/221326-a-large-scale-study-of-programming-languages-and-code-quality-in-github/">A Large-Scale Study of Programming Languages and Code Quality in GitHub&lt;/a>&lt;/strong>，编程语言和代码质量的研究报告。&lt;/p>
&lt;p>这是一项有趣的研究。有四个人从 GitHub 上分析了 728 个项目，6300 万行代码，近 3 万个提交人，150 万次 commits，以及 17 种编程语言（如下图所示），他们想找到编程语言对软件质量的影响。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/83/fa/83a8e04f9d2c0725c1b519f6456349fa.png" alt="">&lt;/p>
&lt;p>然后，他们还对编程语言做了一个分类，想找到不同类型的编程语言的 bug 问题。如下图所示：&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/89/8d/896d4909cb9e980dbc48c87adb51c48d.png" alt="">&lt;/p>
&lt;p>以及，他们还对这众多的开源软件做了个聚类，如下图：&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/b5/15/b5ff49830df9bdaabd42588a89ecb915.png" alt="">&lt;/p>
&lt;p>对 bug 的类型也做了一个聚类，如下图：&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/70/ed/70a562303a472634cf7bf801951b72ed.png" alt="">&lt;/p>
&lt;p>其中分析的方法我不多说了。我们来看一下相关的结果。&lt;/p>
&lt;p>首先，他们得出来的第一个结果是，从查看 bug fix 的 commits 的次数情况来看，C、C++、Objective-C、PHP 和 Python 中有很多很多的 commits 都是和 bug fix 相关的，而 Clojure、Haskell、Ruby、Scala 在 bug fix 的 commits 的数上明显要少很多。&lt;/p>
&lt;p>下图是各个编程语言的 bug 情况。如果你看到是正数，说明高于平均水平，如果你看到是负数，则是低于平均水平。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/a6/a7/a61c4f959ce7775e3d050320638553a7.png" alt="">&lt;/p>
&lt;p>第二个结论是，函数式编程语言的 bug 明显比大多数其它语言要好很多。有隐式类型转换的语言明显产生的 bug 数要比强类型的语言要少很多。函数式的静态类型的语言要比函数式的动态类型语言的程序出 bug 的可能性要小很多。&lt;/p>
&lt;p>第三，研究者想搞清是否 bug 数会和软件的领域相关。比如，业务型、中间件型、框架、lib，或是数据库。研究表明，并没有什么相关性。下面这个图是各个语言在不同领域的 bug 率。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/65/43/65cdbf74558d61d46eda9f92b35c8e43.png" alt="">&lt;/p>
&lt;p>第四，研究人员想搞清楚 bug 的类型是否会和语言有关系。的确如此，bug 的类型和语言是强相关性的。下图是各个语言在不同的 bug 类型的情况。如果你看到的是正数，说明高于平均水平，如果你看到的是负数，则是低于平均水平。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/9f/e4/9fa7b680469ca450af150ff82b07a4e4.png" alt="">&lt;/p>
&lt;p>也许，这份报告可以在你评估编程语言时有一定的借鉴作用。&lt;/p>
&lt;h1 id="电子书c-软件性能优化">电子书：《C++ 软件性能优化》&lt;/h1>
&lt;p>&lt;strong>&lt;a href="http://agner.org/optimize/optimizing_cpp.pdf">Optimizing Software in C++ - Agner Fog&lt;/a>&lt;/strong> - PDF，C++ 软件性能优化。&lt;/p>
&lt;p>这本书是所有 C++ 程序员都应该要读的一本书，它从事无巨细地从语言层面、编译器层面、内存访问层面、多线程层面、CPU 层面讲述了如何对软件性能调优。实在是一本经典的电子书。&lt;/p>
&lt;p>Agner Fog 还写了其它几本和性能调优相关的书，你可以到这个网址&lt;a href="%EF%BC%9Ahttp://www.agner.org/optimize/">下载&lt;/a>。&lt;/p>
&lt;ul>
&lt;li>Optimizing subroutines in assembly language: An optimization guide for x86 platforms&lt;/li>
&lt;li>The microarchitecture of Intel, AMD and VIA CPUs: An optimization guide for assembly programmers and compiler makers&lt;/li>
&lt;li>Instruction tables: Lists of instruction latencies, throughputs and micro-operation breakdowns for Intel, AMD and VIA CPUs&lt;/li>
&lt;li>Calling conventions for different C++ compilers and operating systems&lt;/li>
&lt;/ul>
&lt;p>我今天推荐的内容比较干，都需要慢慢吸收体会，当然最好是能到实践中用用，相信这样你会有更多的感悟和收获。另外，不知道你还对哪些方面的内容感兴趣，欢迎留言给我。我后面收集推荐内容的时候，会有意识地关注整理。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/fc/e9/fcc761001867c60f526665e237f831e9.jpg" alt="">&lt;/p></description></item><item><title>极客专栏: 08丨Go语言，Docker和新技术</title><link>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E/08%E4%B8%A8go%E8%AF%AD%E8%A8%80docker%E5%92%8C%E6%96%B0%E6%8A%80%E6%9C%AF/</link><pubDate>Fri, 27 May 2022 00:00:00 +0000</pubDate><guid>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E/08%E4%B8%A8go%E8%AF%AD%E8%A8%80docker%E5%92%8C%E6%96%B0%E6%8A%80%E6%9C%AF/</guid><description>
&lt;p>上个月，作为 Go 语言的三位创始人之一，Unix 老牌黑客罗勃·派克（Rob Pike）在新文章&amp;quot;Go: Ten years and climbing&amp;quot;中，回顾了 Go 语言的发展历程。文章提到，Go 语言这十年的迅猛发展快到连他们自己都没有想到，并且还成为了云计算领域新一代的开发语言。另外，文中还说到，中国程序员对 Go 语言的热爱完全超出了他们的想象，甚至他们都不敢相信是真的。&lt;/p>
&lt;p>这让我想起我在 2015 年 5 月拜访 Docker 公司在湾区的总部时，Docker 负责人也和我表达了相似的感叹：他们完全没有想到中国居然有那么多人喜欢 Docker，而且还有这么多人在为 Docker 做贡献，这让他们感到非常意外。此外，他还对我说，中国是除了美国本土之外的另外一个如此喜欢 Docker 技术的国家，在其它国家都没有看到。&lt;/p>
&lt;p>的确如他们所说，Go 语言和 Docker 这两种技术已经成为新一代的云计算技术，而且可以看到他们的发展态势非常迅猛。而中国也成为了像美国一样在强力推动这两种技术的国家。这的确是一件让人感到高兴的事儿，因为中国在跟随时代潮流这件事上已经做得相当不错了。&lt;/p>
&lt;p>然而就是在这样的背景下，这几年，总还是有人会问我是否要学 Go 语言，是否要学 Docker，Go 和 Docker 能否用在生产环境等等。从这些问题来看，对于 Go 语言和 Docker 这两种技术，国内的技术圈中还有相当大的一部分人在观望。&lt;/p>
&lt;p>所以，我想写这篇文章，并从两个方面来论述一下我的观点和看法。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>一个方面，为什么 Go 语言和 Docker 会是新一代的云计算技术。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>另一个方面，作为技术人员，我们如何识别什么样的新技术会是未来的趋势。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>这两个问题是相辅相成的，所以我会把这两个问题揉在一起谈。&lt;/p>
&lt;p>虽然 Go 语言是在 2009 年底开源的，但我是从 2012 年才开始接触和学习 Go 语言的。当时，我只花了一个周末两天的时间就学完了，而且在这两天的时间里，我还很快地写出了一个能完美运行的网页爬虫程序，以及一个简单的高并发文件处理服务，用于提取前面抓取的网页关键内容。这两个程序都很简单，总共不到 500 行代码。&lt;/p>
&lt;p>综合下来，我对 Go 语言有如下几点体会。&lt;/p>
&lt;p>第一，&lt;strong>语言简单，上手快&lt;/strong>。Go 语言的语法特性简直是太简单了，简单到你几乎玩不出什么花招，直来直去的，学习难度很低，容易上手。&lt;/p>
&lt;p>第二，&lt;strong>并行和异步编程几乎无痛点&lt;/strong>。Go 语言的 Goroutine 和 Channel 这两个神器简直就是并发和异步编程的巨大福音。像 C、C++、Java、Python 和 JavaScript 这些语言的并发和异步的编程方式控制起来就比较复杂了，并且容易出错，但 Go 语言却用非常优雅和流畅的方式解决了这个问题。这对于编程多年受尽并发和异步折磨的我来说，完全就是眼前一亮的感觉。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/8d/5f/8df5fd56cbb6343a9030265a5f3a565f.png" alt="">
（图片来自 Medium：Why should you learn Go?）&lt;/p>
&lt;p>第三，&lt;strong>Go 语言的 lib 库&amp;quot;麻雀虽小，五脏俱全&amp;quot;&lt;/strong>。Go 语言的 lib 库中基本上有绝大多数常用的库，虽然有些库还不是很好，但我觉得这都不是主要问题，因为随着技术的发展和成熟，这些问题肯定也都会随之解决。&lt;/p>
&lt;p>第四，&lt;strong>C 语言的理念和 Python 的姿态&lt;/strong>。C 语言的理念是信任程序员，保持语言的小巧，不屏蔽底层且对底层友好，关注语言的执行效率和性能。而 Python 的姿态是用尽量少的代码完成尽量多的事。于是我能够感觉到，Go 语言是想要把 C 和 Python 统一起来，这是多棒的一件事。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/03/f7/03ea333bf7b7bb2fe350c4f433047df7.png" alt="">
（图片来自 Medium：Why should you learn Go?）&lt;/p>
&lt;p>所以，即便 Go 语言存在诸多的问题，比如垃圾回收、异常处理、泛型编程等，但相较于上面这几个优势，我认为这些问题都是些小问题。于是就毫不犹豫地入坑了。&lt;/p>
&lt;p>当然，一个技术能不能发展起来，关键还要看三点。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>有没有一个比较好的社区&lt;/strong>。像 C、C++、Java、Python 和 JavaScript 的生态圈都是非常丰富和火爆的。尤其是有很多商业机构参与的社区那就更是人气爆棚了，比如 Linux 社区。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>有没有一个工业化的标准&lt;/strong>。像 C、C++、Java 这些编程语言都是有标准化组织的。尤其是 Java，它在架构上还搞出了像 J2EE 这样的企业级标准。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>有没有一个或多个杀手级应用&lt;/strong>。C、C++ 和 Java 的杀手级应用不用多说了，就算是对于 PHP 这样还不能算是一个优秀的编程语言来说，因为是 Linux 时代的第一个杀手级解决方案 LAMP 中的关键技术，所以，也发展起来了。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>在我看来，上面提到的三点至关重要，新的技术只需要占到其中一到两点就已经很不错了，何况有的技术，比如 Java 三点全都满足，所以，Java 的蓬勃发展也在情理之中。当然，除了上面这三点重要的，还有一些其它的影响因素，比如：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>学习难度是否低，上手是否快&lt;/strong>。这点非常重要，C++ 在这点上越做越不好了。&lt;/li>
&lt;li>&lt;strong>有没有一个不错的提高开发效率的开发框架&lt;/strong>。如：Java 的 Spring 框架，C++ 的 STL 等。&lt;/li>
&lt;li>&lt;strong>是否有一个或多个巨型的技术公司作为后盾&lt;/strong>。如：Java 和 Linux 后面的 IBM、Sun&amp;hellip;&amp;hellip;&lt;/li>
&lt;li>&lt;strong>有没有解决软件开发中的痛点&lt;/strong>。如：Java 解决了 C 和 C++ 的内存管理问题。&lt;/li>
&lt;/ul>
&lt;p>用这些标尺来衡量一下 Go 语言，我们可以清楚地看到：&lt;/p>
&lt;ul>
&lt;li>Go 语言容易上手；&lt;/li>
&lt;li>Go 语言解决了并发编程和底层应用开发效率的痛点；&lt;/li>
&lt;li>Go 语言有 Google 这个世界一流的技术公司在后面；&lt;/li>
&lt;li>Go 语言的杀手级应用是 Docker 容器，而容器的生态圈这几年可谓是发展繁荣，也是热点领域。&lt;/li>
&lt;/ul>
&lt;p>所以，Go 语言的未来是不可限量的。当然，我个人觉得，Go 可能会吞食很多 C、C++、Java 的项目。不过，Go 语言所吞食的项目应该主要是中间层的项目，既不是非常底层也不会是业务层。&lt;/p>
&lt;p>也就是说，Go 语言不会吞食底层到 C 和 C++ 那个级别的，也不会吞食到上层如 Java 业务层的项目。Go 语言能吞食的一定是 PaaS 上的项目，比如一些消息缓存中间件、服务发现、服务代理、控制系统、Agent、日志收集等等，他们没有复杂的业务场景，也到不了特别底层（如操作系统）的软件项目或工具。而 C 和 C++ 会被打到更底层，Java 会被打到更上层的业务层。这是我的一个判断。&lt;/p>
&lt;p>好了，我们再用上面的标尺来衡量一下 Go 语言的杀手级应用 Docker，你会发现基本是一样的。&lt;/p>
&lt;ul>
&lt;li>Docker 容易上手。&lt;/li>
&lt;li>Docker 解决了运维中的环境问题以及服务调度的痛点。&lt;/li>
&lt;li>Docker 的生态圈中有大公司在后面助力，比如 Google。&lt;/li>
&lt;li>Docker 产出了工业界标准 OCI。&lt;/li>
&lt;li>Docker 的社区和生态圈已经出现像 Java 和 Linux 那样的态势。&lt;/li>
&lt;li>&amp;hellip;&amp;hellip;&lt;/li>
&lt;/ul>
&lt;p>所以，早在三四年前我就觉得 Docker 一定会是未来的技术。虽然当时的坑儿还很多，但是，相对于这些大的因素来说，那些小坑都不是问题。只是需要一些时间，这些小坑在未来 5-10 年就可以完全被填平了。&lt;/p>
&lt;p>同样，我们可以看到 Kubernetes 作为服务和容器调度的关键技术一定会是最后的赢家。这点我在去年初就能够很明显地感觉到了。&lt;/p>
&lt;p>关于 Docker 我还想多说几句，这是云计算中 PaaS 的关键技术。虽然，这世上在出现 Docker 之前，几乎所有的要玩公有 PaaS 的公司和产品都玩不起来，比如：Google 的 GAE，国内的各种 XAE，如淘宝的 TAE，新浪的 SAE 等。但我还是想说，&lt;strong>PaaS 是一个被世界或是被产业界严重低估的平台&lt;/strong>。&lt;/p>
&lt;p>PaaS 层是承上启下的关键技术，任何一个不重视 PaaS 的公司，其技术架构都不可能让这家公司成长为一个大型的公司。因为 PaaS 层的技术主要能解决下面这些问题。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>软件生产线的问题&lt;/strong>。持续集成和持续发布，以及 DevOps 中的技术必须通过 PaaS。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>分布式服务化的问题&lt;/strong>。分布式服务化的服务高可用、服务编排、服务调度、服务发现、服务路由，以及分布式服务化的支撑技术完全是 PaaS 的菜。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>提高服务的可用性 SLA&lt;/strong>。提高服务可用性 SLA 所需要的分布式、高可用的技术架构和运维工具，也是 PaaS 层提供的。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>软件能力的复用&lt;/strong>。软件工程中的核心就是软件能力的复用，这一点也完美地体现在 PaaS 平台的技术上。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>老实说，这些问题的关键程度已经到了能判断一家技术驱动公司的研发能力是否靠谱的程度。没有这些技术，我认为，依托技术拓展业务的公司机会就不会很大。&lt;/p>
&lt;p>在后面，我会另外写几篇文章给你详细地讲一下分布式服务化和 PaaS 平台的重要程度。&lt;/p>
&lt;p>最后，我还要说一下，为什么要早一点地进入这些新技术，而不是等待这些技术成熟了后再进入。原因有这么几个。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>技术的发展过程非常重要&lt;/strong>。我进入 Go 和 Docker 的技术不能算早，但也不算晚，从 2012 年学习 Go，再到 2013 年学习 Docker 再到今天，我清楚地看到了这两种技术的生态圈发展过程。这个过程中，我收获最大的并不是这些技术本身，而是一个技术的变迁和行业的发展。&lt;/li>
&lt;/ul>
&lt;p>从中，我看到了非常具体的各种浪潮和思路，这些东西比起 Go 和 Docker 来说更有价值。因为，这不但让我重新思考我已掌握的技术以及如何更好地解决已有的问题，而且还让我看到了未来。我不但有了技术优势，而且这些知识还让我的技术生涯有了更多的可能性。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>这些关键新技术，可以让你提前抢占技术的先机&lt;/strong>。这一点对一个需要技术领导力的个人或公司来说都是非常重要的。&lt;/li>
&lt;/ul>
&lt;p>如果一个公司或是个人能够占有技术先机，就会比其它公司或个人有更大的影响力。一旦未来行业需求引爆，那么这个公司或是个人的影响力就会形成一个比较大的护城河，并可以快速地从中获取经济利益。&lt;/p>
&lt;p>最近，在与中国移动、中国电信以及一些股份制银行交流的过程中，我看到通讯行业、金融行业对于 PaaS 平台的理解已经超过了互联网公司，而我近 3 年来在这些技术上的研究让我也从中受益匪浅。&lt;/p>
&lt;p>所以，Go 语言和 Docker 作为 PaaS 平台的关键技术前途是无限的，我很庆幸自己赶上了这波浪潮，也很庆幸自己在 3 年前就看到了这个趋势，所以现在我也在用这些技术开发相关的技术产品，并助力于为高速成长的公司提供这些关键技术。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/fc/e9/fcc761001867c60f526665e237f831e9.jpg" alt="">&lt;/p></description></item><item><title>极客专栏: 09丨答疑解惑：渴望、热情和选择</title><link>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E/09%E4%B8%A8%E7%AD%94%E7%96%91%E8%A7%A3%E6%83%91%E6%B8%B4%E6%9C%9B%E7%83%AD%E6%83%85%E5%92%8C%E9%80%89%E6%8B%A9/</link><pubDate>Fri, 27 May 2022 00:00:00 +0000</pubDate><guid>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E/09%E4%B8%A8%E7%AD%94%E7%96%91%E8%A7%A3%E6%83%91%E6%B8%B4%E6%9C%9B%E7%83%AD%E6%83%85%E5%92%8C%E9%80%89%E6%8B%A9/</guid><description>
&lt;p>自从专栏上线以来，我陆陆续续从专栏留言、微信、微博、公开演讲等多种途径收到了一些用户的提问。在这篇答疑文章中，我特意挑选了其中最有代表性的三个问题来回答，希望能对你有帮助。&lt;/p>
&lt;ul>
&lt;li>加班太严重完全没有时间学习，怎么办？&lt;/li>
&lt;li>为什么你能写出这么多东西？&lt;/li>
&lt;li>怎样选择自己的人生和职业发展？&lt;/li>
&lt;/ul>
&lt;h1 id="加班太严重完全没有时间学习怎么办">加班太严重完全没有时间学习，怎么办？&lt;/h1>
&lt;p>过去的 7 年时间里，这个问题我已经被很多人问过无数遍了。我觉得有必要在这里统一回答一下。老实说，我真的很理解年轻人工作压力大这事儿，现在的公司加班都很厉害，尤其在大城市工作还要算上路上奔波的时间，这样一来，对于很多人来说，可能就完全没有时间学习和成长了。&lt;/p>
&lt;p>但是从另外一方面，我们在通宵打游戏，追美剧，泡妞的时候，从来不会给自己找借口说时间不够。我们总是能够挤得出时间来干这些&amp;quot;顺人性&amp;quot;的事，甚至做到废寝忘食，而不找任何借口。&lt;/p>
&lt;p>所以，我觉得，可能并不在于加班和工作强度大到没时间，关键看你对学习有多少的渴望程度，对要学的东西有多大的热情。这点是非常重要的，因为学习这事其实挺反人性的。反人性的事基本上都是要付出很多，而且还要坚持很久。所以，如果对学习没有渴望的话，或是不能从学习中找到快乐的话，那么其实是很难坚持的，无论你有没有时间。&lt;/p>
&lt;p>说两个发生在我身上的故事供大家参考。&lt;/p>
&lt;p>第一个故事，发生在 2001 年到 2002 年期间，那时我还是一个外包程序员，有一整年被当成劳动力外包进了某银行做软件开发，从早上 9 点工作到晚上 10 点，每周要从周一工作到周六。这么忙，但是我坚持每天晚上看半个小时到一个小时的书，看得不多，一天 2-3 页。一年后，我看完了两本经典书，一本是《TCP/IP 详解：卷 I》，另一本是《UNIX 环境高级编程》。&lt;/p>
&lt;p>第二个故事，是在 2002 年到 2003 年的时候，我到了一家做分布式系统的公司工作。因为那里的技术比较复杂，我有点跟不上，所以，周末和节假日的时候，我都会到公司来，不是工作，而是看书学习（因为那时我是一个北漂，完全没有个人电脑，只能去蹭公司的电脑）。后来公司的物管都认识了我，甚至经常在周末和节假日的时候打电话给我，让我帮物业做点小事。比如某空调漏水，让我帮他们把接水的桶倒一下&amp;hellip;&amp;hellip;&lt;/p>
&lt;p>我真的不算聪明的人，但是，我对学习真的是有渴望的。说得好听一点，我希望自己在不停地成长，不辜负生活在这个信息化大变革的时代。说得不好一点，我从银行出来了，很多人要看我的笑话，我不能让他们看我的笑话，所以我必须努力。我的渴望就来自这两点。&lt;/p>
&lt;p>时间一定是能找得到的，就看你对你要干的事有多大的渴望程度和多大的热情。 只要你真的想做，你就一定能想出各种各样的招儿来为自己挤出时间。&lt;/p>
&lt;p>在后面的文章中，我还会写一些关于时间管理的主题，敬请关注。&lt;/p>
&lt;h1 id="为什么你能够写出这么多东西">为什么你能够写出这么多东西？&lt;/h1>
&lt;p>其实，还是上面的那个问题，就是你对写作这个事有多少的兴趣和热情。&lt;/p>
&lt;p>我还是先说一下，我对写东西这个事的热情是怎么来的。从 2002 年开始写东西到今天，我基本上经历了几个阶段。&lt;/p>
&lt;p>&lt;strong>第一个阶段，是学习的阶段&lt;/strong>。因为在我刚入行的时候，软件公司对文档的要求还是比较高的，干什么事都要写个文档，所以，我就有了写文档的习惯。不过，这个阶段，对于我个人来说，我会把学习到的东西都以笔记的方式记录下来，方便我以后可以翻出来看看。所以，这个阶段主要还是学习的阶段。&lt;/p>
&lt;p>&lt;strong>第二个阶段，是有利益驱动的阶段&lt;/strong>。正如《程序员如何用技术变现》一文中提到的，因为我写的一篇技术文章，让我接到了一个培训的私活，两天时间就挣了我一个月的工资。说实话，这件事给了我很大的鼓励，让我有了更多的热情来写文章。&lt;/p>
&lt;p>&lt;strong>第三个阶段，是记录自己观点打自己脸的阶段&lt;/strong>。这个时候，我遇到了博客火爆的时代，我看到很多人写博客来记录自己的观点和想法，我也跟着写博客，记录一些自己的想法和观点。时间一长，我发现有个有趣的事&amp;mdash;&amp;mdash;我看自己好几年前写的东西，发现要么是我以前记录的观点打了现在的脸，要么就是现在打了自己过去的脸。&lt;/p>
&lt;p>这种有点科幻色彩的跨时空打自己脸的方式，让我觉得很好，因为这里面，我能够看到自己成长的过程，并且可以及时修正，这真是太好了。&lt;/p>
&lt;p>&lt;strong>第四个阶段，是与他人交互的阶段&lt;/strong>。这个阶段，我开始写一些观点鲜明，甚至看上去比较极端或是理想的文章了。而且我的文章开始有很多人转载和评论，还时不时地引发争论。我发现在这个过程中，我的收获也很大，因为一旦一件事被真正地讨论起来（而不是点赞和转发），就会有很多知识命中了我的认知盲区。虽然这会被别人批评或是指责，但是，我能从中收获到更多，因为我会从不同的观点，以及别人的批评中，让自己变得更加完善和成熟。&lt;/p>
&lt;p>而且，我从写作中还能训练自己的表达能力，这让我能够更好更漂亮地与别人交流和沟通。这一点对于我们整天面对电脑的技术人员来说，太重要了。&lt;/p>
&lt;p>因为我能从写作中得到这么多的好处，所以我当然就能坚持下来了。虽然，我近几年的文章更新频率比较低，但是，我还是在坚持，因为我能从中收获很多对我个人有帮助、有提升、有价值的东西。&lt;/p>
&lt;p>我相信，只要你坚持下来，你一定也会有和我一样的感受。&lt;/p>
&lt;h1 id="怎样选择自己的人生和职业发展">怎样选择自己的人生和职业发展？&lt;/h1>
&lt;p>这也是一个我经常被问到的问题。老实说，我因为这个问题写了好多文章，比如在 CoolShell 上的《技术人员的发展之路》、《算法与人生》，包括在知乎上的一些回答。不过，老实说，这个问题实在是太大了。而且不同的人有不同的想法和追求，所以，这是一个完全没有正确答案的问题。&lt;/p>
&lt;p>虽然我给不出具体的答案，但是我还是可以给出一些相关的思路。希望这些思想能对你有启发，能帮助你规划和思考自己的职业或是人生。&lt;/p>
&lt;p>总体来说，我把人生分为两个阶段。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>一个是在 20-30 岁，这是打基础的阶段&lt;/strong>。在这个阶段，我们要的是开阔眼界，把基础打扎实，努力学习和成长。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>另一个是在 30-40 岁，这是人生发展的阶段&lt;/strong>。因为整个社会一定会把社会的重担交给这群人，30-40 岁的人年富力强，既有经验又有精力，还敢想敢干，所以这群人才是整个社会的中流砥柱。在这个阶段，你需要明确自己奋斗的方向，需要做有挑战的事儿，需要提升自己的技术领导力（关于如何发展技术领导力，可以参看我在本专栏的相关文章）。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>而过了 40 岁，你的事业和人生就有可能会被定型，不过这也不是绝对的。我只是想说，20-40 岁这 20 年是我们每个人最黄金的发展阶段，我们每一个人都要好好把握。&lt;/p>
&lt;p>除此之外，我再从我的角度给大家一些建议。&lt;/p>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>客观地审视自己&lt;/strong> 。找到自己的长处，不断地在自己的长处上发展自我。知道自己几斤几两才能清楚自己适合干什么。不然，目标设置得过高自己达不到，反而让自己难受。在职场上，审视自己的最佳方式，就是隔三差五就出去面试一把，看看自己在市场上能够到什么样的级别。&lt;strong>如果你超过了身边的大多数人，你不妨选择得激进一些冒险一些，否则，还是按部就班地来吧&lt;/strong>。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>确定自己想要什么&lt;/strong> 。如果不确定这个事，你就会纠结，不知道自己要什么，也就不知道自己要去哪里。注意，你不可能什么都要，你需要极端地知道自己要什么。&lt;strong>所谓&amp;quot;极端&amp;quot;，就是自己不会受到其它东西或其他人的影响，不会因为这条路上有人退出你会开始怀疑或者迷茫，也不会因为别的路上有人成功了，你就会羡慕&lt;/strong>。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>注重长期的可能性，而不是短期的功利&lt;/strong>。20-30 岁应该多去经历一些有挑战的事，多去选择能给自己带来更多可能性的事。多去选择能让自己成长的事，尤其是能让自己开阔眼界的事情。人最害怕的不是自己什么都不会，而是自己不知道自己不会。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>尽量关注自己会得到的东西，而不是自己会失去的东西&lt;/strong>。因为无论你怎么选，你都会有得有失。（绝大多数人都会考虑自己会失去的，而不是考虑自己会得到的。）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>不要和大众的思维方式一样&lt;/strong>。因为，绝大多数人都是平庸的，所以，如果你的思维方式和大众一样，这意味着你做出来的选择也会和大众一样平庸。如果你和大众不一样，那么只有两种情况，一个是你比大多数人聪明，一个是你比大多数人愚蠢。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>希望我的这些思考能给你一些启发和帮助。我最近有个感慨就是，很多事情能做到什么程度，其实在思想的源头就被决定了，因为它会绝大程度地受到思考问题的出发点、思维方式、格局观、价值观等因素影响。这些才是最本源的东西，甚至可以定义成思维的&amp;quot;基因&amp;quot;。就我们程序员而言，我认为，编码能力很重要，但是技术视野、技术洞察力，以及我们如何用技术解决问题的能力更为重要。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/40/18/40341574317cc135385c6946a17d2818.jpg" alt="">&lt;/p>
&lt;p>&lt;a href="https://time.geekbang.org/activity/sale-poster?utm_source=geektime&amp;amp;utm_medium=chenhao&amp;amp;utm_campaign=201803&amp;amp;utm_content=chenhaofxbanner">戳此获取你的专属海报&lt;/a>&lt;/p></description></item><item><title>极客专栏: 10丨如何成为一个大家愿意追随的Leader？</title><link>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E/10%E4%B8%A8%E5%A6%82%E4%BD%95%E6%88%90%E4%B8%BA%E4%B8%80%E4%B8%AA%E5%A4%A7%E5%AE%B6%E6%84%BF%E6%84%8F%E8%BF%BD%E9%9A%8F%E7%9A%84leader/</link><pubDate>Fri, 27 May 2022 00:00:00 +0000</pubDate><guid>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E/10%E4%B8%A8%E5%A6%82%E4%BD%95%E6%88%90%E4%B8%BA%E4%B8%80%E4%B8%AA%E5%A4%A7%E5%AE%B6%E6%84%BF%E6%84%8F%E8%BF%BD%E9%9A%8F%E7%9A%84leader/</guid><description>
&lt;p>之前的文章，我们分享过技术领导力（Leadership）相关的话题，主要讨论了作为一个技术人，如何取得技术上的领先优势，而不是如何成为一个技术管理者。今天的文章中，我们着重聊聊如何成为一个大家愿意跟随的技术领导者（Leader）。注意，Leader 不是管理者，不是经理，更不是职称，而是一个领头人。&lt;/p>
&lt;p>所谓领头人和经理或管理者的最大差别就是，领头人（Leader）是大家愿意追随的，而经理或管理者（Boss）则是一种行政和职位上的威慑。说白了，Leader 的影响力来自大家愿意跟随的现象，而经理或管理者的领导力来自职位和震慑，这两者是完全不同的。&lt;/p>
&lt;h1 id="leader-和-boss-的不同">Leader 和 Boss 的不同&lt;/h1>
&lt;p>再或者用通俗的话说，Leader 是大家跟我一起上，而 Boss 则是大家给我上，一个在团队的前面，一个在团队的后面。&lt;/p>
&lt;p>具体来说，这两者的不同点如下。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>Boss 是驱动员工，Leader 是指导员工&lt;/strong>。在面对项目的时候，Boss 制定时间计划，并且推动（push）和鞭策员工完成工作，而 Leader 则是和员工一起讨论工作细节，指导员工关注工作的重点，和员工一起规划出（work out）工作的方向和计划，并且在工作中和员工一起解决细节难题，帮助员工完成工作。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Boss 制造畏惧，Leader 制造热情&lt;/strong>。Boss 在工作中是用工作职位级别压人，用你的绩效考核来制造威慑，让员工畏惧他，从而推行工作。而 Leader 是通过描绘远景，制造激动人心的目标来鼓舞和触发团队的热情和斗志。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Boss 面对错误喜欢使用人事惩罚的手段，而 Leader 面对错误喜欢寻找解决问题的技术或管理方法&lt;/strong>。惩罚员工和解决问题完全是两码事，Boss 因为并不懂技术也并不懂问题的细节，所以他们只能使用惩罚这样的手段，而 Leader 通常是喜欢解决问题的技术型人才，所以，他们会深入技术细节，从技术上找到既治标又治本的技术方案或管理方式。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Boss 只是知道怎么做，而 Leader 则是展示怎么做&lt;/strong>。一个好 Leader 的最大特点就是 Lead by Example，以身作则，用身教而不是言传。而 Boss 只是在说教，总是在大道理上说的一套又一套，但从来不管技术细节。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Boss 是用人，而 Leader 是发展人&lt;/strong>。Boss 不关心人的发展，把人当成劳动力。而 Leader 则会看到人的潜力和特长，通过授权、指导和给员工制定成长计划让员工成长，从而发展员工。所以，我们通常可以看到 Boss 总是说自己的员工有这个问题有那个问题，而 Leader 总是说，如何让员工成长以解决员工个人的各种问题。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Boss 从团队收割成绩，而 Leader 则是给予团队成绩&lt;/strong>。Boss 通常都会把团队的成绩占为己有，虽然 Boss 会说这是团队的功劳，但基本上是一句带过。而 Leader 则是让团队成功，让团队的成员站在台前，自己甘当绿叶和铺路石。Leader 知道只有团队的每个人成功了，团队才会成功，所以，Leader 会帮助团队中的每个人更好更流畅地走向成功。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Boss 喜欢命令和控制（ Command + Control ），而 Leader 喜欢沟通和协作（ Communication + Cooperation ）&lt;/strong>。Boss 喜欢通过命令来控制员工的行为，从而实现团队的有效运转，而 Leader 喜欢通过沟通和协作来增加员工的参与感，从而让员工觉得这是自己的事，愿意为之付出。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Boss 喜欢说&amp;quot;给我上&amp;quot;，而 Leader 喜欢说&amp;quot;跟我上&amp;quot;&lt;/strong>。Boss 总是躲在团队后面，让团队冲锋陷阵，而 Leader 总是冲在前面用自己的行动领着团队浴血奋战。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/2d/ce/2dd368279b137d965d2591d4b2c166ce.jpg" alt="">&lt;/p>
&lt;p>从上面这些比较，我们应该可以看到 Boss 和 Leader 的不同，相信你已经有了一些了解和认识到什么才是一个真正的 Leader，什么才是一个 Leader 应有的素质和行为。&lt;/p>
&lt;p>下面，我将结合我的一些经历和经验分享一下，如何才能成为一个大家愿意追随的人。&lt;/p>
&lt;h1 id="如何成为众人愿意追随的-leader">如何成为众人愿意追随的 Leader&lt;/h1>
&lt;p>说白了，要成为一个大家愿意追随的人，那么你需要有以下这些&amp;quot;征兆&amp;quot;。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>帮人解决问题&lt;/strong>。团队或身边大多数人都在问：&amp;ldquo;这个问题怎么办？&amp;quot;，而你总是能站出来告诉大家该怎么办。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>被人依赖&lt;/strong>。团队或身边大多数人在做比较关键的决定时，都会来找你咨询意见和想法。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>要有这样的现象，你需要有技术领导力。关于技术领导力，你可以参看本专栏主题为《如何才能拥有技术领导力？》的文章。有没有技术领导力（Leadership），是成为一个 Leader 非常关键的因素。因为人们想要跟随的人通常都是比自己强比自己出色的人，或是能够跟他学到东西，能够跟他成长的人。&lt;/p>
&lt;p>但是，有了技术领导力可能并不够，作为一个 Leader，你还需要有其它的一些能力和素质。比如，和我一起共事过的人和下属，他们会把我当成他们的朋友，他们会和我交流很多在员工和老板间比较禁忌的话题，比如：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>有猎头或是别的公司来挖我的下属，我的下属会告诉我，并会征求我的意见。除了帮他们分析利弊，有些时候，我还会帮他们准备面试。甚至，我有时候还会为我的下属介绍其它公司的工作机会。不要误会我（Don&amp;rsquo;t get me wrong），我并不是不站在公司利益的角度，我这样做完全是站在公司利益的角度。&lt;/p>
&lt;p>你要知道这个世界很大，一个公司或是一个 Leader 很难做到把人一辈子留下来，因为人总是需要有不同经历的，优秀的人更是如此。既然做不到把人留一辈子，那么不妨把这件事做得漂亮一些，这样会让要离开的员工觉得这个 Leader 或是这个公司的胸怀不一般，可能是他再也碰不到的公司或 Leader，反而会想留下来，或是离开后又想回来。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>下属会来找我分享他的难处和让他彷徨的事情，包括吐槽公司。一般来说，下属是不会找老板吐槽公司的，因为这是办公室中的禁忌。但是作为老板和经理，其实我们都知道，员工是一定会吐槽老板和公司的。既然做不到不让员工吐槽公司，那么不妨让这件事做得更漂亮一些&amp;mdash;&amp;mdash;可以公开透明地说，而不是在背后说，因为在背后说对公司或是团队的伤害更大。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>举了上面两个例子，我只是想告诉你一个 Leader 除了有技术领导力还需要有其它的素质和人格魅力。如果你的员工把这些看似禁忌的事和你分享向你倾吐，说明他们是何等信任你，何等看重你，这就说明你对他的价值已经非同寻常了，这份信任和托付对于一个 Leader 来说要小心呵护。&lt;/p>
&lt;p>下面是我罗列的一些比较关键的除了技术领导力之外的一个 Leader 需要的素质。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>赢得他人的信任&lt;/strong> 。信任是人类一切活动的基础，人与人之间的关系是否好，完全都是基于信任的。&lt;strong>对于信任来说，并不完全是别人相信你能做到某个事，还有别人愿意向你打开心扉，和你说他心里面最柔软的东西。而后者才是真正的信任&lt;/strong>。这还需要你的人格魅力，你的真诚，你的可信，你的价值观和你的情怀等一些诸多因素，才会让别人愿意找你分享心中的想法和情绪。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>开放的心态 + 倾向性的价值观&lt;/strong>。这两个好像太矛盾了，其实并不是。我想说的是，对于新生事物要有开放的心态，对于每个人的观点都有开放的心态，但并不是要认同所有的观点和事情，成为一个油腔滑调的人。&lt;/p>
&lt;p>也就是说，我可以听进各种不同观点，并在讨论中根据自己的价值观对不同的观点做出相应的判断，而并不是不加判断全部采用。因为如果你要做一个 Leader，你需要有明确的方向和观点，而不是说一些放之四海皆准的完全正确的废话。我的经验告诉我，对于各种各样的技术都要持一种比较开放的态度，可以讨论优缺点，但不会争个是非对错，尤其对于新技术来说，更要开放。&lt;/p>
&lt;p>然而，就价值观来说，还是需要有倾向性的，比如，我就倾向于不加班的文化，倾向于全栈，倾向于按职责分工而不是按技能分工，倾向于做一个 Leader 而不是 Boss，倾向于技术是第一生产力，倾向于 OKR 而不是 KPI&amp;hellip;&amp;hellip;&lt;/p>
&lt;p>&lt;strong>我的这些倾向性可以让别人更清楚地知道我是一个什么样的人，而不会对我琢磨不透，一会东一会西只会让人觉得你太油了，反而会产生距离感和厌恶感。我认为，倾向性的价值观是别人是否可以跟随你的一个基础&lt;/strong>。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Lead by Example&lt;/strong>。用自己的示例来 Lead，用自己的行为来向大家展示你的 Leadership。这就是说，你需要给大家做示范。很多时候，道理人人都知道，但未必人人都会做，知易行难，以身示范，一个示例会比讲一万遍道理都管用。&lt;/p>
&lt;p>所以我认为，对于软件开发来说，不写代码的架构师是根本不靠谱的。&lt;strong>要做一个有人愿意跟随的技术 Leader，你需要终身写代码，也就是所谓的 ABC &amp;ndash; Always Be Coding。这样，你会得到更多的实际经验，能够非常明白一个技术方案的优缺点，实现复杂度，知道什么是 Best Practice，你的方案才会更具执行力和实践性。当有了执行力，你就会获得更多的成就，而这些成就反过来会让更多的人来跟随你&lt;/strong>。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>保持热情和冲劲&lt;/strong>。在这个世界上，有太多太多的东西会让人产生沮丧、不满、彷徨、迷茫、疲惫等这些负面情绪，但是几乎所有的人都不会喜欢在这样的情绪中生活，我们每个人都会去追求更为积极更为正面的生活方式。&lt;/p>
&lt;p>所以，作为一个 Leader 无论在什么情况下，你都需要保持热情和冲劲，只有这样，你才会让别人有跟随的想法和冲动。&lt;/p>
&lt;p>但是，&lt;strong>所谓的保持热情和冲劲，并不是自欺欺人，也不是文过饰非，因为掩耳盗铃、掩盖问题、强颜欢笑的方式根本不是热情。真正的热情和冲劲是，正视问题，正视不足，正视错误，从中进行反思和总结得到更好的解决方案，不怕困难，迎难而上&lt;/strong>。&lt;/p>
&lt;p>正如鲁迅先生在《记念刘和珍君》中所说的那句话&amp;mdash;&amp;mdash;&amp;ldquo;真的猛士，敢于直面惨淡的人生，敢于正视淋漓的鲜血&amp;rdquo;。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>能够抓住重点，看透事物的本质&lt;/strong>。这个世界太复杂，有太多的因素和杂音影响着我们的判断和决定。绝大多数人都会在多重因素中迷失或是纠结。作为一个 Leader，能够抓住主要矛盾，看清事物的本质，给出清楚的观点或方向，简化复杂的事情，传道解惑、开启民智，让人豁然开朗、醍醐灌顶，才会让人追随之。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>描绘令人激动的方向，提供令人向住的环境&lt;/strong>。我相信，我们每个人心中都有激动和理想，就算是被现实摧残得最凶残的人，他们已经忘却了心中那些曾经的激动和理想，但我相信也只是暂时的。一个好的 Leader 一定会把每个人心中最真善美的东西呼唤出来，并且还能让人相信这是有机会有可能做到的。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>甘当铺路石，为他人创造机会&lt;/strong>。别人愿意跟随你，愿意和你共事，有一部分原因是你能够给别人带来更多的可能性和机会，别人觉得和你在一起能够成长，能够进步，你能够带着大家到达更远的地方。帮助别人其实就是帮助自己，成就他人其实也是在成就自己，这就像一个好的足球队一样，球队中的人都互相给队友创造机会，整个团队成功了，球队的每个人也就成功了。作为一个好的 Leader，你一定要在团队中创造好这样的文化和风气。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>做一个好的 Leader 真的不容易，你需要比大家强很多，你需要比大家付出更多；你需要容天下难容之事，你还需要保持热情和朝气；你需要带领团队守护理想，你还需要直面困难迎刃而上&amp;hellip;&amp;hellip;&lt;/p>
&lt;p>也许，你不必做一个 Leader，但是如果你有想跟随的人，你应该去跟随这样的 Leader！&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/fc/e9/fcc761001867c60f526665e237f831e9.jpg" alt="">&lt;/p></description></item><item><title>极客专栏: 11丨程序中的错误处理：错误返回码和异常捕捉</title><link>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E/11%E4%B8%A8%E7%A8%8B%E5%BA%8F%E4%B8%AD%E7%9A%84%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E9%94%99%E8%AF%AF%E8%BF%94%E5%9B%9E%E7%A0%81%E5%92%8C%E5%BC%82%E5%B8%B8%E6%8D%95%E6%8D%89/</link><pubDate>Fri, 27 May 2022 00:00:00 +0000</pubDate><guid>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E/11%E4%B8%A8%E7%A8%8B%E5%BA%8F%E4%B8%AD%E7%9A%84%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E9%94%99%E8%AF%AF%E8%BF%94%E5%9B%9E%E7%A0%81%E5%92%8C%E5%BC%82%E5%B8%B8%E6%8D%95%E6%8D%89/</guid><description>
&lt;p>今天，我们来讨论一下程序中的错误处理。也许你会觉得这个事没什么意思，处理错误的代码并不难写。但你想过没有，要把错误处理写好，并不是件容易的事情。另外，任何一个稳定的程序中都会有大量的代码在处理错误，所以说，处理错误是程序中一件比较重要的事情。这里，我会用两篇文章来系统地讲一下错误处理的各种方式和相关实践。&lt;/p>
&lt;h1 id="传统的错误检查">传统的错误检查&lt;/h1>
&lt;p>首先，我们知道，处理错误最直接的方式是通过错误码，这也是传统的方式，在过程式语言中通常都是用这样的方式处理错误的。比如 C 语言，基本上来说，其通过函数的返回值标识是否有错，然后通过全局的&lt;code>errno&lt;/code>变量并配合一个 &lt;code>errstr&lt;/code> 的数组来告诉你为什么出错。&lt;/p>
&lt;p>为什么是这样的设计？道理很简单，除了可以共用一些错误，更重要的是这其实是一种妥协。比如：&lt;code>read()&lt;/code>, &lt;code>write()&lt;/code>, &lt;code>open()&lt;/code> 这些函数的返回值其实是返回有业务逻辑的值。也就是说，这些函数的返回值有两种语义，一种是成功的值，比如 &lt;code>open()&lt;/code> 返回的文件句柄指针 &lt;code>FILE*&lt;/code> ，或是错误 &lt;code>NULL&lt;/code>。这样会导致调用者并不知道是什么原因出错了，需要去检查 &lt;code>errno&lt;/code> 来获得出错的原因，从而可以正确地处理错误。&lt;/p>
&lt;p>一般而言，这样的错误处理方式在大多数情况下是没什么问题的。但是也有例外的情况，我们来看一下下面这个 C 语言的函数：&lt;/p>
&lt;pre>&lt;code>int atoi(const char *str)
&lt;/code>&lt;/pre>
&lt;p>这个函数是把一个字符串转成整型。但是问题来了，如果一个要传的字符串是非法的（不是数字的格式），如 &amp;ldquo;ABC&amp;rdquo; 或者整型溢出了，那么这个函数应该返回什么呢？出错返回，返回什么数都不合理，因为这会和正常的结果混淆在一起。比如，返回 &lt;code>0&lt;/code>，那么会和正常的对 &amp;ldquo;0&amp;rdquo; 字符的返回值完全混淆在一起。这样就无法判断出错的情况。你可能会说，是不是要检查一下 &lt;code>errno&lt;/code>，按道理说应该是要去检查的，但是，我们在 C99 的规格说明书中可以看到这样的描述&amp;mdash;&amp;mdash;&lt;/p>
&lt;blockquote>
&lt;p>7.20.1&lt;/p>
&lt;p>The functions atof, atoi, atol, and atoll need not affect the value of the integer expression errno on an error. If the value of the result cannot be represented, the behavior is undeﬁned.&lt;/p>
&lt;/blockquote>
&lt;p>像&lt;code>atoi()&lt;/code>, &lt;code>atof()&lt;/code>, &lt;code>atol()&lt;/code> 或是 &lt;code>atoll()&lt;/code> 这样的函数是不会设置 &lt;code>errno&lt;/code>的，而且，还说了，如果结果无法计算的话，行为是&lt;code>undefined&lt;/code>。所以，后来，libc 又给出了一个新的函数&lt;code>strtol()&lt;/code>，这个函数在出错的时会设置全局变量&lt;code>errno&lt;/code> ：&lt;/p>
&lt;pre>&lt;code>long strtol(const char *restrict str, char **restrict endptr, int base);
&lt;/code>&lt;/pre>
&lt;p>于是，我们就可以这样使用：&lt;/p>
&lt;pre>&lt;code>long val = strtol(in_str, &amp;amp;endptr, 10); //10 的意思是 10 进制
// 如果无法转换
if (endptr == str) {
fprintf(stderr, &amp;quot;No digits were found\n&amp;quot;);
exit(EXIT_FAILURE);
}
// 如果整型溢出了
if ((errno == ERANGE &amp;amp;&amp;amp; (val == LONG_MAX || val == LONG_MIN)) {
fprintf(stderr, &amp;quot;ERROR: number out of range for LONG\n&amp;quot;);
exit(EXIT_FAILURE);
}
// 如果是其它错误
if (errno != 0 &amp;amp;&amp;amp; val == 0) {
perror(&amp;quot;strtol&amp;quot;);
exit(EXIT_FAILURE);
}
&lt;/code>&lt;/pre>
&lt;p>虽然，&lt;code>strtol()&lt;/code> 函数解决了 &lt;code>atoi()&lt;/code> 函数的问题，但是我们还是能感觉到不是很舒服和自然。&lt;/p>
&lt;p>因为，这种用 &lt;code>返回值&lt;/code> + &lt;code>errno&lt;/code> 的错误检查方式会有一些问题:&lt;/p>
&lt;ul>
&lt;li>程序员一不小心就会忘记返回值的检查，从而造成代码的 Bug；&lt;/li>
&lt;li>函数接口非常不纯洁，正常值和错误值混淆在一起，导致语义有问题。&lt;/li>
&lt;/ul>
&lt;p>所以，后来，有一些类库就开始区分这样的事情。比如，Windows 的系统调用开始使用 &lt;code>HRESULT&lt;/code> 的返回来统一错误的返回值，这样可以明确函数调用时的返回值是成功还是错误。但这样一来，函数的 input 和 output 只能通过函数的参数来完成，于是出现了所谓的 &lt;code>入参&lt;/code> 和 &lt;code>出参&lt;/code> 这样的区别。&lt;/p>
&lt;p>然而，这又使得函数接入中参数的语义变得复杂，一些参数是入参，一些参数是出参，函数接口变得复杂了一些。而且，依然没有解决函数的成功或失败可以被人为忽略的问题。&lt;/p>
&lt;h1 id="多返回值">多返回值&lt;/h1>
&lt;p>于是，有一些语言通过多返回值来解决这个问题，比如 Go 语言。Go 语言的很多函数都会返回 &lt;code>result, err&lt;/code> 两个值，于是:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>参数上基本上就是入参，而返回接口把结果和错误分离，这样使得函数的接口语义清晰；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>而且，Go 语言中的错误参数如果要忽略，需要显式地忽略，用 &lt;code>_&lt;/code> 这样的变量来忽略；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>另外，因为返回的 &lt;code>error&lt;/code> 是个接口（其中只有一个方法 &lt;code>Error()&lt;/code>，返回一个 &lt;code>string&lt;/code> ），所以你可以扩展自定义的错误处理。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>比如下面这个 JSON 语法的错误：&lt;/p>
&lt;pre>&lt;code>type SyntaxError struct {
msg string // description of error
Offset int64 // error occurred after reading Offset bytes
}
func (e *SyntaxError) Error() string { return e.msg }
&lt;/code>&lt;/pre>
&lt;p>在使用上会是这个样子:&lt;/p>
&lt;pre>&lt;code>if err := dec.Decode(&amp;amp;val); err != nil {
if serr, ok := err.(*json.SyntaxError); ok {
line, col := findLine(f, serr.Offset)
return fmt.Errorf(&amp;quot;%s:%d:%d: %v&amp;quot;, f.Name(), line, col, err)
}
return err
}
&lt;/code>&lt;/pre>
&lt;p>上面这个示例来自 Go 的官方文档 《&lt;a href="https://blog.golang.org/error-handling-and-go">Error Handling and Go&lt;/a>》，如果你有时间，可以点进去链接细看。&lt;/p>
&lt;p>多说一句，如果一个函数返回了多个不同类型的 &lt;code>error&lt;/code>，你也可以使用下面这样的方式：&lt;/p>
&lt;pre>&lt;code>if err != nil {
switch err.(type) {
case *json.SyntaxError:
...
case *ZeroDivisionError:
...
case *NullPointerError:
...
default:
...
}
}
&lt;/code>&lt;/pre>
&lt;p>但即便像 Go 这样的语言能让错误处理语义更清楚，而且还有可扩展性，也有其问题。如果写过一段时间的 Go 语言，你就会明白其中的痛苦&amp;mdash;&amp;mdash; &lt;code>if err != nil&lt;/code> 这样的语句简直是写到吐，只能在 IDE 中定义一个自动写这段代码的快捷键&amp;hellip;&amp;hellip;而且，正常的逻辑代码会被大量的错误处理打得比较凌乱。&lt;/p>
&lt;h1 id="资源清理">资源清理&lt;/h1>
&lt;p>程序出错时需要对已分配的一些资源做清理，在传统的玩法下，每一步的错误都要去清理前面已分配好的资源。于是就出现了 &lt;code>goto fail&lt;/code> 这样的错误处理模式。如下所示：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">#define FREE(p) if(p) { \
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic"> free(p); \
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic"> p = NULL; \
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic"> }
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">&lt;/span>&lt;span style="color:#000">main&lt;/span>&lt;span style="color:#000;font-weight:bold">()&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">char&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">*&lt;/span>&lt;span style="color:#000">fname&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>&lt;span style="color:#204a87">NULL&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">*&lt;/span>&lt;span style="color:#000">lname&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>&lt;span style="color:#204a87">NULL&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">*&lt;/span>&lt;span style="color:#000">mname&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>&lt;span style="color:#204a87">NULL&lt;/span>&lt;span style="color:#000;font-weight:bold">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">fname&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span> &lt;span style="color:#000;font-weight:bold">(&lt;/span> &lt;span style="color:#204a87;font-weight:bold">char&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">*&lt;/span> &lt;span style="color:#000;font-weight:bold">)&lt;/span> &lt;span style="color:#000">calloc&lt;/span> &lt;span style="color:#000;font-weight:bold">(&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">20&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#204a87;font-weight:bold">sizeof&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#204a87;font-weight:bold">char&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span> &lt;span style="color:#000;font-weight:bold">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">if&lt;/span> &lt;span style="color:#000;font-weight:bold">(&lt;/span> &lt;span style="color:#000">fname&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">==&lt;/span> &lt;span style="color:#204a87">NULL&lt;/span> &lt;span style="color:#000;font-weight:bold">){&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">goto&lt;/span> &lt;span style="color:#000">fail&lt;/span>&lt;span style="color:#000;font-weight:bold">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">lname&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span> &lt;span style="color:#000;font-weight:bold">(&lt;/span> &lt;span style="color:#204a87;font-weight:bold">char&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">*&lt;/span> &lt;span style="color:#000;font-weight:bold">)&lt;/span> &lt;span style="color:#000">calloc&lt;/span> &lt;span style="color:#000;font-weight:bold">(&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">20&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#204a87;font-weight:bold">sizeof&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#204a87;font-weight:bold">char&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span> &lt;span style="color:#000;font-weight:bold">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">if&lt;/span> &lt;span style="color:#000;font-weight:bold">(&lt;/span> &lt;span style="color:#000">lname&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">==&lt;/span> &lt;span style="color:#204a87">NULL&lt;/span> &lt;span style="color:#000;font-weight:bold">){&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">goto&lt;/span> &lt;span style="color:#000">fail&lt;/span>&lt;span style="color:#000;font-weight:bold">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">mname&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span> &lt;span style="color:#000;font-weight:bold">(&lt;/span> &lt;span style="color:#204a87;font-weight:bold">char&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">*&lt;/span> &lt;span style="color:#000;font-weight:bold">)&lt;/span> &lt;span style="color:#000">calloc&lt;/span> &lt;span style="color:#000;font-weight:bold">(&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">20&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#204a87;font-weight:bold">sizeof&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#204a87;font-weight:bold">char&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span> &lt;span style="color:#000;font-weight:bold">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">if&lt;/span> &lt;span style="color:#000;font-weight:bold">(&lt;/span> &lt;span style="color:#000">mname&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">==&lt;/span> &lt;span style="color:#204a87">NULL&lt;/span> &lt;span style="color:#000;font-weight:bold">){&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">goto&lt;/span> &lt;span style="color:#000">fail&lt;/span>&lt;span style="color:#000;font-weight:bold">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">......&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f57900">fail&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">FREE&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">fname&lt;/span>&lt;span style="color:#000;font-weight:bold">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">FREE&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">lname&lt;/span>&lt;span style="color:#000;font-weight:bold">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">FREE&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">mname&lt;/span>&lt;span style="color:#000;font-weight:bold">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">ReportError&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">ERR_NO_MEMORY&lt;/span>&lt;span style="color:#000;font-weight:bold">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这样的处理方式虽然可以，但是会有潜在的问题。最主要的一个问题就是你不能在中间的代码中有 &lt;code>return&lt;/code> 语句，因为你需要清理资源。在维护这样的代码时需要格外小心，因为一不注意就会导致代码有资源泄漏的问题。&lt;/p>
&lt;p>于是，C++ 的 RAII（Resource Acquisition Is Initialization）机制使用面向对象的特性可以容易地处理这个事情。RAII 其实使用 C++ 类的机制，在构造函数中分配资源，在析构函数中释放资源。下面看个例子。&lt;/p>
&lt;p>我们先看一个不好的示例：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c++" data-lang="c++">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">std&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">::&lt;/span>&lt;span style="color:#000">mutex&lt;/span> &lt;span style="color:#000">m&lt;/span>&lt;span style="color:#000;font-weight:bold">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">void&lt;/span> &lt;span style="color:#000">bad&lt;/span>&lt;span style="color:#000;font-weight:bold">()&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">m&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">lock&lt;/span>&lt;span style="color:#000;font-weight:bold">();&lt;/span> &lt;span style="color:#8f5902;font-style:italic">// 请求互斥
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">&lt;/span> &lt;span style="color:#000">f&lt;/span>&lt;span style="color:#000;font-weight:bold">();&lt;/span> &lt;span style="color:#8f5902;font-style:italic">// 若 f() 抛异常，则互斥绝不被释放
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">&lt;/span> &lt;span style="color:#204a87;font-weight:bold">if&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">!&lt;/span>&lt;span style="color:#000">everything_ok&lt;/span>&lt;span style="color:#000;font-weight:bold">())&lt;/span> &lt;span style="color:#204a87;font-weight:bold">return&lt;/span>&lt;span style="color:#000;font-weight:bold">;&lt;/span> &lt;span style="color:#8f5902;font-style:italic">// 提早返回，互斥绝不被释放
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">&lt;/span> &lt;span style="color:#000">m&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">unlock&lt;/span>&lt;span style="color:#000;font-weight:bold">();&lt;/span> &lt;span style="color:#8f5902;font-style:italic">// 若 bad() 抵达此语句，互斥才被释放
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">&lt;/span>&lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上面这个例子，在函数的第三条语句提前返回了，直接导致 &lt;code>m.unlock()&lt;/code> 没有被调用，这样会引起死锁问题。我们来看一下用 RAII 的方式是怎样解决这个问题的。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c++" data-lang="c++">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">// 首先，先声明一个 RAII 类，注意其中的构造函数和析构函数
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">&lt;/span>&lt;span style="color:#204a87;font-weight:bold">class&lt;/span> &lt;span style="color:#000">LockGuard&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">public&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">LockGuard&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">std&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">::&lt;/span>&lt;span style="color:#000">mutex&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">&amp;amp;&lt;/span>&lt;span style="color:#000">m&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">:&lt;/span>&lt;span style="color:#000">_m&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">m&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span> &lt;span style="color:#000">m&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">lock&lt;/span>&lt;span style="color:#000;font-weight:bold">();&lt;/span> &lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ce5c00;font-weight:bold">~&lt;/span>&lt;span style="color:#000">LockGuard&lt;/span>&lt;span style="color:#000;font-weight:bold">()&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span> &lt;span style="color:#000">m&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span> &lt;span style="color:#000">unlock&lt;/span>&lt;span style="color:#000;font-weight:bold">();&lt;/span> &lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">private&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">std&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">::&lt;/span>&lt;span style="color:#000">mutex&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">&amp;amp;&lt;/span> &lt;span style="color:#000">_m&lt;/span>&lt;span style="color:#000;font-weight:bold">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">// 然后，我们来看一下，怎样使用的
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">&lt;/span>&lt;span style="color:#204a87;font-weight:bold">void&lt;/span> &lt;span style="color:#000">good&lt;/span>&lt;span style="color:#000;font-weight:bold">()&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">LockGuard&lt;/span> &lt;span style="color:#000">lg&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">m&lt;/span>&lt;span style="color:#000;font-weight:bold">);&lt;/span> &lt;span style="color:#8f5902;font-style:italic">// RAII 类：构造时，互斥量请求加锁
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">&lt;/span> &lt;span style="color:#000">f&lt;/span>&lt;span style="color:#000;font-weight:bold">();&lt;/span> &lt;span style="color:#8f5902;font-style:italic">// 若 f() 抛异常，则释放互斥
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">&lt;/span> &lt;span style="color:#204a87;font-weight:bold">if&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">!&lt;/span>&lt;span style="color:#000">everything_ok&lt;/span>&lt;span style="color:#000;font-weight:bold">())&lt;/span> &lt;span style="color:#204a87;font-weight:bold">return&lt;/span>&lt;span style="color:#000;font-weight:bold">;&lt;/span> &lt;span style="color:#8f5902;font-style:italic">// 提早返回，LockGuard 析构时，互斥量被释放
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">&lt;/span>&lt;span style="color:#000;font-weight:bold">}&lt;/span> &lt;span style="color:#8f5902;font-style:italic">// 若 good() 正常返回，则释放互斥
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在 Go 语言中，使用&lt;code>defer&lt;/code>关键字也可以做到这样的效果。参看下面的示例：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">func&lt;/span> &lt;span style="color:#000">Close&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">c&lt;/span> &lt;span style="color:#000">io&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Closer&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">err&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">:=&lt;/span> &lt;span style="color:#000">c&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Close&lt;/span>&lt;span style="color:#000;font-weight:bold">()&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">if&lt;/span> &lt;span style="color:#000">err&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">!=&lt;/span> &lt;span style="color:#204a87;font-weight:bold">nil&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">log&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Fatal&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">err&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">func&lt;/span> &lt;span style="color:#000">main&lt;/span>&lt;span style="color:#000;font-weight:bold">()&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">r&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">err&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">:=&lt;/span> &lt;span style="color:#000">Open&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#4e9a06">&amp;#34;a&amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">if&lt;/span> &lt;span style="color:#000">err&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">!=&lt;/span> &lt;span style="color:#204a87;font-weight:bold">nil&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">log&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Fatalf&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#4e9a06">&amp;#34;error opening &amp;#39;a&amp;#39;\n&amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">defer&lt;/span> &lt;span style="color:#000">Close&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">r&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span> &lt;span style="color:#8f5902;font-style:italic">// 使用 defer 关键字在函数退出时关闭文件。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">r&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">err&lt;/span> &lt;span style="color:#000;font-weight:bold">=&lt;/span> &lt;span style="color:#000">Open&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#4e9a06">&amp;#34;b&amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">if&lt;/span> &lt;span style="color:#000">err&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">!=&lt;/span> &lt;span style="color:#204a87;font-weight:bold">nil&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">log&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Fatalf&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#4e9a06">&amp;#34;error opening &amp;#39;b&amp;#39;\n&amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">defer&lt;/span> &lt;span style="color:#000">Close&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">r&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span> &lt;span style="color:#8f5902;font-style:italic">// 使用 defer 关键字在函数退出时关闭文件。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">&lt;/span>&lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>不知道从上面这三个例子来看，不同语言的错误处理，你自己更喜欢哪个呢？就代码的易读和干净而言，我更喜欢 C++ 的 RAII 模式，然后是 Go 的 defer 模式，最后才是 C 语言的 goto fail 模式。&lt;/p>
&lt;h1 id="异常捕捉处理">异常捕捉处理&lt;/h1>
&lt;p>上面，我们讲了错误检查和程序出错后对资源的清理这两个事。能把这个事做得比较好的其实是 &lt;code>try - catch - finally&lt;/code> 这个编程模式。&lt;/p>
&lt;pre>&lt;code>try {
... // 正常的业务代码
} catch (Exception1 e) {
... // 处理异常 Exception1 的代码
} catch (Exception2 e) {
... // 处理异常 Exception2 的代码
} finally {
... // 资源清理的代码
}
&lt;/code>&lt;/pre>
&lt;p>把正常的代码、错误处理的代码、资源清理的代码分门别类，看上去非常干净。&lt;/p>
&lt;p>有一些人明确表示不喜欢 &lt;code>try - catch&lt;/code> 这种错误处理方式，比如著名的 软件工程师&lt;a href="https://www.joelonsoftware.com/2005/05/11/making-wrong-code-look-wrong/">Joel Spolsky&lt;/a>。&lt;/p>
&lt;p>但是，我想说一下，&lt;code>try - catch - finally&lt;/code> 这样的异常处理方式有如下一些好处。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>函数接口在 input（参数）和 output（返回值）以及错误处理的语义是比较清楚的。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>正常逻辑的代码可以与错误处理和资源清理的代码分开，提高了代码的可读性。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>异常不能被忽略（如果要忽略也需要 catch 住，这是显式忽略）。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>在面向对象的语言中（如 Java），异常是个对象，所以，可以实现多态式的 catch。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>与状态返回码相比，异常捕捉有一个显著的好处是，函数可以嵌套调用，或是链式调用。比如：&lt;code>int x = add(a, div(b,c));&lt;/code> 或 &lt;code>Pizza p = PizzaBuilder().SetSize(sz) .SetPrice(p)...;&lt;/code> 。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>当然，你可能会觉得异常捕捉对程序的性能是有影响的，这句话也对也不对。原因是这样的。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>异常捕捉的确是对性能有影响的，那是因为一旦异常被抛出，函数也就跟着 return 了。而程序在执行时需要处理函数栈的上下文，这会导致性能变得很慢，尤其是函数栈比较深的时候。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>但从另一方面来说，异常的抛出基本上表明程序的错误。程序在绝大多数情况下，应该是在没有异常的情况下运行的，所以，有异常的情况应该是少数的情况，不会影响正常处理的性能问题。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>总体而言，我还是觉得 &lt;code>try - catch - finally&lt;/code> 这样的方式是很不错的。而且这个方式比返回错误码在诸多方面都更好。&lt;/p>
&lt;p>但是，&lt;code>try - catch - finally&lt;/code> 有个致命的问题，那就是在异步运行的世界里的问题。try 语句块里的函数运行在另外一个线程中，其中抛出的异常无法在调用者的这个线程中被捕捉。这个问题就比较大了。&lt;/p>
&lt;h1 id="错误返回码-vs-异常捕捉">错误返回码 vs 异常捕捉&lt;/h1>
&lt;p>是返回错误状态，还是用异常捕捉的方式处理错误，可能是一个很容易引发争论的问题。有人说，对于一些偏底层的错误，比如：空指针、内存不足等，可以使用返回错误状态码的方式，而对于一些上层的业务逻辑方面的错误，可以使用异常捕捉。这么说有一定道理，因为偏底层的函数可能用得更多一些。但是我并不这么认为。&lt;/p>
&lt;p>&lt;strong>前面也比较过两者的优缺点，总体而言，似乎异常捕捉的优势更多一些。但是，我觉得应该从场景上来讨论这个事才是正确的姿势&lt;/strong>。&lt;/p>
&lt;p>要讨论场景，我们需要先把要处理的错误分好类别，这样有利于简化问题。&lt;/p>
&lt;p>因为，错误其实是很多的，不同的错误需要有不同的处理方式。但错误处理是有一些通用规则的。为了讲清楚这个事，我们需要把错误来分个类。我个人觉得错误可以分为三个大类。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>资源的错误&lt;/strong> 。当我们的代码去请求一些资源时导致的错误，比如打开一个没有权限的文件，写文件时出现的写错误，发送文件到网络端发现网络故障的错误，等等。&lt;strong>这一类错误属于程序运行环境的问题。对于这类错误，有的我们可以处理，有的我们则无法处理。比如，内存耗尽、栈溢出或是一些程序运行时关键性资源不能满足等等这些情况，我们只能停止运行，甚至退出整个程序。&lt;/strong>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>程序的错误&lt;/strong> 。比如：空指针、非法参数等。&lt;strong>这类是我们自己程序的错误，我们要记录下来，写入日志，最好触发监控系统报警&lt;/strong>。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>用户的错误&lt;/strong> 。比如：Bad Request、Bad Format 等这类由用户不合法输入带来的错误。&lt;strong>这类错误基本上是在用户的 API 层上出现的问题&lt;/strong>。比如，解析一个 XML 或 JSON 文件，或是用户输入的字段不合法之类的。&lt;/p>
&lt;p>&lt;strong>对于这类问题，我们需要向用户端报错，让用户自己处理修正他们的输入或操作。然后，我们正常执行，但是需要做统计，统计相应的错误率，这样有利于我们改善软件或是侦测是否有恶意的用户请求。&lt;/strong>&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>我们可以看到，这三类错误中，有些是我们希望杜绝发生的，比如程序的 Bug，有些则是我们杜绝不了的，比如用户的输入。而对于程序运行环境中的一些错误，则是我们希望可以恢复的。也就是说，我们希望可以通过重试或是妥协的方式来解决这些环境的问题，比如重建网络连接，重新打开一个新的文件。&lt;/p>
&lt;p>所以，是不是我们可以这样来在逻辑上分类：&lt;/p>
&lt;ul>
&lt;li>对于我们并不期望会发生的事，我们可以使用异常捕捉；&lt;/li>
&lt;li>对于我们觉得可能会发生的事，使用返回码。&lt;/li>
&lt;/ul>
&lt;p>比如，如果你的函数参数传入的对象不应该是一个 null 对象，那么，一旦传入 null 对象后，函数就可以抛异常，因为我们并不期望总是会发生这样的事。&lt;/p>
&lt;p>而对于一个需要检查用户输入信息是否正确的事，比如：电子邮箱的格式，我们用返回码可能会好一些。所以，对于上面三种错误的类型来说，程序中的错误，可能用异常捕捉会比较合适；用户的错误，用返回码比较合适；而资源类的错误，要分情况，是用异常捕捉还是用返回值，要看这事是不应该出现的，还是经常出现的。&lt;/p>
&lt;p>当然，这只是一个大致的实践原则，并不代表所有的事都需要符合这个原则。&lt;/p>
&lt;p>除了用错误的分类来判断是否用返回码还是用异常捕捉之外，我们还要从程序设计的角度来考虑哪种情况下使用异常捕捉更好，哪种情况下使用返回码更好。&lt;/p>
&lt;p>因为异常捕捉在编程上的好处比函数返回值好很多，所以很多使用异常捕捉的代码会更易读也更健壮一些。而返回码容易被忽略，所以，使用返回码的代码需要做好测试才能得到更好的软件质量。&lt;/p>
&lt;p>不过，我们也要知道，在某些情况下，你只能使用其中的一个，比如：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>在 C++ 重载操作符的情况下，你就很难使用错误返回码，只能抛异常；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>异常捕捉只能在同步的情况下使用，在异步模式下，抛异常这事就不行了，需要通过检查子进程退出码或是回调函数来解决；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>在分布式的情况下，调用远程服务只能看错误返回码，比如 HTTP 的返回码。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>所以，在大多数情况下，我们会混用这两种报错的方式，有时候，我们还会把异常转成错误码（比如 HTTP 的 RESTful API），也会把错误码转成异常（比如对系统调用的错误）。&lt;/p>
&lt;p>总之，&amp;ldquo;报错的类型&amp;rdquo; 和 &amp;ldquo;错误处理&amp;rdquo; 是紧密相关的，错误处理方法多种多样，而且会在不同的层面上处理错误。有些底层错误就需要自己处理掉（比如：底层模块会自动重建网络连接），而有一些错误需要更上层的业务逻辑来处理（比如：重建网络连接不成功后只能让上层业务来处理怎么办？降级使用本地缓存还是直接报错给用户？）。&lt;/p>
&lt;p>所以，不同的错误类型再加上不同的错误处理会导致我们代码组织层面上的不同，从而会让我们使用不同的方式。也就是说，&lt;strong>使用错误码还是异常捕捉主要还是看我们的错误处理流程以及代码组织怎么写会更清楚&lt;/strong>。&lt;/p>
&lt;p>通过学习今天的内容，你是不是已经对如何处理程序中的错误，以及在不同情况下怎样选择错误处理方法，有了一定的认知和理解呢？然而，这些知识和经验仅在同步编程世界中适用。因为在异步编程世界里，被调用的函数是被放到另外一个线程里运行的，所以本文中的两位主角，不管是错误返回码，还是异常捕捉，都难以发挥其威力。&lt;/p>
&lt;p>那么异步编程世界中是如何做错误处理的呢？我们将在下篇文章中讨论。同时，还会给你讲讲我在实战中总结出来的错误处理最佳实践。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/fc/e9/fcc761001867c60f526665e237f831e9.jpg" alt="">&lt;/p></description></item><item><title>极客专栏: 12丨程序中的错误处理：异步编程以及我的最佳实践</title><link>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E/12%E4%B8%A8%E7%A8%8B%E5%BA%8F%E4%B8%AD%E7%9A%84%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E4%BB%A5%E5%8F%8A%E6%88%91%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</link><pubDate>Fri, 27 May 2022 00:00:00 +0000</pubDate><guid>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E/12%E4%B8%A8%E7%A8%8B%E5%BA%8F%E4%B8%AD%E7%9A%84%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E4%BB%A5%E5%8F%8A%E6%88%91%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</guid><description>
&lt;p>上一篇文章中，我们讨论了错误返回码和异常捕捉，以及在不同情况下该如何选择和使用。本文中会接着讲两个有趣的话题：异步编程世界里的错误处理方法，以及我在实战中总结出来的错误处理最佳实践。&lt;/p>
&lt;h1 id="异步编程世界里的错误处理">异步编程世界里的错误处理&lt;/h1>
&lt;p>在异步编程的世界里，因为被调用的函数是被放到了另外一个线程里运行，这将导致：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>无法使用返回码&lt;/strong> 。因为函数在&amp;quot;被&amp;quot;异步运行中，所谓的返回只是把处理权交给下一条指令，而不是把函数运行完的结果返回。&lt;strong>所以，函数返回的语义完全变了，返回码也没有用了&lt;/strong>。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>无法使用抛异常的方式&lt;/strong> 。因为除了上述的函数立马返回的原因之外，抛出的异常也在另外一个线程中，不同线程中的栈是完全不一样的，所以主线程的 &lt;code>catch&lt;/code> 完全看不到另外一个线程中的异常。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>对此，在异步编程的世界里，我们也会有好几种处理错误的方法，最常用的就是 &lt;code>callback&lt;/code> 方式。在做异步请求的时候，注册几个 &lt;code>OnSuccess()&lt;/code>、 &lt;code>OnFailure()&lt;/code> 这样的函数，让在另一个线程中运行的异步代码来回调过来。&lt;/p>
&lt;h2 id="javascript-异步编程的错误处理">JavaScript 异步编程的错误处理&lt;/h2>
&lt;p>比如，下面这个 JavaScript 示例：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-JavaScript" data-lang="JavaScript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">function&lt;/span> &lt;span style="color:#000">successCallback&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">result&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">console&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">log&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#4e9a06">&amp;#34;It succeeded with &amp;#34;&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">+&lt;/span> &lt;span style="color:#000">result&lt;/span>&lt;span style="color:#000;font-weight:bold">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">function&lt;/span> &lt;span style="color:#000">failureCallback&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">error&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">console&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">log&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#4e9a06">&amp;#34;It failed with &amp;#34;&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">+&lt;/span> &lt;span style="color:#000">error&lt;/span>&lt;span style="color:#000;font-weight:bold">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">doSomething&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">successCallback&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">failureCallback&lt;/span>&lt;span style="color:#000;font-weight:bold">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>通过注册错误处理的回调函数，让异步执行的函数在出错的时候，调用被注册进来的错误处理函数，这样的方式比较好地解决了程序的错误处理。&lt;strong>而出错的语义从返回码、异常捕捉到了直接耦合错误出处函数的样子&lt;/strong>，挺好的。&lt;/p>
&lt;p>但是， 如果我们需要把几个异步函数顺序执行的话（异步程序中，程序执行的顺序是不可预测的、也是不确定的，而有时候，函数被调用的上下文是有相互依赖的，所以，我们希望它们能按一定的顺序处理），就会出现了所谓的 Callback Hell 的问题。如下所示：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">doSomething&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#204a87;font-weight:bold">function&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">result&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">doSomethingElse&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">result&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#204a87;font-weight:bold">function&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">newResult&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">doThirdThing&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">newResult&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#204a87;font-weight:bold">function&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">finalResult&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">console&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">log&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#4e9a06">&amp;#39;Got the final result: &amp;#39;&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">+&lt;/span> &lt;span style="color:#000">finalResult&lt;/span>&lt;span style="color:#000;font-weight:bold">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">},&lt;/span> &lt;span style="color:#000">failureCallback&lt;/span>&lt;span style="color:#000;font-weight:bold">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">},&lt;/span> &lt;span style="color:#000">failureCallback&lt;/span>&lt;span style="color:#000;font-weight:bold">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">},&lt;/span> &lt;span style="color:#000">failureCallback&lt;/span>&lt;span style="color:#000;font-weight:bold">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>而这样层层嵌套中需要注册的错误处理函数也有可能是完全不一样的，而且会导致代码非常混乱，难以阅读和维护。&lt;/p>
&lt;p>所以，一般来说，在异步编程的实践里，我们会用 Promise 模式来处理。如下所示（箭头表达式）：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-JavaScript" data-lang="JavaScript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">doSomething&lt;/span>&lt;span style="color:#000;font-weight:bold">()&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">then&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">result&lt;/span> &lt;span style="color:#000;font-weight:bold">=&amp;gt;&lt;/span> &lt;span style="color:#000">doSomethingElse&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">result&lt;/span>&lt;span style="color:#000;font-weight:bold">))&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">then&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">newResult&lt;/span> &lt;span style="color:#000;font-weight:bold">=&amp;gt;&lt;/span> &lt;span style="color:#000">doThirdThing&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">newResult&lt;/span>&lt;span style="color:#000;font-weight:bold">))&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">then&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">finalResult&lt;/span> &lt;span style="color:#000;font-weight:bold">=&amp;gt;&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">console&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">log&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#4e9a06">`Got the final result: &lt;/span>&lt;span style="color:#4e9a06">${&lt;/span>&lt;span style="color:#000">finalResult&lt;/span>&lt;span style="color:#4e9a06">}&lt;/span>&lt;span style="color:#4e9a06">`&lt;/span>&lt;span style="color:#000;font-weight:bold">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">}).&lt;/span>&lt;span style="color:#204a87;font-weight:bold">catch&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">failureCallback&lt;/span>&lt;span style="color:#000;font-weight:bold">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上面代码中的 &lt;code>then()&lt;/code> 和 &lt;code>catch()&lt;/code> 方法就是 Promise 对象的方法，&lt;code>then()&lt;/code>方法可以把各个异步的函数给串联起来，而&lt;code>catch()&lt;/code> 方法则是出错的处理。&lt;/p>
&lt;p>看到上面的那个级联式的调用方式，这就要我们的 &lt;code>doSomething()&lt;/code> 函数返回 Promise 对象，下面是这个函数的相关代码示例：&lt;/p>
&lt;p>比如：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-JavaScript" data-lang="JavaScript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">function&lt;/span> &lt;span style="color:#000">doSomething&lt;/span>&lt;span style="color:#000;font-weight:bold">()&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">let&lt;/span> &lt;span style="color:#000">promise&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span> &lt;span style="color:#204a87;font-weight:bold">new&lt;/span> &lt;span style="color:#204a87">Promise&lt;/span>&lt;span style="color:#000;font-weight:bold">();&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">let&lt;/span> &lt;span style="color:#000">xhr&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span> &lt;span style="color:#204a87;font-weight:bold">new&lt;/span> &lt;span style="color:#000">XMLHttpRequest&lt;/span>&lt;span style="color:#000;font-weight:bold">();&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">xhr&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">open&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#4e9a06">&amp;#39;GET&amp;#39;&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#4e9a06">&amp;#39;http://coolshell.cn/....&amp;#39;&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#204a87;font-weight:bold">true&lt;/span>&lt;span style="color:#000;font-weight:bold">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">xhr&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">onload&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span> &lt;span style="color:#204a87;font-weight:bold">function&lt;/span> &lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">e&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">if&lt;/span> &lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#204a87;font-weight:bold">this&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">status&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">===&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">200&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">results&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span> &lt;span style="color:#000">JSON&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">parse&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#204a87;font-weight:bold">this&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">responseText&lt;/span>&lt;span style="color:#000;font-weight:bold">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">promise&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">resolve&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">results&lt;/span>&lt;span style="color:#000;font-weight:bold">);&lt;/span> &lt;span style="color:#8f5902;font-style:italic">// 成功时，调用 resolve() 方法
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">&lt;/span> &lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">};&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">xhr&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">onerror&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span> &lt;span style="color:#204a87;font-weight:bold">function&lt;/span> &lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">e&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">promise&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">reject&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">e&lt;/span>&lt;span style="color:#000;font-weight:bold">);&lt;/span> &lt;span style="color:#8f5902;font-style:italic">// 失败时，调用 reject() 方法
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">&lt;/span> &lt;span style="color:#000;font-weight:bold">};&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">xhr&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">send&lt;/span>&lt;span style="color:#000;font-weight:bold">();&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">return&lt;/span> &lt;span style="color:#000">promise&lt;/span>&lt;span style="color:#000;font-weight:bold">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>从上面的代码示例中，我们可以看到，如果成功了，要调用&lt;br>
&lt;code>Promise.resolve()&lt;/code> 方法，这样 Promise 对象会继续调用下一个 &lt;code>then()&lt;/code>。如果出错了就调用 &lt;code>Promise.reject()&lt;/code> 方法，这样就会忽略后面的 &lt;code>then()&lt;/code> 直到 &lt;code>catch()&lt;/code> 方法。&lt;/p>
&lt;p>我们可以看到 &lt;code>Promise.reject()&lt;/code> 就像是抛异常一样。这个编程模式让我们的代码组织方便了很多。&lt;/p>
&lt;p>另外，多说一句，Promise 还可以同时等待两个不同的异步方法。比如下面的代码所展示的方式：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-JavaScript" data-lang="JavaScript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">promise1&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span> &lt;span style="color:#000">doSomething&lt;/span>&lt;span style="color:#000;font-weight:bold">();&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">promise2&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span> &lt;span style="color:#000">doSomethingElse&lt;/span>&lt;span style="color:#000;font-weight:bold">();&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87">Promise&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">when&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">promise1&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">promise2&lt;/span>&lt;span style="color:#000;font-weight:bold">).&lt;/span>&lt;span style="color:#000">then&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span> &lt;span style="color:#204a87;font-weight:bold">function&lt;/span> &lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">result1&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">result2&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">...&lt;/span> &lt;span style="color:#8f5902;font-style:italic">// 处理 result1 和 result2 的代码
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">&lt;/span>&lt;span style="color:#000;font-weight:bold">},&lt;/span> &lt;span style="color:#000">handleError&lt;/span>&lt;span style="color:#000;font-weight:bold">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在 ECMAScript 2017 的标准中，我们可以使用&lt;code>async&lt;/code>/&lt;code>await&lt;/code>这两个关键字来取代 Promise 对象，这样可以让我们的代码更易读。&lt;/p>
&lt;p>比如下面的代码示例：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-JavaScript" data-lang="JavaScript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">async&lt;/span> &lt;span style="color:#204a87;font-weight:bold">function&lt;/span> &lt;span style="color:#000">foo&lt;/span>&lt;span style="color:#000;font-weight:bold">()&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">try&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">let&lt;/span> &lt;span style="color:#000">result&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span> &lt;span style="color:#204a87;font-weight:bold">await&lt;/span> &lt;span style="color:#000">doSomething&lt;/span>&lt;span style="color:#000;font-weight:bold">();&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">let&lt;/span> &lt;span style="color:#000">newResult&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span> &lt;span style="color:#204a87;font-weight:bold">await&lt;/span> &lt;span style="color:#000">doSomethingElse&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">result&lt;/span>&lt;span style="color:#000;font-weight:bold">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">let&lt;/span> &lt;span style="color:#000">finalResult&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span> &lt;span style="color:#204a87;font-weight:bold">await&lt;/span> &lt;span style="color:#000">doThirdThing&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">newResult&lt;/span>&lt;span style="color:#000;font-weight:bold">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">console&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">log&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#4e9a06">`Got the final result: &lt;/span>&lt;span style="color:#4e9a06">${&lt;/span>&lt;span style="color:#000">finalResult&lt;/span>&lt;span style="color:#4e9a06">}&lt;/span>&lt;span style="color:#4e9a06">`&lt;/span>&lt;span style="color:#000;font-weight:bold">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">}&lt;/span> &lt;span style="color:#204a87;font-weight:bold">catch&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">error&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">failureCallback&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">error&lt;/span>&lt;span style="color:#000;font-weight:bold">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果在函数定义之前使用了 &lt;code>async&lt;/code> 关键字，就可以在函数内使用 &lt;code>await&lt;/code>。 当在 &lt;code>await&lt;/code> 某个 &lt;code>Promise&lt;/code> 时，函数暂停执行，直至该 &lt;code>Promise&lt;/code> 产生结果，并且暂停不会阻塞主线程。 如果 &lt;code>Promise&lt;/code> resolve，则会返回值。 如果 &lt;code>Promise&lt;/code> reject，则会抛出拒绝的值。&lt;/p>
&lt;p>而我们的异步代码完全可以放在一个 &lt;code>try - catch&lt;/code> 语句块内，在有语言支持了以后，我们又可以使用 &lt;code>try - catch&lt;/code> 语句块了。&lt;/p>
&lt;p>下面我们来看一下 pipeline 的代码。所谓 pipeline 就是把一串函数给编排起来，从而形成更为强大的功能。这个玩法是函数式编程中经常用到的方法。&lt;/p>
&lt;p>比如，下面这个 pipeline 的代码（注意，其上使用了 &lt;code>reduce()&lt;/code> 函数）：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-JavaScript" data-lang="JavaScript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">[&lt;/span>&lt;span style="color:#000">func1&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">func2&lt;/span>&lt;span style="color:#000;font-weight:bold">].&lt;/span>&lt;span style="color:#000">reduce&lt;/span>&lt;span style="color:#000;font-weight:bold">((&lt;/span>&lt;span style="color:#000">p&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">f&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span> &lt;span style="color:#000;font-weight:bold">=&amp;gt;&lt;/span> &lt;span style="color:#000">p&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">then&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">f&lt;/span>&lt;span style="color:#000;font-weight:bold">),&lt;/span> &lt;span style="color:#204a87">Promise&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">resolve&lt;/span>&lt;span style="color:#000;font-weight:bold">());&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>其等同于：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-JavaScript" data-lang="JavaScript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87">Promise&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">resolve&lt;/span>&lt;span style="color:#000;font-weight:bold">().&lt;/span>&lt;span style="color:#000">then&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">func1&lt;/span>&lt;span style="color:#000;font-weight:bold">).&lt;/span>&lt;span style="color:#000">then&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">func2&lt;/span>&lt;span style="color:#000;font-weight:bold">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>我们可以抽象成：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-JavaScript" data-lang="JavaScript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">let&lt;/span> &lt;span style="color:#000">applyAsync&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span> &lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">acc&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span>&lt;span style="color:#000">val&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span> &lt;span style="color:#000;font-weight:bold">=&amp;gt;&lt;/span> &lt;span style="color:#000">acc&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">then&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">val&lt;/span>&lt;span style="color:#000;font-weight:bold">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">let&lt;/span> &lt;span style="color:#000">composeAsync&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span> &lt;span style="color:#000;font-weight:bold">(...&lt;/span>&lt;span style="color:#000">funcs&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span> &lt;span style="color:#000;font-weight:bold">=&amp;gt;&lt;/span> &lt;span style="color:#000">x&lt;/span> &lt;span style="color:#000;font-weight:bold">=&amp;gt;&lt;/span> &lt;span style="color:#000">funcs&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">reduce&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">applyAsync&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#204a87">Promise&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">resolve&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">x&lt;/span>&lt;span style="color:#000;font-weight:bold">));&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>于是，可以这样使用：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-JavaScript" data-lang="JavaScript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">let&lt;/span> &lt;span style="color:#000">transformData&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span> &lt;span style="color:#000">composeAsync&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">func1&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">asyncFunc1&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">asyncFunc2&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">func2&lt;/span>&lt;span style="color:#000;font-weight:bold">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">transformData&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">data&lt;/span>&lt;span style="color:#000;font-weight:bold">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>但是，在 ECMAScript 2017 的 &lt;code>async&lt;/code>/&lt;code>await&lt;/code> 语法糖下，这事儿就变得更简单了。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-JavaScript" data-lang="JavaScript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">for&lt;/span> &lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#204a87;font-weight:bold">let&lt;/span> &lt;span style="color:#000">f&lt;/span> &lt;span style="color:#204a87;font-weight:bold">of&lt;/span> &lt;span style="color:#000;font-weight:bold">[&lt;/span>&lt;span style="color:#000">func1&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">func2&lt;/span>&lt;span style="color:#000;font-weight:bold">])&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">await&lt;/span> &lt;span style="color:#000">f&lt;/span>&lt;span style="color:#000;font-weight:bold">();&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="java-异步编程的-promise-模式">Java 异步编程的 Promise 模式&lt;/h2>
&lt;p>在 Java 中，在 JDK 1.8 里也引入了类似 JavaScript 的玩法 &amp;mdash;&amp;mdash; &lt;code>CompletableFuture&lt;/code>。这个类提供了大量的异步编程中 Promise 的各种方式。下面我列举几个。&lt;/p>
&lt;p>链式处理：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-Java" data-lang="Java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">CompletableFuture&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">.&lt;/span>&lt;span style="color:#c4a000">supplyAsync&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">(&lt;/span>&lt;span style="color:#204a87;font-weight:bold">this&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">::&lt;/span>&lt;span style="color:#000">findReceiver&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ce5c00;font-weight:bold">.&lt;/span>&lt;span style="color:#c4a000">thenApply&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">(&lt;/span>&lt;span style="color:#204a87;font-weight:bold">this&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">::&lt;/span>&lt;span style="color:#000">sendMsg&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ce5c00;font-weight:bold">.&lt;/span>&lt;span style="color:#c4a000">thenAccept&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">(&lt;/span>&lt;span style="color:#204a87;font-weight:bold">this&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">::&lt;/span>&lt;span style="color:#000">notify&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上面的这个链式处理和 JavaScript 中的&lt;code>then()&lt;/code>方法很像，其中的&lt;br>
&lt;code>supplyAsync()&lt;/code> 表示执行一个异步方法，而 &lt;code>thenApply()&lt;/code> 表示执行成功后再串联另外一个异步方法，最后是 &lt;code>thenAccept()&lt;/code> 来处理最终结果。&lt;/p>
&lt;p>下面这个例子是要合并两个异步函数的结果：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-Java" data-lang="Java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">String&lt;/span> &lt;span style="color:#000">result&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span> &lt;span style="color:#000">CompletableFuture&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">.&lt;/span>&lt;span style="color:#c4a000">supplyAsync&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">(()&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">-&amp;gt;&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">return&lt;/span> &lt;span style="color:#4e9a06">&amp;#34;hello&amp;#34;&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ce5c00;font-weight:bold">}).&lt;/span>&lt;span style="color:#c4a000">thenCombine&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">(&lt;/span>&lt;span style="color:#000">CompletableFuture&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">.&lt;/span>&lt;span style="color:#c4a000">supplyAsync&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">(()&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">-&amp;gt;&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">return&lt;/span> &lt;span style="color:#4e9a06">&amp;#34;world&amp;#34;&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ce5c00;font-weight:bold">}),&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">(&lt;/span>&lt;span style="color:#000">s1&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">,&lt;/span> &lt;span style="color:#000">s2&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">)&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">-&amp;gt;&lt;/span> &lt;span style="color:#000">s1&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">+&lt;/span> &lt;span style="color:#4e9a06">&amp;#34; &amp;#34;&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">+&lt;/span> &lt;span style="color:#000">s2&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">).&lt;/span>&lt;span style="color:#c4a000">join&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">());&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">System&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">.&lt;/span>&lt;span style="color:#c4a000">out&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">.&lt;/span>&lt;span style="color:#c4a000">println&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">(&lt;/span>&lt;span style="color:#000">result&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>接下来，我们再来看一下，Java 这个类相关的异常处理：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-Java" data-lang="Java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">CompletableFuture&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">.&lt;/span>&lt;span style="color:#c4a000">supplyAsync&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">(&lt;/span>&lt;span style="color:#000">Integer&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">::&lt;/span>&lt;span style="color:#000">parseInt&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">)&lt;/span> &lt;span style="color:#8f5902;font-style:italic">// 输入: &amp;#34;ILLEGAL&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">.&lt;/span>&lt;span style="color:#c4a000">thenApply&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">(&lt;/span>&lt;span style="color:#000">r&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">-&amp;gt;&lt;/span> &lt;span style="color:#000">r&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">*&lt;/span> &lt;span style="color:#000">2&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">*&lt;/span> &lt;span style="color:#000">Math&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">.&lt;/span>&lt;span style="color:#c4a000">PI&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ce5c00;font-weight:bold">.&lt;/span>&lt;span style="color:#c4a000">thenApply&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">(&lt;/span>&lt;span style="color:#000">s&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">-&amp;gt;&lt;/span> &lt;span style="color:#4e9a06">&amp;#34;apply&amp;gt;&amp;gt; &amp;#34;&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">+&lt;/span> &lt;span style="color:#000">s&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ce5c00;font-weight:bold">.&lt;/span>&lt;span style="color:#c4a000">exceptionally&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">(&lt;/span>&lt;span style="color:#000">ex&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">-&amp;gt;&lt;/span> &lt;span style="color:#4e9a06">&amp;#34;Error: &amp;#34;&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">+&lt;/span> &lt;span style="color:#000">ex&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">.&lt;/span>&lt;span style="color:#c4a000">getMessage&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">());&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>我们要注意到上面代码里的 &lt;code>exceptionally()&lt;/code> 方法，这个和 JavaScript Promise 中的 &lt;code>catch()&lt;/code> 方法相似。&lt;/p>
&lt;p>运行上面的代码，会出现如下输出：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-Java" data-lang="Java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f57900">Error:&lt;/span> &lt;span style="color:#000">java&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">.&lt;/span>&lt;span style="color:#c4a000">lang&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">.&lt;/span>&lt;span style="color:#c4a000">NumberFormatException&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">:&lt;/span> &lt;span style="color:#000">For&lt;/span> &lt;span style="color:#000">input&lt;/span> &lt;span style="color:#000">string&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">:&lt;/span> &lt;span style="color:#4e9a06">&amp;#34;ILLEGAL&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>也可以这样：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-Java" data-lang="Java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">CompletableFuture&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">.&lt;/span>&lt;span style="color:#c4a000">supplyAsync&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">(&lt;/span>&lt;span style="color:#000">Integer&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">::&lt;/span>&lt;span style="color:#000">parseInt&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">)&lt;/span> &lt;span style="color:#8f5902;font-style:italic">// 输入: &amp;#34;ILLEGAL&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">.&lt;/span>&lt;span style="color:#c4a000">thenApply&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">(&lt;/span>&lt;span style="color:#000">r&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">-&amp;gt;&lt;/span> &lt;span style="color:#000">r&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">*&lt;/span> &lt;span style="color:#000">2&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">*&lt;/span> &lt;span style="color:#000">Math&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">.&lt;/span>&lt;span style="color:#c4a000">PI&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ce5c00;font-weight:bold">.&lt;/span>&lt;span style="color:#c4a000">thenApply&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">(&lt;/span>&lt;span style="color:#000">s&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">-&amp;gt;&lt;/span> &lt;span style="color:#4e9a06">&amp;#34;apply&amp;gt;&amp;gt; &amp;#34;&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">+&lt;/span> &lt;span style="color:#000">s&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ce5c00;font-weight:bold">.&lt;/span>&lt;span style="color:#c4a000">handle&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">((&lt;/span>&lt;span style="color:#000">result&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">,&lt;/span> &lt;span style="color:#000">ex&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">)&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">-&amp;gt;&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">if&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">(&lt;/span>&lt;span style="color:#000">result&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">!=&lt;/span> &lt;span style="color:#204a87;font-weight:bold">null&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">)&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">return&lt;/span> &lt;span style="color:#000">result&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ce5c00;font-weight:bold">}&lt;/span> &lt;span style="color:#204a87;font-weight:bold">else&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">return&lt;/span> &lt;span style="color:#4e9a06">&amp;#34;Error handling: &amp;#34;&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">+&lt;/span> &lt;span style="color:#000">ex&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">.&lt;/span>&lt;span style="color:#c4a000">getMessage&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">();&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ce5c00;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ce5c00;font-weight:bold">});&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上面代码中，你可以看到，其使用了 &lt;code>handle()&lt;/code> 方法来处理最终的结果，其中包含了异步函数中的错误处理。&lt;/p>
&lt;h2 id="go-语言的-promise">Go 语言的 Promise&lt;/h2>
&lt;p>在 Go 语言中，如果你想实现一个简单的 Promise 模式，也是可以的。下面的代码纯属示例，只为说明问题。如果你想要更好的代码，可以上 GitHub 上搜一下 Go 语言 Promise 的相关代码库。&lt;/p>
&lt;p>首先，先声明一个结构体。其中有三个成员：第一个 &lt;code>wg&lt;/code> 用于多线程同步；第二个 &lt;code>res&lt;/code> 用于存放执行结果；第三个 &lt;code>err&lt;/code> 用于存放相关的错误。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-Go" data-lang="Go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">type&lt;/span> &lt;span style="color:#000">Promise&lt;/span> &lt;span style="color:#204a87;font-weight:bold">struct&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">wg&lt;/span> &lt;span style="color:#000">sync&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">WaitGroup&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">res&lt;/span> &lt;span style="color:#204a87;font-weight:bold">string&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">err&lt;/span> &lt;span style="color:#204a87;font-weight:bold">error&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>然后，定义一个初始函数，来初始化 Promise 对象。其中可以看到，需要把一个函数 &lt;code>f&lt;/code> 传进来，然后调用 &lt;code>wg.Add(1)&lt;/code> 对 waitGroup 做加一操作，新开一个 Goroutine 通过异步去执行用户传入的函数 &lt;code>f()&lt;/code> ，然后记录这个函数的成功或错误，并把 waitGroup 做减一操作。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-Go" data-lang="Go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">func&lt;/span> &lt;span style="color:#000">NewPromise&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">f&lt;/span> &lt;span style="color:#204a87;font-weight:bold">func&lt;/span>&lt;span style="color:#000;font-weight:bold">()&lt;/span> &lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#204a87;font-weight:bold">string&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#204a87;font-weight:bold">error&lt;/span>&lt;span style="color:#000;font-weight:bold">))&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">*&lt;/span>&lt;span style="color:#000">Promise&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">p&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">:=&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">&amp;amp;&lt;/span>&lt;span style="color:#000">Promise&lt;/span>&lt;span style="color:#000;font-weight:bold">{}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">p&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">wg&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Add&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">1&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">go&lt;/span> &lt;span style="color:#204a87;font-weight:bold">func&lt;/span>&lt;span style="color:#000;font-weight:bold">()&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">p&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">res&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">p&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">err&lt;/span> &lt;span style="color:#000;font-weight:bold">=&lt;/span> &lt;span style="color:#000">f&lt;/span>&lt;span style="color:#000;font-weight:bold">()&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">p&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">wg&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Done&lt;/span>&lt;span style="color:#000;font-weight:bold">()&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">}()&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">return&lt;/span> &lt;span style="color:#000">p&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>然后，我们需要定义 Promise 的 Then 方法。其中需要传入一个函数，以及一个错误处理的函数。并且调用 &lt;code>wg.Wait()&lt;/code> 方法来阻塞（因为之前被&lt;code>wg.Add(1)&lt;/code>)，一旦上一个方法被调用了 &lt;code>wg.Done()&lt;/code>，这个 Then 方法就会被唤醒。&lt;/p>
&lt;p>唤醒的第一件事是，检查一下之前的方法有没有错误。如果有，那么就调用错误处理函数。如果之前成功了，就把之前的结果以参数的方式传入到下一个函数中。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-Go" data-lang="Go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">func&lt;/span> &lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">p&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">*&lt;/span>&lt;span style="color:#000">Promise&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span> &lt;span style="color:#000">Then&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">r&lt;/span> &lt;span style="color:#204a87;font-weight:bold">func&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#204a87;font-weight:bold">string&lt;/span>&lt;span style="color:#000;font-weight:bold">),&lt;/span> &lt;span style="color:#000">e&lt;/span> &lt;span style="color:#204a87;font-weight:bold">func&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#204a87;font-weight:bold">error&lt;/span>&lt;span style="color:#000;font-weight:bold">))&lt;/span> &lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">*&lt;/span>&lt;span style="color:#000">Promise&lt;/span>&lt;span style="color:#000;font-weight:bold">){&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">go&lt;/span> &lt;span style="color:#204a87;font-weight:bold">func&lt;/span>&lt;span style="color:#000;font-weight:bold">()&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">p&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">wg&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Wait&lt;/span>&lt;span style="color:#000;font-weight:bold">()&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">if&lt;/span> &lt;span style="color:#000">p&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">err&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">!=&lt;/span> &lt;span style="color:#204a87;font-weight:bold">nil&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">e&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">p&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">err&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">return&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">r&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">p&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">res&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">}()&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">return&lt;/span> &lt;span style="color:#000">p&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>下面，我们定义一个用于测试的异步方法。这个方面很简单，就是在数数，然后，有一半的机率会出错。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-Go" data-lang="Go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">func&lt;/span> &lt;span style="color:#000">exampleTicker&lt;/span>&lt;span style="color:#000;font-weight:bold">()&lt;/span> &lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#204a87;font-weight:bold">string&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#204a87;font-weight:bold">error&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">for&lt;/span> &lt;span style="color:#000">i&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">:=&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">0&lt;/span>&lt;span style="color:#000;font-weight:bold">;&lt;/span> &lt;span style="color:#000">i&lt;/span> &lt;span style="color:#000;font-weight:bold">&amp;lt;&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">3&lt;/span>&lt;span style="color:#000;font-weight:bold">;&lt;/span> &lt;span style="color:#000">i&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">++&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">fmt&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Println&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">i&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ce5c00;font-weight:bold">&amp;lt;-&lt;/span>&lt;span style="color:#000">time&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Tick&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">time&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Second&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">*&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">1&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">rand&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Seed&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">time&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Now&lt;/span>&lt;span style="color:#000;font-weight:bold">().&lt;/span>&lt;span style="color:#000">UTC&lt;/span>&lt;span style="color:#000;font-weight:bold">().&lt;/span>&lt;span style="color:#000">UnixNano&lt;/span>&lt;span style="color:#000;font-weight:bold">())&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">r&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">:=&lt;/span>&lt;span style="color:#000">rand&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Intn&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">100&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">%&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">fmt&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Println&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">r&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">if&lt;/span> &lt;span style="color:#000">r&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">!=&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">0&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">return&lt;/span> &lt;span style="color:#4e9a06">&amp;#34;hello, world&amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#204a87;font-weight:bold">nil&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">}&lt;/span> &lt;span style="color:#204a87;font-weight:bold">else&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">return&lt;/span> &lt;span style="color:#4e9a06">&amp;#34;&amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">fmt&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Errorf&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#4e9a06">&amp;#34;error&amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>下面，我们来看看我们实现的 Go 语言 Promise 是怎么使用的。代码还是比较直观的，我就不做更多的解释了。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-Go" data-lang="Go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">func&lt;/span> &lt;span style="color:#000">main&lt;/span>&lt;span style="color:#000;font-weight:bold">()&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">doneChan&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">:=&lt;/span> &lt;span style="color:#204a87">make&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#204a87;font-weight:bold">chan&lt;/span> &lt;span style="color:#204a87;font-weight:bold">int&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">var&lt;/span> &lt;span style="color:#000">p&lt;/span> &lt;span style="color:#000;font-weight:bold">=&lt;/span> &lt;span style="color:#000">NewPromise&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">exampleTicker&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">p&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Then&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#204a87;font-weight:bold">func&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">result&lt;/span> &lt;span style="color:#204a87;font-weight:bold">string&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span> &lt;span style="color:#000">fmt&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Println&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">result&lt;/span>&lt;span style="color:#000;font-weight:bold">);&lt;/span> &lt;span style="color:#000">doneChan&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">&amp;lt;-&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">1&lt;/span> &lt;span style="color:#000;font-weight:bold">},&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">func&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">err&lt;/span> &lt;span style="color:#204a87;font-weight:bold">error&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span> &lt;span style="color:#000">fmt&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Println&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">err&lt;/span>&lt;span style="color:#000;font-weight:bold">);&lt;/span> &lt;span style="color:#000">doneChan&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">&amp;lt;-&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">1&lt;/span> &lt;span style="color:#000;font-weight:bold">})&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ce5c00;font-weight:bold">&amp;lt;-&lt;/span>&lt;span style="color:#000">doneChan&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>当然，如果你需要更好的 Go 语言 Promise，可以到 GitHub 上找，上面好些代码都是实现得很不错的。上面的这个示例，实现得比较简陋，仅仅是为了说明问题。&lt;/p>
&lt;h1 id="错误处理的最佳实践">错误处理的最佳实践&lt;/h1>
&lt;p>下面是我个人总结的几个错误处理的最佳实践。如果你知道更好的，请一定告诉我。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>统一分类的错误字典&lt;/strong>。无论你是使用错误码还是异常捕捉，都需要认真并统一地做好错误的分类。最好是在一个地方定义相关的错误。比如，HTTP 的 4XX 表示客户端有问题，5XX 则表示服务端有问题。也就是说，你要建立一个错误字典。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>同类错误的定义最好是可以扩展的&lt;/strong>。这一点非常重要，而对于这一点，通过面向对象的继承或是像 Go 语言那样的接口多态可以很好地做到。这样可以方便地重用已有的代码。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>定义错误的严重程度&lt;/strong>。比如，Fatal 表示重大错误，Error 表示资源或需求得不到满足，Warning 表示并不一定是个错误但还是需要引起注意，Info 表示不是错误只是一个信息，Debug 表示这是给内部开发人员用于调试程序的。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>错误日志的输出最好使用错误码，而不是错误信息&lt;/strong> 。打印错误日志的时候，应该使用统一的格式。但最好不要用错误信息，而应使用相应的错误码，错误码不一定是数字，也可以是一个能从错误字典里找到的一个唯一的可以让人读懂的关键字。这样，会非常有利于日志分析软件进行自动化监控，而不是要从错误信息中做语义分析。比如：HTTP 的日志中就会有 HTTP 的返回码，如：&lt;code>404&lt;/code>。但我更推荐使用像&lt;code>PageNotFound&lt;/code>这样的标识，这样人和机器都很容易处理。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>忽略错误最好有日志&lt;/strong>。不然会给维护带来很大的麻烦。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>对于同一个地方不停的报错，最好不要都打到日志里&lt;/strong>。不然这样会导致其它日志被淹没了，也会导致日志文件太大。最好的实践是，打出一个错误以及出现的次数。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>不要用错误处理逻辑来处理业务逻辑&lt;/strong>。也就是说，不要使用异常捕捉这样的方式来处理业务逻辑，而是应该用条件判断。如果一个逻辑控制可以用 if - else 清楚地表达，那就不建议使用异常方式处理。异常捕捉是用来处理不期望发生的事情，而错误码则用来处理可能会发生的事。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>对于同类的错误处理，用一样的模式&lt;/strong> 。比如，对于&lt;code>null&lt;/code>对象的错误，要么都用返回 null，加上条件检查的模式，要么都用抛 NullPointerException 的方式处理。不要混用，这样有助于代码规范。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>尽可能在错误发生的地方处理错误&lt;/strong>。因为这样会让调用者变得更简单。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>向上尽可能地返回原始的错误&lt;/strong>。如果一定要把错误返回到更高层去处理，那么，应该返回原始的错误，而不是重新发明一个错误。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>处理错误时，总是要清理已分配的资源&lt;/strong>。这点非常关键，使用 RAII 技术，或是 try-catch-finally，或是 Go 的 defer 都可以容易地做到。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>不推荐在循环体里处理错误&lt;/strong>。这里说的是 try-catch，绝大多数的情况你不需要这样做。最好把整个循环体外放在 try 语句块内，而在外面做 catch。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>不要把大量的代码都放在一个 try 语句块内&lt;/strong>。一个 try 语句块内的语句应该是完成一个简单单一的事情。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>为你的错误定义提供清楚的文档以及每种错误的代码示例&lt;/strong>。如果你是做 RESTful API 方面的，使用 Swagger 会帮你很容易搞定这个事。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>对于异步的方式，推荐使用 Promise 模式处理错误&lt;/strong>。对于这一点，JavaScript 中有很好的实践。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>对于分布式的系统，推荐使用 APM 相关的软件&lt;/strong>。尤其是使用 Zipkin 这样的服务调用跟踪的分析来关联错误。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>好了。关于程序中的错误处理，我主要总结了这些。如果你有更好的想法和经验，欢迎来跟我交流。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/fc/e9/fcc761001867c60f526665e237f831e9.jpg" alt="">&lt;/p></description></item><item><title>极客专栏: 13丨魔数0x5f3759df</title><link>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E/13%E4%B8%A8%E9%AD%94%E6%95%B00x5f3759df/</link><pubDate>Fri, 27 May 2022 00:00:00 +0000</pubDate><guid>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E/13%E4%B8%A8%E9%AD%94%E6%95%B00x5f3759df/</guid><description>
&lt;p>下列代码是在《雷神之锤 III 竞技场》源代码中的一个函数（已经剥离了 C 语言预处理器的指令）。其实，最早在 2002 年（或 2003 年）时，这段平方根倒数速算法的代码就已经出现在 Usenet 与其他论坛上了，并且也在程序员圈子里引起了热烈的讨论。&lt;/p>
&lt;p>我先把这段代码贴出来，具体如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">float&lt;/span> &lt;span style="color:#000">Q_rsqrt&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span> &lt;span style="color:#204a87;font-weight:bold">float&lt;/span> &lt;span style="color:#000">number&lt;/span> &lt;span style="color:#000;font-weight:bold">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">long&lt;/span> &lt;span style="color:#000">i&lt;/span>&lt;span style="color:#000;font-weight:bold">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">float&lt;/span> &lt;span style="color:#000">x2&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">y&lt;/span>&lt;span style="color:#000;font-weight:bold">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">const&lt;/span> &lt;span style="color:#204a87;font-weight:bold">float&lt;/span> &lt;span style="color:#000">threehalfs&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">1.5F&lt;/span>&lt;span style="color:#000;font-weight:bold">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">x2&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span> &lt;span style="color:#000">number&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">*&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">0.5F&lt;/span>&lt;span style="color:#000;font-weight:bold">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">y&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span> &lt;span style="color:#000">number&lt;/span>&lt;span style="color:#000;font-weight:bold">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">i&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">*&lt;/span> &lt;span style="color:#000;font-weight:bold">(&lt;/span> &lt;span style="color:#204a87;font-weight:bold">long&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">*&lt;/span> &lt;span style="color:#000;font-weight:bold">)&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">&amp;amp;&lt;/span>&lt;span style="color:#000">y&lt;/span>&lt;span style="color:#000;font-weight:bold">;&lt;/span> &lt;span style="color:#8f5902;font-style:italic">// evil floating point bit level hacking
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">&lt;/span> &lt;span style="color:#000">i&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">0x5f3759df&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">-&lt;/span> &lt;span style="color:#000;font-weight:bold">(&lt;/span> &lt;span style="color:#000">i&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">&amp;gt;&amp;gt;&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">1&lt;/span> &lt;span style="color:#000;font-weight:bold">);&lt;/span> &lt;span style="color:#8f5902;font-style:italic">// what the fuck?
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">&lt;/span> &lt;span style="color:#000">y&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">*&lt;/span> &lt;span style="color:#000;font-weight:bold">(&lt;/span> &lt;span style="color:#204a87;font-weight:bold">float&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">*&lt;/span> &lt;span style="color:#000;font-weight:bold">)&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">&amp;amp;&lt;/span>&lt;span style="color:#000">i&lt;/span>&lt;span style="color:#000;font-weight:bold">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">y&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span> &lt;span style="color:#000">y&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">*&lt;/span> &lt;span style="color:#000;font-weight:bold">(&lt;/span> &lt;span style="color:#000">threehalfs&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">-&lt;/span> &lt;span style="color:#000;font-weight:bold">(&lt;/span> &lt;span style="color:#000">x2&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">*&lt;/span> &lt;span style="color:#000">y&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">*&lt;/span> &lt;span style="color:#000">y&lt;/span> &lt;span style="color:#000;font-weight:bold">)&lt;/span> &lt;span style="color:#000;font-weight:bold">);&lt;/span> &lt;span style="color:#8f5902;font-style:italic">// 1st iteration
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">&lt;/span> &lt;span style="color:#8f5902;font-style:italic">// 2nd iteration, this can be removed
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">&lt;/span> &lt;span style="color:#8f5902;font-style:italic">// y = y * ( threehalfs - ( x2 * y * y ) );
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">return&lt;/span> &lt;span style="color:#000">y&lt;/span>&lt;span style="color:#000;font-weight:bold">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这段代码初读起来，我是完全不知所云，尤其是那个魔数 0x5f3759df，根本不知道它是什么意思，所以，注释里也是 What the fuck。今天的这篇文章里，我主要就是想带你来了解一下这个函数中的代码究竟是怎样出来的。&lt;/p>
&lt;p>其实，这个函数的作用是求平方根倒数，即 x−1/2 &lt;math xmlns="http://www.w3.org/1998/Math/MathML"> x − 1 / 2 &lt;/math>，也就是下面这个算式：{#MathJax-Element-1-Frame}&lt;/p>
&lt;p>1x−−√ &lt;math xmlns="http://www.w3.org/1998/Math/MathML" display="block"> 1 x &lt;/math>&lt;/p>
&lt;br />
&lt;p>当然，它算的是近似值。只不过这个近似值的精度很高，而且计算成本比传统的浮点数运算平方根的算法低太多。在以前那个计算资源还不充分的年代，在一些 3D 游戏场景的计算机图形学中，要求取照明和投影的光照与反射效果，就经常需要计算平方根倒数，而且是大量的计算&amp;mdash;&amp;mdash;对一个曲面上很多的点做平方根倒数的计算。也就是需要用到下面的这个算式，其中的 x,y,z 是 3D 坐标上的一个点的三个坐标值。&lt;/p>
&lt;p>1x2+y2+z2−−−−−−−−−−√ &lt;math xmlns="http://www.w3.org/1998/Math/MathML" display="block"> 1 x 2 + y 2 + z 2 &lt;/math>&lt;/p>
&lt;br />
&lt;p>基本上来说，在一个 3D 游戏中，我们每秒钟都需要做上百万次平方根倒数运算。而在计算硬件还不成熟的时代，这些计算都需要软件来完成，计算速度非常慢。&lt;/p>
&lt;p>我们要知道，在上世纪 90 年代，多数浮点数操作的速度更是远远滞后于整数操作。所以，这段代码所带来的作用是非常大的。&lt;/p>
&lt;h1 id="计算机的浮点数表示">计算机的浮点数表示&lt;/h1>
&lt;p>为了讲清楚这段代码，我们需要先了解一下计算机的浮点数表示法。在 C 语言中，计算机的浮点数表示用的是 IEEE 754 标准，这个标准的表现形式其实就是把一个 32bits 分成三段。&lt;/p>
&lt;ul>
&lt;li>第一段占 1bit，表示符号位。代称为 S（sign）。&lt;/li>
&lt;li>第二段占 8bits，表示指数。代称为 E（Exponent）。&lt;/li>
&lt;li>第三段占 23bits，表示尾数。代称为 M（Mantissa）。&lt;/li>
&lt;/ul>
&lt;p>如下图所示：&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/cf/a2/cfb465ac3800ceb3f8a8997fe527c8a2.jpg" alt="">&lt;/p>
&lt;p>然后呢，一个小数的计算方式是下面这个算式：&lt;/p>
&lt;p>(−1)S∗(1+M223)∗2(E−127) &lt;math xmlns="http://www.w3.org/1998/Math/MathML" display="block"> ( − 1 ) S ∗ ( 1 + M 2 23 ) ∗ 2 ( E − 127 ) &lt;/math>&lt;/p>
&lt;br />
&lt;p>但是，这个算式基本上来说，完全就是让人一头雾水，摸不着门路。对于浮点数的解释基本上就是下面这张漫画里表现的样子。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/7d/eb/7d607f3f90fe6e8152e2268da18e1feb.png" alt="">&lt;/p>
&lt;p>下面，让我来试着解释一下浮点数的那三段表示什么意思。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>第一段符号位。对于这一段，我相信应该没有人不能理解。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>第二段指数位。什么叫指数？也就是说，对于任何数 x，其都可以找到一个 n &lt;math xmlns="http://www.w3.org/1998/Math/MathML"> n &lt;/math>，使得 2n &lt;math xmlns="http://www.w3.org/1998/Math/MathML"> 2 n &lt;/math>&amp;lt;=x&amp;lt;= 2n+1 &lt;math xmlns="http://www.w3.org/1998/Math/MathML"> 2 n + 1 &lt;/math>。比如：对于 3 来说，因为 2 &amp;lt; 3 &amp;lt; 4，所以 n=1。而浮点数的这个指数为了要表示 0.00x 的小数，所以需要有负数，这 8 个 bits 本来可以表示 0-255。为了表示负的，取值要放在 [-127,128] 这个区间中。这就是为什么我们在上面的公式中看到的 2(E−127) &lt;math xmlns="http://www.w3.org/1998/Math/MathML"> 2 ( E − 127 ) &lt;/math> 这一项了。也就是说， n=E−127 &lt;math xmlns="http://www.w3.org/1998/Math/MathML"> n = E − 127 &lt;/math>，如果 n=1 &lt;math xmlns="http://www.w3.org/1998/Math/MathML"> n = 1 &lt;/math>，那么 E &lt;math xmlns="http://www.w3.org/1998/Math/MathML"> E &lt;/math> 就是 128 了。&lt;/p>
&lt;p>{#MathJax-Element-11-Frame}&lt;/p>
&lt;/li>
&lt;li>
&lt;p>第三段尾数位。也就是小数位，但是这里叫偏移量可能好一些。这里的取值是从 [ 0 - 223 &lt;math xmlns="http://www.w3.org/1998/Math/MathML"> 2 23 &lt;/math>] 中。你可以认为，我们把一条线分成 223 &lt;math xmlns="http://www.w3.org/1998/Math/MathML"> 2 23 &lt;/math> 个线段，也就是 8388608 个线段。也就是说，把 2n &lt;math xmlns="http://www.w3.org/1998/Math/MathML"> 2 n &lt;/math> 到 2n+1 &lt;math xmlns="http://www.w3.org/1998/Math/MathML"> 2 n + 1 &lt;/math> 分成了 8388608 个线段。而存储的 M 值，就是从 2n &lt;math xmlns="http://www.w3.org/1998/Math/MathML"> 2 n &lt;/math> 到 x 要经过多少个段。这要计算一下， 2n &lt;math xmlns="http://www.w3.org/1998/Math/MathML"> 2 n &lt;/math> 到 x 的长度占 2n &lt;math xmlns="http://www.w3.org/1998/Math/MathML"> 2 n &lt;/math> 到 2n+1 &lt;math xmlns="http://www.w3.org/1998/Math/MathML"> 2 n + 1 &lt;/math> 长度的比例是多少。&lt;/p>
&lt;p>{#MathJax-Element-19-Frame}&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>我估计你对第三段还是有点不懂，那么我们来举一个例子。比如说，对 3.14 这个小数。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>是正数。所以，S = 0&lt;/p>
&lt;/li>
&lt;li>
&lt;p>21 &lt;math xmlns="http://www.w3.org/1998/Math/MathML"> 2 1 &lt;/math> &amp;lt; 3.14 &amp;lt; 22 &lt;math xmlns="http://www.w3.org/1998/Math/MathML"> 2 2 &lt;/math>。所以，n=1， n+127 = 128。所以，E=128。&lt;/p>
&lt;p>{#MathJax-Element-21-Frame}&lt;/p>
&lt;/li>
&lt;li>
&lt;p>(3.14 - 2) / (4 - 2) = 0.57， 而 0.57∗223=4781506.56 &lt;math xmlns="http://www.w3.org/1998/Math/MathML"> 0.57 ∗ 2 23 = 4781506.56 &lt;/math>，四舍五入，得到 M = 4781507。因为有四舍五入，所以，产生了浮点数据的精度问题。&lt;/p>
&lt;p>{#MathJax-Element-22-Frame}&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>把 S、E、M 转成二进制，得到 3.14 的二进制表示。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/3f/15/3f99e711a80ebe963bd5ca4139224915.jpg" alt="">&lt;/p>
&lt;p>我们再用 IEEE 754 的那个算式来算一下：&lt;/p>
&lt;p>(−1)0∗(1+4781507223)∗2(128−127) &lt;math xmlns="http://www.w3.org/1998/Math/MathML" display="block"> ( − 1 ) 0 ∗ ( 1 + 4781507 2 23 ) ∗ 2 ( 128 − 127 ) &lt;/math>&lt;/p>
&lt;br />
&lt;p>1∗(1+0.5700000524520874)∗2 &lt;math xmlns="http://www.w3.org/1998/Math/MathML" display="block"> 1 ∗ ( 1 + 0.5700000524520874 ) ∗ 2 &lt;/math>&lt;/p>
&lt;p>=3.1400001049041748046875 &lt;math xmlns="http://www.w3.org/1998/Math/MathML" display="block"> = 3.1400001049041748046875 &lt;/math>&lt;/p>
&lt;br />
&lt;p>你看，浮点数的精度问题出现了。&lt;/p>
&lt;p>我们再来看一个示例，小数 0.015。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>是正数。所以，S = 0。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>2−7&amp;lt;0.015&amp;lt;2−6 &lt;math xmlns="http://www.w3.org/1998/Math/MathML"> 2 − 7 &amp;lt; 0.015 &amp;lt; 2 − 6 &lt;/math> 。所以，n=-7， n+127 = 120。所以，E=120。&lt;/p>
&lt;p>{#MathJax-Element-26-Frame}&lt;/p>
&lt;/li>
&lt;li>
&lt;p>(0.015−2−7)/(2−6−2−7) &lt;math xmlns="http://www.w3.org/1998/Math/MathML"> ( 0.015 − 2 − 7 ) / ( 2 − 6 − 2 − 7 ) &lt;/math> = 0.0071875/0.0078125=0.92 &lt;math xmlns="http://www.w3.org/1998/Math/MathML"> 0.0071875 / 0.0078125 = 0.92 &lt;/math>。而 0.92∗223=7717519.36 &lt;math xmlns="http://www.w3.org/1998/Math/MathML"> 0.92 ∗ 2 23 = 7717519.36 &lt;/math>，四舍五入，得到 M = 7717519。&lt;/p>
&lt;p>{#MathJax-Element-29-Frame}&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>于是，我们得到 0.015 的二进制编码：&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/bd/de/bd3c8cae032d818084f2d1ac0a02acde.jpg" alt="">&lt;/p>
&lt;p>其中：&lt;/p>
&lt;ul>
&lt;li>120 的二进制是 01111000&lt;/li>
&lt;li>7717519 的二进制是 11101011100001010001111&lt;/li>
&lt;/ul>
&lt;p>返回过来算一下：&lt;/p>
&lt;p>(−1)0∗(1+7717519223)∗2(120−127) &lt;math xmlns="http://www.w3.org/1998/Math/MathML" display="block"> ( − 1 ) 0 ∗ ( 1 + 7717519 2 23 ) ∗ 2 ( 120 − 127 ) &lt;/math>&lt;/p>
&lt;br />
&lt;p>(1+0.919999957084656)∗0.0078125 &lt;math xmlns="http://www.w3.org/1998/Math/MathML" display="block"> ( 1 + 0.919999957084656 ) ∗ 0.0078125 &lt;/math>&lt;/p>
&lt;p>=0.014999999664724 &lt;math xmlns="http://www.w3.org/1998/Math/MathML" display="block"> = 0.014999999664724 &lt;/math>&lt;/p>
&lt;br />
&lt;p>你看，浮点数的精度问题又出现了。&lt;/p>
&lt;p>我们来用 C 语言验证一下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">int&lt;/span> &lt;span style="color:#000">main&lt;/span>&lt;span style="color:#000;font-weight:bold">()&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">float&lt;/span> &lt;span style="color:#000">x&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">3.14&lt;/span>&lt;span style="color:#000;font-weight:bold">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">float&lt;/span> &lt;span style="color:#000">y&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">0.015&lt;/span>&lt;span style="color:#000;font-weight:bold">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">return&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">0&lt;/span>&lt;span style="color:#000;font-weight:bold">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在我的 Mac 上用 lldb 工具 Debug 一下。&lt;/p>
&lt;pre>&lt;code>(lldb) frame variable
(float) x = 3.1400001
(float) y = 0.0149999997
(lldb) frame variable -f b
(float) x = 0b01000000010010001111010111000011
(float) y = 0b00111100011101011100001010001111
&lt;/code>&lt;/pre>
&lt;p>从结果上，完全验证了我们的方法。&lt;/p>
&lt;p>好了，不知道你看懂了没有？我相信你应该看懂了。&lt;/p>
&lt;h1 id="简化浮点数公式">简化浮点数公式&lt;/h1>
&lt;p>因为那个浮点数表示的公式有点复杂，我们简化一下：&lt;/p>
&lt;p>(−1)S∗(1+M223)∗2(E−127) &lt;math xmlns="http://www.w3.org/1998/Math/MathML" display="block"> ( − 1 ) S ∗ ( 1 + M 2 23 ) ∗ 2 ( E − 127 ) &lt;/math>&lt;/p>
&lt;br />
&lt;p>我们令， m=(M223) &lt;math xmlns="http://www.w3.org/1998/Math/MathML"> m = ( M 2 23 ) &lt;/math>， e=(E−127) &lt;math xmlns="http://www.w3.org/1998/Math/MathML"> e = ( E − 127 ) &lt;/math>。因为符号位在 y=x−12 &lt;math xmlns="http://www.w3.org/1998/Math/MathML"> y = x − 1 2 &lt;/math> 的两端都是 0（正数），也就可以去掉，所以浮点数的算式简化为：{#MathJax-Element-36-Frame}&lt;/p>
&lt;p>(1+m)∗2e &lt;math xmlns="http://www.w3.org/1998/Math/MathML" display="block"> ( 1 + m ) ∗ 2 e &lt;/math>&lt;/p>
&lt;br />
&lt;p>上面这个算式是从一个 32bits 二进制计算出一个浮点数。这个 32bits 的整型算式是：&lt;/p>
&lt;p>M+E∗223 &lt;math xmlns="http://www.w3.org/1998/Math/MathML" display="block"> M + E ∗ 2 23 &lt;/math>&lt;/p>
&lt;br />
&lt;p>比如，0.015 的 32bits 的二进制是：00111100011101011100001010001111，也就是整型的：&lt;/p>
&lt;p>7717519+120∗223 &lt;math xmlns="http://www.w3.org/1998/Math/MathML" display="block"> 7717519 + 120 ∗ 2 23 &lt;/math>&lt;/p>
&lt;p>=1014350479 &lt;math xmlns="http://www.w3.org/1998/Math/MathML" display="block"> = 1014350479 &lt;/math>&lt;/p>
&lt;p>=0X3C75C28F &lt;math xmlns="http://www.w3.org/1998/Math/MathML" display="block"> = 0 X 3 C 75 C 28 F &lt;/math>&lt;/p>
&lt;br />
&lt;h1 id="平方根倒数公式推导">平方根倒数公式推导&lt;/h1>
&lt;p>下面，你会看到好多数学公式，但是请你不要怕，因为这些数学公式只需要高中数学就能看懂的。&lt;/p>
&lt;p>我们来看一下，平方根数据公式：&lt;/p>
&lt;p>y=1x−−√2=x−12 &lt;math xmlns="http://www.w3.org/1998/Math/MathML" display="block"> y = 1 x 2 = x − 1 2 &lt;/math>&lt;/p>
&lt;br />
&lt;p>等式两边取以 2 为基数的对数，就有了：&lt;/p>
&lt;p>log2(y)=−12log2(x) &lt;math xmlns="http://www.w3.org/1998/Math/MathML" display="block"> log 2 ⁡ ( y ) = − 1 2 log 2 ⁡ ( x ) &lt;/math>&lt;/p>
&lt;br />
&lt;p>因为我们实际上在算浮点数，所以将公式中的 x 和 y 分别用浮点数的那个浮点数的简化算式 (1+m)∗2e &lt;math xmlns="http://www.w3.org/1998/Math/MathML"> ( 1 + m ) ∗ 2 e &lt;/math> 替换掉。代入 log() &lt;math xmlns="http://www.w3.org/1998/Math/MathML"> log ⁡ ( ) &lt;/math> 公式中，我们也就有了下面的公式：{#MathJax-Element-45-Frame}&lt;/p>
&lt;p>log2(1+my)+ey &lt;math xmlns="http://www.w3.org/1998/Math/MathML" display="block"> log 2 ⁡ ( 1 + m y ) + e y &lt;/math>&lt;/p>
&lt;p>=−12(log2(1+mx)+ex) &lt;math xmlns="http://www.w3.org/1998/Math/MathML" display="block"> = − 1 2 ( log 2 ⁡ ( 1 + m x ) + e x ) &lt;/math>&lt;/p>
&lt;br />
&lt;p>因为有对数，这公式看着就很麻烦，似乎不能再简化了。但是，我们知道，所谓的 mx &lt;math xmlns="http://www.w3.org/1998/Math/MathML"> m x &lt;/math> 或是 my &lt;math xmlns="http://www.w3.org/1998/Math/MathML"> m y &lt;/math>，其实是个在 0 和 1 区间内的小数。在这种情况下， log2(1.x) &lt;math xmlns="http://www.w3.org/1998/Math/MathML"> log 2 ⁡ ( 1. x ) &lt;/math> 接近一条直线。{#MathJax-Element-50-Frame}&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/2d/4e/2d2b69795d3aa4d07545f0bbe645574e.png" alt="">&lt;/p>
&lt;p>那么我们就可以使用一个直线方程来代替，也就是：&lt;/p>
&lt;p>log2(1+m)≈m+σ &lt;math xmlns="http://www.w3.org/1998/Math/MathML" display="block"> log 2 ⁡ ( 1 + m ) ≈ m + σ &lt;/math>&lt;/p>
&lt;br />
&lt;p>于是，我们的公式就简化成了：&lt;/p>
&lt;p>my+σ+ey≈−12(mx+σ+ex) &lt;math xmlns="http://www.w3.org/1998/Math/MathML" display="block"> m y + σ + e y ≈ − 1 2 ( m x + σ + e x ) &lt;/math>&lt;/p>
&lt;br />
&lt;p>因为 m=(M223) &lt;math xmlns="http://www.w3.org/1998/Math/MathML"> m = ( M 2 23 ) &lt;/math>， e=(E−127) &lt;math xmlns="http://www.w3.org/1998/Math/MathML"> e = ( E − 127 ) &lt;/math>，代入公式，得到：{#MathJax-Element-54-Frame}&lt;/p>
&lt;p>My223+σ+Ey−127 &lt;math xmlns="http://www.w3.org/1998/Math/MathML" display="block"> M y 2 23 + σ + E y − 127 &lt;/math>&lt;/p>
&lt;p>≈−12(Mx223+σ+Ex−127) &lt;math xmlns="http://www.w3.org/1998/Math/MathML" display="block"> ≈ − 1 2 ( M x 2 23 + σ + E x − 127 ) &lt;/math>&lt;/p>
&lt;br />
&lt;p>移项整理一下，把 σ 和 127 从左边，移到右边：&lt;/p>
&lt;p>My223+Ey≈−12(Mx223+Ex)−32(σ−127) &lt;math xmlns="http://www.w3.org/1998/Math/MathML" display="block"> M y 2 23 + E y ≈ − 1 2 ( M x 2 23 + E x ) − 3 2 ( σ − 127 ) &lt;/math>&lt;/p>
&lt;br />
&lt;p>再把整个表达式乘以 223 &lt;math xmlns="http://www.w3.org/1998/Math/MathML"> 2 23 &lt;/math>，得到：{#MathJax-Element-58-Frame}&lt;/p>
&lt;p>My+Ey223 &lt;math xmlns="http://www.w3.org/1998/Math/MathML" display="block"> M y + E y 2 23 &lt;/math>&lt;/p>
&lt;p>≈−12(Mx+Ex223)−32(σ−127)223 &lt;math xmlns="http://www.w3.org/1998/Math/MathML" display="block"> ≈ − 1 2 ( M x + E x 2 23 ) − 3 2 ( σ − 127 ) 2 23 &lt;/math>&lt;/p>
&lt;br />
&lt;p>可以看到一个常数： −32(σ−127)223 &lt;math xmlns="http://www.w3.org/1998/Math/MathML"> − 3 2 ( σ − 127 ) 2 23 &lt;/math>，把负号放进括号里，变成 32(127−σ)223 &lt;math xmlns="http://www.w3.org/1998/Math/MathML"> 3 2 ( 127 − σ ) 2 23 &lt;/math>，并可以用一个常量代数 R 来取代，于是得到公式：{#MathJax-Element-62-Frame}&lt;/p>
&lt;p>My+Ey223≈R−12(Mx+Ex223) &lt;math xmlns="http://www.w3.org/1998/Math/MathML" display="block"> M y + E y 2 23 ≈ R − 1 2 ( M x + E x 2 23 ) &lt;/math>&lt;/p>
&lt;br />
&lt;p>还记得我们前面那个&amp;quot;浮点数 32bits 二进制整型算式&amp;quot; M+E∗223 &lt;math xmlns="http://www.w3.org/1998/Math/MathML"> M + E ∗ 2 23 &lt;/math> 吗？假设，浮点数 x 的 32bits 的整型公式是： Ix=Mx+Ex223 &lt;math xmlns="http://www.w3.org/1998/Math/MathML"> I x = M x + E x 2 23 &lt;/math>，那么上面的公式就可以写成：{#MathJax-Element-65-Frame}&lt;/p>
&lt;p>Iy≈R−12Ix &lt;math xmlns="http://www.w3.org/1998/Math/MathML" display="block"> I y ≈ R − 1 2 I x &lt;/math>&lt;/p>
&lt;br />
&lt;h1 id="代码分析">代码分析&lt;/h1>
&lt;p>让我们回到文章的主题，那个平方根函数的代码。&lt;/p>
&lt;p>首先是：&lt;/p>
&lt;pre>&lt;code>i = * ( long * ) &amp;amp;y; // evil floating point bit level hacking
&lt;/code>&lt;/pre>
&lt;p>这行代码就是把一个浮点数的 32bits 的二进制转成整型。也就是，前面我们例子里说过的，3.14 的 32bits 的二进制是：01000000010010001111010111000011，整型是：1078523331。即 y = 3.14，i = 1078523331。&lt;/p>
&lt;p>然后是：&lt;/p>
&lt;pre>&lt;code>i = 0x5f3759df - ( i &amp;gt;&amp;gt; 1 ); // what the fuck?
&lt;/code>&lt;/pre>
&lt;p>这就是：&lt;/p>
&lt;pre>&lt;code>i = 0x5f3759df - ( i / 2 );
&lt;/code>&lt;/pre>
&lt;p>也就是我们上面推导出来的那个公式：&lt;/p>
&lt;p>Iy≈R−12Ix &lt;math xmlns="http://www.w3.org/1998/Math/MathML" display="block"> I y ≈ R − 1 2 I x &lt;/math>&lt;/p>
&lt;br />
&lt;p>代码里的 R = 0x5f3759df。&lt;/p>
&lt;p>我们又知道，R = 32(127−σ)223 &lt;math xmlns="http://www.w3.org/1998/Math/MathML"> 3 2 ( 127 − σ ) 2 23 &lt;/math>，把代码中的那个魔数代入，就可以计算出来：σ= 0.0450465 。这个数是个神奇的数字，这个数是怎么算出来的，现在还没人知道。不过，我们先往下看后面的代码：{#MathJax-Element-68-Frame}&lt;/p>
&lt;pre>&lt;code> x2 = number * 0.5F;
y = * ( float * ) &amp;amp;i;
y = y * ( threehalfs - ( x2 * y * y ) ); // 1st iteration
// 2nd iteration, this can be removed
// y = y * ( threehalfs - ( x2 * y * y ) );
&lt;/code>&lt;/pre>
&lt;p>这段代码相当于下面这个公式：&lt;/p>
&lt;p>Iy′=Iy(1.5−0.5xI2y) &lt;math xmlns="http://www.w3.org/1998/Math/MathML" display="block"> I y ′ = I y ( 1.5 − 0.5 x I y 2 ) &lt;/math>&lt;/p>
&lt;br />
&lt;p>这个其实是&amp;quot;牛顿求根法&amp;quot;，这是一个为了找到一个 f(x)= 0 的根而用一种不断逼近的计算方式。请看下图：&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/d9/e0/d9c070d857b29966ecb9eeab49057ce0.jpg" alt="">&lt;/p>
&lt;p>首先，初始值为 X0，然后找到 X0 所对应的 Y0（把 X0 代入公式得到 Y0 = f(X0)），然后在（X0,Y0）这个点上做一个切线，得到与 X 轴交汇的 X1。再用 X1 做一次上述的迭代，得到 X2，就这样一直迭代下去，一直找到，y = 0 时，x 的值。&lt;/p>
&lt;p>牛顿法的通用公式是：&lt;/p>
&lt;p>xn+1=xn−f(xn)f′(xn) &lt;math xmlns="http://www.w3.org/1998/Math/MathML" display="block"> x n + 1 = x n − f ( x n ) f ′ ( x n ) &lt;/math>&lt;/p>
&lt;br />
&lt;p>于是，对于 y=1x√ &lt;math xmlns="http://www.w3.org/1998/Math/MathML"> y = 1 x &lt;/math> 来说，对固定的 x（常数），我们求 y 使得 1y2−x=0 &lt;math xmlns="http://www.w3.org/1998/Math/MathML"> 1 y 2 − x = 0 &lt;/math>， f(y)=1y2−x &lt;math xmlns="http://www.w3.org/1998/Math/MathML"> f ( y ) = 1 y 2 − x &lt;/math> , f′(y)=−2y3 &lt;math xmlns="http://www.w3.org/1998/Math/MathML"> f ′ ( y ) = − 2 y 3 &lt;/math> 。 注意： f′(y) &lt;math xmlns="http://www.w3.org/1998/Math/MathML"> f ′ ( y ) &lt;/math> 是 f(y) &lt;math xmlns="http://www.w3.org/1998/Math/MathML"> f ( y ) &lt;/math> 关于 y 的导数。{#MathJax-Element-76-Frame}&lt;/p>
&lt;p>代入上述的牛顿法的通用公式后得到：&lt;/p>
&lt;p>yn+1=yn−1y2n−x−2y3n &lt;math xmlns="http://www.w3.org/1998/Math/MathML" display="block"> y n + 1 = y n − 1 y n 2 − x − 2 y n 3 &lt;/math>&lt;/p>
&lt;p>=yn(3−xy2n)2=yn(1.5−0.5xy2n) &lt;math xmlns="http://www.w3.org/1998/Math/MathML" display="block"> = y n ( 3 − x y n 2 ) 2 = y n ( 1.5 − 0.5 x y n 2 ) &lt;/math>&lt;/p>
&lt;br />
&lt;p>正好就是我们上面的代码。&lt;/p>
&lt;p>整个代码是，之前生成的整数操作产生首次近似值后，将首次近似值作为参数送入函数最后两句进行精化处理。代码中的两次迭代正是为了进一步提高结果的精度。但由于《雷神之锤 III》的图形计算中并不需要太高的精度，所以代码中只进行了一次迭代，二次迭代的代码则被注释了。&lt;/p>
&lt;h1 id="相关历史">相关历史&lt;/h1>
&lt;p>根据 Wikipedia 上的描述，《雷神之锤 III》的代码直到 QuakeCon 2005 才正式放出，但早在 2002 年（或 2003 年）时，平方根倒数速算法的代码就已经出现在 Usenet 和其他论坛上了。最初人们猜测是《雷神之锤》的创始人 John Carmack 写下了这段代码，但他在回复询问他的邮件时否定了这个观点，并猜测可能是先前曾帮 id Software 优化《雷神之锤》的资深汇编程序员 Terje Mathisen 写下了这段代码。&lt;/p>
&lt;p>而 Mathisen 的邮件里表示，在 1990 年代初，他只曾做过类似的实现，确切来说这段代码亦非他所作。现在所知的最早实现是由 Gary Tarolli 在 SGI Indigo 中实现的，但他亦坦承他仅对常数 R 的取值做了一定的改进，实际上他也不是作者。&lt;/p>
&lt;p>在向以发明 MATLAB 而闻名的 Cleve Moler 查证后，Rys Sommefeldt 则认为原始的算法是 Ardent Computer 公司的 Greg Walsh 所发明的，但他也没有任何确定性的证据能证明这一点。&lt;/p>
&lt;p>不仅该算法的原作者不明，人们也仍无法确定当初选择这个&amp;quot;魔术数字&amp;quot;的方法。Chris Lomont 曾做了个研究：他推算出了一个函数以讨论此速算法的误差，并找出了使误差最小的最佳 R 值 0x5f37642f（与代码中使用的 0x5f3759df 相当接近）。但以之代入算法计算并进行一次牛顿迭代后，所得近似值之精度仍略低于代入 0x5f3759df 的结果。&lt;/p>
&lt;p>因此，Lomont 将目标改为查找在进行 1-2 次牛顿迭代后能得到最大精度的 R 值，在暴力搜索后得出最优 R 值为 0x5f375a86，以此值代入算法并进行牛顿迭代，所得的结果都比代入原始值（0x5f3759df）更精确。于是他说，&amp;ldquo;如果可能我想询问原作者，此速算法是以数学推导还是以反复试错的方式求出来的？&amp;rdquo;&lt;/p>
&lt;p>Lomont 亦指出，64 位的 IEEE754 浮点数（即双精度类型）所对应的魔术数字是 0x5fe6ec85e7de30da。但后来的研究表明，代入 0x5fe6eb50c7aa19f9 的结果精确度更高（McEniry 得出的结果则是 0x5fe6eb50c7b537aa，精度介于两者之间）。&lt;/p>
&lt;p>后来 Charles McEniry 使用了一种类似 Lomont 但更复杂的方法来优化 R 值。他最开始使用穷举搜索，所得结果与 Lomont 相同。而后他尝试用带权二分法寻找最优值，所得结果恰是代码中所使用的魔术数字 0x5f3759df。因此，McEniry 认为，这一常数最初或许便是以&amp;quot;在可容忍误差范围内使用二分法&amp;quot;的方式求得。&lt;/p>
&lt;p>这可能是编程世界里最经典的魔数的故事，希望你能够从这篇文章中收获一些数学的基础知识。数学真是需要努力学习好的一门功课，尤其在人工智能火热的今天。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/fc/e9/fcc761001867c60f526665e237f831e9.jpg" alt="">&lt;/p></description></item><item><title>极客专栏: 14丨推荐阅读：机器学习101</title><link>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E/14%E4%B8%A8%E6%8E%A8%E8%8D%90%E9%98%85%E8%AF%BB%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0101/</link><pubDate>Fri, 27 May 2022 00:00:00 +0000</pubDate><guid>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E/14%E4%B8%A8%E6%8E%A8%E8%8D%90%E9%98%85%E8%AF%BB%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0101/</guid><description>
&lt;p>自从 2012 年在亚马逊第一次接触机器学习（一个关于预测商品需求的 Demand Forecasting 的项目）以来，我一直在用一些零星的时间学习机器学习相关的东西。所以，说实话，在机器学习方面，我也只是一个新手，也在入门阶段。&lt;/p>
&lt;p>在前面文章的评论中，有网友希望我写一篇有关大数据和机器学习的文章，老实说，有点为难我了。所以，我只能结合自己的学习过程写一篇入门级的文章，希望能看到高手的指教和指正。&lt;/p>
&lt;p>首先，简单介绍一下机器学习的一些原理。机器学习主要来说有两种方法，监督式学习（Supervised Learning）和非监督式学习（Unsupervised Learning）。&lt;/p>
&lt;h1 id="监督式学习">监督式学习&lt;/h1>
&lt;p>所谓监督式学习，也就是说，我们需要提供一组学习样本，包括相关的特征数据以及相应的标签。程序可以通过这组样本来学习相关的规律或是模式，然后通过得到的规律或模式来判断没有被打过标签的数据是什么样的数据。&lt;/p>
&lt;p>举个例子，假设需要识别一些手写的数字，那么我们就需要找到尽可能多的手写体数字的图像样本，然后人工或是通过某种算法来明确地标注什么是这些手写体的图片，谁是 1，谁是 2，谁是 3&amp;hellip;&amp;hellip;这组数据就叫样本数据，又叫训练数据（training data）。&lt;/p>
&lt;p>通过机器学习的算法，我们可以找到每个数字在不同手写体下的特征，进而找到规律和模式。然后通过得到的规律或模式来识别那些没有被打过标签的手写数据，以此完成识别手写体数字的目标。&lt;/p>
&lt;p>一种比较常见的监督式学习，就是从历史数据中获得数据的走向趋势，来预测未来的走向。比如，我们使用历史上的股票走势数据来预测接下来的股价涨跌，或者通过历史上的一些垃圾邮件的样本来识别新的垃圾邮件。&lt;/p>
&lt;p>在监督式学习下，需要有样本数据或是历史数据来进行学习，这种方式会有一些问题。比如&lt;/p>
&lt;ul>
&lt;li>
&lt;p>如果一个事物没有历史数据，那么就不好做了。变通的解决方式是通过一个和其类似事物的历史数据。我以前做过的需求预测，就属于这种情况。对于新上市的商品来说，完全没有历史数据，比如，iPhone X，那么就需要从其类似的商品上找历史数据，如 iPhone 7 或是别的智能手机。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>历史数据中可能会有一些是噪音数据，需要把这些噪音数据给过滤掉。一般这样的过滤方式要通过人工判断和标注。举两个例子，某名人在其微博或是演讲上推荐了一本书，于是这本书的销量就上升了。这段时间的历史数据不是规律性的，所以就不能成为样本数据，需要去掉。同样，如果某名人（如 Michael Jackson）去世导致和其有关的商品销售量很好，那么，这个事件所产生的数据则不属于噪音数据。因为每年这个名人忌日的时候出现销量上升的可能性非常高，所以，需要标注一下，这是有规律的样本，可以放入样本进行学习。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h1 id="非监督式学习">非监督式学习&lt;/h1>
&lt;p>对于非监督式学习，也就是说，数据是没有被标注过的，所以相关的机器学习算法需要找到这些数据中的共性。因为大量的数据是没有被标识过的，所以这种学习方式可以让大量未标识的数据能够更有价值。&lt;/p>
&lt;p>而且，非监督式的学习，可以为我们找到人类很难发现的数据里的规律或模型。所以，也有人将这种学习称为&amp;quot;特征点学习&amp;quot;。其可以让我们自动地为数据进行分类，并找到分类的模型。&lt;/p>
&lt;p>一般来说，非监督式学习会应用在一些交易型的数据中。比如，有一堆的用户购买数据，但是对于人类来说，我们很难找到用户属性和购买商品类型之间的关系，而非监督式学习算法可以帮助我们找到他们之间的关系。&lt;/p>
&lt;p>比如，一个在某一年龄段区间的女生购买了某种肥皂，有可能说明这个女生在怀孕期，或是某人购买儿童用品，有可能说明这个人的关系链中有孩子，等等。于是这些信息会被用作一些所谓的精准市场营销活动，从而可以增加商品销量。&lt;/p>
&lt;p>我们这么来说吧，监督式学习是在被告诉过正确的答案之后的学习，而非监督式学习是在没有被告诉正确答案时的学习，所以说，非监督式的学习是在大量的非常混乱的数据中找寻一些潜在的关系，这个成本也比较高。&lt;/p>
&lt;p>这种非监督式学习也会经常被用来检测一些不正常的事情发生，比如信用卡的诈骗或是盗刷。也有被用在推荐系统中，比如买了这个商品的人又买了别的什么东西，或是如果某个人喜欢某篇文章、某个音乐、某个餐馆，那么可能他会喜欢某款车、某个明星，或某个地方。&lt;/p>
&lt;p>在监督式的学习的算法下，我们可以用一组&amp;quot;狗&amp;quot;的照片来确定某个照片中的物体是不是狗。而在非监督式的学习算法下，我们可以通过一个照片来找到与其相似事物的照片。这两种学习方式都有各自适用的场景。&lt;/p>
&lt;h1 id="如何找到数据的规律和关联">如何找到数据的规律和关联&lt;/h1>
&lt;p>机器学习基本就是在已知的样本数据中寻找数据的规律，在未知的数据中找数据的关系。所以，这就需要一定的数学知识了，但对于刚入门的人来说，学好高数、线性代数、概率论、数据建模等大学本科的数学知识应该就够用了。以前上大学时，总觉得这些知识没什么用处，原来只不过是自己太 low，还没有从事会运用到这些知识的工作。&lt;/p>
&lt;p>总之，机器学习中的基本方法论是这样的。&lt;/p>
&lt;ol>
&lt;li>
&lt;p>要找到数据中的规律，你需要找到数据中的特征点。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>把特征点抽象成数学中的向量，也就是所谓的坐标轴。一个复杂的学习可能会有成十上百的坐标轴。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>抽象成数学向量后，就可以通过某种数学公式来表达这类数据（就像 y=ax+b 是直线的公式），这就是数据建模。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>这个数据公式就是我们找出来的规律。通过这个规律，我们才可能关联类似的数据。&lt;/p>
&lt;p>当然，也有更为简单粗暴的玩法。&lt;/p>
&lt;ol>
&lt;li>
&lt;p>把数据中的特征点抽象成数学中的向量。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>每个向量一个权重。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>写个算法来找各个向量的权重是什么。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>有人把这个事叫&amp;quot;数据搅拌机&amp;quot;。据说，这种简单粗暴的方式超过了那些所谓的明确的数学公式或规则。这种&amp;quot;土办法&amp;quot;有时候会比高大上的数学更有效，哈哈。&lt;/p>
&lt;p>关于机器学习这个事，你可以读一读 &lt;a href="https://medium.com/@ageitgey/machine-learning-is-fun-80ea3ec3c471">Machine Learning is Fun!&lt;/a> 这篇文章，以及它的&lt;a href="https://zhuanlan.zhihu.com/p/24339995">中文翻译版&lt;/a>。&lt;/p>
&lt;h1 id="相关算法">相关算法&lt;/h1>
&lt;p>对于监督式学习，有如下经典算法。&lt;/p>
&lt;ol>
&lt;li>
&lt;p>决策树（Decision Tree）。比如自动化放贷、风控。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>朴素贝叶斯分类（Naive Bayesian classification）。可以用于判断垃圾邮件，对新闻的类别进行分类，比如科技、政治、运动，判断文本表达的感情是积极的还是消极的，以及人脸识别等。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>最小二乘法（Ordinary Least Squares Regression）。算是一种线性回归。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>逻辑回归（Logisitic Regression）。一种强大的统计学方法，可以用一个或多个变量来表示一个二项式结果。它可以用于信用评分、计算营销活动的成功率、预测某个产品的收入等。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>支持向量机（Support Vector Machine，SVM）。可以用于基于图像的性别检测，图像分类等。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>集成方法（Ensemble methods）。通过构建一组分类器，然后根据它们的预测结果进行加权投票来对新的数据点进行分类。原始的集成方法是贝叶斯平均，但是最近的算法包括纠错输出编码、Bagging 和 Boosting。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>对于非监督式的学习，有如下经典算法。&lt;/p>
&lt;ol>
&lt;li>
&lt;p>聚类算法（Clustering Algorithms）。聚类算法有很多，目标是给数据分类。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>主成分分析（Principal Component Analysis，PCA）。PCA 的一些应用包括压缩、简化数据，便于学习和可视化等。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>奇异值分解（Singular Value Decomposition，SVD）。实际上，PCA 是 SVD 的一个简单应用。在计算机视觉中，第一个人脸识别算法使用 PCA 和 SVD 来将面部表示为&amp;quot;特征面&amp;quot;的线性组合，进行降维，然后通过简单的方法将面部匹配到身份。虽然现代方法更复杂，但很多方面仍然依赖于类似的技术。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>独立成分分析（Independent Component Analysis，ICA）。ICA 是一种统计技术，主要用于揭示随机变量、测量值或信号集中的隐藏因素。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>上面的这些相关算法来源自博文《&lt;a href="https://www.kdnuggets.com/2016/08/10-algorithms-machine-learning-engineers.html">The 10 Algorithms Machine Learning Engineers Need to Know&lt;/a>》。&lt;/p>
&lt;h1 id="相关推荐">相关推荐&lt;/h1>
&lt;p>学习机器学习有几个课是必须要上的，具体如下。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>吴恩达教授（Andrew Ng）在 &lt;a href="https://www.coursera.org/learn/machine-learning">Coursera 上的机器学习课程&lt;/a>非常棒。我强烈建议从此入手。对于任何拥有计算机科学学位的人，或是还能记住一点点数学的人来说，都非常容易入门。这个斯坦福大学的课程后面是有作业的，请尽量拿满分。另外，&lt;a href="http://open.163.com/special/opencourse/machinelearning.html">网易公开课上也有该课程&lt;/a>。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>卡内基梅隆大学计算机科学学院汤姆·米切尔（Tom Mitchell）教授的机器学习课程，这里有&lt;a href="http://www.cs.cmu.edu/~tom/10701_sp11/lectures.shtml">英文原版视频和课件 PDF&lt;/a> 。汤姆·米切尔是全球 AI 界顶级大牛，在机器学习、人工智能、认知神经科学等领域都有建树，撰写了机器学习方面最早的教科书之一&lt;a href="http://item.jd.com/10131321.html">《机器学习》&lt;/a>，被誉为入门必读图书。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>加利福尼亚理工学院亚瑟·阿布·穆斯塔法（Yaser Abu-Mostafa）教授的 &lt;a href="http://work.caltech.edu/lectures.html">Learning from Data 系列课程&lt;/a> 。本课程涵盖机器学习的基本理论和算法，并将理论与实践相结合，更具实践指导意义，适合进阶。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>除了上述的那些课程外，下面这些资源也很不错。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>YouTube 上的 Google Developers 的 &lt;a href="https://www.youtube.com/playlist?list=PLOU2XLYxmsIIuiBfYad6rFYQU_jL2ryal">Machine Learning Recipes with Josh Gordon&lt;/a> 。这 9 集视频，每集不到 10 分钟，从 Hello World 讲到如何使用 TensorFlow，值得一看。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>还有 &lt;a href="https://pythonprogramming.net/machine-learning-tutorial-python-introduction/">Practical Machine Learning Tutorial with Python Introduction&lt;/a> 上面一系列的用 Python 带着你玩 Machine Learning 的教程。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Medium 上的 &lt;a href="https://medium.com/machine-learning-101">Machine Learning - 101&lt;/a> 讲述了好多我们上面提到过的经典算法。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>还有，Medium 上的 &lt;a href="https://medium.com/machine-learning-for-humans">Machine Learning for Humans&lt;/a>，不仅提供了入门指导，更介绍了各种优质的学习资源。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://machinelearningmastery.com/blog/">杰森·布朗利（Jason Brownlee）博士的博客&lt;/a> 也是非常值得一读，其中好多的 &amp;ldquo;How-To&amp;rdquo;，会让你有很多的收获。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="http://iamtrask.github.io">i am trask&lt;/a> 也是一个很不错的博客。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>关于 Deep Learning 中神经网络的学习，推荐 YouTube 介绍视频 &lt;a href="https://www.youtube.com/playlist?list=PLZHQObOWTQDNU6R1_67000Dx_ZCJB-3pi">Neural Networks&lt;/a>。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>用 Python 做自然语言处理&lt;a href="http://www.nltk.org/book/">Natural Language Processing with Python&lt;/a>。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>以及 GitHub 上的 &lt;a href="https://github.com/ujjwalkarn/Machine-Learning-Tutorials">Machine Learning 和 Deep Learning&lt;/a> 的相关教程列表。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>此外，还有一些值得翻阅的图书。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;a href="https://cs.nju.edu.cn/zhouzh/zhouzh.files/publication/MLbook2016.htm">《机器学习》&lt;/a>，南京大学周志华教授著。它是一本机器学习方面的入门级教科书，适合本科三年级以上的学生学习。这本书如同一张地图一般，让你能&amp;quot;观其大略&amp;quot;，了解机器学习的各个种类、各个学派，其覆盖面与同类英文书籍相较不遑多让。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="http://ciml.info/">A Course In Machine Learning&lt;/a>，马里兰大学哈尔·道姆（Hal Daumé III）副教授著。 这本书讲述了几种经典机器学习算法，包括决策树、感知器神经元、kNN 算法、K-means 聚类算法、各种线性模型（包括对梯度下降、支持向量机等的介绍）、概率建模、神经网络、非监督学习等很多主题，还讲了各种算法使用时的经验技巧，适合初学者学习。此外，官网还提供了免费电子版。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="http://www.deeplearningbook.org/">Deep Learning&lt;/a>，麻省理工学院伊恩·古德费洛（Ian Goodfellow）、友华·本吉奥（Yoshua Benjio）和亚伦·考维尔（Aaron Courville）著。这本书是深度学习专题的经典图书。它从历史的角度，将读者带进深度学习的世界。深度学习使用多层的（深度的）神经元网络，通过梯度下降算法来实现机器学习，对于监督式和非监督式学习都有大量应用。如果读者对该领域有兴趣，可以深入阅读本书。本书官网提供免费电子版，但不提供下载。实体书（英文原版或中文翻译版）可以在网上买到。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="http://www.freetechbooks.com/reinforcement-learning-an-introduction-second-edition-draft-t1282.html">Reinforcement Learning&lt;/a>，安德鲁·巴托（Andrew G.Barto）和理查德·萨顿（Richard S. Sutton）著。这本书是强化学习（Reinforcement Learning）方面的入门书。它覆盖了马尔可夫决策过程（MDP）、Q-Learning、Sarsa、TD-Lamda 等方面。这本书的作者是强化学习方面的创始人之一。强化学习（结合深度学习）在围棋程序 AlphaGo 和自动驾驶等方面都有着重要的应用。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.amazon.com/Pattern-Recognition-Learning-Information-Statistics/dp/0387310738">Pattern Recognition and Machine Learning&lt;/a> ，微软剑桥研究院克里斯托夫·比肖普（Christoph M. Bishop）著。这本书讲述了模式识别的技术，包括机器学习在模式识别中的应用。模式识别在图像识别、自然语言处理、控制论等多个领域都有应用。日常生活中扫描仪的 OCR、平板或手机的手写输入等都属于该领域的研究。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>好了，今天推荐的内容就这些。我目前也在学习中，希望能够跟你一起交流探讨，也期望能得到你的指教和帮助。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/fc/e9/fcc761001867c60f526665e237f831e9.jpg" alt="">&lt;/p></description></item><item><title>极客专栏: 15丨时间管理：同扭曲时间的事儿抗争</title><link>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E/15%E4%B8%A8%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86%E5%90%8C%E6%89%AD%E6%9B%B2%E6%97%B6%E9%97%B4%E7%9A%84%E4%BA%8B%E5%84%BF%E6%8A%97%E4%BA%89/</link><pubDate>Fri, 27 May 2022 00:00:00 +0000</pubDate><guid>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E/15%E4%B8%A8%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86%E5%90%8C%E6%89%AD%E6%9B%B2%E6%97%B6%E9%97%B4%E7%9A%84%E4%BA%8B%E5%84%BF%E6%8A%97%E4%BA%89/</guid><description>
&lt;p>我一直说，时间是人生中最宝贵的财富，今天我就来跟你聊聊时间管理方面的话题。&lt;/p>
&lt;p>关于时间管理，我以前在外企工作时，受过一个专门的培训，后来我也在工作中总结过自己的方式。时间管理是非常重要的，因为时间过得实在是太快了，快得让你有点受不了，而看似忙碌的我们似乎在这一年中也没有做太多事，尤其是让自己能成长的事情。&lt;/p>
&lt;p>有那么一句话是这么说，老天很公平，给了所有人同样多的时间，而有的人能够把时间用好，有的人则没有把时间用好。日积月累，人和人的差距就越来越大了。&lt;/p>
&lt;p>之前的文章和你讲过，我在工作强度很大的情况下，依然可以找到时间来学习和提升自己，主要是我自己很渴望学习。今天我就想和你聊一下，除了自己对某件事情的热情外，我们还有什么方法可以管理好自己的时间。&lt;/p>
&lt;p>不过，说实话，在安排时间方面，我成长于一个相对于今天算是比较好的环境，举几个例子。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>那个年代，没有智能手机，工作中也不用实时聊天工具。而现在，很多公司都会有若干个聊天群，所有人都可以把信息发给所有的人，而不管这个事是否与你相关。但这些信息无法像邮件那样根据邮件标题聚合，或是通过设置规则自动分类&amp;hellip;&amp;hellip;于是你工作在了一个信息杂乱无章的环境里，而且还在不断地被人打扰，不断地被人打断。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>那个年代，别人要来找我开会，需要先给我发会议邀请，而且发会议邀请的时候，会找我日历上空闲的时间段来确定会议时间。所以，我可以把很多工作安排在我的日历上，通过邮箱（Outlook 或是 Gmail 都有这样的功能）共享出去。这样，别人都会自觉地绕开我有安排的时间段来找我。&lt;/p>
&lt;p>而今天，我看到很多公司直接在微信上联系。你要是回复慢了，电话直接打过来，直接叫你去开会。不像我那个年代，老板临时给员工开会也要问一下员工有没有时间，但现在的工作环境连问都不问，直接一句，你来一下。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>那个年代，我们喜欢有计划地安排工作，然后按此执行。还记得在路透工作的时候，管理者们都说，你工作时如果有 70% 的时间能花在项目开发上，算是很高效了，一般来说，正常值也就是 50% 左右。在亚马逊的时候，每次开会都会把会议中要讨论的事打印出来，前 10 分钟大家都在读文档，然后直接讨论，所以基本上会议都保持在半小时左右。&lt;/p>
&lt;p>这可能是外企的好处吧，从上到下都知道时间管理是很重要的事，所以，从管理层到执行层都会想方设法帮助程序员专注地做好开发工作。包括尽可能的不开会，不开长会，需求和设计都是要论证很久才会决定做不做，项目管理会帮你把你处理额外工作的时间也算进去，还会把你在学习上花的时间也计算进去。所以，时间在整个组织上能够被有效地管理和安排着。完全不像今天国内的互联网公司。&lt;/p>
&lt;p>所以，我以前管理自己的时间还是比较容易的，然而，现在人的工作环境的确是非常不利于管理。不过，我还是想在这里谈一下如何管理自己的时间，希望对你有帮助。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h1 id="主动管理">主动管理&lt;/h1>
&lt;p>无论什么事情，如果你发现你持续处于被动的状态下，那么你一定要停下来想一想如何把被动变为主动。因为在被动的方式下工作，你是不可能做好工作的，无论什么事。我是一个非常不喜欢被动的人，所以，对于任何被动状态，我都要&amp;quot;反转控制&amp;quot;，想尽一切方式变成主动。&lt;/p>
&lt;p>如果你发现你的时间老是被别人打断，那么你就要告诉大家，我什么时间段在做什么事，请大家不要打扰我。我以前在国外看到有个老外就在自己的工位上挂了一个条幅，上面写着&amp;quot;正在努力写代码中，请勿打断&amp;hellip;&amp;hellip;&amp;ldquo;而我在亚马逊工作时，亚马逊也允许员工想沉浸于工作时不用来公司而是可以在家办公（work from home）。我在阿里工作那会，有时候也怕被人打断，所以，我会跑到别的楼里找个空的工位工作。&lt;/p>
&lt;p>在今天，我觉得你也可以这么干，你可以在群里事先告诉大家，我在几点到几点要无间断地做某个事，这个期间不会看任何微信或是钉钉的群聊，也不会接任何的电话，请大家不要来打扰我。而且还可以学习一下那个我见过的老外，在自己的工位上挂一个不要打扰我的条幅。人肉 Mute 掉所有的打扰。&lt;/p>
&lt;p>另外，可以仿照一下以前在 Outlook 里设置工作日程的方式，把你的工作安排预先设置到一个可以共享的日历上，然后分享给大家，让大家了解你的日程。这样，可以让你的同事和老板能事先有个谱儿，而不至于想打断你就打断你。&lt;/p>
&lt;p>你甚至可以要求你的同事，重要的事，不要发微信，而是要发邮件，因为微信会有很大概率看不到。这样一来，你就再也不用在一大堆聊天信息中做人肉的大数据挖掘，来找到和你有关的信息。&lt;/p>
&lt;p>信息管理真的非常重要，因为将信息做好分类，才方便检索，方便你通过自己的优先级来处理信息。而目前看来，这些只有邮件才能够更好地完成（邮件可以帮你通过邮件标题聚合，你可以设置很多规则来自动化分类邮件，还可以帮你设置自动化回复）。&lt;/p>
&lt;p>换句话说，&lt;strong>你要主动管理的不是你的时间，而是管理你的同事，管理你的信息&lt;/strong>。&lt;/p>
&lt;h1 id="学会说不">学会说&amp;quot;不&amp;rdquo;&lt;/h1>
&lt;p>上面说了如何主动地管理你的时间。但是，那只是能让你有大块可以专注于工作的时间。然而，这并不能帮助你解决时间不够的问题。比如，现在的很多公司总是把工作安排得非常紧，今天提的需求，恨不得明天就上线，这也就是为什么今天加班的严重程度比我那个时候还更为严重。&lt;/p>
&lt;p>我认为，现在的很多公司已经不尊重科学和客观规律了，如果让他来管理孕妇，我觉得他们恨不得要把 10 个月的产期缩短成 2 个月。&lt;/p>
&lt;p>所以，在这种情况下，你要学会对某些事说&amp;quot;不&amp;quot;，甚至是要学习对老板说不。这其实是一种&amp;quot;向上管理&amp;quot;的能力。&lt;/p>
&lt;p>以前在外企接受到的管理方面的培训，有这么一条&amp;quot;Never Say No&amp;quot;&amp;mdash;&amp;mdash;永不说不。的确是这样，说&amp;quot;不&amp;quot;会让人产生距离和不信任。所以，真是这样的，永远不要说不。但是，你明明做不到，还不能说不，这应该怎么办呢？这里面的诀窍如下。&lt;/p>
&lt;ol>
&lt;li>
&lt;p>当你面对做不到的需求时，你不要说这个需求做不到。尤其是，你不要马上说做不到，你要先想一下，这样让别人觉得你是想做的，但是，在认真思考过后，你觉得做不到，并且给出一个你觉得能做到的方案。这里的诀窍是&amp;mdash;&amp;mdash;&lt;strong>给出另一个你可以做到的方案，而不是把对方的方案直接回绝掉&lt;/strong>。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>当你面对过于复杂的需求时，你不要说不。你要反问一下，为什么要这样做？这样做的目的是什么？当了解完目的以后，你可以给出一个自己的方案，或是和对方讨论一个性价比更好的方案。你可以回复说，这个需求好复杂，我们能不能先干这个，再做那个，这样会更经济一些。这里的诀窍是&amp;mdash;&amp;mdash;&lt;strong>我不说我不能完全满足你，但我说我可以部分满足你&lt;/strong>。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>当你面对时间完全不够的需求时，你也不要说不。既然对方把压力给你，你要想办法把这个压力还回去，或是让对方来和你一同分担这个压力。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>这个时候，我惯用的方式是给回三个选择：a. 我可以加班加点完成，但是我不保证好的质量，有 bug 你得认，而且事后你要给我 1 个月的时间还债。b. 我可以加班加点，还能保证质量，但我没办法完成这么多需求，能不能减少一些？c. 我可以保质保量地完成所有的需求，但是，能不能多给我 2 周时间？&lt;/p>
&lt;p>这里的诀窍是&amp;mdash;&amp;mdash;&lt;strong>我不能说不，但是我要有条件地说是。而且，我要把你给我的压力再反过来还给你，看似我给了需求方选择，实际上，我掌握了主动&lt;/strong>。&lt;/p>
&lt;p>这就是学会说&amp;quot;不&amp;quot;的方法。说白了，你要学会在**&amp;ldquo;积极主动的态度下对于不合理的事讨价还价&amp;rdquo;。只有学会了说&amp;quot;不&amp;quot;，你才能够控制好你的时间**。&lt;/p>
&lt;h1 id="加班和开会">加班和开会&lt;/h1>
&lt;p>国内的公司和国外公司还有一个很不同的事情，就是大量的加班和大量冗长的会议。我见过很多国内的公司，无论大公司还是小的创业公司，都是这个样子的。&lt;/p>
&lt;p>老实说，我对这个事情也能理解也不能理解。一方面，我能理解为什么会有这么多的加班和会议，主要原因还是管理者在管理上只会使用低级的通过劳动密集型的方式来做事。&lt;/p>
&lt;p>另一方面，我不能理解的是，国外公司的加班和会议长度根本不像国内的公司，人家做的也比中国的公司好得多。在国内的公司，老板们看到团队在拼命加班，会很高兴，而在国外的公司，老板看到团队在拼命加班，会觉得这个团队一定是哪里出了问题，老板会比较焦虑。&lt;/p>
&lt;p>那么，对于身处于这样环境中的我们，应该怎样管理好自己的时间，或是为自己争取时间呢？老实说，在恶劣的环境中优雅的行动，基本上是一件不可能的事情。我也经历过这样的事，但我也没有太好的办法。不过，我还是可以跟你分享几个我的实践方式。&lt;/p>
&lt;p>对于加班的事，除了像上面说的那样，学会如何说&amp;quot;不&amp;quot;外，我发现很多时候造成加班的原因就是恶性循环。也就是说，因为加班干出来了质量不好的软件，于是线上故障很多，要花时间处理，而后面的需求也过来了，发现复杂代码的扩展性很差，越干越慢，越干越烂，越干故障越多。于是，你会被抱怨得越来越多。&lt;/p>
&lt;p>这里，我觉得，&lt;strong>如果怎么做都要受伤害，那么两害相权取其轻&lt;/strong>。你要学会比较是项目延期的伤害大，还是线上故障的伤害大，是先苦后甜好，还是积压问题好，聪明的你应该能做出正确的判断。&lt;/p>
&lt;p>对于开会，我觉得今天大多数的会都开错了。在会上抛出问题，还是开放性的问题，然后公说公有理，婆说婆有理，任大家自由发挥，各种跑题跑偏，最后还没有任何的答案。&lt;strong>开会，不是讨论问题，而是讨论方案，开会不是要有议题，而是要有议案&lt;/strong>。&lt;/p>
&lt;p>所以，作为与会者，如果你发现没有议案，大家海了去说，那么你有两种选择，跳出来帮大家理一理，或者也可以说一下，如果会上讨论不清，要不先线下讨论，有了方案再来评审。也许在一些会上你不敢这么干，但是有些会你是可以这么干的。能影响的这些都能为你争取到很多时间。&lt;/p>
&lt;p>好了，总结一下。今天我主要跟你分享了几个能为自己争取更多时间的方法，比如主动管理时间、学会说&amp;quot;不&amp;quot;，以及面对高强度的加班和冗长的会议时，该如何应对和解决等。因为我认为，只有将使用时间的主动权掌握在自己手上，才能更好地利用时间，才能更为高效率的工作。所以，&lt;strong>这才是时间管理的关键点。&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/fc/e9/fcc761001867c60f526665e237f831e9.jpg" alt="">&lt;/p></description></item><item><title>极客专栏: 16丨时间管理：如何利用好自己的时间？</title><link>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E/16%E4%B8%A8%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8%E5%A5%BD%E8%87%AA%E5%B7%B1%E7%9A%84%E6%97%B6%E9%97%B4/</link><pubDate>Fri, 27 May 2022 00:00:00 +0000</pubDate><guid>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E/16%E4%B8%A8%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8%E5%A5%BD%E8%87%AA%E5%B7%B1%E7%9A%84%E6%97%B6%E9%97%B4/</guid><description>
&lt;p>前面我们讨论了如何争取到更多自己可以控制的时间，今天，我们接着再来聊另外一个话题&amp;mdash;&amp;mdash;如何利用好自己的时间。对此，我有下面的这些心得和方法，如果你有更好的方法，也欢迎告诉我。&lt;/p>
&lt;h1 id="投资自己的时间">投资自己的时间&lt;/h1>
&lt;p>其实，时间就像金钱一样，你得学会投资时间，把时间投资在有价值有意义的地方，你就会有&amp;quot;更多的时间&amp;quot;。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>花时间学习基础知识，花时间读文档&lt;/strong> 。在参加工作的这 20 年时间里，我发现，很多程序员都把时间都浪费在了查错上。究其根本原因就是基础知识不完整，没有好好地把技术相关的用户文档读完就仓促上手做事情了。其实只要把基础打扎实，认真读一下文档，你会省出很多很多的时间。&lt;strong>系统地学习一门技术是非常关键的，所以这个时间是值得投资的&lt;/strong>。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>花时间在解放自己生产力的事上&lt;/strong>。在自动化、可配置、可重用、可扩展上要多花时间。对于软件开发来说，能自动化的事，就算多花点时间也要自动化，因为下次就不用花时间了。让自己的软件模块可以更灵活地配置和扩展，这样如果有需求变更或是有新需求的时候，可以不用改代码，或者就算要改代码也很容易。&lt;/p>
&lt;p>这里，可能很多人会说不要过度设计，对于这个观点，我既同意，也反对。的确，过度设计不好，但是只要是能在未来节省时间的，宁可这个项目延期，我也会做的。&lt;strong>花时间在解放自己的事上是最有意义的了&lt;/strong>。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>花时间在让自己成长的事上&lt;/strong>。注意，晋升并不代表成长，成长不应该只看在一个公司内，而是要看在行业内，在行业内的成长才是真正的成长。所以，把时间花在能让自己成长，能让自己有更强的竞争力，能让自己有更大的视野，能让自己有更多可能性的事情上。这样的时间投资才是有价值的。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>花时间在建立高效的环境上&lt;/strong>。我相信你和我会有一样的一个习惯，那就&amp;quot;工欲善其事，必先利其器&amp;quot;。我们程序员在做事之前都喜欢把自己的工作环境整理到自己喜欢的状态下。比如使用趁手的开发工具，使用趁手的设备。&lt;/p>
&lt;p>这里，我想把这个事扩大一下，花些时间在影响你身边的人上，比如你的同事，你的产品经理，你的老板，去影响他们，让他们理解你，让他们配合你来建立更好的流程和管理方法。在这个方向上花时间也是很值得的。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h1 id="规划自己的时间">规划自己的时间&lt;/h1>
&lt;p>&lt;strong>定义好优先级&lt;/strong>。无论你写不写出来，你一定都会有一个自己的 to-do list。有 to-do list 并不是什么高深的事。更重要的是，你要知道什么事是重要的，什么事是紧急的，什么事重要但不紧急，什么事又重要又紧急。这有利于你划分优先级。&lt;/p>
&lt;p>&lt;strong>最短作业优先&lt;/strong>。对于相同优先级的事，我个人喜欢的是&amp;quot;最短作业优先&amp;quot;的调度算法。理由是，先把可以快速做完的事做完，看到 to-do list 上划掉一个任务，看到任何的数据在减少，对于自己也好，对于老板也好。老板可以看到你的工作进度飞快，一方面有利于为后面复杂的工作争取更多的时间（老板只有在你有 Deliver 的时候才愿意给你更多的时间），另一方面，看到任务列表的减少会让你的心态更为积极。&lt;/p>
&lt;p>而反过来，你花太多的时间在长作业上，长作业通常很容易出现&amp;quot;意外情况&amp;quot;让你花更多的时间，但此时你发现还有很多别的事没有做，这会让你产生焦虑感，产生更多的压力，进而导致更慢的生产效率。&lt;/p>
&lt;p>&lt;strong>想清楚再做&lt;/strong>。我发现很多时候，我们没有想清楚就开干了，边干边想，这样的工作方式其实很糟糕。你会发现，如果你没有想清楚，你总是要对已完成的工作进行返工，返工好几次，其实是非常浪费时间的。&lt;/p>
&lt;p>所以，对于一些没想清楚的事，或是自己不太有信心的事，还是先看看有没有已有的成熟解决方案，或是找更牛的人来给你把把关，帮你出出主意，看看有没有更好、更简单的方式。&lt;/p>
&lt;p>&lt;strong>关注长期利益规划&lt;/strong>。要多关注长远可以节省多少时间，而不是当前会花费多少时间。长期成本会比短期成本大得多。所以，宁可在短期延期，也不要透支未来。这里的逻辑是，工作上的事你永远也做不完的，长痛不如短痛。&lt;/p>
&lt;p>我一年要做 10 个项目，我宁可第 1 或第 2 个项目被老板骂，但是我可以赢得后面 8 个项目，从后面 8 个项目上把之前失去的找回来。而如果反过来的话，我虽然一开始得到了老板的信任，但是后面越来越玩不动，最终搬起一块大石头砸了自己的脚。而且，不关注长远利益的人，基本上来说也是很难有成长的。&lt;/p>
&lt;p>也就是说，&lt;strong>你要学会规划自己的行动计划，不是短期的，而是一个中长期的。我个人建议是按季度来规划，这个季度做什么，达到什么目标，一年往前走四步，而不是只考虑眼下&lt;/strong>。&lt;/p>
&lt;h1 id="用好自己的时间">用好自己的时间&lt;/h1>
&lt;p>&lt;strong>将军赶路不追小兔&lt;/strong>。这个世界有太多的东西会让我们分心和跑偏。能专注地把时间投入到一个有价值的事上是非常重要的。确定自己的目标，专注达到这个目标，而不是分心。将军的目标是要攻城，而不是追兔子。所以，你要学会过滤掉与自己目标无关的事，不要让那些无关的事控制自己。&lt;/p>
&lt;p>比如，不要让别人来影响自己的心情，心情被影响了，你一下就会什么都不想干了。做自己心情的主人，不要让别人 hack 了你的心情。再比如，知道哪些是自己可以控制的事，哪些是自己控制不了的事，在自己能控制的地方花时间。&lt;/p>
&lt;p>再比如，知道哪些是更有效的路径，是花时间改变别人，还是花时间去寻找志同道合的人。不与不如自己的人争论，也不要尝试花时间去叫醒那些装睡的人，这些都是非常浪费时间的事。多花时间在有产出的事上，少花时间在说服别人的事上。&lt;/p>
&lt;p>&lt;strong>形成习惯&lt;/strong>。再好的方法，如果没有形成习惯，不能在实际的工作和生活中解决实际问题，都将成为空谈。如果你是个追求上进的人，我相信一定看过很多时间管理方法的文章和书籍，并且看的时候还会有些振奋，内心有时还会不自觉地想，&amp;ldquo;嗯，嗯！这个方法不错，正是我需要的，可以解决我的问题&amp;hellip;&amp;hellip;&amp;ldquo;但很多时候都坚持不了几天就抛之脑后了。&lt;/p>
&lt;p>所以，在讲述完如何争取时间，及如何使用时间之后，我想分享一下如何将这些时间管理方法形成习惯，因为我坚信：&amp;ldquo;做&amp;quot;比&amp;quot;做好&amp;quot;更重要。养成一个好习惯通常需要 30 天左右的时间，尤其在最初的几天就更为重要了。这时，不妨将文章中提到的方法和几个要点，写在某本书或者笔记本的扉页上，方便查看，时刻提醒自己。&lt;/p>
&lt;p>而且，你可以结合自己的实际情况，适当做出调整。我的方法是我根据自己的情况总结的，不一定完全适合你，你完全可以基于我说的几个原则，发掘其他更适合自己的方法，这样才能更有利于形成习惯，对你更有帮助。&lt;/p>
&lt;p>&lt;strong>形成正反馈&lt;/strong>。在前面的文章中，我提到过，要有正反馈，也就是成就感，有助于完成一些看似难以完成的事儿。比如，我们说过，学习是逆人性的事儿，但如果在学习过程中不断地有正反馈，就更利于我们坚持下去。要让自己有正反馈，那就需要把时间花在有价值的地方，比如，解决自己和他人的痛点，这样你会收获别人的赞扬和鼓励。&lt;/p>
&lt;p>&lt;strong>反思和举一反三&lt;/strong>。可以尝试每周末花上点时间思考一下，本周做了哪些事儿？时间安排是否合理？还有哪些可以优化提高的地方？有点儿类似于我们常说的&amp;quot;复盘&amp;rdquo;。然后思考一下，下周的主要任务是什么？并根据优先级规划一下完成这些任务的顺序，也就是做一些下周的工作规划。&lt;/p>
&lt;p>这样每周都能及时得到自己做时间管理之后的反馈，并有助于持续优化。通常坚持做时间管理一段时间以后，你都能在每次复盘时得到正反馈，这是有利于我们形成时间管理习惯的。但我这里也想强调一点，我们也要允许偶尔的&amp;quot;负反馈&amp;rdquo;，因为人的状态总是会有高潮和低谷的，控制好一个合理的度就可以了。&lt;/p>
&lt;p>人最宝贵的财富就是时间，把时间用在刀刃上，必将让你的人生有更多收获。&lt;/p>
&lt;h1 id="其他">其他&lt;/h1>
&lt;p>写了这么多，还是让你来开心一下吧。下面这个图是我在某国内互联网公司工作的时候和我老板的聊天记录。是的，就只有这些信息，每次看到这个聊天记录时，我都会有一种莫明的喜感。结合这篇文章的主题，也给你开心开心。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/52/82/52588aac81ed725e8acf1008867c4d82.png" alt="">&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/fc/e9/fcc761001867c60f526665e237f831e9.jpg" alt="">&lt;/p></description></item><item><title>极客专栏: 17丨故障处理最佳实践：应对故障</title><link>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E/17%E4%B8%A8%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E5%BA%94%E5%AF%B9%E6%95%85%E9%9A%9C/</link><pubDate>Fri, 27 May 2022 00:00:00 +0000</pubDate><guid>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E/17%E4%B8%A8%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E5%BA%94%E5%AF%B9%E6%95%85%E9%9A%9C/</guid><description>
&lt;p>或多或少我们都会经历线上的故障。在我的职业生涯中，就经历过很多的线上故障。老实说，线上故障是我们技术人员成长中必须要经历的事。从故障中我们可以吸取到很多教训，也能让我们学到很多书本上学不到的知识。坑踩多了，我们会变得越来越有经验，也就成为老司机了。&lt;/p>
&lt;p>不过，我看到很多公司处理线上故障的方式并不科学，而且存在很多问题，所以，今天这篇文章就来分享一些我的经验。这些经验主要来自亚马逊和阿里这两家互联网公司，以及我个人的经验总结。希望这套方法能够对你有帮助。&lt;/p>
&lt;h1 id="故障发生时">故障发生时&lt;/h1>
&lt;p>在故障发生时，最重要的是快速恢复故障。而快速恢复故障的前提是快速定位故障源。因为在很多分布式系统中，一旦发生故障就会出现&amp;quot;多米诺骨牌效应&amp;quot;。也就是说，系统会随着一个故障开始一点一点地波及到其它系统，而且这个过程可能会很快。一旦很多系统都在报警，要想快速定位到故障源就不是一件简单的事了。&lt;/p>
&lt;p>在亚马逊内部，每个开发团队至少都会有一位 oncall 的工程师。在 oncall 的时候，工程师要专心处理线上故障，轮换周期为每人一周。一旦发生比较大的故障，比如，S1 全部不可用，或 S2 某功能不可用，而且找不到替代方案，那么这个故障就会被提交到一个工单系统里。几乎所有相关团队 oncall 的工程师都会被叫到线上处理问题。&lt;/p>
&lt;p>工作流是这样的，工程师先线上签到，然后自查自己的服务，如果自己的服务没有问题，那么就可以在旁边待命（standby），以备在需要时进行配合。如果问题没有被及时解决，就会自动升级到高层，直到 SVP 级别。&lt;/p>
&lt;p>大家都知道，在亚马逊，不是按技能分工，而是按职责分工，也就是一个团队不是按前端、后端、运维等来分工，而是按所负责的 Service 来分工。&lt;/p>
&lt;p>所以，亚马逊的开发人员都是前端、后端、测试、运维全部都要干的。而亚马逊内部有很多的服务，一旦出现问题，为了避免一个工单在各个团队流转，需要所有团队上线处理，这样是最快的。&lt;/p>
&lt;p>如果我们的系统架构是分布式服务化的，那么一个用户的请求可能会经过很多的服务，开发和运维起来是非常麻烦的。此时，跨团队跨部门的开发和运维就变得非常重要了。&lt;/p>
&lt;p>就我的经历而言，在故障发生时，亚马逊的处理过程是比较有效和快速的，尤其是能够快速地定位故障源。对于被影响的其他团队也可以做一定的处理，比如做降级处理，这样可以控制故障的范围不被扩散。&lt;/p>
&lt;p>故障源团队通常会有以下几种手段来恢复系统。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>重启和限流&lt;/strong>。重启和限流主要解决的是可用性的问题，不是功能性的问题。重启还好说，但是限流这个事就需要相关的流控中间件了。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>回滚操作&lt;/strong>。回滚操作一般来说是解决新代码的 bug，把代码回滚到之前的版本是快速的方式。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>降级操作&lt;/strong>。并不是所有的代码变更都是能够回滚的，如果无法回滚，就需要降级功能了。也就是说，需要挂一个停止服务的故障公告，主要是不要把事态扩大。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>紧急更新&lt;/strong>。紧急更新是常用的手段，这个需要强大的自动化系统，尤其是自动化测试和自动化发布系统。假如你要紧急更新 1000 多台服务器，没有一个强大的自动化发布系统是很难做到的。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>也就是说，出现故障时，&lt;strong>最重要的不是 debug 故障，而是尽可能地减少故障的影响范围，并尽可能快地修复问题&lt;/strong>。&lt;/p>
&lt;p>国内的很多公司，都是由专职的运维团队来处理线上问题的。然而，运维团队通常只能处理一些基础设施方面的问题，或是非功能性的问题。对于一些功能性的问题，运维团队是完全没有能力处理的，只能通过相应的联系人，把相关的开发人员叫到线上来看。&lt;/p>
&lt;p>而可能这个开发人员看到的是别的系统有问题，又会叫上其它团队的人来。所以，一级一级地传递下去，会浪费很多时间。&lt;/p>
&lt;h1 id="故障前的准备工作">故障前的准备工作&lt;/h1>
&lt;p>为了能够在面临故障时做得有条不紊，我们需要做一些前期的准备工作。这些准备工作做得越细，故障处理起来也就越有条理。我们知道，故障来临时，一切都会变得混乱。此时，对于需要处理故障的我们来说，事可以乱，但人不能乱。如果人跟着事一起乱，那就是真正的混乱了。&lt;/p>
&lt;p>所以，我们需要做一些故障前的准备工作。在这里，我给出一些我的经验。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>以用户功能为索引的服务和资源的全视图&lt;/strong>。首先，我们需要一个系统来记录前端用户操作界面和后端服务，以及服务使用到的硬件资源之间的关联关系。这个系统有点像 CMDB（配置管理数据库），但是比 CMDB 要大得多，是以用户端的功能来做索引的。然后，把后端的服务、服务的调用关系，以及服务使用到的资源都关联起来做成一个视图。&lt;/p>
&lt;p>这个视图最好是由相应的自动化监控系统生成。有了这个资源图后，我们就可以很容易地找到处理故障的路径了。&lt;strong>这就好像一张地图，如果没有地图，我们只能像个无头苍蝇一样乱试了&lt;/strong>。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>为地图中的各个服务制定关键指标，以及一套运维流程和工具，包括应急方案&lt;/strong>。以用户功能为索引，为每个用户功能的服务都制定一个服务故障的检测、处理和恢复手册，以及相关的检测、查错或是恢复的运维工具。对于基础层和一些通用的中间件，也需要有相应的最佳实践的方法。&lt;/p>
&lt;p>比如 Redis，怎样检查其是否存在问题，怎样查看其健康和运行状态？哪些是关键指标，面对常见的故障应该怎么应对，服务不可用的服务方案是什么，服务需要回滚了应该怎么操作，等等。&lt;strong>这就好像一个导航仪，能够告诉你怎么做。而没有导航仪，就没有章法，会导致混乱&lt;/strong>。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>设定故障的等级&lt;/strong>。还要设定不同故障等级的处理方式。比如，亚马逊一般将故障分为 4 级：1 级是全站不可用；2 级是某功能不可用，且无替代方案；3 级是某功能不可用，但有替代方案；4 级是非功能性故障，或是用户不关心的故障。阿里内的分类更多样一些，有时会根据影响多少用户来定故障等级。&lt;/p>
&lt;p>制定故障等级，主要是为了确定该故障要牵扯进多大规模的人员来处理。故障级别越高，牵扯进来的人就越多，参与进来的管理层级别也就越高。就像亚马逊的全员上线 oncall 一样。&lt;strong>这就好像是我们社会中常用的&amp;quot;红色警报&amp;quot;、&amp;ldquo;橙色警报&amp;rdquo;、&amp;ldquo;黄色警报&amp;quot;之类的，会触发不同的处理流程&lt;/strong>。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>故障演练&lt;/strong> 。故障是需要演练的。因为故障并不会时常发生，但我们又需要不断提升处理故障的能力，所以需要经常演练。一些大公司，如 Netflix，会有一个叫 Chaos Monkey 的东西，随机地在生产线上乱来。Facebook 也会有一些故障演习，比如，随机关掉线上的一些服务器。总之，要提升故障处理水平，最好的方式就是实践。见得多了，处理得多了，才能驾轻就熟。&lt;strong>故障演练是一个非常好的实践&lt;/strong>。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>灰度发布系统&lt;/strong>。要减少线上故障的影响范围，通过灰度发布系统来发布是一个很不错的方式。毕竟，我们在测试环境中很难模拟出线上环境的所有情况，所以，在生产线上进行灰度发布或是 A/B 测试是一件很好的事。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>在亚马逊，发布系统中有一个叫 Weblab 的系统，就是用来做灰度发布的。另外，亚马逊全球会有多个站点。一般来说，会先发中国区。如果中国区没什么问题了，就发日本区，然后发欧洲区，最后是美国区。而如果没有很多站点的话，那么你就需要一个流量分配系统来做这个事了。&lt;/p>
&lt;p>好了。今天就分享这么多。我觉得，只要能做好上面的几点，你处理起故障来就一定会比较游刃有余了。&lt;/p>
&lt;p>在这篇文章的末尾，我想发个邀请给你。请你来聊聊，你所经历过的线上故障，以及有哪些比较好的故障处理方法。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/fc/e9/fcc761001867c60f526665e237f831e9.jpg" alt="">&lt;/p></description></item><item><title>极客专栏: 18丨故障处理最佳实践：故障改进</title><link>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E/18%E4%B8%A8%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E6%95%85%E9%9A%9C%E6%94%B9%E8%BF%9B/</link><pubDate>Fri, 27 May 2022 00:00:00 +0000</pubDate><guid>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E/18%E4%B8%A8%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E6%95%85%E9%9A%9C%E6%94%B9%E8%BF%9B/</guid><description>
&lt;p>在上篇文章中，我跟你分享了在故障发生时，我们该怎样做，以及在故障前该做些什么准备。只要做到我提到的那几点，你基本上就能游刃有余地处理好故障了。然而，在故障排除后，如何做故障复盘及整改优化则更为重要。在这篇文章中，我就跟你聊聊这几个方面的内容。&lt;/p>
&lt;h1 id="故障复盘过程">故障复盘过程&lt;/h1>
&lt;p>对于故障，复盘是一件非常重要的事情，因为我们的成长基本上就是从故障中总结各种经验教训，从而可以获得最大的提升。在亚马逊和阿里，面对故障的复盘有不一样的流程，虽然在内容上差不多，但细节上有很多不同。&lt;/p>
&lt;p>亚马逊内部面对 S1 和 S2 的故障复盘，需要那个团队的经理写一个叫 COE（Correction of Errors）的文档。这个 COE 文档，基本上包括以下几方面的内容。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>故障处理的整个过程&lt;/strong>。就像一个 log 一样，需要详细地记录几点几分干了什么事，把故障从发生到解决的所有细节过程都记录下来。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>故障原因分析&lt;/strong>。需要说明故障的原因和分析报告。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Ask 5 Whys&lt;/strong>。需要反思并反问至少 5 个为什么，并为这些&amp;quot;为什么&amp;quot;找到答案。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>故障后续整改计划&lt;/strong>。需要针对上述的&amp;quot;Ask 5 Whys&amp;quot;说明后续如何举一反三地从根本上解决所有的问题。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>然后，这个文档要提交到管理层，向公司的 VP 级的负责人进行汇报，并由他们来审查。&lt;/p>
&lt;p>阿里的故障复盘会会把所有的相关人员都叫到现场进行复盘。我比较喜欢这样的方式，而不是亚马逊的由经理来操作这个事的方式。虽然阿里的故障复盘会会开很长时间，但是把大家叫在一起复盘的确是一个很好的方式。一方面信息是透明的，另一方面，也是对大家的一次教育。&lt;/p>
&lt;p>阿里的故障处理内容和亚马逊的很相似，只是没有&amp;quot;Ask 5 Whys&amp;quot;，但是加入了&amp;quot;故障等级&amp;quot;和&amp;quot;故障责任人&amp;quot;。对于比较大的故障，责任人基本上都是由 P9/M4 的人来承担。而且对于引发故障的直接工程师，阿里是会有相关的惩罚机制的，比如，全年无加薪无升职，或者罚款。&lt;/p>
&lt;p>&lt;strong>老实说，我对惩罚故障责任人的方式非常不认同。&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>
&lt;p>首先，惩罚故障责任人对于解决故障完全没有任何帮助。因为它们之间没有因果关系，既不是充分条件，也不是必要条件，更不是充要条件。这是逻辑上的错误。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>其次，做得越多，错得越多。如果不想出错，最好什么也不要做。所以，惩罚故障责任人只会让大家都很保守，也会让大家都学会保守，而且开始推诿，营造一种恐怖的气氛。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>说个小插曲。有一次和一个同学一起开发一个系统，我们两个人的代码在同一个代码库中，而且也会运行在同一个进程里。这个系统中有一个线程池模型，我想直接用了。结果因为这个线程池是那个同学写的，他死活不让我用，说是各用各的分开写，以免出了问题后，说不清楚，引起不必要的麻烦。最后，在一个代码库中实现了两个线程池模型，我也是很无语。&lt;/p>
&lt;p>另外，亚马逊和阿里的故障整改内容不太一样。亚马逊更多的是通过技术手段来解决问题，几乎没有增加更复杂的流程或是把现有的系统复杂化。&lt;/p>
&lt;p>阿里的故障整改中会有一些复杂化问题的整改项，比如，对于误操作的处理方式是，以后线上操作需要由两个人来完成，其中一个人操作，另一个人检查操作过程。或是对于什么样的流程需要有审批环节。再比如：不去把原有的系统改好，而是加入一个新的系统来看（kān，第一声）着原来的那个不好的系统。当然，也有一些整改措施是好的，比如，通过灰度发布系统来减少故障面积。&lt;/p>
&lt;h1 id="故障整改方法">故障整改方法&lt;/h1>
&lt;p>就故障整改来说，我比较喜欢亚马逊的那个 Ask 5 Whys 玩法，这个对后面的整改会有非常大的帮助。最近一次，在帮一家公司做一个慢 SQL 的故障复盘时，我一共问了近 9 个为什么。&lt;/p>
&lt;ol>
&lt;li>为什么从故障发生到系统报警花了 27 分钟？为什么只发邮件，没有短信？&lt;/li>
&lt;li>为什么花了 15 分钟，开发的同学才知道是慢 SQL 问题？&lt;/li>
&lt;li>为什么监控系统没有监测到 Nginx 499 错误，以及 Nginx 的 upstream_response_time 和 request_time？&lt;/li>
&lt;li>为什么在一开始按 DDoS 处理？&lt;/li>
&lt;li>为什么要重启数据库？&lt;/li>
&lt;li>为什么这个故障之前没有发生？因为以前没有上首页，最近上的。&lt;/li>
&lt;li>为什么上首页时没有做性能测试？&lt;/li>
&lt;li>为什么使用这个高危的 SQL 语句？&lt;/li>
&lt;li>上线过程中为什么没有 DBA 评审？&lt;/li>
&lt;/ol>
&lt;p>通过这 9 个为什么，我为这家公司整理出来很多不足的地方。提出这些问题的大致逻辑是这样的。&lt;/p>
&lt;p>第一，优化故障获知和故障定位的时间。&lt;/p>
&lt;ul>
&lt;li>从故障发生到我们知道的时间是否可以优化得更短？&lt;/li>
&lt;li>定位故障的时间是否可以更短？&lt;/li>
&lt;li>有哪些地方可以做到自动化？&lt;/li>
&lt;/ul>
&lt;p>第二，优化故障的处理方式。&lt;/p>
&lt;ul>
&lt;li>故障处理时的判断和章法是否科学，是否正确？&lt;/li>
&lt;li>故障处理时的信息是否全透明？&lt;/li>
&lt;li>故障处理时人员是否安排得当？&lt;/li>
&lt;/ul>
&lt;p>第三，优化开发过程中的问题。&lt;/p>
&lt;ul>
&lt;li>Code Review 和测试中的问题和优化点。&lt;/li>
&lt;li>软件架构和设计是否可以更好？&lt;/li>
&lt;li>对于技术欠债或是相关的隐患问题是否被记录下来，是否有风险计划？&lt;/li>
&lt;/ul>
&lt;p>第四，优化团队能力。&lt;/p>
&lt;ul>
&lt;li>如何提高团队的技术能力？&lt;/li>
&lt;li>如何让团队有严谨的工程意识？&lt;/li>
&lt;/ul>
&lt;p>具体采取什么样的整改方案会和这些为什么有很大关系。&lt;/p>
&lt;p>总之还是那句话，解决一个故障可以通过技术和管理两方面的方法。如果你喜欢技术，是个技术范，你就更多地用技术手段；如果你喜欢管理，那么你就会使用更多的管理手段。&lt;strong>我是一个技术人员，我更愿意使用技术手段。&lt;/strong>&lt;/p>
&lt;h1 id="根除问题的本质">根除问题的本质&lt;/h1>
&lt;p>最后，对于故障处理，我能感觉得到，&lt;strong>一个技术问题，后面隐藏的是工程能力问题，工程能力问题后面隐藏的是管理问题，管理问题后面隐藏的是一个公司文化的问题，公司文化的问题则隐藏着创始人的问题&amp;hellip;&amp;hellip;&lt;/strong>&lt;/p>
&lt;p>所以，这里给出三条我工作这 20 年总结出来的原则（Principle），供你参考。&lt;/p>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>举一反三解决当下的故障&lt;/strong>。为自己赢得更多的时间。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>简化复杂、不合理的技术架构、流程和组织&lt;/strong>。你不可能在一个复杂的环境下根本地解决问题。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>全面改善和优化整个系统，包括组织&lt;/strong>。解决问题的根本方法是改善和调整整体结构。而只有简单优雅的东西才有被改善和优化的可能。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>换句话说，我看到很多问题出了又出，换着花样地出，大多数情况下是因为这个公司的系统架构太过复杂和混乱，以至于你不可能在这样的环境下干干净净地解决所有的问题。&lt;/p>
&lt;p>所以，你要先做大扫除，简化掉现有的复杂和混乱。如果你要从根本上改善一个事，那么首先得把它简化了。这就是这么多年来我得到的认知。&lt;/p>
&lt;p>但是，很不幸，我们就是生活在这样一个复杂的世界，有太多的人喜欢把简单的问题复杂化。所以，要想做到简化，基本上来说是非常非常难的。（下面这个小视频很有意思，非常形象地说明了，想在一个烂摊子中解决问题，几乎是不可能的事儿。）&lt;/p>
&lt;br />
&lt;br />
&lt;p>路漫漫其修远兮&amp;hellip;&amp;hellip;&lt;/p>
&lt;p>在这篇文章的末尾，我想发个邀请给你。请你来聊聊，在处理好故障之后，你所在的企业会采取什么样的复盘方式。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/fc/e9/fcc761001867c60f526665e237f831e9.jpg" alt="">&lt;/p></description></item><item><title>极客专栏: 19丨答疑解惑：我们应该能够识别的表象和本质</title><link>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E/19%E4%B8%A8%E7%AD%94%E7%96%91%E8%A7%A3%E6%83%91%E6%88%91%E4%BB%AC%E5%BA%94%E8%AF%A5%E8%83%BD%E5%A4%9F%E8%AF%86%E5%88%AB%E7%9A%84%E8%A1%A8%E8%B1%A1%E5%92%8C%E6%9C%AC%E8%B4%A8/</link><pubDate>Fri, 27 May 2022 00:00:00 +0000</pubDate><guid>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E/19%E4%B8%A8%E7%AD%94%E7%96%91%E8%A7%A3%E6%83%91%E6%88%91%E4%BB%AC%E5%BA%94%E8%AF%A5%E8%83%BD%E5%A4%9F%E8%AF%86%E5%88%AB%E7%9A%84%E8%A1%A8%E8%B1%A1%E5%92%8C%E6%9C%AC%E8%B4%A8/</guid><description>
&lt;p>前两天，我以前在亚马逊（Amazon）团队的一个小伙伴从西雅图打来电话，和我主要聊了一下他最近的一些想法和动向。他在最近几个月面试了很多美国的本土公司，从大公司到创业公司都有，比如 Facebook、Snapchat、Oracle、微软、谷歌、Netflix、Uber 等。他今年 30 岁出头，到美国那边也有 3 年多时间了，所以想要多一些经历，到不同的公司看一下。&lt;/p>
&lt;p>我觉得他这个想法挺好的。于是我们聊了一些对这些公司的看法，进而聊到他想要什么，感兴趣什么，想要经历什么，以及擅长什么，未来如何发展等话题&amp;hellip;&amp;hellip;在两个多小时交谈的过程中，我们谈论到了一些关于他个人发展以及技术上的东西。他听我的建议后，说很有价值。于是，我想既然有价值，那么就把这些分享出来，供更多的人参考吧。&lt;/p>
&lt;p>首先，我觉得在美国做技术真的比国内幸福好多，有那么多很不错的不同类别的公司可供选择。这与国内相比，选择空间实在是太大了，真是幸福。所以，在如此纷乱和多样化的地方，真是需要确定自己的发展方向和目标。不然就会像这个小伙儿一样，当 offer 像雪片一样飞过来的时候，却有点不知所措了。&lt;/p>
&lt;p>我直接和他说，你现在不愁工作了，可以规划自己的职业生涯了，那么问题是你想走哪条路，对什么方向有兴趣，或是自己的长项是什么？结果，他说他也不知道，说就是想多看看多经历一些事情，也不知道自己最终会对什么事有兴趣，也不知道哪个方向更适合自己，可能再来个 5 年就能明确了。不过，他明确表示对前端技术不感兴趣。&lt;/p>
&lt;p>我对他的这些思考没有任何异议，因为我觉得他的能力没有问题，我无非就是想和他说说我的一些认识和看法，希望可以帮他开阔开阔思路。我基本上是给了他如下的这些看法和观点。&lt;/p>
&lt;h1 id="关于兴趣和投入">关于兴趣和投入&lt;/h1>
&lt;p>兴趣是学习的助燃剂。对一件事有兴趣是是否愿意对这件事投入更多时间或者资源的前提条件。因此，找到自己的兴趣点的确是非常关键的。不过，我们也能看到下面几点。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>一方面，兴趣是需要保持的&lt;/strong>。有的人有的事就是三分钟的兴趣。刚开始兴趣十足，然而时间一长，兴趣因为各种原因不能保持，就会很快地&amp;quot;移情别恋&amp;quot;了。所以，不能持久的兴趣，或是一时兴起的兴趣，都无法让人投入下去。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>另一方面，兴趣其实也是可以培养出来的&lt;/strong>。我高考时，对计算机软件毫无兴趣，反而对物理世界里的很多东西感兴趣，比如无线电、原子能，或是飞行器之类的。但阴差阳错，我最终考了个计算机软件专业，然后发现，自己越来越喜欢编程了，于是就到了今天。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>我发现，一个可以持久的兴趣，或是可以培养出来的兴趣，后面都有一个比较本质的东西，其实就是成就感，他是你坚持或者努力的最直接的正反馈。也就是说，&lt;strong>兴趣只是开始，而能让人不断投入时间和精力的则是正反馈，是成就感&lt;/strong>。&lt;/p>
&lt;p>带娃的父母可能对此比较好理解。比如，我家小孩 3 岁的时候，我买了一桶积木给她。她一开始只喜欢把积木胡乱堆放，没玩一会就对这种抽象的玩具失去了兴趣，去玩别的更形象的玩具去了。&lt;/p>
&lt;p>于是，我就搭了一个小城堡给她看，她看完后兴趣就来了，也想自己搭一个。但是，不一会儿，她就受挫了，因为没有掌握好物体在构建时的平衡和支点的方法，所以搭出来的东西会倒。&lt;/p>
&lt;p>我能看到，有时积木倒了之后，她会从中有一点点的学习总结，但更多的时候总结不出来。于是，我就上前帮她做调整，她很快就学会了，并且每一次都比上一次搭得更好&amp;hellip;&amp;hellip;如此反复，最终，我家小孩玩积木上花的时间大大超过了其它的玩具，直到她无法从中得到成就感。&lt;/p>
&lt;p>很显然，我把孩子从&amp;quot;天性喜欢破坏的兴趣点&amp;quot;上拉到了&amp;quot;喜欢创造的兴趣点&amp;quot;上。因为创造能带来更多的成就感，不是吗？&lt;/p>
&lt;p>所以，我对这个朋友说，你对一件事的兴趣只是一种表象，而内在更多的是你做这件事的成就感是否可以持续。&lt;strong>你需要找到让自己能够更有成就感的事情，兴趣总是可以培养的&lt;/strong>。&lt;/p>
&lt;h1 id="关于学习和工作">关于学习和工作&lt;/h1>
&lt;p>后面，我们又谈到了工作，他觉得只有找到与兴趣相匹配的工作才是能否学好一个技术的关键。对此，我给了他如下一些回应。&lt;/p>
&lt;p>我觉得，学好一项技术和是否找到与之相匹配的工作有关联，但它们之间并不是强关联的。但之所以，我们都觉得通过工作才让我们学习和成长得更快，主要有这些原因。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>工作能为我们带来相应的场景和实际的问题，而不是空泛的学习。带着问题去学习，带着场景去解决问题，的确是一种高效的学习方式。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>在工作当中，有同事和高手帮助。和他们的交互和讨论，可以让你更快地学习和成长。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>本质上来说，并不是只有找到了相应的工作我们才可以学好一项技术，而是，我们在通过解决实际问题，在和他人讨论，获得高手帮助的环境中，才能更快更有效率地学习和成长。&lt;/strong>&lt;/p>
&lt;p>有时候，在工作中你反而学不到东西，那是因为你找的这个工作能够提供的场景不够丰富，需要解决的实际问题太过简单，以及你的同事对你的帮助不大。这时，这个工作反而限制了你的学习和成长。&lt;/p>
&lt;p>所以，我给了这个小伙子两点建议。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>找工作不只是找用这个技术的工作，更是要找场景，找实际问题，找团队。这些才是本质。一项技术很多公司都在用，然而，只有进入到有更多的场景、有挑战性的问题、有靠谱团队的公司，才对学习和成长更有帮助。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>不要完全把自己的学习寄希望于找一份工作，才会学得好。我给他的建议是，在一些开源社区内，有助于学习的场景会更多，要解决的实际问题也更多，同时你能接触到的牛人也更多。特别是一些有大量公司和几万、几十万甚至上百万的开发人员在贡献代码的项目，我认为可以让人成长很快。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>我入行前十年并没有生活在一个开源软件爆发的年代，也没有生活在一个场景像今天这么丰富的年代，所以也走了很多弯路。不过，比较幸运的是，我还是在一些关键时期找到了靠谱的工作，为我带来了一般人看不到的实际问题，也为我提供了很不错的团队和实际场景。&lt;/p>
&lt;p>今天的年轻人有比我更好的环境和条件，应该能比我成长得更好、更快。当然，和我的成长一样，都需要小心地鉴别和甄选。&lt;/p>
&lt;p>&lt;strong>总之，找到学习的方法，提升自己对新事物学习的能力，才是学习和成长的关键。&lt;/strong>&lt;/p>
&lt;h1 id="关于技术和价值">关于技术和价值&lt;/h1>
&lt;p>后面，我们又聊到了什么样的技术会是属于未来的技术，以及应该把时间花在什么样的技术上。我问了他这样一个问题：&amp;ldquo;你觉得，让人登月探索宇宙的技术价值大，还是造高铁的技术价值大？或者是科学种田的技术价值大？&amp;hellip;&amp;hellip;&amp;rdquo;&lt;/p>
&lt;p>是的，对于这个问题，从不同的角度上看，就会得到不同的结论。似乎，我们无法说明白哪项技术创造的价值更大，因为完全没法比较。&lt;/p>
&lt;p>于是我又说了一个例子，在第一次工业革命的时候，也就是蒸汽机时代，除了蒸汽机之外还有其它一些技术含量更高的技术，比如化学、冶金、水泥、玻璃&amp;hellip;&amp;hellip;但是，这么一个不起眼的技术引发了人类社会的变革。也许，那个时候，在技术圈中，很多技术专家还鄙视蒸汽机的技术含量太低呢。&lt;/p>
&lt;p>我并不是想说高大上的技术无用，我想说的是，技术无贵贱，很多伟大的事就是通过一些不起眼的技术造就的。所以，我们应该关注的是：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>要用技术解决什么样的问题，场景非常重要；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>如何降低技术的学习成本，提高易用性，从而可以让技术更为普及。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>另外，我又说了一个例子。假设，我们今天没有电，忽然，有人说他发明了电。我相信，这个世界上的很多人都会觉得&amp;quot;电&amp;quot;这个东西没什么用，而只有等到&amp;quot;电灯&amp;quot;的发明，人们才明白发明&amp;quot;电&amp;quot;是多么牛。&lt;/p>
&lt;p>所以，对于一些&amp;quot;基础技术&amp;quot;来说，通常会在某段时间内会被人类社会低估。就像国内前几年低估&amp;quot;云计算&amp;quot;技术一样。基础技术就像是创新的引擎，其不断地成熟和完善会引发更上层的技术不断地衍生，越滚越大。&lt;/p>
&lt;p>而在一个基础技术被广泛应用的过程中，如何规模化也会成为一个关键。这就好像发电厂一样，没有发电厂，电力就无法做到规模化。记得汽车发明的时候，要组装一个汽车的时间成本、人力成本、物力成本都非常高，所以完全无法做到规模化，而通过模块化分工、自动化生产等技术手段才释放了产能，从而普及。&lt;/p>
&lt;p>所以，我个人觉得一项有价值的技术，并不在于这项技术是否有技术含量，而是在于：&lt;/p>
&lt;ul>
&lt;li>能否低成本高效率地解决实际问题；&lt;/li>
&lt;li>是不是众多产品的基础技术；&lt;/li>
&lt;li>是不是可以支持规模化的技术。&lt;/li>
&lt;/ul>
&lt;p>对于我们搞计算机软件的人来说，也可以找到相对应的技术点。比如：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>低成本高效率地解决实际问题的技术，一定是自动化的技术。软件天生就是用来完成重复劳动的，天生就是用来做自动化的。而未来的 AI 和 IoT 也是在拼命数字化和自动化还没有自动化的领域。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>基础技术总是枯燥和有价值的。数学、算法、网络、存储等基础技术吃得越透，就越容易服务上层的各种衍生技术或产品。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>支持规模化的技术也是很有价值的。在软件行业中，也就是 PaaS 的相关技术。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>当然，我的意思并不是别的技术都没有价值了。重申一下，&lt;strong>技术无贵贱。我只是想说，能规模化低成本高效率解决实际问题的技术及其基础技术，就算是很 low，也是很有价值的。&lt;/strong>&lt;/p>
&lt;h1 id="关于趋势和未来">关于趋势和未来&lt;/h1>
&lt;p>好像每次跟人聊天的时候都会扯到这个事上来。老实说，真的没人可以预测未来会是什么样的。不过，似乎有些规律也是有迹可寻的。&lt;/p>
&lt;p>我一直认为，&lt;strong>这个世界的技术趋势和未来其实是被人控制的&lt;/strong>。就是被那些有权有势有钱的公司或国家来控制的。当然，他们控制的不是长期的未来，但短期的未来（3-5 年）一定是他们控制着的。&lt;/p>
&lt;p>也就是说，技术的未来要去哪，主要是看这个世界的投入会到哪。基本上就是这个世界上的有钱有势的人把财富投到哪个领域，也就是这个世界的大公司或大国们的规划。&lt;/p>
&lt;p>一旦他们把大量的金钱投到某个领域，这个领域就会得到发展，那么发展之后，这个领域也就成为未来了。只要是有一堆公司在往一个方向上不间断地投资或者花钱，这个方向不想成为未来似乎都不可能。&lt;/p>
&lt;p>听上去多少有点儿令人沮丧，但我个人觉得世界就是如此简单粗暴运作着的。&lt;/p>
&lt;p>所以，对于我们这些在这个世界里排不上号的人来说，只能默默地跟随着这些大公司所引领的趋势和未来。对一些缺钱缺人的创业公司，唯一能够做的，也许只是两条路，一是用更为低的成本来提供和大公司相应的技术，另一条路是在细分垂直市场上做得比大公司更专更精。等着自己有一天长大后，也能加入第一梯队从而&amp;quot;引领&amp;quot;未来。&lt;/p>
&lt;h1 id="小结">小结&lt;/h1>
&lt;p>今天的这个主题，我其实观察和酝酿了很久，正好结合跟这位小伙伴的交流，总结整理出来。在我们的生活和工作中，总是会有很多人混淆一些看似有联系，实则关系不大的词和概念，分辨不清事物的表象和本质。&lt;/p>
&lt;p>比如文中提到的兴趣和投入。表面上，兴趣是决定一件事儿能否做持久的关键因素。而反观我们自己和他人的经历不难发现，兴趣扮演的角色通常是敲门砖，它引发我们关注到某事某物。而真正能让我们坚持下去的，实际上是做一件事之后从中收获到的正反馈，也就是成就感。&lt;/p>
&lt;p>同样，人们也经常搞错学习和工作之间的关系。多数人都会认为，在工作中学习和成长速度更快。而仔细观察下来，你会发现，工作不过是提供了一个能够解决实际问题，能跟人讨论，有高手帮助的环境。&lt;/p>
&lt;p>所以说，让我们成长的并不是工作本身，而是有利于学习的环境。也就是说，如果我们想学习，除了可以选择有助于学习的工作机会，开源社区提供的环境同样有助于我们的学习和提高，那里高手更多，实际问题不少。&lt;/p>
&lt;p>还有，技术和价值。人们通常认为技术含量高的技术其价值会更高，而历史上无数的事实却告诉我们，能规模化、低成本、高效率地解决实际问题的技术及其基础技术，才发挥出了更为深远的影响，甚至其价值更是颠覆性的，难以估量。&lt;/p>
&lt;p>趋势和未来也是被误解得很深的一对&amp;quot;孪生兄弟&amp;quot;。虽然大家通常会认为有什么样的技术趋势，必然带来什么样的未来。殊不知，所谓的趋势和未来，其实都是可以由人为控制的，特别是哪些有钱有势的人和公司。也就是，社会的资金和资源流向什么领域，这个领域势必会得到成长和发展，会逐渐形成趋势，进而成为未来。我们遵循这样的规律，就能很容易地判断出未来的，最起码是近几年的，技术流向了。&lt;/p>
&lt;p>再如，加班和产出，努力和成功，速度和效率&amp;hellip;&amp;hellip;加班等于高产出吗？显然不是。很努力就一定会成功吗？当然不是。速度快就是效率高吗？更加不是。可以枚举的还有很多，如干得多就等于干得好吗？等等。&lt;/p>
&lt;p>读完这篇文章，你是不是不再混淆一些现象和本质，是不是能将一些事情看得更加清晰了呢？欢迎来跟我交流。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/fc/e9/fcc761001867c60f526665e237f831e9.jpg" alt="">&lt;/p></description></item><item><title>极客专栏: 20丨Git协同工作流，你该怎么选？</title><link>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E/20%E4%B8%A8git%E5%8D%8F%E5%90%8C%E5%B7%A5%E4%BD%9C%E6%B5%81%E4%BD%A0%E8%AF%A5%E6%80%8E%E4%B9%88%E9%80%89/</link><pubDate>Fri, 27 May 2022 00:00:00 +0000</pubDate><guid>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E/20%E4%B8%A8git%E5%8D%8F%E5%90%8C%E5%B7%A5%E4%BD%9C%E6%B5%81%E4%BD%A0%E8%AF%A5%E6%80%8E%E4%B9%88%E9%80%89/</guid><description>
&lt;p>与传统的代码版本管理工具相比，Git 有很多的优势，因而越来越成为程序员喜欢的版本管理工具。我觉得，Git 这个代码版本管理工具最大的优势有以下几个。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Git 是一个分布式的版本管理工具，而且可以是单机版的，所以，你在没有网络的时候同样可以提交（commit）代码。对于我们来说，这意味着在出差途中或是没有网络的环境中依然可以工作写代码。&lt;/p>
&lt;p>这是不是听起来有点不对？一方面，以后你再也不能以&amp;quot;没有网络&amp;quot;作为不能工作的借口了。另一方面，没有网络意味着没有 Google 和 StackOverflow，光有个本地的 Git 我也一样不能写代码啊&amp;hellip;&amp;hellip;（哈哈。好吧，这已经超出了 Git 这个技术的范畴了，这里就不讨论了）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Git 从一个分支向另一个分支合并代码的时候，会把要合并的分支上的所有提交一个一个应用到被合并的分支上，合并后也能看得到整个代码的变更记录。而其他的版本管理工具则不能。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Git 切换分支的时候通常很快。不像其他版本管理器，每个分支一份拷贝。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Git 有很多非常有用的命令，让你可以很方便地工作。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>比如我很喜欢的&lt;code>git stash&lt;/code>命令，可以把当前没有完成的事先暂存一下，然后去忙别的事。&lt;code>git cherry-pick&lt;/code>命令可以让你有选择地合并提交。&lt;code>git add -p&lt;/code>可以让你挑选改动提交，&lt;code>git grep $regexp $(git rev-list --all)&lt;/code>可以用来在所有的提交中找代码。因为都是本地操作，所以你会觉得速度飞快。&lt;/p>
&lt;p>除此之外，由 Git 衍生出来的 GitHub/GitLab 可以帮你很好地管理编程工作，比如 wiki、fork、pull request、issue&amp;hellip;&amp;hellip;集成了与编程相关的工作，让人觉得这不是一个冷冰冰的工具，而真正和我们的日常工作发生了很好的交互。&lt;/p>
&lt;p>GitHub/GitLab 这样工具的出现，让我们的工作可以呈现在一个工作平台上，并以此来规范整个团队的工作，这才正是 Git 这个版本管理工具成功的原因。&lt;/p>
&lt;p>今天，我们不讲 Git 是怎么用的，因为互联网上有太多的文章和书了。而且，如果你还不会用 Git 的话，那么我觉得你已经严重落后于这个时代了。在这篇文章中，我想讲一下 Git 的协同工作流，因为我看到很多团队在使用 Git 时，并没有用好。&lt;/p>
&lt;p>注意，因为 Git 是一个分布式的代码管理器，所以，是分布式就会出现数据不一致的情况，因此，我们需要一个协同工作流来让工作变得高效，同时可以有效地让代码具有更好的一致性。&lt;/p>
&lt;p>说到一致性，就是每个人手里的开发代码，还有测试和生产线上的代码，要有一个比较好的一致性的管理和协同方法。这就是 Git 协同工作流需要解决的问题。&lt;/p>
&lt;p>目前来说，你可能以为我想说的是 GitFlow 工作流。恭喜你猜对了。但是，我想说的是，GitFlow 工作流太过复杂，我并不觉得 GitFlow 工作流是一个好的工作流。如果你的团队在用这种工作流开发软件，我相信你的感觉一定是糟透了。&lt;/p>
&lt;p>所以，我的这篇文章会对比一些比较主流的协同工作流，然后，再抨击一下 GitFlow 工作流。&lt;/p>
&lt;h1 id="中心式协同工作流">中心式协同工作流&lt;/h1>
&lt;p>首先，我们先说明一下，Git 是可以像 SVN 这样的中心工作流一样工作的。我相信很多程序员都是在采用这样的工作方式。&lt;/p>
&lt;p>这个过程一般是下面这个样子的。&lt;/p>
&lt;ol>
&lt;li>从服务器上做&lt;code>git pull origin master&lt;/code>把代码同步下来。&lt;/li>
&lt;li>改完后，&lt;code>git commit&lt;/code>到本地仓库中。&lt;/li>
&lt;li>然后&lt;code>git push origin master&lt;/code>到远程仓库中，这样其他同学就可以得到你的代码了。&lt;/li>
&lt;/ol>
&lt;p>如果在第 3 步发现 push 失败，因为别人已经提交了，那么你需要先把服务器上的代码给 pull 下来，为了避免有 merge 动作，你可以使用 &lt;code>git pull --rebase&lt;/code> 。这样就可以把服务器上的提交直接合并到你的代码中，对此，Git 的操作是这样的。&lt;/p>
&lt;ol>
&lt;li>先把你本地提交的代码放到一边。&lt;/li>
&lt;li>然后把服务器上的改动下载下来。&lt;/li>
&lt;li>然后在本地把你之前的改动再重新一个一个地做 commit，直到全部成功。&lt;/li>
&lt;/ol>
&lt;p>如下图所示。Git 会把 Origin/Master 的远程分支下载下来（紫色的），然后把本地的 Master 分支上的改动一个一个地提交上去（蓝色的）。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/59/6b/5974a4026acca1000cd21772c4c52a6b.png" alt="">&lt;/p>
&lt;p>如果有冲突，那么你要先解决冲突，然后做 &lt;code>git rebase --continue&lt;/code> 。如下图所示，git 在做 pull &amp;ndash;rebase 时，会一个一个地应用（apply）本地提交的代码，如果有冲突就会停下来，等你解决冲突。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/75/e7/75b3fea18fa91b837f4f3ae6db6ab6e7.png" alt="">&lt;/p>
&lt;h1 id="功能分支协同工作流">功能分支协同工作流&lt;/h1>
&lt;p>上面的那种方式有一个问题，就是大家都在一个主干上开发程序，对于小团队或是小项目你可以这么干，但是对比较大的项目或是人比较多的团队，这么干就会有很多问题。&lt;/p>
&lt;p>最大的问题就是代码可能干扰太严重。尤其是，我们想安安静静地开发一个功能时，我们想把各个功能的代码变动隔离开来，同时各个功能又会有多个开发人员在开发。&lt;/p>
&lt;p>这时，我们不想让各个功能的开发人员都在 Master 分支上共享他们的代码。我们想要的协同方式是这样的：同时开发一个功能的开发人员可以分享各自的代码，但是不会把代码分享给开发其他功能的开发人员，直到整个功能开发完毕后，才会分享给其他的开发人员（也就是进入主干分支）。&lt;/p>
&lt;p>因此，我们引入&amp;quot;功能分支&amp;quot;。这个协同工作流的开发过程如下。&lt;/p>
&lt;ol>
&lt;li>首先使用 &lt;code>git checkout -b new-feature&lt;/code> 创建 &amp;ldquo;new-feature&amp;quot;分支。&lt;/li>
&lt;li>然后共同开发这个功能的程序员就在这个分支上工作，进行 add、commit 等操作。&lt;/li>
&lt;li>然后通过 &lt;code>git push -u origin new-feature&lt;/code> 把分支代码 push 到服务器上。&lt;/li>
&lt;li>其他程序员可以通过&lt;code>git pull --rebase&lt;/code>来拿到最新的这个分支的代码。&lt;/li>
&lt;li>最后通过 Pull Request 的方式做完 Code Review 后合并到 Master 分支上。&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/45/ec/455b921b2d178c87fe66714910301aec.png" alt="">&lt;/p>
&lt;p>就像上面这个图显示的一样，紫色的分支就是功能分支，合并后就会像上面这个样子。&lt;/p>
&lt;p>我们可以看到，其实，这种开发也是以服务器为中心的开发，还不是 Git 分布式开发，它只不过是用分支来完成代码改动的隔离。&lt;/p>
&lt;p>另外，我想提醒一下，为什么会叫&amp;quot;功能分支&amp;rdquo;，而不是&amp;quot;项目分支&amp;quot;？因为 Git 的最佳实践希望大家在开发的过程中，快速提交，快速合并，快速完成。这样可以少很多冲突的事，所以叫功能分支。&lt;/p>
&lt;p>传统的项目分支开得太久，时间越长就越合不回去。这种玩法其实就是让我们把一个大项目切分成若干个小项目来执行（最好是一个小功能一个项目）。这样才是互联网式的快速迭代式的开发流程。&lt;/p>
&lt;h1 id="gitflow-协同工作流">GitFlow 协同工作流&lt;/h1>
&lt;p>在真实的生产过程中，前面的协同工作流还是不能满足工作的要求。这主要因为我们的生产过程是比较复杂的，软件生产中会有各式各样的问题，并要面对不同的环境。我们要在不停地开发新代码的同时，维护线上的代码，于是，就有了下面这些需求。&lt;/p>
&lt;ol>
&lt;li>
&lt;p>希望有一个分支是非常干净的，上面是可以发布的代码，上面的改动永远都是可以发布到生产环境中的。这个分支上不能有中间开发过程中不可以上生产线的代码提交。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>希望当代码达到可以上线的状态时，也就是在 alpha/beta release 时，在测试和交付的过程中，依然可以开发下一个版本的代码。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>最后，对于已经发布的代码，也会有一些 Bug-fix 的改动，不会将正在开发的代码提交到生产线上去。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>你看，面对这些需求，前面的那些协同方式就都不行了。因为我们不仅是要在整个团队中共享代码，我们要的更是管理好不同环境下的代码不互相干扰。说得技术一点儿就是，要管理好代码与环境的一致性。&lt;/p>
&lt;p>为了解决这些问题，GitFlow 协同工作流就出来了。&lt;/p>
&lt;p>GitFlow 协同工作流是由 Vincent Driessen 于 2010 年在 A successful Git branching model 这篇文章介绍给世人的。&lt;/p>
&lt;p>这个协同工作流的核心思想如下图所示。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/9c/ca/9cf4c9bc17bf11aa07d47f61d2137fca.png" alt="">&lt;/p>
&lt;p>整个代码库中一共有五种分支。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Master 分支。也就是主干分支，用作发布环境，上面的每一次提交都是可以发布的。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Feature 分支。也就是功能分支，用于开发功能，其对应的是开发环境。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Developer 分支。是开发分支，一旦功能开发完成，就向 Developer 分支合并，合并完成后，删除功能分支。这个分支对应的是集成测试环境。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Release 分支。当 Developer 分支测试达到可以发布状态时，开出一个 Release 分支来，然后做发布前的准备工作。这个分支对应的是预发环境。之所以需要这个 Release 分支，是我们的开发可以继续向前，不会因为要发布而被 block 住而不能提交。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>一旦 Release 分支上的代码达到可以上线的状态，那么需要把 Release 分支向 Master 分支和 Developer 分支同时合并，以保证代码的一致性。然后再把 Release 分支删除掉。&lt;/p>
&lt;ul>
&lt;li>Hotfix 分支。是用于处理生产线上代码的 Bug-fix，每个线上代码的 Bug-fix 都需要开一个 Hotfix 分支，完成后，向 Developer 分支和 Master 分支上合并。合并完成后，删除 Hotfix 分支。&lt;/li>
&lt;/ul>
&lt;p>这就是整个 GitFlow 协同工作流的工作过程。我们可以看到：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>我们需要长期维护 Master 和 Developer 两个分支。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>这其中的方式还是有一定复杂度的，尤其是 Release 和 Hotfix 分支需要同时向两个分支作合并。所以，如果没有一个好的工具来支撑的话，这会因为我们可能会忘了做一些操作而导致代码不一致。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>GitFlow 协同虽然工作流比较重。但是它几乎可以应对所有公司的各种开发流程，包括瀑布模型，或是快速迭代模型。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h1 id="githubgitlab-协同工作流">GitHub/GitLab 协同工作流&lt;/h1>
&lt;h2 id="gitflow-的问题">GitFlow 的问题&lt;/h2>
&lt;p>对于 GitFlow 来说，虽然可以解决我们的问题，但是也有很多问题。在 GitFlow 流行了一段时间后，圈内出现了一些不同的声音。参看下面两篇吐槽文章。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="http://endoflineblog.com/gitflow-considered-harmful">GitFlow considered harmful&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://luci.criosweb.ro/a-real-life-git-workflow-why-git-flow-does-not-work-for-us/">Why git flow does not work for us&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>其中有个问题就是因为分支太多，所以会出现 git log 混乱的局面。具体来说，主要是 git-flow 使用&lt;code>git merge --no-ff&lt;/code>来合并分支，在 git-flow 这样多个分支的环境下会让你的分支管理的 log 变得很难看。如下所示，左边是使用&amp;ndash;no-ff 参数在多个分支下的问题。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/13/b8/13a78e9d493ba2737c3d6b8431be47b8.png" alt="">&lt;/p>
&lt;p>所谓&lt;code>--no-ff&lt;/code>参数的意思是&lt;code>------no fast forward&lt;/code>的意思。也就是说，合并的方法不要把这个分支的提交以前置合并的方式，而是留下一个 merge 的提交。这是把双刃剑，我们希望我们的&lt;code>--no-ff&lt;/code>能像右边那样，而不是像左边那样。&lt;/p>
&lt;p>对此的建议是：只有 feature 合并到 developer 分支时，使用&amp;ndash;no-ff 参数，其他的合并都不使用&lt;code>--no-ff&lt;/code>参数来做合并。&lt;/p>
&lt;p>另外，还有一个问题就是，在开发得足够快的时候，你会觉得同时维护 Master 和 Developer 两个分支是一件很无聊的事，因为这两个分支在大多数情况下都是一样的。包括 Release 分支，你会觉得创建的这些分支太无聊。&lt;/p>
&lt;p>而你的整个开发过程也会因为这么复杂的管理变得非常复杂。尤其当你想回滚某些人的提交时，你就会发现这事似乎有点儿不好干了。而且在工作过程中，你会来来回回地切换工作的分支，有时候一不小心没有切换，就提交到了不正确的分支上，你还要回滚和重新提交，等等。&lt;/p>
&lt;p>GitLab 一开始是 GitFlow 的坚定支持者，后来因为这些吐槽，以及 Hacker News 和 Reddit 上大量的讨论，GitLab 也开始不玩了。他们写了&lt;a href="https://about.gitlab.com/2014/09/29/gitlab-flow/">一篇 blog&lt;/a>来创造了一个新的 Workflow&amp;mdash;&amp;mdash;GitLab Flow，这个 GitLab Flow 是基于 GitHub Flow 来做的（参看：&lt;a href="http://scottchacon.com/2011/08/31/github-flow.html">GitHub Flow&lt;/a> ）。&lt;/p>
&lt;h2 id="github-flow">GitHub Flow&lt;/h2>
&lt;p>所谓 GitHub Flow，其实也叫 Forking flow，也就是 GitHub 上的那个开发方式。&lt;/p>
&lt;ol>
&lt;li>
&lt;p>每个开发人员都把&amp;quot;官方库&amp;quot;的代码 fork 到自己的代码仓库中。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>然后，开发人员在自己的代码仓库中做开发，想干啥干啥。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>因此，开发人员的代码库中，需要配两个远程仓库，一个是自己的库，一个是官方库（用户的库用于提交代码改动，官方库用于同步代码）。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>然后在本地建&amp;quot;功能分支&amp;quot;，在这个分支上做代码开发。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>这个功能分支被 push 到开发人员自己的代码仓库中。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>然后，向&amp;quot;官方库&amp;quot;发起 pull request，并做 Code Review。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>一旦通过，就向官方库进行合并。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>这就是 GitHub 的工作流程。&lt;/p>
&lt;p>如果你有&amp;quot;官方库&amp;quot;的权限，那么就可以直接在&amp;quot;官方库&amp;quot;中建功能分支开发，然后提交 pull request。通过 Code Review 后，合并进 Master 分支，而 Master 一旦有代码被合并就可以马上 release。&lt;/p>
&lt;p>这是一种非常 Geek 的玩法。这需要一个自动化的 CI/CD 工具做辅助。是的，CI/CD 应该是开发中的标配了。&lt;/p>
&lt;h2 id="gitlab-flow">GitLab Flow&lt;/h2>
&lt;p>然而，GitHub Flow 这种玩法依然会有好多问题，因为其虽然变得很简单，但是没有把我们的代码和我们的运行环境给联系在一起。所以，GitLab 提出了几个优化点。&lt;/p>
&lt;p>其中一个是引入环境分支，如下图所示，其包含了预发布（Pre-Production）和生产（Production）分支。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/c9/84/c9cf817612cc9d474cd253d26344e184.png" alt="">&lt;/p>
&lt;p>而有些时候，我们还会有不同版本的发布，所以，还需要有各种 release 的分支。如下图所示。Master 分支是一个 roadmap 分支，然后，一旦稳定了就建稳定版的分支，如 2.3.stable 分支和 2.4.stable 分支，其中可以 cherry-pick master 分支上的一些改动过去。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/ed/96/ed94b250461ca2bf6d7faa2d0aaa1a96.png" alt="">&lt;/p>
&lt;p>这样也就解决了两个问题：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>环境和代码分支对应的问题；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>版本和代码分支对应的问题。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>老实说，对于互联网公司来说，环境和代码分支对应这个事，只要有个比较好的 CI/CD 生产线，这种环境分支应该也是没有必要的。而对于版本和代码分支的问题，我觉得这应该是有意义的，但是，最好不要维护太多的版本，版本应该是短暂的，等新的版本发布时，老的版本就应该删除掉了。&lt;/p>
&lt;h1 id="协同工作流的本质">协同工作流的本质&lt;/h1>
&lt;p>对于上面这些各式各样的工作流的比较和思考，虽然，我个人非常喜欢 GitHub Flow，在必要的时候使用上 GitLab 中的版本或环境分支。不过，我们现实生活中，还是有一些开发工作不是以功能为主，而是以项目为主的。也就是说，项目的改动量可能比较大，时间和周期可能也比较长。&lt;/p>
&lt;p>我在想，是否有一种工作流，可以面对我们现实工作中的各种情况。但是，我想这个世界太复杂了，应该不存在一种一招鲜吃遍天的放之四海皆准的银弹方案。所以，我们还要根据自己的实际情况来挑选适合我们的协同工作的方式。&lt;/p>
&lt;p>而代码的协同工作流属于 SCM（Software Configuration Management）的范畴，要挑选好适合自己的方式，我们需要知道软件工程配置管理的本质。&lt;/p>
&lt;p>根据这么多年来我在各个公司的经历，有互联网的，有金融的，有项目的，有快速迭代的等，我认为团队协同工作的本质不外乎这么几个事儿。&lt;/p>
&lt;ol>
&lt;li>不同的团队能够尽可能地并行开发。&lt;/li>
&lt;li>不同软件版本和代码的一致性。&lt;/li>
&lt;li>不同环境和代码的一致性。&lt;/li>
&lt;li>代码总是会在稳定和不稳定间交替。我们希望生产线上的代码总是能对应到稳定的代码上来。&lt;/li>
&lt;/ol>
&lt;p>基本上述的四个事儿，上述的工作流大都是在以建立不同的分支，来做到开发并行、代码和环境版本一致，以及稳定的代码。&lt;/p>
&lt;p>要选择适合自己的协同工作流，我们就不得不谈一下软件开发的工作模式。&lt;/p>
&lt;p>首先，我们知道软件开发的趋势一定是下面这个样子的。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>以微服务或是 SOA 为架构的方式&lt;/strong>。一个大型软件会被拆分成若干个服务，那么，我们的代码应该也会跟着服务拆解成若干个代码仓库。这样一来，我们的每个代码仓库都会变小，于是我们的协同工作流程就会变简单。&lt;/p>
&lt;p>对于每个服务的代码仓库，我们的开发和迭代速度也会变得很快，开发团队也会跟服务一样被拆分成多个小团队。这样一来， GitFlow 这种协同工作流程就非常重了，而 GitHub 这种方式或是功能分支这种方式会更适合我们的开发。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>以 DevOps 为主的开发流程&lt;/strong>。DevOps 关注于 CI/CD，需要我们有自动化的集成测试和持续部署的工具。这样一来，我们的代码发布速度就会大大加快，每一次提交都能很快地被完整地集成测试，并很快地发布到生产线上。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>于是，我们就可以使用更简单的协同工作流程，不需要维护多个版本，也不需要关注不同的运行环境，只需要一套代码，就可以了。GitHub Flow 或是功能分支这种方式也更适应这种开发。&lt;/p>
&lt;p>你看，如果我们将软件开发升级并简化到 SOA 服务化以及 DevOps 上来，那么协同工作流就会变得非常简单。所以，&lt;strong>协同工作流的本质，并不是怎么玩好代码仓库的分支策略，而是玩好我们的软件架构和软件开发流程&lt;/strong>。&lt;/p>
&lt;p>当然，服务化和 DevOps 是每个开发团队需要去努力的目标，但就算是这样，也有某些情况我们需要用重的协同工作的模式。比如，整个公司在做一个大的升级项目，这其中会对代码做一个大的调整（很有可能是一次重大的重构）。&lt;/p>
&lt;p>这个时候，可能还有一些并行的开发需要做，如一些小功能的优化，一些线上 Bug 的处理，我们可能还需要在生产线上做新旧两个版本的 A/B 测试。在这样的情况下，我们可能会或多或少地使用 GitFlow 协同工作流。&lt;/p>
&lt;p>但是，这样的方式不会是常态，是特殊时期，我们不可能隔三差五地对系统做架构或是对代码做大规模的重构。所以，在大多数情况下，我们还是应该选择一个比较轻量的协同工作流，而在特殊时期特例特办。&lt;/p>
&lt;p>最后，让我用一句话来结束这篇文章&amp;mdash;&amp;mdash;&lt;strong>与其花时间在 Git 协同工作流上，还不如把时间花在调整软件架构和自动化软件生产和运维流程上来，这才是真正简化协同工作流程的根本&lt;/strong>。&lt;/p>
&lt;p>(这篇文章中有大量的 Git 命令，很难用音频体现出来，所以没有录制音频，还望谅解。)&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/fc/e9/fcc761001867c60f526665e237f831e9.jpg" alt="">&lt;/p></description></item><item><title>极客专栏: 21丨分布式系统架构的冰与火</title><link>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E/21%E4%B8%A8%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E7%9A%84%E5%86%B0%E4%B8%8E%E7%81%AB/</link><pubDate>Fri, 27 May 2022 00:00:00 +0000</pubDate><guid>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E/21%E4%B8%A8%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E7%9A%84%E5%86%B0%E4%B8%8E%E7%81%AB/</guid><description>
&lt;p>最近几年，我们一直在谈论各式各样的架构，如高并发架构、异地多活架构、容器化架构、微服务架构、高可用架构、弹性化架构等。还有和这些架构相关的管理型的技术方法，如 DevOps、应用监控、自动化运维、SOA 服务治理、去 IOE 等。面对这么多纷乱的技术，我看到很多团队或是公司都是一个一个地去做这些技术，非常辛苦，也非常累。这样的做法就像我们在撑开一张网里面一个一个的网眼。&lt;/p>
&lt;p>其实，只要我们能够找到这张网的&amp;quot;纲&amp;quot;，我们就能比较方便和自如地打开整张网了。那么，这张&amp;quot;分布式大网&amp;quot;的总线&amp;mdash;&amp;mdash;&amp;ldquo;纲&amp;quot;在哪里呢？我希望通过这一系列文章可以让你找到这个&amp;quot;纲&amp;rdquo;，从而能让你更好更有效率地做好架构和工程。&lt;/p>
&lt;h1 id="分布式系统架构的冰与火">分布式系统架构的冰与火&lt;/h1>
&lt;p>首先，我们需要阐述一下为什么需要分布式系统，而不是传统的单体架构。也许这对你来说已经不是什么问题了，但是请允许我在这里重新说明一下。使用分布式系统主要有两方面原因。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>增大系统容量&lt;/strong>。我们的业务量越来越大，而要能应对越来越大的业务量，一台机器的性能已经无法满足了，我们需要多台机器才能应对大规模的应用场景。所以，我们需要垂直或是水平拆分业务系统，让其变成一个分布式的架构。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>加强系统可用&lt;/strong>。我们的业务越来越关键，需要提高整个系统架构的可用性，这就意味着架构中不能存在单点故障。这样，整个系统不会因为一台机器出故障而导致整体不可用。所以，需要通过分布式架构来冗余系统以消除单点故障，从而提高系统的可用性。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>当然，分布式系统还有一些优势，比如：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>因为模块化，所以系统模块重用度更高；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>因为软件服务模块被拆分，开发和发布速度可以并行而变得更快；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>系统扩展性更高；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>团队协作流程也会得到改善；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&amp;hellip;&amp;hellip;&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>不过，这个世界上不存在完美的技术方案，采用任何技术方案都是&amp;quot;按下葫芦浮起瓢&amp;quot;，都是有得有失，都是一种 trade-off。也就是说，分布式系统在解决上述问题的同时，也给我们带来了其他的问题。因此，我们需要清楚地知道分布式系统所带来的问题。&lt;/p>
&lt;p>下面这个表格比较了单体应用和分布式架构的优缺点。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/c1/55/c1ac4e9db638a1e2f4bcfc66bd0c8255.png" alt="">&lt;/p>
&lt;p>从上面的表格我们可以看到，分布式系统虽然有一些优势，但也存在一些问题。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>架构设计变得复杂（尤其是其中的分布式事务）。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>部署单个服务会比较快，但是如果一次部署需要多个服务，流程会变得复杂。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>系统的吞吐量会变大，但是响应时间会变长。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>运维复杂度会因为服务变多而变得很复杂。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>架构复杂导致学习曲线变大。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>测试和查错的复杂度增大。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>技术多元化，这会带来维护和运维的复杂度。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>管理分布式系统中的服务和调度变得困难和复杂。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>也就是说，分布式系统架构的难点在于系统设计，以及管理和运维。所以，分布式架构解决了&amp;quot;单点&amp;quot;和&amp;quot;性能容量&amp;quot;的问题，但却新增了一堆问题。而对于这些新增的问题，还会衍生出更多的子问题，这就需要我们不断地用各式各样的技术和手段来解决这些问题。&lt;/p>
&lt;p>这就出现了我前面所说的那些架构方式，以及各种相关的管理型的技术方法。这个世界就是这样变得复杂起来的。&lt;/p>
&lt;h1 id="分布式系统的发展">分布式系统的发展&lt;/h1>
&lt;p>从 20 世纪 70 年代的模块化编程，80 年代的面向事件设计，90 年代的基于接口 / 构件设计，这个世界很自然地演化出了 SOA&amp;mdash;&amp;mdash;基于服务的架构。SOA 架构是构造分布式计算应用程序的方法。它将应用程序功能作为服务发送给最终用户或者其他服务。它采用开放标准与软件资源进行交互，并采用标准的表示方式。&lt;/p>
&lt;p>开发、维护和使用 SOA 要遵循以下几条基本原则。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>可重用，粒度合适，模块化，可组合，构件化以及有互操作性。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>符合开放标准（通用的或行业的）。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>服务的识别和分类，提供和发布，监控和跟踪。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>但 IBM 搞出来的 SOA 非常重，所以对 SOA 的裁剪和优化从来没有停止过。比如，之前的 SOAP、WSDL 和 XML 这样的东西基本上已经被抛弃了，而改成了 RESTful 和 JSON 这样的方式。而 ESB（Enterprise Service Bus，企业服务总线）这样非常重要的东西也被简化成了 Pub/Sub 的消息服务&amp;hellip;&amp;hellip;&lt;/p>
&lt;p>不过，SOA 的思想一直延续着。所以，我们现在也不说 SOA 了，而是说分布式服务架构了。&lt;/p>
&lt;p>下面是一个 SOA 架构的演化图。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/54/42/542f449c5aeffd20a6d66b32c1736f42.png" alt="">&lt;/p>
&lt;p>我们可以看到，面向服务的架构有以下三个阶段。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>20 世纪 90 年代前，是单体架构，软件模块高度耦合。当然，这张图同样也说明了有的 SOA 架构其实和单体架构没什么两样，因为都是高度耦合在一起的。就像图中的齿轮一样，当你调用一个服务时，这个服务会调用另一个服务，然后又调用另外的服务&amp;hellip;&amp;hellip;于是整个系统就转起来了。但是这本质是比较耦合的做法。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>而 2000 年左右出现了比较松耦合的 SOA 架构，这个架构需要一个标准的协议或是中间件来联动其它相关联的服务（如 ESB）。这样一来，服务间并不直接依赖，而是通过中间件的标准协议或是通讯框架相互依赖。这其实就是 IoC（控制反转）和 DIP（依赖倒置原则）设计思想在架构中的实践。它们都依赖于一个标准的协议或是一个标准统一的交互方式，而不是直接调用。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>而 2010 年后，出现了微服务架构，这个架构更为松耦合。每一个微服务都能独立完整地运行（所谓的自包含），后端单体的数据库也被微服务这样的架构分散到不同的服务中。而它和传统 SOA 的差别在于，服务间的整合需要一个服务编排或是服务整合的引擎。就好像交响乐中需要有一个指挥来把所有乐器编排和组织在一起。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>一般来说，这个编排和组织引擎可以是工作流引擎，也可以是网关。当然，还需要辅助于像容器化调度这样的技术方式，如 Kubernetes。在 Martin Fowler 的 &lt;a href="https://martinfowler.com/articles/microservices.html">Microservices 这篇文章&lt;/a>中有详细描述。&lt;/p>
&lt;p>微服务的出现使得开发速度变得更快，部署快，隔离性高，系统的扩展度也很好，但是在集成测试、运维和服务管理等方面就比较麻烦了。所以，需要一套比较好的微服务 PaaS 平台。就像 Spring Cloud 一样需要提供各种配置服务、服务发现、智能路由、控制总线&amp;hellip;&amp;hellip;还有像 Kubernetes 提供的各式各样的部署和调度方式。&lt;/p>
&lt;p>没有这些 PaaS 层的支撑，微服务也是很难被管理和运维的。好在今天的世界已经有具备了这些方面的基础设施，所以，采用微服务架构，我认为只是一个时间问题了。&lt;/p>
&lt;h1 id="小结">小结&lt;/h1>
&lt;p>好了，今天的内容就到这里。相信通过今天的学习，你应该已经对为什么需要分布式系统，而不是传统的单体架构，有了清晰的认识。并且对分布式系统的发展历程了然于心。下一篇文章，我将结合亚马逊的分布式架构实践，来谈谈分布式系统架构的技术难点及应对方案。&lt;/p>
&lt;p>下面我列出了《分布式系统架构的本质》系列文章的目录，希望你能在这个列表里找到自己感兴趣的内容。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/1411">分布式系统架构的冰与火&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/1505">从亚马逊的实践，谈分布式系统的难点&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/1512">分布式系统的技术栈&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/1513">分布式系统关键技术：全栈监控&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/1604">分布式系统关键技术：服务调度&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/1609">分布式系统关键技术：流量与数据调度&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/1610">洞悉 PaaS 平台的本质&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/2080">推荐阅读：分布式系统架构经典资料&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/2421">推荐阅读：分布式数据调度相关论文&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>在文章的最后，很想听听大家在进行分布式系统开发，把一个单体应用拆解成服务化或是微服务中遇到的问题和难点是什么？踩过什么样的坑？你是如何应对的？&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/9e/cd/9e00f2d01bc172e791e6e39b9de2a2cd.jpg" alt="">&lt;/p></description></item><item><title>极客专栏: 22丨从亚马逊的实践，谈分布式系统的难点</title><link>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E/22%E4%B8%A8%E4%BB%8E%E4%BA%9A%E9%A9%AC%E9%80%8A%E7%9A%84%E5%AE%9E%E8%B7%B5%E8%B0%88%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%9A%84%E9%9A%BE%E7%82%B9/</link><pubDate>Fri, 27 May 2022 00:00:00 +0000</pubDate><guid>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E/22%E4%B8%A8%E4%BB%8E%E4%BA%9A%E9%A9%AC%E9%80%8A%E7%9A%84%E5%AE%9E%E8%B7%B5%E8%B0%88%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%9A%84%E9%9A%BE%E7%82%B9/</guid><description>
&lt;p>从目前已经公开的资料来看，分布式服务化架构思想实践最早的公司应该是亚马逊。因为早在 2002 年的时候，亚马逊 CEO 杰夫·贝索斯（Jeff Bezos）就向全公司颁布了下面的这几条架构规定（来自《&lt;a href="https://coolshell.cn/articles/5701.html">Steve Yegge 对 Google 平台吐槽&lt;/a>》一文）。&lt;/p>
&lt;ol>
&lt;li>
&lt;p>所有团队的程序模块都要通过 Service Interface 方式将其数据与功能开放出来。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>团队间程序模块的信息通信，都要通过这些接口。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>除此之外没有其它的通信方式。其他形式一概不允许：不能直接链结别的程序（把其他团队的程序当做动态链接库来链接），不能直接读取其他团队的数据库，不能使用共享内存模式，不能使用别人模块的后门，等等。唯一允许的通信方式是调用 Service Interface。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>任何技术都可以使用。比如：HTTP、CORBA、Pub/Sub、自定义的网络协议等。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>所有的 Service Interface，毫无例外，都必须从骨子里到表面上设计成能对外界开放的。也就是说，团队必须做好规划与设计，以便未来把接口开放给全世界的程序员，没有任何例外。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>不这样做的人会被炒鱿鱼。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>这应该就是 AWS（Amazon Web Service）出现的基因吧。当然，前面说过，采用分布式系统架构后会出现很多的问题。比如：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>一个线上故障的工单会在不同的服务和不同的团队中转过来转过去。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>每个团队都可能成为一个潜在的 DDoS 攻击者，除非每个服务都要做好配额和限流。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>监控和查错变得更为复杂。除非有非常强大的监控手段。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>服务发现和服务治理也变得非常复杂。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>为了克服这些问题，亚马逊这么多年的实践让其可以运维和管理极其复杂的分布式服务架构。我觉得主要有以下几点。&lt;/p>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>分布式服务的架构需要分布式的团队架构&lt;/strong>。在亚马逊，一个服务由一个小团队（Two Pizza Team 不超过 16 个人，两张 Pizza 可以喂饱的团队）负责，从前端到数据，从需求分析到上线运维。这是良性的分工策略&amp;mdash;&amp;mdash;按职责分工，而不是按技能分工。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>分布式服务查错不容易&lt;/strong>。一旦出现比较严重的故障，需要整体查错。出现一个 S2 的故障，就可以看到每个团队的人都会上线。在工单系统里能看到，在故障发生的一开始，大家都在签到并自查自己的系统。如果没问题，也要在线待命（standby），等问题解决。（我在《故障处理最佳实践：应对故障》一文中详细地讲过这个事）。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>没有专职的测试人员，也没有专职的运维人员，开发人员做所有的事情&lt;/strong>。开发人员做所有事情的好处是&amp;mdash;&amp;mdash;吃自己的狗粮（Eat Your Own Dog Food）。自己写的代码自己维护自己养，会让开发人员明白，写代码容易维护代码复杂。这样，开发人员在接需求、做设计、写代码、做工具时都会考虑到软件的长期维护性。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>运维优先，崇尚简化和自动化&lt;/strong>。为了能够运维如此复杂的系统，亚马逊内部在运维上下了非常大的功夫。现在人们所说的 DevOps 这个事，亚马逊在 10 多年前就做到了。亚马逊最为强大的就是运维，拼命地对系统进行简化和自动化，让亚马逊做到了可以轻松运维拥有上千万台虚机的 AWS 云平台。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>内部服务和外部服务一致&lt;/strong>。无论是从安全方面，还是接口设计方面，无论是从运维方面，还是故障处理的流程方面，亚马逊的内部系统都和外部系统一样对待。这样做的好处是，内部系统的服务随时都可以开放出来。而且，从第一天开始，服务提供方就有对外服务的能力。可以想象，以这样的标准运作的团队其能力会是什么样的。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>在进化的过程中，亚马逊遇到的问题很多，甚至还有很多几乎没有人会想到的非常生僻的东西，它都一一学习和总结了，而且都解决得很好。&lt;/p>
&lt;p>构建分布式系统非常难，这其中充满了各种各样的挑战，但亚马逊还是毫不犹豫地走了下去。这是因为亚马逊想做平台，不是&amp;quot;像淘宝这样的中介式流量平台&amp;quot;，而是那种&amp;quot;可以对外输出能力的平台&amp;quot;。&lt;/p>
&lt;p>亚马逊觉得自己没有像史蒂夫·乔布斯（Steve Jobs）这样的牛人，不可能做出像 iPhone 这样的爆款产品，而且用户天生就是众口难调，与其做一个大家都不满意的软件，还不如把一些基础能力对外输出，引入外部的力量来一起完成一个用户满意的产品。&lt;/p>
&lt;p>这其实就是在建立自己的生态圈。虽然在今天看来这个事已经不稀奇了，但是贝索斯早在十五年前就悟到了，实在是个天才。&lt;/p>
&lt;p>所以，分布式服务架构是需要从组织，到软件工程，再到技术上的一个大的改造，需要比较长的时间来磨合和改进，并不断地总结教训和成功经验。&lt;/p>
&lt;h1 id="分布式系统中需要注意的问题">分布式系统中需要注意的问题&lt;/h1>
&lt;p>我们再来看一下分布式系统在技术上需要注意的问题。&lt;/p>
&lt;h1 id="问题一异构系统的不标准问题">问题一：异构系统的不标准问题&lt;/h1>
&lt;p>这主要表现在：&lt;/p>
&lt;ul>
&lt;li>软件和应用不标准。&lt;/li>
&lt;li>通讯协议不标准。&lt;/li>
&lt;li>数据格式不标准。&lt;/li>
&lt;li>开发和运维的过程和方法不标准。&lt;/li>
&lt;/ul>
&lt;p>不同的软件，不同的语言会出现不同的兼容性和不同的开发、测试、运维标准。不同的标准会让我们用不同的方式来开发和运维，引起架构复杂度的提升。比如：有的软件修改配置要改它的.conf 文件，而有的则是调用管理 API 接口。&lt;/p>
&lt;p>在通讯方面，不同的软件用不同的协议，就算是相同的网络协议里也会出现不同的数据格式。还有，不同的团队因为使用不同的技术，也会有不同的开发和运维方式。这些不同的东西，会让我们的整个分布式系统架构变得异常复杂。所以，分布式系统架构需要有相应的规范。&lt;/p>
&lt;p>比如，我看到，很多服务的 API 出错不返回 HTTP 的错误状态码，而是返回个正常的状态码 200，然后在 HTTP Body 里的 JSON 字符串中写着个：error，bla bla error message。这简直就是一种反人类的做法。我实在不明白为什么会有众多这样的设计。这让监控怎么做啊？现在，你应该使用 Swagger 的规范了。&lt;/p>
&lt;p>再比如，我看到很多公司的软件配置管理里就是一个 key-value 的东西，这样的东西灵活到可以很容易地被滥用。不规范的配置命名，不规范的值，甚至在配置中直接嵌入前端展示内容&amp;hellip;&amp;hellip;&lt;/p>
&lt;p>一个好的配置管理，应该分成三层：底层和操作系统相关，中间层和中间件相关，最上面和业务应用相关。于是底层和中间层是不能让用户灵活修改的，而是只让用户选择。比如：操作系统的相关配置应该形成模板来让人选择，而不是让人乱配置的。只有配置系统形成了规范，我们才 hold 得住众多的系统。&lt;/p>
&lt;p>再比如：数据通讯协议。通常来说，作为一个协议，一定要有协议头和协议体。协议头定义了最基本的协议数据，而协议体才是真正的业务数据。对于协议头，我们需要非常规范地让每一个使用这个协议的团队都使用一套标准的方式来定义，这样我们才容易对请求进行监控、调度和管理。&lt;/p>
&lt;p>这样的规范还有很多，我在这就不一一列举了。&lt;/p>
&lt;h1 id="问题二系统架构中的服务依赖性问题">问题二：系统架构中的服务依赖性问题&lt;/h1>
&lt;p>对于传统的单体应用，一台机器挂了，整个软件就挂掉了。但是你千万不要以为在分布式的架构下不会发生这样的事。分布式架构下，服务是会有依赖的，一个服务依赖链上的某个服务挂掉了，可能会导致出现&amp;quot;多米诺骨牌&amp;quot;效应。&lt;/p>
&lt;p>所以，在分布式系统中，服务的依赖也会带来一些问题。&lt;/p>
&lt;ul>
&lt;li>如果非关键业务被关键业务所依赖，会导致非关键业务变成一个关键业务。&lt;/li>
&lt;li>服务依赖链中，出现&amp;quot;木桶短板效应&amp;quot;&amp;mdash;&amp;mdash;整个 SLA 由最差的那个服务所决定。&lt;/li>
&lt;/ul>
&lt;p>这是服务治理的内容了。服务治理不但需要我们定义出服务的关键程度，还需要我们定义或是描述出关键业务或服务调用的主要路径。没有这个事情，我们将无法运维或是管理整个系统。&lt;/p>
&lt;p>这里需要注意的是，很多分布式架构在应用层上做到了业务隔离，然而，在数据库结点上并没有。如果一个非关键业务把数据库拖死，那么会导致全站不可用。所以，数据库方面也需要做相应的隔离。也就是说，最好一个业务线用一套自己的数据库。这就是亚马逊服务器的实践&amp;mdash;&amp;mdash;系统间不能读取对方的数据库，只通过服务接口耦合。这也是微服务的要求。我们不但要拆分服务，还要为每个服务拆分相应的数据库。&lt;/p>
&lt;h1 id="问题三故障发生的概率更大">问题三：故障发生的概率更大&lt;/h1>
&lt;p>在分布式系统中，因为使用的机器和服务会非常多，所以，故障发生的频率会比传统的单体应用更大。只不过，单体应用的故障影响面很大，而分布式系统中，虽然故障的影响面可以被隔离，但是因为机器和服务多，出故障的频率也会多。另一方面，因为管理复杂，而且没人知道整个架构中有什么，所以非常容易犯错误。&lt;/p>
&lt;p>你会发现，对分布式系统架构的运维，简直就是一场噩梦。我们会慢慢地明白下面这些道理。&lt;/p>
&lt;ul>
&lt;li>出现故障不可怕，故障恢复时间过长才可怕。&lt;/li>
&lt;li>出现故障不可怕，故障影响面过大才可怕。&lt;/li>
&lt;/ul>
&lt;p>运维团队在分布式系统下会非常忙，忙到每时每刻都要处理大大小小的故障。我看到，很多大公司，都在自己的系统里拼命地添加各种监控指标，有的能够添加出几万个监控指标。我觉得这完全是在&amp;quot;使蛮力&amp;quot;。一方面，信息太多等于没有信息，另一方面，SLA 要求我们定义出&amp;quot;Key Metrics&amp;quot;，也就是所谓的关键指标。然而，他们却没有。这其实是一种思维上的懒惰。&lt;/p>
&lt;p>但是，上述的都是在&amp;quot;救火阶段&amp;quot;而不是&amp;quot;防火阶段&amp;quot;。所谓&amp;quot;防火胜于救火&amp;quot;，我们还要考虑如何防火，这需要我们在设计或运维系统时都要为这些故障考虑，即所谓 Design for Failure。在设计时就要考虑如何减轻故障。如果无法避免，也要使用自动化的方式恢复故障，减少故障影响面。&lt;/p>
&lt;p>因为当机器和服务数量越来越多时，你会发现，人类的缺陷就成为了瓶颈。这个缺陷就是人类无法对复杂的事情做到事无巨细的管理，只有机器自动化才能帮助人类。 也就是，人管代码，代码管机器，人不管机器！&lt;/p>
&lt;h1 id="问题四多层架构的运维复杂度更大">问题四：多层架构的运维复杂度更大&lt;/h1>
&lt;p>通常来说，我们可以把系统分成四层：基础层、平台层、应用层和接入层。&lt;/p>
&lt;ul>
&lt;li>基础层就是我们的机器、网络和存储设备等。&lt;/li>
&lt;li>平台层就是我们的中间件层，Tomcat、MySQL、Redis、Kafka 之类的软件。&lt;/li>
&lt;li>应用层就是我们的业务软件，比如，各种功能的服务。&lt;/li>
&lt;li>接入层就是接入用户请求的网关、负载均衡或是 CDN、DNS 这样的东西。&lt;/li>
&lt;/ul>
&lt;p>对于这四层，我们需要知道：&lt;/p>
&lt;ul>
&lt;li>任何一层的问题都会导致整体的问题；&lt;/li>
&lt;li>没有统一的视图和管理，导致运维被割裂开来，造成更大的复杂度。&lt;/li>
&lt;/ul>
&lt;p>很多公司都是按技能分工的，他们按照技能把技术团队分为产品开发、中间件开发、业务运维、系统运维等子团队。这样的分工导致的结果就是大家各管一摊，很多事情完全连不在一起。整个系统会像 &amp;ldquo;多米诺骨牌&amp;quot;一样，一个环节出现问题，就会倒下去一大片。因为没有一个统一的运维视图，不知道一个服务调用是如何经过每一个服务和资源，也就导致在出现故障时要花大量的时间在沟通和定位问题上。&lt;/p>
&lt;p>之前我在某云平台的一次经历就是这样的。从接入层到负载均衡，再到服务层，再到操作系统底层，设置的 KeepAlive 的参数完全不一致，导致用户发现，软件运行的行为和文档中定义的完全不一样。工程师查错的过程简直就是一场恶梦，以为找到了一个，结果还有一个，来来回回花了大量的时间才把所有 KeepAlive 的参数设置成一致的，浪费了太多的时间。&lt;/p>
&lt;p>&lt;strong>分工不是问题，问题是分工后的协作是否统一和规范&lt;/strong>。这点，你一定要重视。&lt;/p>
&lt;h1 id="小结">小结&lt;/h1>
&lt;p>好了，我们来总结一下今天分享的主要内容。首先，我以亚马逊为例，讲述了它是如何做分布式服务架构的，遇到了哪些问题，以及是如何解决的。&lt;/p>
&lt;p>我认为，亚马逊在分布式服务系统方面的这些实践和经验积累，是 AWS 出现的基因。随后分享了在分布式系统中需要注意的几个问题，同时给出了应对方案。我认为，构建分布式服务需要从组织，到软件工程，再到技术上的一次大的改造，需要比较长的时间来磨合和改进，并不断地总结教训和成功经验。下篇文章中，我们讲述分布式系统的技术栈。希望对你有帮助。&lt;/p>
&lt;p>也欢迎大家分享一下你在分布式架构中遇到的各种问题。&lt;/p>
&lt;p>下面我列出了**《分布式系统架构的本质》系列文章**的目录，希望你能在这个列表里找到自己感兴趣的内容。如果你在分布式系统架构方面，有其他想了解的话题和内容，欢迎留言给我。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/1411">分布式系统架构的冰与火&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/1505">从亚马逊的实践，谈分布式系统的难点&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/1512">分布式系统的技术栈&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/1513">分布式系统关键技术：全栈监控&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/1604">分布式系统关键技术：服务调度&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/1609">分布式系统关键技术：流量与数据调度&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/1610">洞悉 PaaS 平台的本质&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/2080">推荐阅读：分布式系统架构经典资料&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/2421">推荐阅读：分布式数据调度相关论文&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/fc/e9/fcc761001867c60f526665e237f831e9.jpg" alt="">&lt;/p></description></item><item><title>极客专栏: 23丨分布式系统的技术栈</title><link>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E/23%E4%B8%A8%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%8A%80%E6%9C%AF%E6%A0%88/</link><pubDate>Fri, 27 May 2022 00:00:00 +0000</pubDate><guid>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E/23%E4%B8%A8%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%8A%80%E6%9C%AF%E6%A0%88/</guid><description>
&lt;p>正如我们前面所说的，构建分布式系统的目的是增加系统容量，提高系统的可用性，转换成技术方面，也就是完成下面两件事。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>大流量处理&lt;/strong>。通过集群技术把大规模并发请求的负载分散到不同的机器上。&lt;/li>
&lt;li>&lt;strong>关键业务保护&lt;/strong>。提高后台服务的可用性，把故障隔离起来阻止多米诺骨牌效应（雪崩效应）。如果流量过大，需要对业务降级，以保护关键业务流转。&lt;/li>
&lt;/ul>
&lt;p>说白了就是干两件事。一是提高整体架构的吞吐量，服务更多的并发和流量，二是为了提高系统的稳定性，让系统的可用性更高。&lt;/p>
&lt;h1 id="提高架构的性能">提高架构的性能&lt;/h1>
&lt;p>咱们先来看看，提高系统性能的常用技术。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/a9/17/a9edeae125a80f381003d8d9d0056317.png" alt="">&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>缓存系统&lt;/strong>。加入缓存系统，可以有效地提高系统的访问能力。从前端的浏览器，到网络，再到后端的服务，底层的数据库、文件系统、硬盘和 CPU，全都有缓存，这是提高快速访问能力最有效的手段。对于分布式系统下的缓存系统，需要的是一个缓存集群。这其中需要一个 Proxy 来做缓存的分片和路由。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>负载均衡系统&lt;/strong>。负载均衡系统是水平扩展的关键技术，它可以使用多台机器来共同分担一部分流量请求。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>异步调用&lt;/strong>。异步系统主要通过消息队列来对请求做排队处理，这样可以把前端的请求的峰值给&amp;quot;削平&amp;quot;了，而后端通过自己能够处理的速度来处理请求。这样可以增加系统的吞吐量，但是实时性就差很多了。同时，还会引入消息丢失的问题，所以要对消息做持久化，这会造成&amp;quot;有状态&amp;quot;的结点，从而增加了服务调度的难度。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>数据分区和数据镜像&lt;/strong> 。&lt;strong>数据分区&lt;/strong> 是把数据按一定的方式分成多个区（比如通过地理位置），不同的数据区来分担不同区的流量。这需要一个数据路由的中间件，会导致跨库的 Join 和跨库的事务非常复杂。而&lt;strong>数据镜像&lt;/strong>是把一个数据库镜像成多份一样的数据，这样就不需要数据路由的中间件了。你可以在任意结点上进行读写，内部会自行同步数据。然而，数据镜像中最大的问题就是数据的一致性问题。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>对于一般公司来说，在初期，会使用读写分离的数据镜像方式，而后期会采用分库分表的方式。&lt;/p>
&lt;h1 id="提高架构的稳定性">提高架构的稳定性&lt;/h1>
&lt;p>接下来，咱们再来看看提高系统系统稳定性的一些常用技术。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/be/79/befd21e1b41a257c5028f8c1bc7fa279.png" alt="">&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>服务拆分&lt;/strong>。服务拆分主要有两个目的：一是为了隔离故障，二是为了重用服务模块。但服务拆分完之后，会引入服务调用间的依赖问题。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>服务冗余&lt;/strong>。服务冗余是为了去除单点故障，并可以支持服务的弹性伸缩，以及故障迁移。然而，对于一些有状态的服务来说，冗余这些有状态的服务带来了更高的复杂性。其中一个是弹性伸缩时，需要考虑数据的复制或是重新分片，迁移的时候还要迁移数据到其它机器上。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>限流降级&lt;/strong>。当系统实在扛不住压力时，只能通过限流或者功能降级的方式来停掉一部分服务，或是拒绝一部分用户，以确保整个架构不会挂掉。这些技术属于保护措施。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>高可用架构&lt;/strong>。通常来说高可用架构是从冗余架构的角度来保障可用性。比如，多租户隔离，灾备多活，或是数据可以在其中复制保持一致性的集群。总之，就是为了不出单点故障。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>高可用运维&lt;/strong>。高可用运维指的是 DevOps 中的 CI/CD（持续集成 / 持续部署）。一个良好的运维应该是一条很流畅的软件发布管线，其中做了足够的自动化测试，还可以做相应的灰度发布，以及对线上系统的自动化控制。这样，可以做到&amp;quot;计划内&amp;quot;或是&amp;quot;非计划内&amp;quot;的宕机事件的时长最短。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>上述这些技术非常有技术含量，而且需要投入大量的时间和精力。&lt;/p>
&lt;h1 id="分布式系统的关键技术">分布式系统的关键技术&lt;/h1>
&lt;p>而通过上面的分析，我们可以看到，引入分布式系统，会引入一堆技术问题，需要从以下几个方面来解决。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>服务治理&lt;/strong>。服务拆分、服务调用、服务发现、服务依赖、服务的关键度定义&amp;hellip;&amp;hellip;服务治理的最大意义是需要把服务间的依赖关系、服务调用链，以及关键的服务给梳理出来，并对这些服务进行性能和可用性方面的管理。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>架构软件管理&lt;/strong>。服务之间有依赖，而且有兼容性问题，所以，整体服务所形成的架构需要有架构版本管理、整体架构的生命周期管理，以及对服务的编排、聚合、事务处理等服务调度功能。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>DevOps&lt;/strong>。分布式系统可以更为快速地更新服务，但是对于服务的测试和部署都会是挑战。所以，还需要 DevOps 的全流程，其中包括环境构建、持续集成、持续部署等。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>自动化运维&lt;/strong>。有了 DevOps 后，我们就可以对服务进行自动伸缩、故障迁移、配置管理、状态管理等一系列的自动化运维技术了。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>资源调度管理&lt;/strong>。应用层的自动化运维需要基础层的调度支持，也就是云计算 IaaS 层的计算、存储、网络等资源调度、隔离和管理。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>整体架构监控&lt;/strong>。如果没有一个好的监控系统，那么自动化运维和资源调度管理只可能成为一个泡影，因为监控系统是你的眼睛。没有眼睛，没有数据，就无法进行高效的运维。所以说，监控是非常重要的部分。这里的监控需要对三层系统（应用层、中间件层、基础层）进行监控。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>流量控制&lt;/strong>。最后是我们的流量控制，负载均衡、服务路由、熔断、降级、限流等和流量相关的调度都会在这里，包括灰度发布之类的功能也在这里。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>此时，你会发现，要做好这么多的技术，或是要具备这么多的能力，简直就是一个门槛，是一个成本巨高无比的技术栈，看着就都头晕。要实现出来得投入多少人力、物力和时间啊。是的，这就是分布式系统中最大的坑。&lt;/p>
&lt;p>不过，我们应该庆幸自己生活在了一个非常不错的年代。今天有一个技术叫&amp;mdash;&amp;mdash;Docker，通过 Docker 以及其衍生出来的 Kubernetes 之类的软件或解决方案，大大地降低了做上面很多事情的门槛。Docker 把软件和其运行的环境打成一个包，然后比较轻量级地启动和运行。在运行过程中，因为软件变成了服务可能会改变现有的环境。但是没关系，当你重新启动一个 Docker 的时候，环境又会变成初始化状态。&lt;/p>
&lt;p>这样一来，我们就可以利用 Docker 的这个特性来把软件在不同的机器上进行部署、调度和管理。如果没有 Docker 或是 Kubernetes，那么你可以认为我们还活在&amp;quot;原始时代&amp;quot;。&lt;/p>
&lt;p>现在你知道为什么 Docker 这样的容器化虚拟化技术是未来了吧。因为分布式系统已经是完全不可逆转的技术趋势了。&lt;/p>
&lt;p>但是，上面还有很多的技术是 Docker 及其周边技术没有解决的，所以，依然还有很多事情要做。那么，如果是一个一个地去做这些技术的话，就像是我们在撑开一张网里面一个一个的网眼，本质上这是使蛮力的做法。我们希望可以找到系统的&amp;quot;纲&amp;quot;，一把就能张开整张网。那么，这个纲在哪里呢？&lt;/p>
&lt;h1 id="分布式系统的纲">分布式系统的&amp;quot;纲&amp;quot;&lt;/h1>
&lt;p>总结一下上面讲述的内容，你不难发现，分布式系统有五个关键技术，它们是：&lt;/p>
&lt;ul>
&lt;li>全栈系统监控；&lt;/li>
&lt;li>服务 / 资源调度；&lt;/li>
&lt;li>流量调度；&lt;/li>
&lt;li>状态 / 数据调度；&lt;/li>
&lt;li>开发和运维的自动化。&lt;/li>
&lt;/ul>
&lt;p>而最后一项&amp;mdash;&amp;mdash;开发和运维的自动化，是需要把前四项都做到了，才有可能实现的。所以，最为关键是下面这四项技术，即应用整体监控、资源和服务调度、状态和数据调度及流量调度，它们是构建分布式系统最最核心的东西。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/89/f2/8958a432f32dd742b6503b60f97cc3f2.png" alt="">&lt;/p>
&lt;p>后面的文章中，我会一项一项地解析这些关键技术。&lt;/p>
&lt;h1 id="小结">小结&lt;/h1>
&lt;p>回顾一下今天的要点内容。首先，我总结了分布式系统需要干的两件事：一是提高整体架构的吞吐量，服务更多的并发和流量，二是为了提高系统的稳定性，让系统的可用性更高。然后分别从这两个方面阐释，需要通过哪些技术来实现，并梳理出其中的技术难点及可能会带来的问题。最后，欢迎你分享一下你在解决系统的性能和可用性方面使用到的方法和技巧。&lt;/p>
&lt;p>虽然 Docker 及其衍生出来的 Kubernetes 等软件或解决方案，能极大地降低很多事儿的门槛。但它们没有解决的问题还有很多，需要掌握分布式系统的五大关键技术，从根本上解决问题。后面我将陆续撰写几篇文章一一阐述这几大关键技术，详见文末给出的《分布式系统架构的本质》系列文章的目录。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/1411">分布式系统架构的冰与火&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/1505">从亚马逊的实践，谈分布式系统的难点&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/1512">分布式系统的技术栈&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/1513">分布式系统关键技术：全栈监控&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/1604">分布式系统关键技术：服务调度&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/1609">分布式系统关键技术：流量与数据调度&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/1610">洞悉 PaaS 平台的本质&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/2080">推荐阅读：分布式系统架构经典资料&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/2421">推荐阅读：分布式数据调度相关论文&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/fc/e9/fcc761001867c60f526665e237f831e9.jpg" alt="">&lt;/p></description></item><item><title>极客专栏: 24丨分布式系统关键技术：全栈监控</title><link>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E/24%E4%B8%A8%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%85%B3%E9%94%AE%E6%8A%80%E6%9C%AF%E5%85%A8%E6%A0%88%E7%9B%91%E6%8E%A7/</link><pubDate>Fri, 27 May 2022 00:00:00 +0000</pubDate><guid>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E/24%E4%B8%A8%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%85%B3%E9%94%AE%E6%8A%80%E6%9C%AF%E5%85%A8%E6%A0%88%E7%9B%91%E6%8E%A7/</guid><description>
&lt;p>首先，我们需要一个全栈系统监控的东西。它就像是我们的眼睛，没有它，我们就不知道系统到底发生了什么，我们将无法管理或是运维整个分布式系统。所以，这个系统是非常非常关键的。&lt;/p>
&lt;p>而在分布式或 Cloud Native 的情况下，系统分成多层，服务各种关联，需要监控的东西特别多。没有一个好的监控系统，我们将无法进行自动化运维和资源调度。&lt;/p>
&lt;p>这个监控系统需要完成的功能为：&lt;/p>
&lt;ul>
&lt;li>全栈监控；&lt;/li>
&lt;li>关联分析；&lt;/li>
&lt;li>跨系统调用的串联；&lt;/li>
&lt;li>实时报警和自动处置；&lt;/li>
&lt;li>系统性能分析。&lt;/li>
&lt;/ul>
&lt;h1 id="多层体系的监控">多层体系的监控&lt;/h1>
&lt;p>所谓全栈监控，其实就是三层监控。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>基础层&lt;/strong>：监控主机和底层资源。比如：CPU、内存、网络吞吐、硬盘 I/O、硬盘使用等。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>中间层&lt;/strong>：就是中间件层的监控。比如：Nginx、Redis、ActiveMQ、Kafka、MySQL、Tomcat 等。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>应用层&lt;/strong>：监控应用层的使用。比如：HTTP 访问的吞吐量、响应时间、返回码，调用链路分析，性能瓶颈，还包括用户端的监控。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/cf/66/cf6fe8ee30a3ac3b693d1188b46e4e66.png" alt="">&lt;/p>
&lt;p>这还需要一些监控的标准化。&lt;/p>
&lt;ul>
&lt;li>日志数据结构化；&lt;/li>
&lt;li>监控数据格式标准化；&lt;/li>
&lt;li>统一的监控平台；&lt;/li>
&lt;li>统一的日志分析。&lt;/li>
&lt;/ul>
&lt;h1 id="什么才是好的监控系统">什么才是好的监控系统&lt;/h1>
&lt;p>这里还要多说一句，现在我们的很多监控系统都做得很不好，它们主要有两个很大的问题。&lt;/p>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>监控数据是隔离开来的&lt;/strong>。因为公司分工的问题，开发、应用运维、系统运维，各管各的，所以很多公司的监控系统之间都有一道墙，完全串不起来。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>监控的数据项太多&lt;/strong>。有些公司的运维团队把监控的数据项多做为一个亮点到处讲，比如监控指标达到 5 万多个。老实说，这太丢人了。因为信息太多等于没有信息，抓不住重点的监控才会做成这个样子，完全就是使蛮力的做法。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>一个好的监控系统应该有以下几个特征。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>关注于整体应用的 SLA&lt;/strong>。主要从为用户服务的 API 来监控整个系统。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>关联指标聚合&lt;/strong>。 把有关联的系统及其指标聚合展示。主要是三层系统数据：基础层、平台中间件层和应用层。其中，最重要的是把服务和相关的中间件以及主机关联在一起，服务有可能运行在 Docker 中，也有可能运行在微服务平台上的多个 JVM 中，也有可能运行在 Tomcat 中。总之，无论运行在哪里，我们都需要把服务的具体实例和主机关联在一起，否则，对于一个分布式系统来说，定位问题犹如大海捞针。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>快速故障定位&lt;/strong>。 对于现有的系统来说，故障总是会发生的，而且还会频繁发生。故障发生不可怕，可怕的是故障的恢复时间过长。所以，快速地定位故障就相当关键。快速定位问题需要对整个分布式系统做一个用户请求跟踪的 trace 监控，我们需要监控到所有的请求在分布式系统中的调用链，这个事最好是做成没有侵入性的。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>换句话说，一个好的监控系统主要是为以下两个场景所设计的。&lt;/p>
&lt;h2 id="体检">&amp;ldquo;体检&amp;rdquo;&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>容量管理&lt;/strong>。 提供一个全局的系统运行时数据的展示，可以让工程师团队知道是否需要增加机器或者其它资源。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>性能管理。可以通过查看大盘，找到系统瓶颈，并有针对性地优化系统和相应代码。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="急诊">&amp;ldquo;急诊&amp;rdquo;&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>定位问题&lt;/strong>。可以快速地暴露并找到问题的发生点，帮助技术人员诊断问题。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>性能分析&lt;/strong>。当出现非预期的流量提升时，可以快速地找到系统的瓶颈，并帮助开发人员深入代码。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>只有做到了上述的这些关键点才能是一个好的监控系统。&lt;/p>
&lt;h1 id="如何做出一个好的监控系统">如何做出一个好的监控系统&lt;/h1>
&lt;p>下面是我认为一个好的监控系统应该实现的功能。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>服务调用链跟踪&lt;/strong>。这个监控系统应该从对外的 API 开始，然后将后台的实际服务给关联起来，然后再进一步将这个服务的依赖服务关联起来，直到最后一个服务（如 MySQL 或 Redis），这样就可以把整个系统的服务全部都串连起来了。这个事情的最佳实践是 Google Dapper 系统，其对应于开源的实现是 Zipkin。对于 Java 类的服务，我们可以使用字节码技术进行字节码注入，做到代码无侵入式。&lt;/li>
&lt;/ul>
&lt;p>如下图所示（截图来自我做的一个 APM 的监控系统）。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/ab/81/ab79054e0a3cf2d8f1d696e3c367ab81.png" alt="">&lt;/p>
&lt;ul>
&lt;li>&lt;strong>服务调用时长分布&lt;/strong>。使用 Zipkin，可以看到一个服务调用链上的时间分布，这样有助于我们知道最耗时的服务是什么。下图是 Zipkin 的服务调用时间分布。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/5f/4c/5fd70b4194854fc8d55c48987cf3644c.png" alt="">&lt;/p>
&lt;ul>
&lt;li>&lt;strong>服务的 TOP N 视图&lt;/strong>。所谓 TOP N 视图就是一个系统请求的排名情况。一般来说，这个排名会有三种排名的方法：a）按调用量排名，b) 按请求最耗时排名，c）按热点排名（一个时间段内的请求次数的响应时间和）。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/f4/f1/f4f91d5a3ee95b478c47f62499b0dcf1.png" alt="">&lt;/p>
&lt;ul>
&lt;li>&lt;strong>数据库操作关联&lt;/strong>。对于 Java 应用，我们可以很方便地通过 JavaAgent 字节码注入技术拿到 JDBC 执行数据库操作的执行时间。对此，我们可以和相关的请求对应起来。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/29/f4/29587fed0823f6e8ae7a2d38eaf35af4.png" alt="">&lt;/p>
&lt;ul>
&lt;li>&lt;strong>服务资源跟踪&lt;/strong>。我们的服务可能运行在物理机上，也可能运行在虚拟机里，还可能运行在一个 Docker 的容器里，Docker 容器又运行在物理机或是虚拟机上。我们需要把服务运行的机器节点上的数据（如 CPU、MEM、I/O、DISK、NETWORK）关联起来。&lt;/li>
&lt;/ul>
&lt;p>这样一来，我们就可以知道服务和基础层资源的关系。如果是 Java 应用，我们还要和 JVM 里的东西进行关联，这样我们才能知道服务所运行的 JVM 中的情况（比如 GC 的情况）。&lt;/p>
&lt;p>有了这些数据上的关联，我们就可以达到如下的目标。&lt;/p>
&lt;ol>
&lt;li>
&lt;p>当一台机器挂掉是因为 CPU 或 I/O 过高的时候，我们马上可以知道其会影响到哪些对外服务的 API。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>当一个服务响应过慢的时候，我们马上能关联出来是否在做 Java GC，或是其所在的计算结点上是否有资源不足的情况，或是依赖的服务是否出现了问题。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>当发现一个 SQL 操作过慢的时候，我们能马上知道其会影响哪个对外服务的 API。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>当发现一个消息队列拥塞的时候，我们能马上知道其会影响哪些对外服务的 API。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>总之，我们就是想知道用户访问哪些请求会出现问题，这对于我们了解故障的影响面非常有帮助。&lt;/p>
&lt;p>一旦了解了这些信息，我们就可以做出调度。比如：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>一旦发现某个服务过慢是因为 CPU 使用过多，我们就可以做弹性伸缩。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>一旦发现某个服务过慢是因为 MySQL 出现了一个慢查询，我们就无法在应用层上做弹性伸缩，只能做流量限制，或是降级操作了。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>所以，一个分布式系统，或是一个自动化运维系统，或是一个 Cloud Native 的云化系统，最重要的事就是把监控系统做好。在把数据收集好的同时，更重要的是把数据关联好。这样，我们才可能很快地定位故障，进而才能进行自动化调度。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/6b/33/6b17dd779cfecd62e02924dc8618e833.png" alt="">&lt;/p>
&lt;p>上图只是简单地展示了一个分布式系统的服务调用链接上都在报错，其根本原因是数据库链接过多，服务不过来。另外一个原因是，Java 在做 Full GC 导致处理过慢。于是，消息队列出现消息堆积堵塞。这个图只是一个示例，其形象地体现了在分布式系统中监控数据关联的重要性。&lt;/p>
&lt;h1 id="小结">小结&lt;/h1>
&lt;p>回顾一下今天的要点内容。首先，我强调了全栈系统监控的重要性，它就像是我们的眼睛，没有它，我们根本就不知道系统到底发生了什么。随后，从基础层、中间层和应用层三个层面，讲述了全栈监控系统要监控哪些内容。然后，阐释了什么才是好的监控系统，以及如何做出好的监控。最后，欢迎你分享一下你在监控系统中的比较好的实践和方法。&lt;/p>
&lt;p>下一篇文章中，我将讲述分布式系统的另一关键技术：服务调度。&lt;/p>
&lt;p>下面我列出了《分布式系统架构的本质》系列文章的目录，方便你快速找到自己感兴趣的内容。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/1411">分布式系统架构的冰与火&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/1505">从亚马逊的实践，谈分布式系统的难点&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/1512">分布式系统的技术栈&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/1513">分布式系统关键技术：全栈监控&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/1604">分布式系统关键技术：服务调度&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/1609">分布式系统关键技术：流量与数据调度&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/1610">洞悉 PaaS 平台的本质&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/2080">推荐阅读：分布式系统架构经典资料&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/2421">推荐阅读：分布式数据调度相关论文&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/fc/e9/fcc761001867c60f526665e237f831e9.jpg" alt="">&lt;/p></description></item><item><title>极客专栏: 25丨分布式系统关键技术：服务调度</title><link>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E/25%E4%B8%A8%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%85%B3%E9%94%AE%E6%8A%80%E6%9C%AF%E6%9C%8D%E5%8A%A1%E8%B0%83%E5%BA%A6/</link><pubDate>Fri, 27 May 2022 00:00:00 +0000</pubDate><guid>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E/25%E4%B8%A8%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%85%B3%E9%94%AE%E6%8A%80%E6%9C%AF%E6%9C%8D%E5%8A%A1%E8%B0%83%E5%BA%A6/</guid><description>
&lt;p>服务治理，你应该听得很多了。但是我想说，你所听到的服务治理可能混合了流量调度等其它内容。我们这里会把服务治理和流量调度分开来讲。所以，今天这篇文章只涉及服务治理上的一些关键技术，主要有以下几点。&lt;/p>
&lt;ul>
&lt;li>服务关键程度&lt;/li>
&lt;li>服务依赖关系&lt;/li>
&lt;li>服务发现&lt;/li>
&lt;li>整个架构的版本管理&lt;/li>
&lt;li>服务应用生命周期全管理&lt;/li>
&lt;/ul>
&lt;h1 id="服务关键程度和服务的依赖关系">服务关键程度和服务的依赖关系&lt;/h1>
&lt;p>下面，我们先看看服务关键程度和服务的依赖关系。关于服务关键程度，主要是要我们梳理和定义服务的重要程度。这不是使用技术可以完成的，它需要细致地管理对业务的理解，才能定义出架构中各个服务的重要程度。&lt;/p>
&lt;p>然后，我们还要梳理出服务间的依赖关系，这点也非常重要。我们常说，&amp;ldquo;没有依赖，就没有伤害&amp;rdquo;。这句话的意思就是说，服务间的依赖是一件很易碎的事。依赖越多，依赖越复杂，我们的系统就越易碎。&lt;/p>
&lt;p>因为依赖关系就像&amp;quot;铁锁连环&amp;quot;一样，一个服务的问题很容易出现一条链上的问题。因此，传统的 SOA 希望通过 ESB 来解决服务间的依赖关系，这也是为什么微服务中希望服务间是没有依赖的，而让上层或是前端业务来整合这些个后台服务。&lt;/p>
&lt;p>但是要真正做到服务无依赖，我认为还是比较有困难的，总是会有一些公有服务会被依赖。我们只能是降低服务依赖的深度和广度，从而让管理更为简单和简洁。在这一点上，以 Spring Boot 为首的微服务开发框架就开了一个好头。&lt;/p>
&lt;p>&lt;strong>微服务是服务依赖最优解的上限，而服务依赖的下限是千万不要有依赖环&lt;/strong>。如果系统架构中有服务依赖环，那么表明你的架构设计是错误的。循环依赖有很多的副作用，最大的问题是这是一种极强的耦合，会导致服务部署相当复杂和难解，而且会导致无穷尽的递归故障和一些你意想不到的问题。&lt;/p>
&lt;p>解决服务依赖环的方案一般是，依赖倒置的设计模式。在分布式架构上，你可以使用一个第三方的服务来解决这个事。比如，通过订阅或发布消息到一个消息中间件，或是把其中的依赖关系抽到一个第三方的服务中，然后由这个第三方的服务来调用这些原本循环依赖的服务。&lt;/p>
&lt;p>服务的依赖关系是可以通过技术的手段来发现的，这其中，&lt;a href="https://zipkin.io/">Zipkin&lt;/a>是一个很不错的服务调用跟踪系统，它是通过 &lt;a href="https://research.google.com/pubs/pub36356.html">Google Dapper&lt;/a>这篇论文来实现的。这个工具可以帮你梳理服务的依赖关系，以及了解各个服务的性能。&lt;/p>
&lt;p>在梳理完服务的重要程度和服务依赖关系之后，我们就相当于知道了整个架构的全局。就好像我们得到了一张城市地图，在这张地图上可以看到城市的关键设施，以及城市的主干道。再加上相关的监控，我们就可以看到城市各条道路上的工作和拥堵情况。这对于我们整个分布式架构是非常非常关键的。&lt;/p>
&lt;p>我给很多公司做过相关的咨询。当他们需要我帮忙解决一些高并发或是架构问题的时候，我一般都会向他们要一张这样的&amp;quot;地图&amp;quot;，但是几乎所有的公司都没有这样的地图。&lt;/p>
&lt;h1 id="服务状态和生命周期的管理">服务状态和生命周期的管理&lt;/h1>
&lt;p>有了上面这张地图后，我们还需要有一个服务发现的中间件，这个中间件是非常非常关键的。因为这个&amp;quot;架构城市&amp;quot;是非常动态的，有的服务会新加进来，有的会离开，有的会增加更多的实例，有的会减少，有的服务在维护过程中（发布、伸缩等），所以我们需要有一个服务注册中心，来知道这么几个事。&lt;/p>
&lt;ul>
&lt;li>整个架构中有多少种服务？&lt;/li>
&lt;li>这些服务的版本是什么样的？&lt;/li>
&lt;li>每个服务的实例数有多少个，它们的状态是什么样的?&lt;/li>
&lt;li>每个服务的状态是什么样的？是在部署中，运行中，故障中，升级中，还是在回滚中，伸缩中，或者是在下线中&amp;hellip;&amp;hellip;&lt;/li>
&lt;/ul>
&lt;p>这个服务注册中心有点像我们系统运维同学说的 CMDB 这样的东西，它也是非常之关键的，因为没有它，我们将无法知道这些服务运作的状态和情况。&lt;/p>
&lt;p>有了这些服务的状态和运行情况之后，你就需要对这些服务的生命周期进行管理了。服务的生命周期通常会有以下几个状态：&lt;/p>
&lt;ul>
&lt;li>Provision，代表在供应一个新的服务；&lt;/li>
&lt;li>Ready，表示启动成功了；&lt;/li>
&lt;li>Run，表示通过了服务健康检查；&lt;/li>
&lt;li>Update，表示在升级中；&lt;/li>
&lt;li>Rollback，表示在回滚中；&lt;/li>
&lt;li>Scale，表示正在伸缩中（可以有 Scale-in 和 Scale-out 两种）；&lt;/li>
&lt;li>Destroy，表示在销毁中；&lt;/li>
&lt;li>Failed，表示失败状态。&lt;/li>
&lt;/ul>
&lt;p>这几个状态需要管理好，不然的话，你将不知道这些服务在什么样的状态下。不知道在什么样的状态下，你对整个分布式架构也就无法控制了。&lt;/p>
&lt;p>有了这些服务的状态和生命周期的管理，以及服务的重要程度和服务的依赖关系，再加上一个服务运行状态的拟合控制（后面会提到），你一下子就有了管理整个分布式服务的手段了。&lt;/p>
&lt;p>一个纷乱无比的世界从此就可以干干净净地管理起来了。&lt;/p>
&lt;h1 id="整个架构的版本管理">整个架构的版本管理&lt;/h1>
&lt;p>对于整个架构的版本管理这个事，我只见到亚马逊有这个东西，叫 VersionSet，也就是由一堆服务的版本集所形成的整个架构的版本控制。&lt;/p>
&lt;p>除了各个项目的版本管理之外，还需要在上面再盖一层版本管理。如果 Build 过 Linux 分发包，那么你就会知道，Linux 分发包中各个软件的版本上会再盖一层版本控制。毕竟，这些分发包也是有版本依赖的，这样可以解决各个包的版本兼容性问题。&lt;/p>
&lt;p>所以，在分布式架构中，我们也需要一个架构的版本，用来控制其中各个服务的版本兼容。比如，A 服务的 1.2 版本只能和 B 服务的 2.2 版本一起工作，A 服务的上个版本 1.1 只能和 B 服务的 2.0 一起工作。这就是版本兼容性。&lt;/p>
&lt;p>如果架构中有这样的问题，那么我们就需要一个上层架构的版本管理。这样，如果我们要回滚一个服务的版本，就可以把与之有版本依赖的服务也一起回滚掉。&lt;/p>
&lt;p>当然，一般来说，在设计过程中，我们希望没有版本的依赖性问题。但可能有些时候，我们会有这样的问题，那么就需要在架构版本中记录下这个事，以便可以回滚到上一次相互兼容的版本。&lt;/p>
&lt;p>要做到这个事，你需要一个架构的 manifest，一个服务清单，这个服务清单定义了所有服务的版本运行环境，其中包括但不限于：&lt;/p>
&lt;ul>
&lt;li>服务的软件版本；&lt;/li>
&lt;li>服务的运行环境&amp;mdash;&amp;mdash;环境变量、CPU、内存、可以运行的结点、文件系统等；&lt;/li>
&lt;li>服务运行的最大最小实例数。&lt;/li>
&lt;/ul>
&lt;p>每一次对这个清单的变更都需要被记录下来，算是一个架构的版本管理。而我们上面所说的那个集群控制系统需要能够解读并执行这个清单中的变更，以操作和管理整个集群中的相关变更。&lt;/p>
&lt;h1 id="资源--服务调度">资源 / 服务调度&lt;/h1>
&lt;p>服务和资源的调度有点像操作系统。操作系统一方面把用户进程在硬件资源上进行调度，另一方面提供进程间的通信方式，可以让不同的进程在一起协同工作。服务和资源调度的过程，与操作系统调度进程的方式很相似，主要有以下一些关键技术。&lt;/p>
&lt;ul>
&lt;li>服务状态的维持和拟合。&lt;/li>
&lt;li>服务的弹性伸缩和故障迁移。&lt;/li>
&lt;li>作业和应用调度。&lt;/li>
&lt;li>作业工作流编排。&lt;/li>
&lt;li>服务编排。&lt;/li>
&lt;/ul>
&lt;h2 id="服务状态的维持和拟合">服务状态的维持和拟合&lt;/h2>
&lt;p>所谓服务状态不是服务中的数据状态，而是服务的运行状态，换句话说就是服务的 Status，而不是 State。也就是上述服务运行时生命周期中的状态&amp;mdash;&amp;mdash;Provision，Ready，Run，Scale，Rollback，Update，Destroy，Failed&amp;hellip;&amp;hellip;&lt;/p>
&lt;p>服务运行时的状态是非常关键的。服务运行过程中，状态也是会有变化的，这样的变化有两种。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>一种是不预期的变化。比如，服务运行因为故障导致一些服务挂掉，或是别的什么原因出现了服务不健康的状态。而一个好的集群管理控制器应该能够强行维护服务的状态。在健康的实例数变少时，控制器会把不健康的服务给摘除，而又启动几个新的，强行维护健康的服务实例数。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>另外一种是预期的变化。比如，我们需要发布新版本，需要伸缩，需要回滚。这时，集群管理控制器就应该把集群从现有状态迁移到另一个新的状态。这个过程并不是一蹴而就的，集群控制器需要一步一步地向集群发送若干控制命令。这个过程叫&amp;quot;拟合&amp;quot;&amp;mdash;&amp;mdash;从一个状态拟合到另一个状态，而且要穷尽所有的可能，玩命地不断地拟合，直到达到目的。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>详细说明一下，对于分布式系统的服务管理来说，当需要把一个状态变成另一个状态时，我们需要对集群进行一系列的操作。比如，当需要对集群进行 Scale 的时候，我们需要：&lt;/p>
&lt;ul>
&lt;li>先扩展出几个结点；&lt;/li>
&lt;li>再往上部署服务；&lt;/li>
&lt;li>然后启动服务；&lt;/li>
&lt;li>再检查服务的健康情况；&lt;/li>
&lt;li>最后把新扩展出来的服务实例加入服务发现中提供服务。&lt;/li>
&lt;/ul>
&lt;p>可以看到，这是一个比较稳健和严谨的 Scale 过程，这需要集群控制器往生产集群中进行若干次操作。&lt;/p>
&lt;p>这个操作的过程一定是比较&amp;quot;慢&amp;quot;的。一方面，需要对其它操作排它；另一方面，在整个过程中，我们的控制系统需要努力地逼近最终状态，直到完全达到。此外，正在运行的服务可能也会出现问题，离开了我们想要的状态，而控制系统检测到后，会强行地维持服务的状态。&lt;/p>
&lt;p>&lt;strong>我们把这个过程就叫做&amp;quot;拟合&amp;quot;&lt;/strong>。基本上来说，集群控制系统都是要干这个事的。没有这种设计的控制系统都不能算做设计精良的控制系统，而且在运行时一定会有很多的坑和 bug。&lt;/p>
&lt;p>如果研究过 Kubernetes 这个调度控制系统，你就会看到它的思路就是这个样子的。&lt;/p>
&lt;h2 id="服务的弹性伸缩和故障迁移">服务的弹性伸缩和故障迁移&lt;/h2>
&lt;p>有了上述的服务状态拟合的基础工作之后，我们就能很容易地管理服务的生命周期了，甚至可以通过底层的支持进行便利的服务弹性伸缩和故障迁移。&lt;/p>
&lt;p>对于弹性伸缩，在上面我已经给出了一个服务伸缩所需要的操作步骤。还是比较复杂的，其中涉及到了：&lt;/p>
&lt;ul>
&lt;li>底层资源的伸缩；&lt;/li>
&lt;li>服务的自动化部署；&lt;/li>
&lt;li>服务的健康检查；&lt;/li>
&lt;li>服务发现的注册；&lt;/li>
&lt;li>服务流量的调度。&lt;/li>
&lt;/ul>
&lt;p>而对于故障迁移，也就是服务的某个实例出现问题时，我们需要自动地恢复它。对于服务来说，有两种模式，一种是宠物模式，一种是奶牛模式。&lt;/p>
&lt;ul>
&lt;li>所谓宠物模式，就是一定要救活，主要是对于 stateful 的服务。&lt;/li>
&lt;li>而奶牛模式，就是不救活了，重新生成一个实例。&lt;/li>
&lt;/ul>
&lt;p>对于这两种模式，在运行中也是比较复杂的，其中涉及到了：&lt;/p>
&lt;ul>
&lt;li>服务的健康监控（这可能需要一个 APM 的监控）。&lt;/li>
&lt;li>如果是宠物模式，需要：服务的重新启动和服务的监控报警（如果重试恢复不成功，需要人工介入）。&lt;/li>
&lt;li>如果是奶牛模式，需要：服务的资源申请，服务的自动化部署，服务发现的注册，以及服务的流量调度。&lt;/li>
&lt;/ul>
&lt;p>我们可以看到，弹性伸缩和故障恢复需要很相似的技术步骤。但是，要完成这些事情并不容易，你需要做很多工作，而且有很多细节上的问题会让你感到焦头烂额。&lt;/p>
&lt;p>当然，好消息是，我们非常幸运地生活在了一个比较不错的时代，因为有 Docker 和 Kubernetes 这样的技术，可以非常容易地让我们做这个工作。&lt;/p>
&lt;p>但是，需要把传统的服务迁移到 Docker 和 Kubernetes 上来，再加上更上层的对服务生命周期的控制系统的调度，我们就可以做到一个完全自动化的运维架构了。&lt;/p>
&lt;h2 id="服务工作流和编排">服务工作流和编排&lt;/h2>
&lt;p>正如上面和操作系统做的类比一样，一个好的操作系统需要能够通过一定的机制把一堆独立工作的进程给协同起来。在分布式的服务调度中，这个工作叫做 Orchestration，国内把这个词翻译成&amp;quot;编排&amp;quot;。&lt;/p>
&lt;p>从《分布式系统架构的冰与火》一文中的 SOA 架构演化图来看，要完成这个编排工作，传统的 SOA 是通过 ESB（Enterprise Service Bus）&amp;mdash;&amp;mdash;企业服务总线来完成的。ESB 的主要功能是服务通信路由、协议转换、服务编制和业务规则应用等。&lt;/p>
&lt;p>注意，ESB 的服务编制叫 Choreography，与我们说的 Orchestration 是不一样的。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Orchestration 的意思是，一个服务像大脑一样来告诉大家应该怎么交互，就跟乐队的指挥一样。（查看&lt;a href="https://eprints.qut.edu.au/622/1/SOD_%28revised%29.pdf">Service-oriented Design：A Multi-viewpoint Approach&lt;/a>，了解更多信息）。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Choreography 的意思是，在各自完成专属自己的工作的基础上，怎样互相协作，就跟芭蕾舞团的舞者一样。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>而在微服务中，我们希望使用更为轻量的中间件来取代 ESB 的服务编排功能。&lt;/p>
&lt;p>简单来说，这需要一个 API Gateway 或一个简单的消息队列来做相应的编排工作。在 Spring Cloud 中，所有的请求都统一通过 API Gateway（Zuul）来访问内部的服务。这个和 Kubernetes 中的 Ingress 相似。&lt;/p>
&lt;p>我觉得，关于服务的编排会直接导致一个服务编排的工作流引擎中间件的产生，这可能是因为我受到了亚马逊的软件工程文化的影响所致&amp;mdash;&amp;mdash;亚马逊是一家超级喜欢工作流引擎的公司。通过工作流引擎，可以非常快速地将若干个服务编排起来形成一个业务流程。（你可以看一下 AWS 上的 Simple Workflow 服务。）&lt;/p>
&lt;p>这就是所谓的 Orchestration 中的 conductor 指挥了。&lt;/p>
&lt;h1 id="小结">小结&lt;/h1>
&lt;p>好了，今天的分享就这些。总结一下今天的主要内容：我们从服务关键程度、服务依赖关系、整个架构的版本管理等多个方面，全面阐述了分布式系统架构五大关键技术之一&amp;mdash;&amp;mdash;服务资源调度。希望这些内容能对你有所启发。&lt;/p>
&lt;p>你现在的公司中是怎样管理和运维线上的服务的呢？欢迎分享一下你的经验和方法。&lt;/p>
&lt;p>下一篇文章中，我们将从流量调度和状态数据调度两个方面，来接着聊分布式系统关键技术。&lt;/p>
&lt;p>文末有系列文章《分布式系统架构的本质》的目录，供你查看，方便你找到自己感兴趣的内容。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/1411">分布式系统架构的冰与火&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/1505">从亚马逊的实践，谈分布式系统的难点&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/1512">分布式系统的技术栈&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/1513">分布式系统关键技术：全栈监控&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/1604">分布式系统关键技术：服务调度&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/1609">分布式系统关键技术：流量与数据调度&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/1610">洞悉 PaaS 平台的本质&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/2080">推荐阅读：分布式系统架构经典资料&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/2421">推荐阅读：分布式数据调度相关论文&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/fc/e9/fcc761001867c60f526665e237f831e9.jpg" alt="">&lt;/p></description></item><item><title>极客专栏: 26丨分布式系统关键技术：流量与数据调度</title><link>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E/26%E4%B8%A8%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%85%B3%E9%94%AE%E6%8A%80%E6%9C%AF%E6%B5%81%E9%87%8F%E4%B8%8E%E6%95%B0%E6%8D%AE%E8%B0%83%E5%BA%A6/</link><pubDate>Fri, 27 May 2022 00:00:00 +0000</pubDate><guid>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E/26%E4%B8%A8%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%85%B3%E9%94%AE%E6%8A%80%E6%9C%AF%E6%B5%81%E9%87%8F%E4%B8%8E%E6%95%B0%E6%8D%AE%E8%B0%83%E5%BA%A6/</guid><description>
&lt;p>关于流量调度，现在很多架构师都把这个事和服务治理混为一谈了。我觉得还是应该分开的。一方面，服务治理是内部系统的事，而流量调度可以是内部的，更是外部接入层的事。另一方面，服务治理是数据中心的事，而流量调度要做得好，应该是数据中心之外的事，也就是我们常说的边缘计算，是应该在类似于 CDN 上完成的事。&lt;/p>
&lt;p>所以，流量调度和服务治理是在不同层面上的，不应该混在一起，所以在系统架构上应该把它们分开。&lt;/p>
&lt;h1 id="流量调度的主要功能">流量调度的主要功能&lt;/h1>
&lt;p>对于一个流量调度系统来说，其应该具有的主要功能是：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>依据系统运行的情况，自动地进行流量调度，在无需人工干预的情况下，提升整个系统的稳定性；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>让系统应对爆品等突发事件时，在弹性计算扩缩容的较长时间窗口内或底层资源消耗殆尽的情况下，保护系统平稳运行。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>这还是为了提高系统架构的稳定性和高可用性。&lt;/p>
&lt;p>此外，这个流量调度系统还可以完成以下几方面的事情。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>服务流控&lt;/strong>。服务发现、服务路由、服务降级、服务熔断、服务保护等。&lt;/li>
&lt;li>&lt;strong>流量控制&lt;/strong>。负载均衡、流量分配、流量控制、异地灾备（多活）等。&lt;/li>
&lt;li>&lt;strong>流量管理&lt;/strong>。协议转换、请求校验、数据缓存、数据计算等。&lt;/li>
&lt;/ul>
&lt;p>所有的这些都应该是一个 API Gateway 应该做的事。&lt;/p>
&lt;h1 id="流量调度的关键技术">流量调度的关键技术&lt;/h1>
&lt;p>但是，作为一个 API Gateway 来说，因为要调度流量，首先需要扛住流量，而且还需要有一些比较轻量的业务逻辑，所以一个好的 API Gateway 需要具备以下的关键技术。&lt;/p>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>高性能&lt;/strong>。API Gateway 必须使用高性能的技术，所以，也就需要使用高性能的语言。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>扛流量&lt;/strong>。要能扛流量，就需要使用集群技术。集群技术的关键点是在集群内的各个结点中共享数据。这就需要使用像 Paxos、Raft、Gossip 这样的通讯协议。因为 Gateway 需要部署在广域网上，所以还需要集群的分组技术。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>业务逻辑&lt;/strong>。API Gateway 需要有简单的业务逻辑，所以，最好是像 AWS 的 Lambda 服务一样，可以让人注入不同语言的简单业务逻辑。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>服务化&lt;/strong>。一个好的 API Gateway 需要能够通过 Admin API 来不停机地管理配置变更，而不是通过一个.conf 文件来人肉地修改配置。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>基于上述的这几个技术要求，就其本质来说，目前可以做成这样的 API Gateway 几乎没有。这也是为什么我现在自己自主开发的原因（你可以到我的官网 MegaEase.com 上查看相关的产品和技术信息）。&lt;/p>
&lt;h1 id="状态数据调度">状态数据调度&lt;/h1>
&lt;p>对于服务调度来说，最难办的就是有状态的服务了。这里的状态是 State，也就是说，有些服务会保存一些数据，而这些数据是不能丢失的，所以，这些数据是需要随服务一起调度的。&lt;/p>
&lt;p>一般来说，我们会通过&amp;quot;转移问题&amp;quot;的方法来让服务变成&amp;quot;无状态的服务&amp;quot;。也就是说，会把这些有状态的东西存储到第三方服务上，比如 Redis、MySQL、ZooKeeper，或是 NFS、Ceph 的文件系统中。&lt;/p>
&lt;p>这些&amp;quot;转移问题&amp;quot;的方式把问题转移到了第三方服务上，于是自己的 Java 或 PHP 服务中没有状态，但是 Redis 和 MySQL 上则有了状态。所以，我们可以看到，现在的分布式系统架构中出问题的基本都是这些存储状态的服务。&lt;/p>
&lt;p>因为数据存储结点在 Scale 上比较困难，所以成了一个单点的瓶颈。&lt;/p>
&lt;h1 id="分布式事务一致性的问题">分布式事务一致性的问题&lt;/h1>
&lt;p>要解决数据结点的 Scale 问题，也就是让数据服务可以像无状态的服务一样在不同的机器上进行调度，这就会涉及数据的 replication 问题。而数据 replication 则会带来数据一致性的问题，进而对性能带来严重的影响。&lt;/p>
&lt;p>要解决数据不丢失的问题，只能通过数据冗余的方法，就算是数据分区，每个区也需要进行数据冗余处理。这就是数据副本。当出现某个节点的数据丢失时，可以从副本读到。数据副本是分布式系统解决数据丢失异常的唯一手段。简单来说：&lt;/p>
&lt;ol>
&lt;li>要想让数据有高可用性，就得写多份数据。&lt;/li>
&lt;li>写多份会引起数据一致性的问题。&lt;/li>
&lt;li>数据一致性的问题又会引发性能问题。&lt;/li>
&lt;/ol>
&lt;p>在解决数据副本间的一致性问题时，我们有一些技术方案。&lt;/p>
&lt;ul>
&lt;li>Master-Slave 方案。&lt;/li>
&lt;li>Master-Master 方案。&lt;/li>
&lt;li>两阶段和三阶段提交方案。&lt;/li>
&lt;li>Paxos 方案。&lt;/li>
&lt;/ul>
&lt;p>你可以仔细地读一下我在 3 年前写的&lt;a href="https://coolshell.cn/articles/10910.html">《分布式系统的事务处理》这篇文章&lt;/a>。其中我引用了 Google App Engine 联合创始人赖安·巴里特（Ryan Barrett）在 2009 年 Google I/O 上的演讲&lt;a href="http://www.youtube.com/watch?v=srOgpXECblk">Transaction Across DataCenter 视频&lt;/a> 中的一张图。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/e5/ec/e566933d9967f2f5e0f4dcddc66247ec.png" alt="">&lt;/p>
&lt;p>从上面这张经典的图中，我们可以看到各种不同方案的对比。&lt;/p>
&lt;p>现在，很多公司的分布式系统事务基本上都是两阶段提交的变种。比如：阿里推出的 TCC&amp;ndash;Try&amp;ndash;Confirm&amp;ndash;Cancel，或是我在亚马逊见到的 Plan&amp;ndash;Reserve&amp;ndash;Confirm 的方式，等等。凡是通过业务补偿，或是在业务应用层上做的分布式事务的玩法，基本上都是两阶段提交，或是两阶段提交的变种。&lt;/p>
&lt;p>换句话说，迄今为止，在应用层上解决事务问题，只有&amp;quot;两阶段提交&amp;quot;这样的方式，而在数据层解决事务问题，Paxos 算法则是不二之选。&lt;/p>
&lt;h1 id="数据结点的分布式方案">数据结点的分布式方案&lt;/h1>
&lt;p>真正完整解决数据 Scale 问题的应该还是数据结点自身。只有数据结点自身解决了这个问题，才能做到对上层业务层的透明，业务层可以像操作单机数据库一样来操作分布式数据库，这样才能做到整个分布式服务架构的调度。&lt;/p>
&lt;p>也就是说，这个问题应该解决在数据存储方。但是因为数据存储结果有太多不同的 Scheme，所以现在的数据存储也是多种多样的，有文件系统，有对象型的，有 Key-Value 式，有时序的，有搜索型的，有关系型的&amp;hellip;&amp;hellip;&lt;/p>
&lt;p>这就是为什么分布式数据存储系统比较难做，因为很难做出来一个放之四海皆准的方案。类比一下编程中的各种不同的数据结构你就会明白为什么会有这么多的数据存储方案了。&lt;/p>
&lt;p>但是我们可以看到，这个&amp;quot;数据存储的动物园&amp;quot;中，基本上都在解决数据副本、数据一致性和分布式事务的问题。&lt;/p>
&lt;p>比如 AWS 的 Aurora，就是改写了 MySQL 的 InnoDB 引擎。为了承诺高可用的 SLA，所以需要写 6 个副本，但实现方式上，它不像 MySQL 通过 bin log 的数据复制方式，而是更为&amp;quot;惊艳&amp;quot;地复制 SQL 语句，然后拼命地使用各种 tricky 的方式来降低 latency。比如，使用多线程并行、使用 SQL 操作的 merge 等。&lt;/p>
&lt;p>MySQL 官方也有 MySQL Cluster 的技术方案。此外，MongoDB、国内的 PingCAP 的 TiDB、国外的 CockroachDB，还有阿里的 OceanBase 都是为了解决大规模数据的写入和读取的问题而出现的数据库软件。所以，我觉得成熟的可以用到生产线上的分布式数据库这个事估计也不远了。&lt;/p>
&lt;p>而对于一些需要文件存储的，则需要分布式文件系统的支持。试想，一个 Kafka 或 ZooKeeper 需要把它们的数据存储到文件系统上。当这个结点有问题时，我们需要再启动一个 Kafka 或 ZooKeeper 的实例，那么也需要把它们持久化的数据搬迁到另一台机器上。&lt;/p>
&lt;p>（注意，虽然 Kafka 和 ZooKeeper 是 HA 的，数据会在不同的结点中进行复制，但是我们也应该搬迁数据，这样有利用于新结点的快速启动。否则，新的结点需要等待数据同步，这个时间会比较长，可能会导致数据层的其它问题。）&lt;/p>
&lt;p>于是，我们就需要一个底层是分布式的文件系统，这样新的结点只需要做一个简单的远程文件系统的 mount 就可以把数据调度到另外一台机器上了。&lt;/p>
&lt;p>所以，真正解决数据结点调度的方案应该是底层的数据结点。在它们上面做这个事才是真正有效和优雅的。而像阿里的用于分库分表的数据库中间件 TDDL 或是别的公司叫什么 DAL 之类的这样的中间件都会成为过渡技术。&lt;/p>
&lt;h2 id="状态数据调度小结">状态数据调度小结&lt;/h2>
&lt;p>接下来，我们对状态数据调度做个小小的总结。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>对于应用层上的分布式事务一致性，只有两阶段提交这样的方式。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>而底层存储可以解决这个问题的方式是通过一些像 Paxos、Raft 或是 NWR 这样的算法和模型来解决。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>状态数据调度应该是由分布式存储系统来解决的，这样会更为完美。但是因为数据存储的 Scheme 太多，所以，导致我们有各式各样的分布式存储系统，有文件对象的，有关系型数据库的，有 NoSQL 的，有时序数据的，有搜索数据的，有队列的&amp;hellip;&amp;hellip;&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>总之，我相信状态数据调度应该是在 IaaS 层的数据存储解决的问题，而不是在 PaaS 层或者 SaaS 层来解决的。&lt;/p>
&lt;p>在 IaaS 层上解决这个问题，一般来说有三种方案，一种是使用比较廉价的开源产品，如：NFS、Ceph、TiDB、CockroachDB、ElasticSearch、InfluxDB、MySQL Cluster 和 Redis Cluster 之类的；另一种是用云计算厂商的方案。当然，如果不差钱的话，可以使用更为昂贵的商业网络存储方案。&lt;/p>
&lt;h1 id="小结">小结&lt;/h1>
&lt;p>回顾一下今天分享的主要内容。首先，我先明确表态，不要将流量调度和服务治理混为一谈（当然，服务治理是流量调度的前提），并比较了两者有何不同。&lt;/p>
&lt;p>然后，讲述了流量调度的主要功能和关键技术。接着进入本文的第二个话题&amp;mdash;&amp;mdash;状态数据调度，讲述了真正完整解决数据 Scale 问题的应该还是数据结点自身，并给出了相应的技术方案，随后对状态数据调度进行了小结。&lt;/p>
&lt;p>欢迎你也谈一谈自己经历过的技术场景中是采用了哪些流量和数据调度的技术和产品，遇到过什么样的问题，是怎样解决的？&lt;/p>
&lt;p>下篇文章中，我们将开启一个全新的话题&amp;mdash;&amp;mdash;洞悉 PaaS 平台的本质。&lt;/p>
&lt;p>下面我列出了系列文章《分布式系统架构的本质》的目录，以方便你快速找到自己感兴趣的内容。如果你在分布式系统架构方面，有其他想了解的话题和内容，欢迎留言给我。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/1411">分布式系统架构的冰与火&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/1505">从亚马逊的实践，谈分布式系统的难点&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/1512">分布式系统的技术栈&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/1513">分布式系统关键技术：全栈监控&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/1604">分布式系统关键技术：服务调度&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/1609">分布式系统关键技术：流量与数据调度&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/1610">洞悉 PaaS 平台的本质&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/2080">推荐阅读：分布式系统架构经典资料&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/2421">推荐阅读：分布式数据调度相关论文&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/fc/e9/fcc761001867c60f526665e237f831e9.jpg" alt="">&lt;/p></description></item><item><title>极客专栏: 27丨洞悉PaaS平台的本质</title><link>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E/27%E4%B8%A8%E6%B4%9E%E6%82%89paas%E5%B9%B3%E5%8F%B0%E7%9A%84%E6%9C%AC%E8%B4%A8/</link><pubDate>Fri, 27 May 2022 00:00:00 +0000</pubDate><guid>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E/27%E4%B8%A8%E6%B4%9E%E6%82%89paas%E5%B9%B3%E5%8F%B0%E7%9A%84%E6%9C%AC%E8%B4%A8/</guid><description>
&lt;p>在了解了前面几篇文章中提的这些问题以后，我们需要思考一下该怎样解决这些问题。为了解决这些问题，请先允许我来谈谈软件工程的本质。&lt;/p>
&lt;p>我认为，一家商业公司的软件工程能力主要体现在三个地方。&lt;/p>
&lt;p>&lt;strong>第一，提高服务的 SLA。&lt;/strong>&lt;/p>
&lt;p>所谓服务的 SLA，也就是我们能提供多少个 9 的系统可用性，而每提高一个 9 的可用性都是对整个系统架构的重新洗礼。在我看来，提高系统的 SLA 主要表现在两个方面：&lt;/p>
&lt;ul>
&lt;li>高可用的系统；&lt;/li>
&lt;li>自动化的运维。&lt;/li>
&lt;/ul>
&lt;p>你可以看一下我在 CoolShell 上写的《&lt;a href="https://coolshell.cn/articles/17459.html">关于高可用系统&lt;/a>》这篇文章，它主要讲了构建高可用的系统需要使用的分布式系统设计思路。然而这还不够，我们还需要一个高度自动化的运维和管理系统，因为故障是常态，如果没有自动化的故障恢复，就很难提高服务的 SLA。&lt;/p>
&lt;p>&lt;strong>第二，能力和资源重用或复用。&lt;/strong>&lt;/p>
&lt;p>软件工程还有一个重要的能力就是让能力和资源可以重用。其主要表现在如下两个方面：&lt;/p>
&lt;ul>
&lt;li>软件模块的重用；&lt;/li>
&lt;li>软件运行环境和资源的重用。&lt;/li>
&lt;/ul>
&lt;p>为此，需要我们有两个重要的能力：一个是&amp;quot;软件抽象的能力&amp;quot;，另一个是&amp;quot;软件标准化的能力&amp;quot;。你可以认为软件抽象就是找出通用的软件模块或服务，软件标准化就是使用统一的软件通讯协议、统一的开发和运维管理方法&amp;hellip;&amp;hellip;这样能让整体软件开发运维的能力和资源得到最大程度的复用，从而增加效率。&lt;/p>
&lt;p>&lt;strong>第三，过程的自动化。&lt;/strong>&lt;/p>
&lt;p>编程本来就是把一个重复工作自动化的过程，所以，&lt;strong>软件工程的第三个本质就是把软件生产和运维的过程自动化起来&lt;/strong>。也就是下面这两个方面：&lt;/p>
&lt;ul>
&lt;li>软件生产流水线；&lt;/li>
&lt;li>软件运维自动化。&lt;/li>
&lt;/ul>
&lt;p>为此，我们除了需要 CI/CD 的 DevOps 式的自动化之外，也需要能够对正在运行的生产环境中的软件进行自动化运维。&lt;/p>
&lt;p>通过了解软件工程的这三个本质，你会发现，我们上面所说的那些分布式的技术点是高度一致的，也就是下面这三个方面的能力。（是的，世界就是这样的。当参透了本质之后，你会发现世界是大同的。）&lt;/p>
&lt;ul>
&lt;li>分布式多层的系统架构。&lt;/li>
&lt;li>服务化的能力供应。&lt;/li>
&lt;li>自动化的运维能力。&lt;/li>
&lt;/ul>
&lt;p>只有做到了这些，我们才能够真正拥有云计算的威力。这就是所谓的 Cloud Native。而这些目标都完美地体现在 PaaS 平台上。&lt;/p>
&lt;p>前面讲述的分布式系统关键技术和软件工程的本质，都可以在 PaaS 平台上得到完全体现。所以，需要一个 PaaS 平台把那么多的东西给串联起来。这里，我结合自己的认知给你讲一下 PaaS 相关的东西，并把前面讲过的所有东西做一个总结。&lt;/p>
&lt;h1 id="paas-平台的本质">PaaS 平台的本质&lt;/h1>
&lt;p>一个好的 PaaS 平台应该具有分布式、服务化、自动化部署、高可用、敏捷以及分层开放的特征，并可与 IaaS 实现良好的联动。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/96/0b/966f319745518156545e34d85eee010b.png" alt="">&lt;/p>
&lt;p>下面这三件事是 PaaS 跟传统中间件最大的差别。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>服务化是 PaaS 的本质&lt;/strong>。软件模块重用，服务治理，对外提供能力是 PaaS 的本质。&lt;/li>
&lt;li>&lt;strong>分布式是 PaaS 的根本特性&lt;/strong>。多租户隔离、高可用、服务编排是 PaaS 的基本特性。&lt;/li>
&lt;li>&lt;strong>自动化是 PaaS 的灵魂&lt;/strong>。自动化部署安装运维，自动化伸缩调度是 PaaS 的关键。&lt;/li>
&lt;/ul>
&lt;h2 id="paas-平台的总体架构">PaaS 平台的总体架构&lt;/h2>
&lt;p>从下面的图中可以看到，我用了 Docker+Kubernetes 层来做了一个&amp;quot;技术缓冲层&amp;quot;。也就是说，如果没有 Docker 和 Kubernetes，构建 PaaS 将会复杂很多。当然，如果你正在开发一个类似 PaaS 的平台，那么你会发现自己开发出来的东西会跟 Docker 和 Kubernetes 非常像。相信我，最终你还是会放弃自己的轮子而采用 Docker+Kubernetes 的。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/f6/68/f65ccf66daf8d01d59fa8948c8136c68.png" alt="">&lt;/p>
&lt;p>在 Docker+Kubernetes 层之上，我们看到了两个相关的 PaaS 层。一个是 PaaS 调度层，很多人将其称为 iPaaS；另一个是 PaaS 能力层，通常被称为 aPaaS。没有 PaaS 调度层，PaaS 能力层很难被管理和运维，而没有 PaaS 能力层，PaaS 就失去了提供实际能力的业务价值。而本文更多的是在讲 PaaS 调度层上的东西。&lt;/p>
&lt;p>在两个相关的 PaaS 层之上，有一个流量调度的接入模块，这也是 PaaS 中非常关键的东西。流控、路由、降级、灰度、聚合、串联等等都在这里，包括最新的 AWS Lambda Service 的小函数等也可以放在这里。这个模块应该是像 CDN 那样来部署的。&lt;/p>
&lt;p>然后，在这个图的两边分别是与运营和运维相关的。运营这边主要是管理一些软件资源方面的东西（类似 Docker Hub 和 CMDB），以及外部接入和开放平台上的东西，这主要是对外提供能力的相关组件；而运维这边主要是对内的相关东西，主要就是 DevOps。&lt;/p>
&lt;p>总结一下，一个完整的 PaaS 平台会包括以下几部分。&lt;/p>
&lt;ul>
&lt;li>PaaS 调度层 &amp;ndash; 主要是 PaaS 的自动化和分布式对于高可用高性能的管理。&lt;/li>
&lt;li>PaaS 能力服务层 &amp;ndash; 主要是 PaaS 真正提供给用户的服务和能力。&lt;/li>
&lt;li>PaaS 的流量调度 &amp;ndash; 主要是与流量调度相关的东西，包括对高并发的管理。&lt;/li>
&lt;li>PaaS 的运营管理 &amp;ndash; 软件资源库、软件接入、认证和开放平台门户。&lt;/li>
&lt;li>PaaS 的运维管理 &amp;ndash; 主要是 DevOps 相关的东西。&lt;/li>
&lt;/ul>
&lt;p>因为我画的是一个大而全的东西，所以看上去似乎很重很复杂。实际上，其中的很多组件是可以根据自己的需求被简化和裁剪的，而且很多开源软件能帮你简化好多工作。虽然构建 PaaS 平台看上去很麻烦，但是其实并不是很复杂，不要被我吓到了。哈哈。&lt;/p>
&lt;h2 id="paas-平台的生产和运维">PaaS 平台的生产和运维&lt;/h2>
&lt;p>下面的图我给出了一个大概的软件生产、运维和服务接入的流程，它把之前的东西都串起来了。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/61/dd/61b89202b59959df224ae8ff29bdf0dd.png" alt="">&lt;/p>
&lt;p>从左上开始软件构建，进入软件资产库（Docker Registry+ 一些软件的定义），然后走 DevOps 的流程，通过整体架构控制器进入生产环境，生产环境通过控制器操作 Docker+Kubernetes 集群进行软件部署和生产变更。&lt;/p>
&lt;p>其中，同步服务的运行状态，并通过生命周期管理来拟合状态，如图右侧部分所示。服务运行时的数据会进入到相关应用监控，应用监控中的一些监控事件会同步到生命周期管理中，再由生命周期管理器来做出决定，通过控制器来调度服务运行。当应用监控中心发现流量变化，要进行强制性伸缩时，它通过生命周期管理来通知控制系统进行伸缩。&lt;/p>
&lt;p>左下是服务接入的相关组件，主要是网关服务，以及 API 聚合编排和流程处理。这对应于之前说过的流量调度和 API Gateway 的相关功能。&lt;/p>
&lt;h1 id="总结">总结&lt;/h1>
&lt;p>恭喜你，已经听完了《分布式系统架构的本质》系列文章的 7 篇文章。下面，我们对这些内容做一下总结。&lt;/p>
&lt;p>传统的单体架构系统容量显然是有上限的。同时，为了应对有计划和无计划的下线时间，系统的可用性也是有其极限的。分布式系统为以上两个问题提供了解决方案，并且还附带有其他优势。但是，要同时解决这两个问题决非易事。为了构建分布式系统，我们面临的主要问题如下。&lt;/p>
&lt;ul>
&lt;li>分布式系统的硬件故障发生率更高，故障发生是常态，需要尽可能地将运维流程自动化。&lt;/li>
&lt;li>需要良好地设计服务，避免某服务的单点故障对依赖它的其他服务造成大面积影响。&lt;/li>
&lt;li>为了容量的可伸缩性，服务的拆分、自治和无状态变得更加重要，可能需要对老的软件逻辑做大的修改。&lt;/li>
&lt;li>老的服务可能是异构的，此时需要让它们使用标准的协议，以便可以被调度、编排，且互相之间可以通信。&lt;/li>
&lt;li>服务软件故障的处理也变得复杂，需要优化的流程，以加快故障的恢复。&lt;/li>
&lt;li>为了管理各个服务的容量，让分布式系统发挥出最佳性能，需要有流量调度技术。&lt;/li>
&lt;li>分布式存储会让事务处理变得复杂；在事务遇到故障无法被自动恢复的情况下，手动恢复流程也会变得复杂。&lt;/li>
&lt;li>测试和查错的复杂度增大。&lt;/li>
&lt;li>系统的吞吐量会变大，但响应时间会变长。&lt;/li>
&lt;/ul>
&lt;p>为了解决这些问题，我们深入了解了以下这些解决方案。&lt;/p>
&lt;ul>
&lt;li>需要有完善的监控系统，以便对服务运行状态有全面的了解。&lt;/li>
&lt;li>设计服务时要分析其依赖链；当非关键服务故障时，其他服务要自动降级功能，避免调用该服务。&lt;/li>
&lt;li>重构老的软件，使其能被服务化；可以参考 SOA 和微服务的设计方式，目标是微服务化；使用 Docker 和 Kubernetes 来调度服务。&lt;/li>
&lt;li>为老的服务编写接口逻辑来使用标准协议，或在必要时重构老的服务以使得它们有这些功能。&lt;/li>
&lt;li>自动构建服务的依赖地图，并引入好的处理流程，让团队能以最快速度定位和恢复故障，详见《故障处理最佳实践：应对故障》一文。&lt;/li>
&lt;li>使用一个 API Gateway，它具备服务流向控制、流量控制和管理的功能。&lt;/li>
&lt;li>事务处理建议在存储层实现；根据业务需求，或者降级使用更简单、吞吐量更大的最终一致性方案，或者通过二阶段提交、Paxos、Raft、NWR 等方案之一，使用吞吐量小的强一致性方案。&lt;/li>
&lt;li>通过更真实地模拟生产环境，乃至在生产环境中做灰度发布，从而增加测试强度；同时做充分的单元测试和集成测试以发现和消除缺陷；最后，在服务故障发生时，相关的多个团队同时上线自查服务状态，以最快地定位故障原因。&lt;/li>
&lt;li>通过异步调用来减少对短响应时间的依赖；对关键服务提供专属硬件资源，并优化软件逻辑以缩短响应时间。&lt;/li>
&lt;/ul>
&lt;p>你已经看到，解决分布式服务的吞吐量和可用性问题不是件容易的事，以及目前的主流技术是怎么办到的。衍生出来的许多子问题，每一个都值得去细化、去研究其解决方案。这已经超出本文的篇幅所能及的了，但的确都是值得我们做技术的人去深入思考的。&lt;/p>
&lt;p>在这里，我想邀请你来讨论一下，你在分布式系统的哪个领域研究得比较深？有什么独特的心得能与我们分享？期待你的留言。&lt;/p>
&lt;p>本文末尾给出了《分布式系统架构的本质》系列文章的目录，方便你查找自己关注的内容。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/1411">分布式系统架构的冰与火&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/1505">从亚马逊的实践，谈分布式系统的难点&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/1512">分布式系统的技术栈&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/1513">分布式系统关键技术：全栈监控&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/1604">分布式系统关键技术：服务调度&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/1609">分布式系统关键技术：流量与数据调度&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/1610">洞悉 PaaS 平台的本质&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/2080">推荐阅读：分布式系统架构经典资料&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/2421">推荐阅读：分布式数据调度相关论文&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/fc/e9/fcc761001867c60f526665e237f831e9.jpg" alt="">&lt;/p></description></item><item><title>极客专栏: 28丨推荐阅读：分布式系统架构经典资料</title><link>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E/28%E4%B8%A8%E6%8E%A8%E8%8D%90%E9%98%85%E8%AF%BB%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E7%BB%8F%E5%85%B8%E8%B5%84%E6%96%99/</link><pubDate>Fri, 27 May 2022 00:00:00 +0000</pubDate><guid>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E/28%E4%B8%A8%E6%8E%A8%E8%8D%90%E9%98%85%E8%AF%BB%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E7%BB%8F%E5%85%B8%E8%B5%84%E6%96%99/</guid><description>
&lt;p>前段时间，我写了一系列分布式系统架构方面的文章，有很多读者纷纷留言讨论相关的话题，还有读者留言表示对分布式系统架构这个主题感兴趣，希望我能推荐一些学习资料。&lt;/p>
&lt;p>就像我在前面的文章中多次提到的，分布式系统的技术栈巨大无比，所以我要推荐的学习资料也比较多，后面在文章中我会结合主题逐步推荐给你。在今天这篇文章中，我将推荐一些分布式系统的基础理论和一些不错的图书和资料。&lt;/p>
&lt;p>这篇文章比较长，所以我特意整理了目录，帮你快速找到自己感兴趣的内容。&lt;/p>
&lt;h1 id="基础理论">基础理论&lt;/h1>
&lt;ul>
&lt;li>CAP 定理&lt;/li>
&lt;li>Fallacies of Distributed Computing&lt;/li>
&lt;/ul>
&lt;h1 id="经典资料">经典资料&lt;/h1>
&lt;ul>
&lt;li>Distributed systems theory for the distributed systems engineer&lt;/li>
&lt;li>FLP Impossibility Result&lt;/li>
&lt;li>An introduction to distributed systems&lt;/li>
&lt;li>Distributed Systems for fun and profit&lt;/li>
&lt;li>Distributed Systems: Principles and Paradigms&lt;/li>
&lt;li>Scalable Web Architecture and Distributed Systems&lt;/li>
&lt;li>Principles of Distributed Systems&lt;/li>
&lt;li>Making reliable distributed systems in the presence of software errors&lt;/li>
&lt;li>Designing Data Intensive Applications&lt;/li>
&lt;/ul>
&lt;h1 id="基础理论-1">基础理论&lt;/h1>
&lt;p>下面这些基础知识有可能你已经知道了，不过还是容我把它分享在这里。我希望用比较通俗易懂的文字将这些枯燥的理论知识讲请楚。&lt;/p>
&lt;h2 id="cap-定理httpsenwikipediaorgwikicap_theorem">&lt;a href="https://en.wikipedia.org/wiki/CAP_theorem">CAP 定理&lt;/a>&lt;/h2>
&lt;p>CAP 定理是分布式系统设计中最基础，也是最为关键的理论。它指出，分布式数据存储不可能同时满足以下三个条件。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>一致性（Consistency）&lt;/strong>：每次读取要么获得最近写入的数据，要么获得一个错误。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>可用性（Availability）&lt;/strong>：每次请求都能获得一个（非错误）响应，但不保证返回的是最新写入的数据。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>分区容忍（Partition tolerance）&lt;/strong>：尽管任意数量的消息被节点间的网络丢失（或延迟），系统仍继续运行。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>也就是说，CAP 定理表明，在存在网络分区的情况下，一致性和可用性必须二选一。而在没有发生网络故障时，即分布式系统正常运行时，一致性和可用性是可以同时被满足的。这里需要注意的是，CAP 定理中的一致性与 ACID 数据库事务中的一致性截然不同。&lt;/p>
&lt;p>掌握 CAP 定理，尤其是能够正确理解 C、A、P 的含义，对于系统架构来说非常重要。因为对于分布式系统来说，网络故障在所难免，如何在出现网络故障的时候，维持系统按照正常的行为逻辑运行就显得尤为重要。你可以结合实际的业务场景和具体需求，来进行权衡。&lt;/p>
&lt;p>例如，对于大多数互联网应用来说（如门户网站），因为机器数量庞大，部署节点分散，网络故障是常态，可用性是必须要保证的，所以只有舍弃一致性来保证服务的 AP。而对于银行等，需要确保一致性的场景，通常会权衡 CA 和 CP 模型，CA 模型网络故障时完全不可用，CP 模型具备部分可用性。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/d9/a6/d98d65bef3719e175f16bdb5901f37a6.png" alt="">&lt;/p>
&lt;ul>
&lt;li>
&lt;p>CA (consistency + availability)，这样的系统关注一致性和可用性，它需要非常严格的全体一致的协议，比如&amp;quot;两阶段提交&amp;quot;（2PC）。CA 系统不能容忍网络错误或节点错误，一旦出现这样的问题，整个系统就会拒绝写请求，因为它并不知道对面的那个结点是否挂掉了，还是只是网络问题。唯一安全的做法就是把自己变成只读的。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>CP (consistency + partition tolerance)，这样的系统关注一致性和分区容忍性。它关注的是系统里大多数人的一致性协议，比如：Paxos 算法（Quorum 类的算法）。这样的系统只需要保证大多数结点数据一致，而少数的结点会在没有同步到最新版本的数据时变成不可用的状态。这样能够提供一部分的可用性。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>AP (availability + partition tolerance)，这样的系统关心可用性和分区容忍性。因此，这样的系统不能达成一致性，需要给出数据冲突，给出数据冲突就需要维护数据版本。Dynamo 就是这样的系统。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>然而，还是有一些人会错误地理解 CAP 定理，甚至误用。Cloudera 工程博客中，&lt;a href="http://blog.cloudera.com/blog/2010/04/cap-confusion-problems-with-partition-tolerance/">CAP Confusion: Problems with &amp;lsquo;partition tolerance&amp;rsquo;&lt;/a>一文中对此有详细的阐述。&lt;/p>
&lt;p>在谷歌的&lt;a href="http://www.youtube.com/watch?v=srOgpXECblk">Transaction Across DataCenter 视频&lt;/a>中，我们可以看到下面这样的图。这个是 CAP 理论在具体工程中的体现。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/f6/b8/f62e32b1a3d81db6ae24b174f1b727b8.png" alt="">&lt;/p>
&lt;h2 id="fallacies-of-distributed-computinghttpenwikipediaorgwikifallacies_of_distributed_computing">&lt;a href="http://en.wikipedia.org/wiki/Fallacies_of_distributed_computing">Fallacies of Distributed Computing&lt;/a>&lt;/h2>
&lt;p>本文是英文维基百科上的一篇文章。它是 Sun 公司的&lt;a href="https://en.wikipedia.org/wiki/L_Peter_Deutsch">劳伦斯·彼得·多伊奇（Laurence Peter Deutsch）&lt;/a>等人于 1994~1997 年提出的，讲的是刚刚进入分布式计算领域的程序员常会有的一系列错误假设。&lt;/p>
&lt;p>多伊奇于 1946 年出生在美国波士顿。他创办了阿拉丁企业（Aladdin Enterprises），并在该公司编写出了著名的 Ghostscript 开源软件，于 1988 年首次发布。&lt;/p>
&lt;p>他在学生时代就和艾伦·凯（Alan Kay）等比他年长的人一起开发了 Smalltalk，并且他的开发成果激发了后来 Java 语言 JIT 编译技术的创造灵感。他后来在 Sun 公司工作并成为 Sun 的公司院士。在 1994 年，他成为了 ACM 院士。&lt;/p>
&lt;p>基本上，每个人刚开始建立一个分布式系统时，都做了以下 8 条假定。随着时间的推移，每一条都会被证明是错误的，也都会导致严重的问题，以及痛苦的学习体验。&lt;/p>
&lt;ol>
&lt;li>网络是稳定的。&lt;/li>
&lt;li>网络传输的延迟是零。&lt;/li>
&lt;li>网络的带宽是无穷大。&lt;/li>
&lt;li>网络是安全的。&lt;/li>
&lt;li>网络的拓扑不会改变。&lt;/li>
&lt;li>只有一个系统管理员。&lt;/li>
&lt;li>传输数据的成本为零。&lt;/li>
&lt;li>整个网络是同构的。&lt;/li>
&lt;/ol>
&lt;p>阿尔农·罗特姆 - 盖尔 - 奥兹（Arnon Rotem-Gal-Oz）写了一篇长文&lt;a href="http://www.rgoarchitects.com/Files/fallacies.pdf">Fallacies of Distributed Computing Explained&lt;/a>来解释这些点。&lt;/p>
&lt;p>由于他写这篇文章的时候已经是 2006 年了，所以从中能看到这 8 条常见错误被提出十多年后还有什么样的影响：一是，为什么当今的分布式软件系统也需要避免这些设计错误；二是，在当今的软硬件环境里，这些错误意味着什么。比如，文中在谈&amp;quot;延迟为零&amp;quot;假设时，还谈到了 AJAX，而这是 2005 年开始流行的技术。&lt;/p>
&lt;p>而&lt;a href="http://blog.fogcreek.com/eight-fallacies-of-distributed-computing-tech-talk/">加勒思·威尔逊（Gareth Wilson）的文章&lt;/a>则用日常生活中的例子，对这些点做了更为通俗的解释。&lt;/p>
&lt;p>这 8 个需要避免的错误不仅对于中间件和底层系统开发者及架构师是重要的知识，而且对于网络应用程序开发者也同样重要。分布式系统的其他部分，如容错、备份、分片、微服务等也许可以对应用程序开发者部分透明，但这 8 点则是应用程序开发者也必须知道的。&lt;/p>
&lt;p>&lt;strong>为什么我们要深刻地认识这 8 个错误？是因为，这要我们清楚地认识到&amp;mdash;&amp;mdash;在分布式系统中错误是不可能避免的，我们能做的不是避免错误，而是要把错误的处理当成功能写在代码中。&lt;/strong>&lt;/p>
&lt;p>后面，我会写一个系列的文章来谈一谈，分布式系统容错设计中的一些常见设计模式。敬请关注！&lt;/p>
&lt;h1 id="经典资料-1">经典资料&lt;/h1>
&lt;h2 id="distributed-systems-theory-for-the-distributed-systems-engineerhttpthe-paper-trailorgblogdistributed-systems-theory-for-the-distributed-systems-engineer">&lt;a href="http://the-paper-trail.org/blog/distributed-systems-theory-for-the-distributed-systems-engineer/">Distributed systems theory for the distributed systems engineer&lt;/a>&lt;/h2>
&lt;p>本文作者认为，推荐大量的理论论文是学习分布式系统理论的错误方法，除非这是你的博士课程。因为论文通常难度大又很复杂，需要认真学习，而且需要理解这些研究成果产生的时代背景，才能真正的领悟到其中的精妙之处。&lt;/p>
&lt;p>在本文中，作者给出了他整理的分布式工程师必须要掌握的知识列表，并直言掌握这些足够设计出新的分布式系统。首先，作者推荐了 4 份阅读材料，它们共同概括了构建分布式系统的难点，以及所有工程师必须克服的技术难题。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;a href="http://book.mixu.net/distsys/">Distributed Systems for Fun and Profit&lt;/a>，这是一本小书，涵盖了分布式系统中的关键问题，包括时间的作用和不同的复制策略。后文中对这本书有较详细的介绍。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.somethingsimilar.com/2013/01/14/notes-on-distributed-systems-for-young-bloods/">Notes on distributed systems for young bloods&lt;/a>，这篇文章中没有理论，是一份适合新手阅读的分布式系统实践笔记。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.41.7628">A Note on Distributed Systems&lt;/a>，这是一篇经典的论文，讲述了为什么在分布式系统中，远程交互不能像本地对象那样进行。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://en.wikipedia.org/wiki/Fallacies_of_distributed_computing">The fallacies of distributed computing&lt;/a>，每个分布式系统新手都会做的 8 个错误假设，并探讨了其会带来的影响。上文中专门对这篇文章做了介绍。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>随后，分享了几个关键点。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>失败和时间（Failure and Time）&lt;/strong>。分布式系统工程师面临的很多困难都可以归咎于两个根本原因：1. 进程可能会失败；2. 没有好方法表明进程失败。这就涉及到如何设置系统时钟，以及进程间的通讯机制，在没有任何共享时钟的情况下，如何确定一个事件发生在另一个事件之前。&lt;/li>
&lt;/ul>
&lt;p>可以参考 Lamport 时钟和 Vector 时钟，还可以看看&lt;a href="http://www.allthingsdistributed.com/files/amazon-dynamo-sosp2007.pdf">Dynamo 论文&lt;/a>。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>容错的压力（The basic tension of fault tolerance）&lt;/strong>。能在不降级的情况下容错的系统一定要像没有错误发生的那样运行。这就意味着，系统的某些部分必须冗余地工作，从而在性能和资源消耗两方面带来成本。&lt;/li>
&lt;/ul>
&lt;p>最终一致性以及其他技术方案在以系统行为弱保证为代价，来试图避免这种系统压力。阅读&lt;a href="http://www.allthingsdistributed.com/files/amazon-dynamo-sosp2007.pdf">Dynamo 论文&lt;/a>和帕特·赫尔兰（Pat Helland）的经典论文&lt;a href="http://www.cloudtran.com/pdfs/LifeBeyondDistTRX.pdf">Life Beyond Transactions&lt;/a>能获很得大启发。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>基本原语（Basic primitives）&lt;/strong> 。在分布式系统中几乎没有一致认同的基本构建模块，但目前在越来越多地在出现。比如 Leader 选举，可以参考&lt;a href="https://en.wikipedia.org/wiki/Bully_algorithm">Bully 算法&lt;/a>；分布式状态机复制，可以参考&lt;a href="https://en.wikipedia.org/wiki/State_machine_replication">维基百科&lt;/a>和&lt;a href="https://www.microsoft.com/en-us/research/publication/how-to-build-a-highly-available-system-using-consensus/?from=http%3A%2F%2Fresearch.microsoft.com%2Fen-us%2Fum%2Fpeople%2Fblampson%2F58-consensus%2Facrobat.pdf">Lampson 的论文&lt;/a>，后者更权威，只是有些枯燥。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>基本结论（Fundamental Results）&lt;/strong>。某些事实是需要吸收理解的，有几点：如果进程之间可能丢失某些消息，那么不可能在实现一致性存储的同时响应所有的请求，这就是 CAP 定理；一致性不可能同时满足以下条件：a. 总是正确，b. 在异步系统中只要有一台机器发生故障，系统总是能终止运行&amp;mdash;&amp;mdash;停止失败（FLP 不可能性）；一般而言，消息交互少于两轮都不可能达成共识（Consensus）。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>真实系统（Real systems）&lt;/strong>。学习分布式系统架构最重要的是，结合一些真实系统的描述，反复思考和点评其背后的设计决策。如谷歌的 GFS、Spanner、Chubby、BigTable、Dapper 等，以及 Dryad、Cassandra 和 Ceph 等非谷歌系统。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="flp-impossibility-resulthttpsgroupscsailmitedutdspaperslynchjacm85pdf">&lt;a href="https://groups.csail.mit.edu/tds/papers/Lynch/jacm85.pdf">FLP Impossibility Result&lt;/a>&lt;/h2>
&lt;p>FLP 不可能性的名称起源于它的三位作者，Fischer、Lynch 和 Paterson。它是关于理论上能做出的功能最强的共识算法会受到怎样的限制的讨论。&lt;/p>
&lt;p>所谓共识问题，就是让网络上的分布式处理者最后都对同一个结果值达成共识。该解决方案对错误有恢复能力，处理者一旦崩溃以后，就不再参与计算。在同步环境下，每个操作步骤的时间和网络通信的延迟都是有限的，要解决共识问题是可能的，方式是：等待一个完整的步长来检测某个处理者是否已失败。如果没有收到回复，那就假定它已经崩溃。&lt;/p>
&lt;p>共识问题有几个变种，它们在&amp;quot;强度&amp;quot;方面有所不同&amp;mdash;&amp;mdash;通常，一个更&amp;quot;强&amp;quot;问题的解决方案同时也能解决比该问题更&amp;quot;弱&amp;quot;的问题。共识问题的一个较强的形式如下。&lt;/p>
&lt;p>给出一个处理者的集合，其中每一个处理者都有一个初始值：&lt;/p>
&lt;ul>
&lt;li>所有无错误的进程（处理过程）最终都将决定一个值；&lt;/li>
&lt;li>所有会做决定的无错误进程决定的都将是同一个值；&lt;/li>
&lt;li>最终被决定的值必须被至少一个进程提出过。&lt;/li>
&lt;/ul>
&lt;p>这三个特性分别被称为&amp;quot;终止&amp;quot;、&amp;ldquo;一致同意&amp;quot;和&amp;quot;有效性&amp;rdquo;。任何一个具备这三点特性的算法都被认为是解决了共识问题。&lt;/p>
&lt;p>FLP 不可能性则讨论了异步模型下的情况，主要结论有两条。&lt;/p>
&lt;ol>
&lt;li>
&lt;p>在异步模型下不存在一个完全正确的共识算法。不仅上述较&amp;quot;强&amp;quot;形式的共识算法不可能实现，FLP 还证明了比它弱一些的、只需要有一些无错误的进程做决定就足够的共识算法也是不可能实现的。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>在异步模型下存在一个部分正确的共识算法，前提是所有无错误的进程都总能做出一个决定，此外没有进程会在它的执行过程中死亡，并且初始情况下超过半数进程都是存活状态。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>FLP 的结论是，在异步模型中，仅一个处理者可能崩溃的情况下，就已经没有分布式算法能解决共识问题。这是该问题的理论上界。其背后的原因在于，异步模型下对于一个处理者完成工作然后再回复消息所需的时间并没有上界。因此，无法判断出一个处理者到底是崩溃了，还是在用较长的时间来回复，或者是网络有很大的延迟。&lt;/p>
&lt;p>FLP 不可能性对我们还有别的启发。一是网络延迟很重要，网络不能长时间处于拥塞状态，否则共识算法将可能因为网络延迟过长而导致超时失败。二是计算时间也很重要。对于需要计算共识的处理过程（进程），如分布式数据库提交，需要在短时间里就计算出能否提交的结果，那就要保证计算结点资源充分，特别是内存容量、磁盘空闲时间和 CPU 时间方面要足够，并在软件层面确保计算不超时。&lt;/p>
&lt;p>另一个问题是，像 Paxos 这样的共识算法为什么可行？实际上它并不属于 FLP 不可能性证明中所说的&amp;quot;完全正确&amp;quot;的算法。它的正确性会受超时值的影响。但这并不妨碍它在实践中有效，因为我们可以通过避免网络拥塞等手段来保证超时值是合适的。&lt;/p>
&lt;h2 id="an-introduction-to-distributed-systemshttpsgithubcomaphyrdistsys-class">&lt;a href="https://github.com/aphyr/distsys-class">An introduction to distributed systems&lt;/a>&lt;/h2>
&lt;p>它是&lt;a href="https://github.com/aphyr/distsys-class#review-1">分布式系统基础课&lt;/a>的课程提纲，也是一份很棒的分布式系统介绍，几乎涵盖了所有知识点，并辅以简洁并切中要害的说明文字，非常适合初学者提纲挈领地了解知识全貌，快速与现有知识结合，形成知识体系。此外，还可以把它作为分布式系统的知识图谱，根据其中列出的知识点一一搜索，你能学会所有的东西。&lt;/p>
&lt;h2 id="distributed-systems-for-fun-and-profithttpbookmixunetdistsyssingle-pagehtml">&lt;a href="http://book.mixu.net/distsys/single-page.html">Distributed Systems for fun and profit&lt;/a>&lt;/h2>
&lt;p>这是一本免费的电子书。作者撰写此书的目的是希望以一种更易于理解的方式，讲述以亚马逊的 Dynamo、谷歌的 BigTable 和 MapReduce 等为代表的分布式系统背后的核心思想。&lt;/p>
&lt;p>因而，书中着力撰写分布式系统中的关键概念，以便让读者能够快速了解最为核心的知识，并且进行了足够详实的讲述，方便读者体会和理解，又不至于陷入细节。&lt;/p>
&lt;p>全书分为五章，讲述了扩展性、可用性、性能和容错等基础知识，FLP 不可能性和 CAP 定理，探讨了大量的一致性模型；讨论了时间和顺序，及时钟的各种用法。随后，探讨了复制问题，如何防止差异，以及如何接受差异。此外，每章末尾都给出了针对本章内容的扩展阅读资源列表，这些资料是对本书内容的很好补充。&lt;/p>
&lt;h2 id="distributed-systems-principles-and-paradigmshttpbarbieutaedujliresourcesmapreducehadoopdistributed20systems20principles20and20paradigmspdf">&lt;a href="http://barbie.uta.edu/~jli/Resources/MapReduce&amp;amp;Hadoop/Distributed%20Systems%20Principles%20and%20Paradigms.pdf">Distributed Systems: Principles and Paradigms&lt;/a>&lt;/h2>
&lt;p>本书是由计算机科学家安德鲁·斯图尔特·塔能鲍姆（Andrew S. Tanenbaum）和其同事马丁·范·斯蒂恩（Martin van Steen）合力撰写的，是分布式系统方面的经典教材。&lt;/p>
&lt;p>语言简洁，内容通俗易懂，介绍了分布式系统的七大核心原理，并给出了大量的例子；系统讲述了分布式系统的概念和技术，包括通信、进程、命名、同步化、一致性和复制、容错以及安全等；讨论了分布式应用的开发方法（即范型）。&lt;/p>
&lt;p>但本书不是一本指导&amp;quot;如何做&amp;quot;的手册，仅适合系统性地学习基础知识，了解编写分布式系统的基本原则和逻辑。中文翻译版为&lt;a href="https://item.jd.com/10079452.html">《分布式系统原理与范型》（第二版）&lt;/a>。&lt;/p>
&lt;h2 id="scalable-web-architecture-and-distributed-systemshttpwwwaosabookorgendistsyshtml">&lt;a href="http://www.aosabook.org/en/distsys.html">Scalable Web Architecture and Distributed Systems&lt;/a>&lt;/h2>
&lt;p>这是一本免费的在线小册子，其中文翻译版为&lt;a href="http://nettee.github.io/posts/2016/Scalable-Web-Architecture-and-Distributed-Systems/">可扩展的 Web 架构和分布式系统&lt;/a>。&lt;/p>
&lt;p>本书主要针对面向的互联网（公网）的分布式系统，但其中的原理或许也可以应用于其他分布式系统的设计中。作者的观点是，通过了解大型网站的分布式架构原理，小型网站的构建也能从中受益。本书从大型互联网系统的常见特性，如高可用、高性能、高可靠、易管理等出发，引出了一个类似于 Flickr 的典型的大型图片网站的例子。&lt;/p>
&lt;p>首先，从程序模块化易组合的角度出发，引出了面向服务架构（SOA）的概念。同时，引申出写入和读取两者的性能问题，及对此二者如何调度的考量&amp;mdash;&amp;mdash;在当今的软硬件架构上，写入几乎总是比读取更慢，包括软件层面引起的写入慢（如数据库的一致性要求和 B 树的修改）和硬件层面引起的写入慢（如 SSD）。&lt;/p>
&lt;p>网络提供商提供的下载带宽也通常比上传带宽更大。读取往往可以异步操作，还可以做 gzip 压缩。写入则往往需要保持连接直到数据上传完成。因此，往往我们会想把服务做成读写分离的形式。然后通过一个 Flickr 的例子，介绍了他们的服务器分片式集群做法。&lt;/p>
&lt;p>接下来讲了冗余。数据的冗余异地备份（如 master-slave）、服务的多版本冗余、避免单点故障等。&lt;/p>
&lt;p>随后，在冗余的基础上，讲了多分区扩容，亦即横向扩容。横向扩容是在单机容量无法满足需求的情况下不得不做的设计。但横向扩容会带来一个问题，即数据的局域性会变差。本来数据可以存在于同一台服务器上，但现在数据不得不存在于不同服务器上，潜在地降低了系统的性能（主要是可能延长响应时间）。另一个问题是多份数据的不一致性。&lt;/p>
&lt;p>之后，本书开始深入讲解数据访问层面的设计。首先抛出一个大型数据（TB 级以上）的存储问题。如果内存都无法缓存该数据量，性能将大幅下降，那么就需要缓存数据。数据可以缓存在每个节点上。&lt;/p>
&lt;p>但如果为所有节点使用负载均衡，那么分配到每个节点的请求将十分随机，大大降低缓存命中率，从而导致低效的缓存。接下来考虑全局缓存的设计。再接下来考虑分布式缓存的设计。进一步，介绍了 Memcached，以及 Facebook 的缓存设计方案。&lt;/p>
&lt;p>代理服务器则可以用于把多个重复请求合并成一个，对于公网上的公共服务来说，这样做可以大大减少对数据层访问的次数。Squid 和 Varnish 是两个可用于生产的代理服务软件。&lt;/p>
&lt;p>当知道所需要读取的数据的元信息时，比如知道一张图片的 URL，或者知道一个要全文搜索的单词时，索引就可以帮助找到那几台存有该信息的服务器，并从它们那里获取数据。文中扩展性地讨论了本话题。&lt;/p>
&lt;p>接下来谈负载均衡器，以及一些典型的负载均衡拓扑。然后讨论了对于用户会话数据如何处理。比如，对于电子商务网站，用户的购物车在没有下单之前都必须保持有效。&lt;/p>
&lt;p>一种办法是让用户会话与服务器产生关联，但这样做会较难实现自动故障转移，如何做好是个问题。另外，何时该使用负载均衡是个问题。有时节点数量少的情况下，只要使用轮换式 DNS 即可。负载均衡也会让在线性能问题的检测变得更麻烦。&lt;/p>
&lt;p>对于写入的负载，可以用队列的方式来减少对服务器的压力，保证服务器的效率。消息队列的开源实现有很多，如 RabbitMQ、ActiveMQ、BeanstalkD，但有些队列方案也使用了如 Zookeeper，甚至是像 Redis 这样的存储服务。&lt;/p>
&lt;p>本书主要讲述了高性能互联网分布式服务的架构方案，并介绍了许多实用的工具。作者指出这是一个令人兴奋的设计领域，虽然只讲了一些皮毛，但这一领域不仅现在有很多创新，将来也会越来越多。&lt;/p>
&lt;h2 id="principles-of-distributed-systemshttpdcgethzchlecturespodc_allstarslecturepodcpdf">&lt;a href="http://dcg.ethz.ch/lectures/podc_allstars/lecture/podc.pdf">Principles of Distributed Systems&lt;/a>&lt;/h2>
&lt;p>本书是苏黎世联邦理工学院的教材。它讲述了多种分布式系统中会用到的算法。虽然分布式系统的不同场景会用到不同算法，但并不表示这些算法都会被用到。不过，对于学生来说，掌握了算法设计的精髓也就能举一反三地设计出解决其他问题的算法，从而得到分布式系统架构设计中所需的算法。&lt;/p>
&lt;p>本书覆盖的算法有：&lt;/p>
&lt;ul>
&lt;li>顶点涂色算法（可用于解决互相冲突的任务分配问题）&lt;/li>
&lt;li>分布式的树算法（广播算法、会聚算法、广度优先搜索树算法、最小生成树算法）&lt;/li>
&lt;li>容错以及 Paxos（Paxos 是最经典的共识算法之一）&lt;/li>
&lt;li>拜占庭协议（节点可能没有完全宕机，而是输出错误的信息）&lt;/li>
&lt;li>全互联网络（服务器两两互联的情况下算法的复杂度）&lt;/li>
&lt;li>多核计算的工程实践（事务性存储、资源争用管理）&lt;/li>
&lt;li>主导集（又一个用随机化算法打破对称性的例子；这些算法可以用于路由器建立路由）&lt;/li>
&lt;li>&amp;hellip;&amp;hellip;&lt;/li>
&lt;/ul>
&lt;p>这些算法对你迈向更高级更广阔的技术领域真的相当有帮助的。&lt;/p>
&lt;h2 id="making-reliable-distributed-systems-in-the-presence-of-software-errorshttpsgithubcomtheanalystawesome-distributed-systemsblobmasterreadmemd">&lt;a href="https://github.com/theanalyst/awesome-distributed-systems/blob/master/README.md">Making reliable distributed systems in the presence of software errors&lt;/a>&lt;/h2>
&lt;p>这本书的书名直译过来是在有软件错误的情况下，构建可靠的分布式系统，Erlang 之父乔·阿姆斯特朗（Joe Armstrong）的力作。书中撰写的内容是从 1981 年开始的一个研究项目的成果，这个项目是寻找更好的电信应用编程方式。&lt;/p>
&lt;p>当时的电信应用都是大型程序，虽然经过了仔细的测试，但投入使用时程序中仍会存在大量的错误。作者及其同事假设这些程序中确实有错误，然后想法设法在这些错误存在的情况下构建可靠的系统。他们测试了所有的编程语言，没有一门语言拥有电信行业所需要的所有特性，所以促使一门全新的编程语言 Erlang 的开发，以及随之出现的构建健壮系统（OTP）的设计方法论和库集。&lt;/p>
&lt;p>书中抽象了电信应用的所有需求，定义了问题域，讲述了系统构建思路&amp;mdash;&amp;mdash;模拟现实，简单通用，并给出了指导规范。阿姆斯特朗认为，在存在软件错误的情况下，构建可靠系统的核心问题可以通过编程语言或者编程语言的标准库来解决。所以本书有很大的篇幅来介绍 Erlang，以及如何运用其构建具有容错能力的电信应用。&lt;/p>
&lt;p>虽然书中的内容是以构建 20 世纪 80 年代的电信系统为背景，但是这种大规模分布式的系统开发思路，以及对系统容错能力的核心需求，与互联网时代的分布式系统架构思路出奇一致。书中对问题的抽象、总结，以及解决问题的思路和方案，有深刻的洞察和清晰的阐释，所以此书对现在的项目开发和架构有极强的指导和借鉴意义。&lt;/p>
&lt;h2 id="designing-data-intensive-applicationshttpswwwamazoncomdesigning-data-intensive-applications-reliable-maintainabledp1449373321">&lt;a href="https://www.amazon.com/Designing-Data-Intensive-Applications-Reliable-Maintainable/dp/1449373321">Designing Data Intensive Applications&lt;/a>&lt;/h2>
&lt;p>这是一本非常好的书。我们知道，在分布式的世界里，数据结点的扩展是一件非常麻烦的事。而这本书则深入浅出地用很多工程案例讲解了如何让数据结点做扩展。&lt;/p>
&lt;p>作者马丁·科勒普曼（Martin Kleppmann）在分布式数据系统领域有着很深的功底，并在这本书中完整地梳理各类纷繁复杂设计背后的技术逻辑，不同架构之间的妥协与超越，很值得开发人员与架构设计者阅读。&lt;/p>
&lt;p>这本书深入到 B-Tree、SSTables、LSM 这类数据存储结构中，并且从外部的视角来审视这些数据结构对 NoSQL 和关系型数据库所产生的影响。它可以让你很清楚地了解到真正世界的大数据架构中的数据分区、数据复制的一些坑，并提供了很好的解决方案。&lt;/p>
&lt;p>&lt;strong>最赞的是，作者将各种各样的技术的本质非常好地关联在一起，帮你触类旁通&lt;/strong>。而且抽丝剥茧，循循善诱，从&amp;quot;提出问题&amp;quot;，到&amp;quot;解决问题&amp;quot;，到&amp;quot;解决方案&amp;quot;，再到&amp;quot;优化方案&amp;quot;和&amp;quot;对比不同的方案&amp;quot;，一点一点地把非常晦涩的技术和知识展开。&lt;/p>
&lt;p>本书的引用相当多，每章后面都有几百个 Reference。通过这些 Reference，你可以看到更为广阔更为精彩的世界。&lt;/p>
&lt;p>这本书是 2017 年 3 月份出版的，目前还没有中译版，不过英文也不难读。非常推荐。这里有&lt;a href="http://www.antonfagerberg.com/files/intensive.pdf">这本书的 PPT&lt;/a>，你可从这个 PPT 中管中窥豹一下。&lt;/p>
&lt;h1 id="小结">小结&lt;/h1>
&lt;p>在今天的文章中，我给出了一些分布式系统的基础理论知识和几本很不错的图书和资料，需要慢慢消化吸收。也许你看到这么庞大的书单和资料列表有点望而却步，但是我真的希望你能够花点时间来看看这些资料。相信你看完这些资料后，一定能上一个新的台阶。再加上一些在工程项目中的实践，我保证你，一定能达到大多数人难以企及的技术境界。&lt;/p>
&lt;p>自从 2002 年开始接触分布式计算系统至今，我学习分布式系统已经有 15 年了，发现还有很多东西还要继续学习。是的，学无止境啊。如果你想成为一名很不错的架构师，你一定要好好学习这些知识。&lt;/p>
&lt;p>&lt;strong>2018 年新年来临，祝你新年快乐！&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/a3/bb/a321a64415498cbbf5222b3971accabb.png" alt="">&lt;br>
&lt;strong>插图来自电影《摔跤吧！爸爸》&lt;/strong>&lt;/p>
&lt;p>《分布式系统架构的本质》系列文章的目录如下，方便你查找自己关注的内容。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/1411">分布式系统架构的冰与火&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/1505">从亚马逊的实践，谈分布式系统的难点&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/1512">分布式系统的技术栈&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/1513">分布式系统关键技术：全栈监控&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/1604">分布式系统关键技术：服务调度&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/1609">分布式系统关键技术：流量与数据调度&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/1610">洞悉 PaaS 平台的本质&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/2080">推荐阅读：分布式系统架构经典资料&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/2421">推荐阅读：分布式数据调度相关论文&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/fc/e9/fcc761001867c60f526665e237f831e9.jpg" alt="">&lt;/p></description></item><item><title>极客专栏: 29丨推荐阅读：分布式数据调度相关论文</title><link>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E/29%E4%B8%A8%E6%8E%A8%E8%8D%90%E9%98%85%E8%AF%BB%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E8%B0%83%E5%BA%A6%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87/</link><pubDate>Fri, 27 May 2022 00:00:00 +0000</pubDate><guid>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E/29%E4%B8%A8%E6%8E%A8%E8%8D%90%E9%98%85%E8%AF%BB%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E8%B0%83%E5%BA%A6%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87/</guid><description>
&lt;p>我们在之前的系列文章《分布式系统架构的本质》中说过，分布式系统的一个关键技术是&amp;quot;数据调度&amp;quot;。因为我们需要扩充节点，提高系统的高可用性，所以必需冗余数据结点。&lt;/p>
&lt;p>建立数据结点的副本看上去容易，但其中最大的难点就是分布式一致性的问题。下面，我会带你看看数据调度世界中的一些技术点以及相关的技术论文。&lt;/p>
&lt;p>对于分布式的一致性问题，相信你在前面看过好几次下面这张图。从中，我们可以看出，Paxos 算法的重要程度。还有人说，分布式下真正的一致性算法只有 Paxos。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/95/50/95e0fd0862be0e3489713687bf363f50.png" alt="">&lt;/p>
&lt;h1 id="paxos-算法">Paxos 算法&lt;/h1>
&lt;p>Paxos 算法，是莱斯利·兰伯特（Lesile Lamport）于 1990 年提出来的一种基于消息传递且具有高度容错特性的一致性算法。但是这个算法太过于晦涩，所以，一直以来都属于理论上的论文性质的东西。&lt;/p>
&lt;p>其进入工程圈的源头在于 Google 的 Chubby lock&amp;mdash;&amp;mdash;一个分布式的锁服务，用在了 Bigtable 中。直到 Google 发布了下面的这两篇论文，Paxos 才进入到工程界的视野中来。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;a href="https://static.googleusercontent.com/media/research.google.com/en//archive/bigtable-osdi06.pdf">Bigtable: A Distributed Storage System for Structured Data&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://static.googleusercontent.com/media/research.google.com/en//archive/chubby-osdi06.pdf">The Chubby lock service for loosely-coupled distributed systems&lt;/a>&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>Google 与 Big Table 相齐名的还有另外两篇论文。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;a href="https://static.googleusercontent.com/media/research.google.com/en//archive/gfs-sosp2003.pdf">The Google File System&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://static.googleusercontent.com/media/research.google.com/en//archive/mapreduce-osdi04.pdf">MapReduce: Simplifed Data Processing on Large Clusters&lt;/a>&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>不过，这几篇论文中并没有讲太多的 Paxos 算法细节上的内容，反而在论文&lt;a href="https://static.googleusercontent.com/media/research.google.com/en//archive/paxos_made_live.pdf">Paxos Made Live &amp;ndash; An Engineering Perspective&lt;/a> 中提到了很多工程实现的细节。比如，Google 实现 Paxos 时遇到的各种问题和解决方案，讲述了从理论到实际应用二者之间巨大的鸿沟。&lt;/p>
&lt;p>尤其在满地都是坑的分布式系统领域，这篇论文没有过多讨论 Paxos 算法本身，而是在讨论如何将理论应用到实践，如何弥补理论在实践中的不足，如何取舍，如何测试，这些在实践中的各种问题才是工程的魅力。所以建议你读一读。&lt;/p>
&lt;p>Paxos 算法的原版论文我在这里就不贴了，因为一来比较晦涩，二来也不易懂。推荐一篇比较容易读的&amp;mdash;&amp;mdash;&lt;a href="http://harry.me/blog/2014/12/27/neat-algorithms-paxos/">Neat Algorithms - Paxos&lt;/a> ，这篇文章中还有一些小动画帮助你读懂。还有一篇可以帮你理解的文章是&lt;a href="https://angus.nyc/2012/paxos-by-example/">Paxos by Examples&lt;/a>。&lt;/p>
&lt;p>如果你要自己实现 Paxos 算法，这里有几篇文章供你参考。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;a href="http://www.inf.usi.ch/faculty/pedone/MScThesis/marco.pdf">Paxos Made Code&lt;/a> ，作者是马克罗·普里米 (Macro Primi)，他实现了一个 Paxos 开源库&lt;a href="http://libpaxos.sourceforge.net/">libpaxos&lt;/a>。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="http://www.cnds.jhu.edu/pub/papers/cnds-2008-2.pdf">Paxos for System Builders&lt;/a> ，从一个系统实现者的角度讨论了实现 Paxos 的诸多具体问题，比如 Leader 选举、数据及消息类型、流控等。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="http://www.cs.cornell.edu/courses/cs7412/2011sp/paxos.pdf">Paxos Made Moderately Complex&lt;/a>，这篇文章比较新，是 2011 年才发表的。文中介绍了很多实现细节，并提供了很多伪代码，一方面可以帮助理解 Paxos，另一方面也可以据此实现一个 Paxos。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://web.stanford.edu/class/cs340v/papers/paxos.pdf">Paxos Made Practical&lt;/a>主要介绍如何采用 Paxos 实现 replication。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>除了马克罗·普里米的那个开源实现外，到 GitHub 上找一下，你就会看到这些项目：&lt;a href="https://github.com/cocagne/paxos">Plain Paxos Implementations Python &amp;amp; Java&lt;/a>、&lt;a href="https://github.com/xiang90/paxos">A go implementation of the Paxos algorithm&lt;/a> 。&lt;/p>
&lt;p>ZooKeeper 有和 Paxos 非常相似的一些特征，比如领导选举、提案号等，但是它本质上不是 Paxos 协议，而是自己发明的 Zab 协议，有兴趣的话，可以读一下这篇论文：&lt;br>
&lt;a href="https://pdfs.semanticscholar.org/fc11/031895c302dc52404d34de58af1a72f3b817.pdf">Zab: High-Performance broadcast for primary-backup systems&lt;/a>。&lt;/p>
&lt;p>上述的 Google File System、MapReduce、Bigtable 并称为&amp;quot;谷三篇&amp;quot;。基本上来说，整个世界工程系统因为这三篇文章，开始向分布式系统演化，而云计算中的很多关键技术也是因为这三篇文章才得以成熟。 后来，雅虎公司也基于这三篇论文开发了一个开源的软件&amp;mdash;&amp;mdash;Hadoop。&lt;/p>
&lt;h1 id="raft-算法">Raft 算法&lt;/h1>
&lt;p>因为 Paxos 算法太过于晦涩，而且在实际的实现上有太多的坑，并不太容易写对。所以，有人搞出了另外一个一致性的算法，叫 Raft。其原始论文是&lt;a href="https://raft.github.io/raft.pdf">In search of an Understandable Consensus Algorithm (Extended Version)&lt;/a>寻找一种易于理解的 Raft 算法。这篇论文的译文在 InfoQ 上《&lt;a href="http://www.infoq.com/cn/articles/raft-paper">Raft 一致性算法论文译文&lt;/a>》，推荐你读一读。&lt;/p>
&lt;p>Raft 算法和 Paxos 的性能和功能是一样的，但是它和 Paxos 算法的结构不一样，这使 Raft 算法更容易理解并且更容易实现。那么 Raft 是怎样做到的呢？&lt;/p>
&lt;p>Raft 把这个一致性的算法分解成了几个部分，一个是领导选举（Leader Selection），一个是日志复制（Log Replication），一个是安全性（Safety），还有一个是成员变化（Membership Changes）。对于一般人来说，Raft 协议比 Paxos 的学习曲线更低，也更平滑。&lt;/p>
&lt;p>Raft 协议中有一个状态机，每个结点会有三个状态，分别是 Leader、Candidate 和 Follower。Follower 只响应其他服务器的请求，如果没有收到任何信息，它就会成为一个 Candidate，并开始进行选举。收到大多数人同意选票的人会成为新的 Leader。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/40/33/408fe585546319dbe0e6c8422dc0e733.png" alt="">&lt;/p>
&lt;p>一旦选举出了一个 Leader，它就开始负责服务客户端的请求。每个客户端的请求都包含一个要被复制状态机执行的指令。Leader 首先要把这个指令追加到 log 中形成一个新的 entry，然后通过 AppendEntries RPC 并行地把该 entry 发给其他服务器（server）。如果其他服务器没发现问题，复制成功后会给 Leader 一个表示成功的 ACK。&lt;/p>
&lt;p>Leader 收到大多数 ACK 后应用该日志，返回客户端执行结果。如果 Follower 崩溃 （crash）或者丢包，Leader 会不断重试 AppendEntries RPC。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/04/9f/0428dd28b89eba37de4e13ff9093ba9f.png" alt="">&lt;/p>
&lt;p>这里推荐几个不错的 Raft 算法的动画演示。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;a href="http://thesecretlivesofdata.com/raft/">Raft &amp;ndash; The Secret Lives of Data&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://raft.github.io/">Raft Consensus Algorithm&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="http://kanaka.github.io/raft.js/">Raft Distributed Consensus Algorithm Visualization&lt;/a>&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h1 id="逻辑钟和向量钟">逻辑钟和向量钟&lt;/h1>
&lt;p>后面，业内又搞出来一些工程上的东西，比如 Amazon 的 DynamoDB，其论文&lt;a href="http://bnrg.eecs.berkeley.edu/~randy/Courses/CS294.F07/Dynamo.pdf">Dynamo: Amazon&amp;rsquo;s Highly Available Key Value Store&lt;/a> 的影响力也很大。这篇论文中讲述了 Amazon 的 DynamoDB 是如何满足系统的高可用、高扩展和高可靠要求的，其中还展示了系统架构是如何做到数据分布以及数据一致性的。&lt;/p>
&lt;p>GFS 采用的是查表式的数据分布，而 DynamoDB 采用的是计算式的，也是一个改进版的通过虚拟结点减少增加结点带来数据迁移的一致性哈希。另外，这篇论文中还讲述了一个 NRW 模式用于让用户可以灵活地在 CAP 系统中选取其中两项，这使用到了 Vector Clock&amp;mdash;&amp;mdash;向量时钟来检测相应的数据冲突。最后还介绍了使用 Handoff 的机制对可用性的提升。&lt;/p>
&lt;p>这篇文章中有几个关键的概念，一个是 Vector Clock，另一个是 Gossip 协议。&lt;/p>
&lt;p>提到向量时钟就需要提一下逻辑时钟。所谓逻辑时间，也就是在分布系统中为了解决消息有序的问题，由于在不同的机器上有不同的本地时间，这些本地时间的同步很难搞，会导致消息乱序。&lt;/p>
&lt;p>于是 Paxos 算法的发明人兰伯特（Lamport）搞了个向量时钟，每个系统维护一个本地的计数器，这就是所谓的逻辑时钟。每执行一个事件（例如向网络发送消息，或是交付到应用层）都对这个计数器做加 1 操作。当跨系统的时候，在消息体上附着本地计算器，当接收端收到消息时，更新自己的计数器（取对端传来的计数器和自己当成计数器的最大值），也就是调整自己的时钟。&lt;/p>
&lt;p>逻辑时钟可以保证，如果事件 A 先于事件 B，那么事件 A 的时钟一定小于事件 B 的时钟，但是返过来则无法保证，因为返过来没有因果关系。所以，向量时钟解释了因果关系。向量时钟维护了数据更新的一组版本号（版本号其实就是使用逻辑时钟）。&lt;/p>
&lt;p>假如一个数据需要存在三个结点上 A、B、C。那么向量维度就是 3，在初始化的时候，所有结点对于这个数据的向量版本是 [A:0, B:0, C:0]。当有数据更新时，比如从 A 结点更新，那么，数据的向量版本变成 [A:1, B:0, C:0]，然后向其他结点复制这个版本，其在语义上表示为我当前的数据是由 A 结果更新的，而在逻辑上则可以让分布式系统中的数据更新的顺序找到相关的因果关系。&lt;/p>
&lt;p>这其中的逻辑关系，你可以看一下&lt;a href="http://lass.cs.umass.edu/~shenoy/courses/spring05/lectures.html">马萨诸塞大学课程 Distributed Operating System&lt;/a>中第 10 节&lt;a href="http://lass.cs.umass.edu/~shenoy/courses/spring05/lectures/Lec10.pdf">Clock Synchronization&lt;/a>这篇讲议。关于 Vector Clock，你可以看一下&lt;a href="http://basho.com/posts/technical/why-vector-clocks-are-easy/">Why Vector Clocks are Easy&lt;/a>和&lt;a href="http://basho.com/posts/technical/why-vector-clocks-are-hard/">Why Vector Clocks are Hard&lt;/a> 这两篇文章。&lt;/p>
&lt;h1 id="gossip-协议">Gossip 协议&lt;/h1>
&lt;p>另外，DynamoDB 中使用到了 Gossip 协议来做数据同步，这个协议的原始论文是 &lt;a href="https://www.cs.cornell.edu/home/rvr/papers/flowgossip.pdf">Efficient Reconciliation and Flow Control for Anti-Entropy Protocols&lt;/a>。Gossip 算法也是 Cassandra 使用的数据复制协议。这个协议就像八卦和谣言传播一样，可以 &amp;ldquo;一传十、十传百&amp;quot;传播开来。但是这个协议看似简单，细节上却非常麻烦。&lt;/p>
&lt;p>根据这篇论文，节点之间存在三种通信方式。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>push 方式。A 节点将数据 (key,value,version) 及对应的版本号推送给 B 节点，B 节点更新 A 中比自己新的数据。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>pull 方式。A 仅将数据 key,version 推送给 B，B 将本地比 A 新的数据 (key,value,version) 推送给 A，A 更新本地。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>push/pull 方式。与 pull 类似，只是多了一步，A 再将本地比 B 新的数据推送给 B，B 更新本地。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>如果把两个节点数据同步一次定义为一个周期，那么在一个周期内，push 需通信 1 次，pull 需 2 次，push/pull 则需 3 次。从效果上来讲，push/pull 最好，理论上一个周期内可以使两个节点完全一致。直观感觉上，也是 push/pull 的收敛速度最快。&lt;/p>
&lt;p>另外，每个节点上的又需要一个协调机制，也就是如何交换数据能达到最快的一致性&amp;mdash;&amp;mdash;消除节点的不一致性。上面所讲的 push、pull 等是通信方式，协调是在通信方式下的数据交换机制。&lt;/p>
&lt;p>协调所面临的最大问题是，一方面需要找到一个经济的方式，因为不可能每次都把一个节点上的数据发送给另一个节点；另一方面，还需要考虑到相关的容错方式，也就是当因为网络问题不可达的时候，怎么办？&lt;/p>
&lt;p>一般来说，有两种机制：一种是以固定概率传播的 Anti-Entropy 机制，另一种是仅传播新到达数据的 Rumor-Mongering 机制。前者有完备的容错性，但是需要更多的网络和 CPU 资源，后者则反过来，不耗资源，但在容错性上难以保证。&lt;/p>
&lt;p>Anti-Entropy 的机制又分为 Precise Reconciliation（精确协调）和 Scuttlebutt Reconciliation（整体协调）这两种。前者希望在每次通信周期内都非常精确地消除双方的不一致性，具体表现就是互发对方需要更新的数据。因为每个结点都可以读写，所以这需要每个数据都要独立维护自己的版本号。&lt;/p>
&lt;p>而整体协调与精确协调不同的是，整体协调不是为每个数据都维护单独的版本号，而是每个节点上的数据统一维护一个版本号，也就是一个一致的全局版本。这样与其他结果交换数据的时候，就只需要比较节点版本，而不是数据个体的版本，这样会比较经济一些。如果版本不一样，则需要做精确协调。&lt;/p>
&lt;p>因为篇幅问题，这里就不多说了，你可以看看原始的论文，还可以去看看 Cassandra 中的源码，以及到 GitHub 搜一下其他人的实现。多说一句，Cassandra 的实现是基于整体协调的 push/pull 模式。&lt;/p>
&lt;p>关于 Gossip 的一些图示化的东西，你可以看一下动画&lt;a href="https://rrmoelker.github.io/gossip-visualization/">gossip visualization&lt;/a>。&lt;/p>
&lt;h1 id="分布式数据库方面">分布式数据库方面&lt;/h1>
&lt;p>上面讲的都是一些基本概念相关的东西，下面我们来谈谈数据库方面的一些论文。&lt;/p>
&lt;p>一篇是 AWS Aurora 的论文 &lt;a href="http://www.allthingsdistributed.com/files/p1041-verbitski.pdf">Amazon Aurora: Design Considerations for High Throughput Cloud &amp;ndash;Native Relation Databases&lt;/a>。&lt;/p>
&lt;p>Aurora 是 AWS 将 MySQL 的计算和存储分离后，计算节点 scale up，存储节点 scale out。并把其 redo log 独立设计成一个存储服务，把分布式的数据方面的东西全部甩给了底层存储系统。从而提高了整体的吞吐量和水平的扩展能力。&lt;/p>
&lt;p>Aurora 要写 6 份拷贝，但是其只需要把一个 Quorum 中的日志写成功就可以了。如下所示。可以看到，将存储服务做成一个跨数据中心的服务，提高数据库容灾，降低性能影响。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/70/eb/70eac246964e3ef8ad5100944bf5bdeb.png" alt="">&lt;/p>
&lt;p>对于存储服务的设计，核心的原理就是 latency 一定要低，毕竟写 6 个 copy 是一件开销很大的事。所以，基本上来说，Aurora 用的是异步模型，然后拼命地做并行处理，其中用到的也是 Gossip 协议。如下所示。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/7f/81/7f89ba6764ede9fc4df223e541179381.png" alt="">&lt;/p>
&lt;p>在上面这个图中，我们可以看到，完成前两步，就可以 ACK 回调用方。也就是说，只要数据在本地落地了，就可以返回成功了。然后，对于六个副本，这个 log 会同时发送到 6 个存储结点，只需要有大于 4 个成功 ACK，就算写成功了。第 4 步我们可以看到用的是 Gossip 协议。然后，第 5 步产生 cache 页，便于查询。第 6 步在 S3 做 Snapshot，类似于 Checkpoint。&lt;/p>
&lt;p>第二篇比较有代表的论文是 Google 的 &lt;a href="http://static.googleusercontent.com/media/research.google.com/zh-CN//archive/spanner-osdi2012.pdf">Spanner: Google&amp;rsquo;s Globally-Distributed Database&lt;/a>。&lt;br>
Spanner 是 Google 的全球分布式数据库 Globally-Distributed Database) 。Spanner 的扩展性达到了令人咋舌的全球级，可以扩展到数百万台机器，数以百计的数据中心，上万亿的行。更给力的是，除了夸张的扩展性之外，它还能同时通过同步复制和多版本来满足外部一致性，可用性也是很好的。&lt;/p>
&lt;p>下面是 Spanserver 的一个架构。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/11/8e/116a697f8753877308661a69a9af0a8e.png" alt="">&lt;/p>
&lt;p>我们可以看到，每个数据中心都会有一套 Colossus，这是第二代的 GFS。每个机器有 100-1000 个 tablet，也就是相当数据库表中的行集，物理存储就是数据文件。比如，一张表有 2000 行，然后有 20 个 tablet，那么每个 tablet 分别有 100 行数据。&lt;/p>
&lt;p>在 tablet 上层通过 Paxos 协议进行分布式跨数据中心的一致性数据同步。Paxos 会选出一个 replica 做 Leader，这个 Leader 的寿命默认是 10s，10s 后重选。Leader 就相当于复制数据的 master，其他 replica 的数据都是从它那里复制的。读请求可以走任意的 replica，但是写请求只有去 Leader。这些 replica 统称为一个 Paxos Group。&lt;/p>
&lt;p>Group 之间也有数据交互传输，Google 定义了最小传输复制单元 directory，是一些有共同前缀的 key 记录，这些 key 也有相同的 replica 配置属性。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/e8/68/e85a1bf5efac06601fd6c5e9b75aa068.png" alt="">&lt;/p>
&lt;p>目前，基于 Spanner 论文的开源实现有两个，一个是 Google 公司自己的人出来做的&lt;a href="https://github.com/cockroachdb/cockroach">CockroachDB&lt;/a>，另一个是国人做的&lt;a href="https://github.com/pingcap/tidb">TiDB&lt;/a>。&lt;/p>
&lt;h1 id="小结">小结&lt;/h1>
&lt;p>正如我在之前的分布式系统的本质文章里所说到的，分布式的服务的调度需要一个分布式的存储系统来支持服务的数据调度。而我们可以看到，各大公司都在分布式的数据库上做各种各样的创新，他们都在使用底层的分布式文件系统来做存储引擎，把存储和计算分离开来，然后使用分布式一致性的数据同步协议的算法来在上层提供高可用、高扩展的支持。&lt;/p>
&lt;p>从这点来看，可以预见到，过去的分库分表并通过一个数据访问的代理服务的玩法，应该在不久就会过时就会成为历史。真正的现代化的分布式数据存储就是 Aurora 和 Spanner 这样的方式。&lt;/p>
&lt;p>通过上面的这些论文和相关的工程实践以及开源项目，相信可以让你在细节方面对分布式中最难的一块&amp;mdash;&amp;mdash;数据调度方面有更多的认识。&lt;/p>
&lt;p>(&lt;strong>这篇文章中提到了大量的英文文章和论文，担心读者听音频时很难理解和对应，所以没有录制音频，敬望谅解。&lt;/strong>)&lt;/p>
&lt;p>《分布式系统架构的本质》系列文章的目录如下，方便你查找自己关注的内容。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/1411">分布式系统架构的冰与火&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/1505">从亚马逊的实践，谈分布式系统的难点&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/1512">分布式系统的技术栈&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/1513">分布式系统关键技术：全栈监控&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/1604">分布式系统关键技术：服务调度&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/1609">分布式系统关键技术：流量与数据调度&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/1610">洞悉 PaaS 平台的本质&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/2080">推荐阅读：分布式系统架构经典资料&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/2421">推荐阅读：分布式数据调度相关论文&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/fc/e9/fcc761001867c60f526665e237f831e9.jpg" alt="">&lt;/p></description></item><item><title>极客专栏: 30丨编程范式游记（1）-起源</title><link>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E/30%E4%B8%A8%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F%E6%B8%B8%E8%AE%B01-%E8%B5%B7%E6%BA%90/</link><pubDate>Fri, 27 May 2022 00:00:00 +0000</pubDate><guid>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E/30%E4%B8%A8%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F%E6%B8%B8%E8%AE%B01-%E8%B5%B7%E6%BA%90/</guid><description>
&lt;h1 id="序">序&lt;/h1>
&lt;p>现在很多的文章和演讲都在谈架构，很少有人再会谈及编程范式。然而， 这些基础性和本质性的话题，却是非常非常重要的。&lt;/p>
&lt;p>一方面，我发现在一些语言争论上，有很多人对编程语言的认识其实并不深；另一方面，通过编程语言的范式，我们不但可以知道整个编程语言的发展史，而且还能提高自己的编程技能写出更好的代码。&lt;/p>
&lt;p>&lt;strong>我希望通过一系列的文章带大家漫游一下各式各样的编程范式。&lt;/strong>（这一系列文章中代码量很大，很难用音频体现出来，所以没有录制音频，还望谅解。）&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/301">编程范式游记（1）- 起源&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/303">编程范式游记（2）- 泛型编程&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/2017">编程范式游记（3）- 类型系统和泛型的本质&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/2711">编程范式游记（4）- 函数式编程&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/2723">编程范式游记（5）- 修饰器模式&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/2729">编程范式游记（6）- 面向对象编程&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/2741">编程范式游记（7）- 基于原型的编程范式&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/2748">编程范式游记（8）- Go 语言的委托模式&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/2751">编程范式游记（9）- 编程的本质&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/2752">编程范式游记（10）- 逻辑编程范式&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/2754">编程范式游记（11）- 程序世界里的编程范式&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>这一经历可能有些漫长，途中也会有各式各样的各种语言的代码。但是我保证这一历程对于一个程序员来说是非常有价值的，因为你不但可以对主流编程语言的一些特性有所了解，而且当我们到达终点的时候，你还能了解到编程的本质是什么。&lt;/p>
&lt;p>这一系列文章中有各种语言的代码，其中有 C、C++、Python、Java、Scheme、Go、JavaScript、Prolog 等。所以，如果要能跟上本文的前因后果，你要对这几门比较主流的语言多少有些了解。&lt;/p>
&lt;p>而且，你需要在一线编写一段时间（大概 5 年以上吧）的代码，可能才能体会到这一系列文章的内涵。&lt;/p>
&lt;p>我根据每篇文章中所讲述的内容，将这一系列文章分为四个部分。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>第一部分：泛型编程&lt;/strong>，第 1~3 章，讨论了从 C 到 C++ 的泛型编程方法，并系统地总结了编程语言中的类型系统和泛型编程的本质。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>第二部分：函数式编程&lt;/strong>，第 4 章和第 5 章，讲述了函数式编程用到的技术，及其思维方式，并通过 Python 和 Go 修饰器的例子，展示了函数式编程下的代码扩展能力，以及函数的相互和随意拼装带来的好处。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>第三部分：面向对象编程&lt;/strong>，第 6~8 章，讲述与传统的编程思想相反，面向对象设计中的每一个对象都应该能够接受数据、处理数据并将数据传达给其它对象，列举了面向对象编程的优缺点，基于原型的编程范式，以及 Go 语言的委托模式。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>第四部分：编程本质和逻辑编程&lt;/strong>，第 9~11 章，先探讨了编程的本质：逻辑部分才是真正有意义的，控制部分只能影响逻辑部分的效率，然后结合 Prolog 语言介绍了逻辑编程范式，最后对程序世界里的编程范式进行了总结，对比了它们之间的不同。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>我会以每部分为一个发布单元，将这些文章陆续发表在专栏中。如果在编程范式方面，你有其他感兴趣的主题，欢迎留言给我。&lt;/p>
&lt;p>下面我们来说说什么是编程范式。编程范式的英语是 programming paradigm，范即模范之意，范式即模式、方法，是一类典型的编程风格，是指从事软件工程的一类典型的风格（可以对照&amp;quot;方法学&amp;quot;一词）。&lt;/p>
&lt;p>编程语言发展到今天，出现了好多不同的代码编写方式，但不同的方式解决的都是同一个问题，那就是如何写出更为通用、更具可重用性的代码或模块。&lt;/p>
&lt;p>如果你准备好了，就和我一起来吧。&lt;/p>
&lt;h1 id="先从-c-语言开始">先从 C 语言开始&lt;/h1>
&lt;p>为了讲清楚这个问题，我需要从 C 语言开始讲起。因为 C 语言历史悠久，而几乎现在看到的所有编程语言都是以 C 语言为基础来拓展的，不管是 C++、Java、C#、Go、Python、PHP、Perl、JavaScript、Lua，还是 Shell。&lt;/p>
&lt;p>自 C 语言问世 40 多年以来，其影响了太多太多的编程语言，到现在还一直被广泛使用，不得不佩服它的生命力。但是，我们也要清楚地知道，大多数 C Like 编程语言其实都是在改善 C 语言带来的问题。&lt;/p>
&lt;p>那 C 语言有哪些特性呢？我简单来总结下：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>C 语言是一个静态弱类型语言，在使用变量时需要声明变量类型，但是类型间可以有隐式转换；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>不同的变量类型可以用结构体（struct）组合在一起，以此来声明新的数据类型；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>C 语言可以用 &lt;code>typedef&lt;/code> 关键字来定义类型的别名，以此来达到变量类型的抽象；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>C 语言是一个有结构化程序设计、具有变量作用域以及递归功能的过程式语言；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>C 语言传递参数一般是以值传递，也可以传递指针；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>通过指针，C 语言可以容易地对内存进行低级控制，然而这引入了非常大的编程复杂度；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>编译预处理让 C 语言的编译更具有弹性，比如跨平台。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>C 语言的这些特性，可以让程序员在微观层面写出非常精细和精确的编程操作，让程序员可以在底层和系统细节上非常自由、灵活和精准地控制代码。&lt;/p>
&lt;p>然而，在代码组织和功能编程上，C 语言的上述特性，却不那么美妙了。&lt;/p>
&lt;h2 id="从-c-语言的一个简单例子说起">从 C 语言的一个简单例子说起&lt;/h2>
&lt;p>我们从 C 语言最简单的交换两个变量的 swap 函数说起，参看下面的代码。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">void&lt;/span> &lt;span style="color:#000">swap&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#204a87;font-weight:bold">int&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">*&lt;/span> &lt;span style="color:#000">x&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#204a87;font-weight:bold">int&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">*&lt;/span> &lt;span style="color:#000">y&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">int&lt;/span> &lt;span style="color:#000">temp&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">*&lt;/span>&lt;span style="color:#000">x&lt;/span>&lt;span style="color:#000;font-weight:bold">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ce5c00;font-weight:bold">*&lt;/span>&lt;span style="color:#000">x&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">*&lt;/span>&lt;span style="color:#000">y&lt;/span>&lt;span style="color:#000;font-weight:bold">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ce5c00;font-weight:bold">*&lt;/span>&lt;span style="color:#000">y&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span> &lt;span style="color:#000">tmp&lt;/span>&lt;span style="color:#000;font-weight:bold">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>你可以想一想，这里为什么要传指针？这里是 C 语言指针，因为如果你不用指针的话，那么参数变成传值，即函数的形参是调用实参的一个拷贝，函数里面对形参的修改无法影响实参的结果。为了要达到调用完函数后，实参内容的交换，必须要把实参的地址传递进来，也就是传指针。这样在函数里面做交换，实际变量的值也被交换了。&lt;/p>
&lt;p>然而，这个函数最大的问题就是它只能给 int 值用，这个世界上还有很多类型包括 double、float，这就是静态语言最糟糕的一个问题。&lt;/p>
&lt;h2 id="数据类型与现实世界的类比">数据类型与现实世界的类比&lt;/h2>
&lt;p>与现实世界类比一下，数据类型就好像螺帽一样，有多种接口方式：平口的、有十字的、有六角的等，而螺丝刀就像是函数，或是用来操作这些螺丝的算法或代码。我们发现，这些不同类型的螺帽（数据类型），需要我们为之适配一堆不同的螺丝刀。&lt;/p>
&lt;p>而且它们还有不同的尺寸（尺寸就代表它是单字节的，还是多字节的，比如整型的 int、long，浮点数的 float 和 double），这样复杂度一下就提高了，最终导致电工（程序员）工作的时候需要带下图这样的一堆工具。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/4a/3e/4a5e3c03a3aef6015cc93f5f11f8003e.png" alt="">&lt;/p>
&lt;p>这就是类型为编程带来的问题。要解决这个问题，我们还是来看一下现实世界。&lt;/p>
&lt;p>你应该见过下面图片中的这种经过优化的螺丝刀，上面手柄是一样的，拧螺丝的动作也是一样的，只是接口不一样。每次我看到这张图片的时候就在想，这密密麻麻的看着有 40 多种接口，不知道为什么人类世界要干出这么多的花样？你们这群人类究竟是要干什么啊。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/e9/85/e907bb9069217abbbe85f1819c1cbc85.png" alt="">&lt;/p>
&lt;p>我们可以看到，无论是传统世界，还是编程世界，我们都在干一件事情，什么事呢？&lt;strong>那就是通过使用一种更为通用的方式，用另外的话说就是抽象和隔离，让复杂的&amp;quot;世界&amp;quot;变得简单一些&lt;/strong>。&lt;/p>
&lt;p>然而，要做到抽象，对于 C 语言这样的类型语言来说，首当其冲的就是抽象类型，这就是所谓的&amp;mdash;&amp;mdash;泛型编程。&lt;/p>
&lt;p>另外，我们还要注意到，在编程世界里，对于 C 语言来说，类型还可以转换。编译器会使用一切方式来做类型转换，因为类型转换有时候可以让我们编程更方便一些，也让相近的类型可以做到一点点的泛型。&lt;/p>
&lt;p>然而，对于 C 语言的类型转换，是会出很多问题的。比如说，传给我一个数组，这个数组本来是 double 的，或者是 long 64 位的，但是如果把数组类型强转成 int，那么就会出现很多问题，因为这会导致程序遍历数组的步长不一样了。&lt;/p>
&lt;p>比如：一个 &lt;code>double a[10]&lt;/code> 的数组，&lt;code>a[2]&lt;/code> 意味着 &lt;code>a + sizeof(double) * 2&lt;/code>。如果你把 &lt;code>a&lt;/code> 强转成 &lt;code>int&lt;/code>，那么 &lt;code>a[2]&lt;/code> 就意味着 &lt;code>a + sizeof(int) * 2&lt;/code>。我们知道 &lt;code>sizeof(double)&lt;/code> 是 &lt;code>8&lt;/code>，而 &lt;code>sizeof(int)&lt;/code> 是 &lt;code>4&lt;/code>。于是访问到了不同的地址和内存空间，这就导致程序出现严重的问题。&lt;/p>
&lt;h2 id="c-语言的泛型">C 语言的泛型&lt;/h2>
&lt;h3 id="一个泛型的示例---swap-函数">一个泛型的示例 - swap 函数&lt;/h3>
&lt;p>好了，我们再看下，C 语言是如何泛型的。C 语言的类型泛型基本上来说就是使用&lt;code>void *&lt;/code>关键字或是使用宏定义。&lt;/p>
&lt;p>下面是一个使用了&lt;code>void*&lt;/code>泛型版本的 swap 函数。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-C" data-lang="C">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">void&lt;/span> &lt;span style="color:#000">swap&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#204a87;font-weight:bold">void&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">*&lt;/span> &lt;span style="color:#000">x&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#204a87;font-weight:bold">void&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">*&lt;/span> &lt;span style="color:#000">y&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">size_t&lt;/span> &lt;span style="color:#000">size&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">char&lt;/span> &lt;span style="color:#000">tmp&lt;/span>&lt;span style="color:#000;font-weight:bold">[&lt;/span>&lt;span style="color:#000">size&lt;/span>&lt;span style="color:#000;font-weight:bold">];&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">memcpy&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">tmp&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">y&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">size&lt;/span>&lt;span style="color:#000;font-weight:bold">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">memcpy&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">y&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">x&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">size&lt;/span>&lt;span style="color:#000;font-weight:bold">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">memcpy&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">x&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">tmp&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">size&lt;/span>&lt;span style="color:#000;font-weight:bold">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上面这个函数几乎完全改变了 int 版的函数的实现方式，这个实现方式有三个重点：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>函数接口中增加了一个&lt;code>size&lt;/code>参数&lt;/strong> 。为什么要这么干呢？因为，用了 &lt;code>void*&lt;/code> 后，类型被&amp;quot;抽象&amp;quot;掉了，编译器不能通过类型得到类型的尺寸了，所以，需要我们手动地加上一个类型长度的标识。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>函数的实现中使用了&lt;code>memcpy()&lt;/code>函数&lt;/strong>。为什么要这样干呢？还是因为类型被&amp;quot;抽象&amp;quot;掉了，所以不能用赋值表达式了，很有可能传进来的参数类型还是一个结构体，因此，为了要交换这些复杂类型的值，我们只能使用内存复制的方法了。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>函数的实现中使用了一个&lt;code>temp[size]&lt;/code>数组&lt;/strong>。这就是交换数据时需要用的 buffer，用 buffer 来做临时的空间存储。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>于是，新增的&lt;code>size&lt;/code>参数，使用的&lt;code>memcpy&lt;/code>内存拷贝以及一个 buffer，这增加了编程的复杂度。这就是 C 语言的类型抽象所带来的复杂度的提升。&lt;/p>
&lt;p>在提升复杂度的同时，我们发现还有问题，比如，我们想交换两个字符串数组，类型是：&lt;code>char*&lt;/code>，那么，我的&lt;code>swap()&lt;/code>函数的&lt;code>x&lt;/code>和&lt;code>y&lt;/code>参数是不是要用&lt;code>void**&lt;/code>了？这样一来，接口就没法定义了。&lt;/p>
&lt;p>除了使用 &lt;code>void*&lt;/code> 来做泛型，在 C 语言中，还可以用宏定义来做泛型，如下所示：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">#define swap(x, y, size) {\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic"> char temp[size]; \
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic"> memcpy(temp, &amp;amp;y, size); \
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic"> memcpy(&amp;amp;y, &amp;amp;x, size); \
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic"> memcpy(&amp;amp;x, temp, size); \
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">}
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>但用宏带来的问题就是编译器做字符串替换，因为宏是做字符串替换，所以会导致代码膨胀，导致编译出的执行文件比较大。不过对于 swap 这个简单的函数来说，用&lt;code>void*&lt;/code>和宏替换来说都可以达到泛型。&lt;/p>
&lt;p>但是，如果我们不是 swap，而是 min() 或 max() 函数，那么宏替换的问题就会暴露得更多一些。比如，对于下面的这个宏：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">#define min(x, y) （(x)&amp;gt;(y) ? (y) : (x)）
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>其中一个最大的问题，就是有可能会有&lt;strong>重复执行&lt;/strong>的问题。如：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;code>min(i++, j++)&lt;/code> 对于这个案例来说，我们本意是比较完后，对变量做累加，但是，因为宏替换的缘故，这会导致变量&lt;code>i&lt;/code>或&lt;code>j&lt;/code>被累加两次。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>min(foo(), bar())&lt;/code> 对于这个示例来说，我们本意是比较 &lt;code>foo()&lt;/code> 和 &lt;code>bar()&lt;/code> 函数的返回值，然而，经过宏替换后，&lt;code>foo()&lt;/code> 或 &lt;code>bar()&lt;/code> 会被调用两次，这会带来很多问题。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>另外，你会不会觉得无论是用哪种方式，这种&amp;quot;泛型&amp;quot;是不是太宽松了一些，完全不做类型检查，就是在内存上对拷，直接操作内存的这种方式，感觉是不是比较危险，而且就像一个定时炸弹一样，不知道什么时候，在什么条件下就爆炸了。&lt;/p>
&lt;p>从上面的两个例子，我们可以发现，无论哪种方式，接口都变得复杂了&amp;mdash;&amp;mdash;加入了&lt;code>size&lt;/code>，因为如果不加入&lt;code>size&lt;/code>的话，那么我们的函数内部就需要自己检查&lt;code>size&lt;/code>。然而，&lt;code>void*&lt;/code> 这种地址的方式是没法得到&lt;code>size&lt;/code>的。&lt;/p>
&lt;p>而宏定义的那种方式，虽然不会把类型给隐藏掉，可以使用像 &lt;code>sizeof(x)&lt;/code> 这样的方式得到 &lt;code>size&lt;/code>。但是如果类型是 &lt;code>char*&lt;/code>，那么，使用&lt;code>sizeof&lt;/code>方式只能提到指针类型的&lt;code>size&lt;/code>，而不是值的&lt;code>size&lt;/code>。另外，对于不同的类型，比如说&lt;code>double&lt;/code>和&lt;code>int&lt;/code>，那应该用谁的&lt;code>size&lt;/code>呢？是不是先转一下型呢？这些都是问题。&lt;/p>
&lt;p>于是，这种泛型，让我们根本没有办法检查传入参数的&lt;code>size&lt;/code>，导致我们只能增加接口复杂度，加入一个&lt;code>size&lt;/code>参数，然后把这个问题抛给调用者了。&lt;/p>
&lt;h3 id="一个更为复杂的泛型示例---search-函数">一个更为复杂的泛型示例 - Search 函数&lt;/h3>
&lt;p>如果我们把这个事情变得更复杂，写个&lt;code>search&lt;/code>函数，再传一个&lt;code>int&lt;/code>数组，然后想搜索&lt;code>target&lt;/code>，搜到返回数组下标，搜不到返回&lt;code>-1&lt;/code>。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">int&lt;/span> &lt;span style="color:#000">search&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#204a87;font-weight:bold">int&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">*&lt;/span> &lt;span style="color:#000">a&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">size_t&lt;/span> &lt;span style="color:#000">size&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#204a87;font-weight:bold">int&lt;/span> &lt;span style="color:#000">target&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">for&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#204a87;font-weight:bold">int&lt;/span> &lt;span style="color:#000">i&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">0&lt;/span>&lt;span style="color:#000;font-weight:bold">;&lt;/span> &lt;span style="color:#000">i&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#000">size&lt;/span>&lt;span style="color:#000;font-weight:bold">;&lt;/span> &lt;span style="color:#000">i&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">++&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">if&lt;/span> &lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">a&lt;/span>&lt;span style="color:#000;font-weight:bold">[&lt;/span>&lt;span style="color:#000">i&lt;/span>&lt;span style="color:#000;font-weight:bold">]&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">==&lt;/span> &lt;span style="color:#000">target&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">return&lt;/span> &lt;span style="color:#000">i&lt;/span>&lt;span style="color:#000;font-weight:bold">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">return&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">-&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">1&lt;/span>&lt;span style="color:#000;font-weight:bold">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>我们可以看到，这个函数是类型 &lt;code>int&lt;/code> 版的。如果我们要把这个函数变成泛型的应该怎么变呢？&lt;/p>
&lt;p>就像上面&lt;code>swap()&lt;/code>函数那样，如果要把它变成泛型，我们需要变更并复杂化函数接口。&lt;/p>
&lt;ol>
&lt;li>
&lt;p>我们需要在函数接口上增加一个 element size，也就是数组里面每个元素的 size。这样，当我们遍历数组的时候，可以通过这个 size 正确地移动指针到下一个数组元素。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>我还要加个&lt;code>cmpFn&lt;/code>。因为我要去比较数组里的每个元素和&lt;code>target&lt;/code>是否相等。因为不同数据类型的比较的实现不一样，比如，整型比较用 &lt;code>==&lt;/code> 就好了。但是如果是一个字符串数组，那么比较就需要用 &lt;code>strcmp&lt;/code> 这类的函数。而如果你传一个结构体数组（如 Account 账号），那么比较两个数据对象是否一样就比较复杂了。所以，必须要自定义一个比较函数。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>最终我们的&lt;code>search&lt;/code>函数的泛型版如下所示：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">int&lt;/span> &lt;span style="color:#000">search&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#204a87;font-weight:bold">void&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">*&lt;/span> &lt;span style="color:#000">a&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">size_t&lt;/span> &lt;span style="color:#000">size&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#204a87;font-weight:bold">void&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">*&lt;/span> &lt;span style="color:#000">target&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">size_t&lt;/span> &lt;span style="color:#000">elem_size&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#204a87;font-weight:bold">int&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">*&lt;/span>&lt;span style="color:#000">cmpFn&lt;/span>&lt;span style="color:#000;font-weight:bold">)(&lt;/span>&lt;span style="color:#204a87;font-weight:bold">void&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">*&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#204a87;font-weight:bold">void&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">*&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span> &lt;span style="color:#000;font-weight:bold">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">for&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#204a87;font-weight:bold">int&lt;/span> &lt;span style="color:#000">i&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">0&lt;/span>&lt;span style="color:#000;font-weight:bold">;&lt;/span> &lt;span style="color:#000">i&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#000">size&lt;/span>&lt;span style="color:#000;font-weight:bold">;&lt;/span> &lt;span style="color:#000">i&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">++&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f5902;font-style:italic">// why not use memcmp()
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">&lt;/span> &lt;span style="color:#8f5902;font-style:italic">// use unsigned char * to calculate the address
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">&lt;/span> &lt;span style="color:#204a87;font-weight:bold">if&lt;/span> &lt;span style="color:#000;font-weight:bold">(&lt;/span> &lt;span style="color:#000">cmpFn&lt;/span> &lt;span style="color:#000;font-weight:bold">((&lt;/span>&lt;span style="color:#204a87;font-weight:bold">unsigned&lt;/span> &lt;span style="color:#204a87;font-weight:bold">char&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">*&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span>&lt;span style="color:#000">a&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">+&lt;/span> &lt;span style="color:#000">elem_size&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">*&lt;/span> &lt;span style="color:#000">i&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">target&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">==&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">0&lt;/span> &lt;span style="color:#000;font-weight:bold">)&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">return&lt;/span> &lt;span style="color:#000">i&lt;/span>&lt;span style="color:#000;font-weight:bold">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">return&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">-&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">1&lt;/span>&lt;span style="color:#000;font-weight:bold">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在上面的代码中，我们没有使用&lt;code>memcmp()&lt;/code>函数，这是因为，如果这个数组是一个指针数组，或是这个数组是一个结构体数组，而结构体数组中有指针成员。我们想比较的是指针指向的内容，而不是指针这个变量。所以，用&lt;code>memcmp()&lt;/code>会导致我们在比较指针（内存地址），而不是指针所指向的值。&lt;/p>
&lt;p>而调用者需要提供如下的比较函数：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">int&lt;/span> &lt;span style="color:#000">int_cmp&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#204a87;font-weight:bold">int&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">*&lt;/span> &lt;span style="color:#000">x&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#204a87;font-weight:bold">int&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">*&lt;/span> &lt;span style="color:#000">y&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">return&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">*&lt;/span>&lt;span style="color:#000">x&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">-&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">*&lt;/span>&lt;span style="color:#000">y&lt;/span>&lt;span style="color:#000;font-weight:bold">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">int&lt;/span> &lt;span style="color:#000">string_cmp&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#204a87;font-weight:bold">char&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">*&lt;/span> &lt;span style="color:#000">x&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#204a87;font-weight:bold">char&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">*&lt;/span> &lt;span style="color:#000">y&lt;/span>&lt;span style="color:#000;font-weight:bold">){&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">return&lt;/span> &lt;span style="color:#000">strcmp&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">x&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">y&lt;/span>&lt;span style="color:#000;font-weight:bold">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果面对有业务类型的结构体，可能会是这样的比较函数：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">typedef&lt;/span> &lt;span style="color:#204a87;font-weight:bold">struct&lt;/span> &lt;span style="color:#000">_account&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">char&lt;/span> &lt;span style="color:#000">name&lt;/span>&lt;span style="color:#000;font-weight:bold">[&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">10&lt;/span>&lt;span style="color:#000;font-weight:bold">];&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">char&lt;/span> &lt;span style="color:#000">id&lt;/span>&lt;span style="color:#000;font-weight:bold">[&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">20&lt;/span>&lt;span style="color:#000;font-weight:bold">];&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">}&lt;/span> &lt;span style="color:#000">Account&lt;/span>&lt;span style="color:#000;font-weight:bold">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">int&lt;/span> &lt;span style="color:#000">account_cmp&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">Account&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">*&lt;/span> &lt;span style="color:#000">x&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">Account&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">*&lt;/span> &lt;span style="color:#000">y&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">int&lt;/span> &lt;span style="color:#000">n&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span> &lt;span style="color:#000">strcmp&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">x&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">-&amp;gt;&lt;/span>&lt;span style="color:#000">name&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">y&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">-&amp;gt;&lt;/span>&lt;span style="color:#000">name&lt;/span>&lt;span style="color:#000;font-weight:bold">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">if&lt;/span> &lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">n&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">!=&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">0&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span> &lt;span style="color:#204a87;font-weight:bold">return&lt;/span> &lt;span style="color:#000">n&lt;/span>&lt;span style="color:#000;font-weight:bold">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">return&lt;/span> &lt;span style="color:#000">strcmp&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">x&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">-&amp;gt;&lt;/span>&lt;span style="color:#000">id&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">y&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">-&amp;gt;&lt;/span>&lt;span style="color:#000">id&lt;/span>&lt;span style="color:#000;font-weight:bold">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>我们的 C 语言干成这个样子，看上去还行，但是，上面的这个&lt;code>search&lt;/code>函数只能用于数组这样的顺序型的数据容器（数据结构）。如果这个&lt;code>search&lt;/code>函数能支持一些非顺序型的数据容器（数据结构），比如：堆、栈、哈希表、树、图。那么，用 C 语言来干基本上干不下去了，对于像&lt;code>search()&lt;/code>这样的算法来说，数据类型的自适应问题就已经把事情搞得很复杂了。然而，数据结构的自适应就会把这个事的复杂度搞上几个数量级。&lt;/p>
&lt;h1 id="小结">小结&lt;/h1>
&lt;p>这里，如果说，&lt;code>程序 = 算法 + 数据&lt;/code>，我觉得 C 语言会有这几个问题。&lt;/p>
&lt;ol>
&lt;li>
&lt;p>一个通用的算法，需要对所处理的数据的数据类型进行适配。但在适配数据类型的过程中，C 语言只能使用 &lt;code>void*&lt;/code> 或 &lt;code>宏替换&lt;/code>的方式，这两种方式导致了类型过于宽松，并带来很多其它问题。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>适配数据类型，需要 C 语言在泛型中加入一个类型的 size，这是因为我们识别不了被泛型后的数据类型，而 C 语言没有运行时的类型识别，所以，只能将这个工作抛给调用泛型算法的程序员来做了。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>算法其实是在操作数据结构，而数据则是放到数据结构中的。所以，真正的泛型除了适配数据类型外，还要适配数据结构。最后这个事情导致泛型算法的复杂急剧上升。比如容器内存的分配和释放，不同的数据体可能有非常不一样的内存分配和释放模型，再比如对象之间的复制，要把它存进来我需要有一个复制，这其中又涉及到是深拷贝，还是浅拷贝。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>最后，在实现泛型算法的时候，你会发现自己在纠结哪些东西应该抛给调用者处理，哪些又是可以封装起来。如何平衡和选择，并没有定论，也不好解决。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>总体来说，C 语言设计目标是提供一种能以简易的方式编译、处理低层内存、产生少量的机器码以及不需要任何运行环境支持便能运行的编程语言。C 语言也很适合搭配汇编语言来使用。C 语言把非常底层的控制权交给了程序员，它设计的理念是：&lt;/p>
&lt;ul>
&lt;li>相信程序员；&lt;/li>
&lt;li>不会阻止程序员做任何底层的事；&lt;/li>
&lt;li>保持语言的最小和最简的特性；&lt;/li>
&lt;li>保证 C 语言的最快的运行速度，那怕牺牲移值性。&lt;/li>
&lt;/ul>
&lt;p>从某种角度上来说，C 语言的伟大之处在于&amp;mdash;&amp;mdash;&lt;strong>使用 C 语言的程序员在高级语言的特性之上还能简单地做任何底层上的微观控制&lt;/strong>。这是 C 语言的强大和优雅之处。也有人说，C 语言是高级语言中的汇编语言。&lt;/p>
&lt;p>不过，这只是在针对底层指令控制和过程式的编程方式。而对于更高阶更为抽象的编程模型来说，C 语言这种基于过程和底层的初衷设计方式就会成为它的短板。因为，在编程这个世界中，更多的编程工作是解决业务上的问题，而不是计算机的问题，所以，我们需要更为贴近业务更为抽象的语言。&lt;/p>
&lt;p>说到这里，我想你会问，那 C 语言本会怎么去解决这些问题呢？简单点说，C 语言并没有解决这些问题，所以才有了后面的 C++ 等其他语言，下一篇文章中，我也会和你聊聊 C++ 是如何解决这些问题的。&lt;/p>
&lt;p>C 语言诞生于 1972 年，到现在已经有 45 年的历史，在它之后，C++、Java、C# 等语言前仆后继，一浪高过一浪，都在试图解决那个时代的那个特定问题，我们不能去否定某个语言，但可以确定的是，随着历史的发展，每一门语言都还在默默迭代，不断优化和更新。同时，也会有很多新的编程语言带着新的闪光耀眼的特性出现在我们面前。&lt;/p>
&lt;p>再回过头来说，编程范式其实就是程序的指导思想，它也代表了这门语言的设计方向，我们并不能说哪种范式更为超前，只能说各有千秋。&lt;/p>
&lt;p>比如 C 语言就是过程式的编程语言，像 C 语言这样的过程式编程语言优点是底层灵活而且高效，特别适合开发运行较快且对系统资源利用率要求较高的程序，但我上面抛出的问题它在后来也没有试图去解决，因为编程范式的选择基本已经决定了它的&amp;quot;命运&amp;quot;。&lt;/p>
&lt;p>我们怎么解决上述 C 语言没有解决好的问题呢？请期待接下来的文章。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/fc/e9/fcc761001867c60f526665e237f831e9.jpg" alt="">&lt;/p></description></item><item><title>极客专栏: 31丨编程范式游记（2）-泛型编程</title><link>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E/31%E4%B8%A8%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F%E6%B8%B8%E8%AE%B02-%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/</link><pubDate>Fri, 27 May 2022 00:00:00 +0000</pubDate><guid>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E/31%E4%B8%A8%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F%E6%B8%B8%E8%AE%B02-%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/</guid><description>
&lt;p>上一篇文章中，我从 C 语言开始说起，聊了聊面向过程式的编程范式，相信从代码的角度你对这类型的语言已经有了一些理解。作为一门高级语言，C 语言绝对是编程语言历史发展中的一个重要里程碑，但随着认知的升级，面向过程的 C 语言已经无法满足更高层次的编程的需要。于是，C++ 出现了。&lt;/p>
&lt;h1 id="c-语言">C++ 语言&lt;/h1>
&lt;p>1980 年，AT&amp;amp;T 贝尔实验室的&lt;strong>Bjarne Stroustrup&lt;/strong>创建的 C++ 语言横空出世，它既可以全面兼容 C 语言，又巧妙揉和了一些面向对象的编程理念。现在来看，不得不佩服 Stroustrup 的魄力。在这里，我也向你推荐一本书，书名是《C++ 语言的设计和演化》。&lt;/p>
&lt;p>这本书系统介绍了 C++ 诞生的背景以及初衷，书的作者就是&lt;a href="https://book.douban.com/author/362072/">Stroustrup&lt;/a>本人，所以你可以非常详细地从语言创建者的角度了解他的设计思路和创新之旅。当然，就是在今天，C++ 这门语言也还有很多争议，这里我不细说。如果你感兴趣的话，可以看看我几年前在酷壳上发表的文章《&lt;a href="https://coolshell.cn/articles/7992.html">C++ 的坑真的多吗？&lt;/a>》。&lt;/p>
&lt;p>从语言角度来说，实际上早期 C++ 的许多工作是对 C 的强化和净化，并把完全兼容 C 作为强制性要求（这也是 C++ 复杂晦涩的原因，这点 Java 就干得比 C++ 彻底得多）。在 C89、C99 这两个 C 语言的标准中，有许多改进都是从 C++ 中引进的。&lt;/p>
&lt;p>可见，C++ 对 C 语言的贡献非常之大。是的，因为 C++ 很大程度就是用来解决 C 语言中的各种问题和各种不方便的。比如：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>用引用来解决指针的问题。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>用 namespace 来解决名字空间冲突的问题。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>通过 try-catch 来解决检查返回值编程的问题。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>用 class 来解决对象的创建、复制、销毁的问题，从而可以达到在结构体嵌套时可以深度复制的内存安全问题。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>通过重载操作符来达到操作上的泛型。（比如，消除&lt;a href="https://time.geekbang.org/column/article/301">上一篇文章&lt;/a>中提到的比较函数&lt;code>cmpFn&lt;/code>，再比如用&lt;code>&amp;gt;&amp;gt;&lt;/code>操作符消除&lt;code>printf()&lt;/code>的数据类型不够泛型的问题。）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>通过模板 template 和虚函数的多态以及运行时识别来达到更高层次的泛型和多态。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>用 RAII、智能指针的方式，解决了 C 语言中因为需要释放资源而出现的那些非常 ugly 也很容易出错的代码的问题。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>用 STL 解决了 C 语言中算法和数据结构的 N 多种坑。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h1 id="c-泛型编程">C++ 泛型编程&lt;/h1>
&lt;p>C++ 是支持编程范式最多的一门语言，它虽然解决了很多 C 语言的问题，但我个人觉得它最大的意义是解决了 C 语言泛型编程的问题。因为，我们可以看到一些 C++ 的标准规格说明书里，有一半以上都在说明 STL 的标准规格应该是什么样的，这说明泛型编程是 C++ 重点中的重点。&lt;/p>
&lt;p>理想情况下，算法应是和数据结构以及类型无关的，各种特殊的数据类型理应做好自己分内的工作。算法只关心一个标准的实现。&lt;strong>而对于泛型的抽象，我们需要回答的问题是，如果我们的数据类型符合通用算法，那么对数据类型的最小需求又是什么呢？&lt;/strong>&lt;/p>
&lt;p>我们来看看 C++ 是如何有效解决程序泛型问题的，我认为有三点。&lt;/p>
&lt;p>&lt;strong>第一，它通过类的方式来解决&lt;/strong>。&lt;/p>
&lt;ul>
&lt;li>类里面会有构造函数、析构函数表示这个类的分配和释放。&lt;/li>
&lt;li>还有它的拷贝构造函数，表示了对内存的复制。&lt;/li>
&lt;li>还有重载操作符，像我们要去比较大于、等于、不等于。&lt;/li>
&lt;/ul>
&lt;p>这样可以让一个用户自定义的数据类型和内建的那些数据类型就很一致了。&lt;/p>
&lt;p>&lt;strong>第二，通过模板达到类型和算法的妥协&lt;/strong>。&lt;/p>
&lt;ul>
&lt;li>模板有点像 DSL，模板的特化会根据使用者的类型在编译时期生成那个模板的代码。&lt;/li>
&lt;li>模板可以通过一个虚拟类型来做类型绑定，这样不会导致类型转换时的问题。&lt;/li>
&lt;/ul>
&lt;p>模板很好地取代了 C 时代宏定义带来的问题。&lt;/p>
&lt;p>&lt;strong>第三，通过虚函数和运行时类型识别&lt;/strong>。&lt;/p>
&lt;ul>
&lt;li>虚函数带来的多态在语义上可以支持&amp;quot;同一类&amp;quot;的类型泛型。&lt;/li>
&lt;li>运行时类型识别技术可以做到在泛型时对具体类型的特殊处理。&lt;/li>
&lt;/ul>
&lt;p>这样一来，就可以写出基于抽象接口的泛型。&lt;/p>
&lt;p>拥有了这些 C++ 引入的技术，我们就可以做到 C 语言很难做到的泛型编程了。&lt;/p>
&lt;p>正如前面说过的，一个良好的泛型编程需要解决如下几个泛型编程的问题：&lt;/p>
&lt;ol>
&lt;li>算法的泛型；&lt;/li>
&lt;li>类型的泛型；&lt;/li>
&lt;li>数据结构（数据容器）的泛型。&lt;/li>
&lt;/ol>
&lt;h2 id="c-泛型编程的示例---search-函数">C++ 泛型编程的示例 - Search 函数&lt;/h2>
&lt;p>就像前面的&lt;code>search()&lt;/code>函数，里面的 &lt;code>for(int i=0; i&amp;lt;len; i++)&lt;/code> 这样的遍历方式，只能适用于&lt;strong>顺序型的数据结构&lt;/strong> 的方式迭代，如：array、set、queue、list 和 link 等。并不适用于&lt;strong>非顺序型的数据结构&lt;/strong>。&lt;/p>
&lt;p>如哈希表 hash table，二叉树 binary tree、图 graph 等这样数据不是按顺序存放的数据结构（数据容器）。所以，如果找不到一种&lt;strong>泛型的数据结构的操作方式（如遍历、查找、增加、删除、修改&amp;hellip;&amp;hellip;）&lt;/strong>，那么，任何的算法或是程序都不可能做到真正意义上的泛型。&lt;/p>
&lt;p>除了&lt;code>search()&lt;/code>函数的&amp;quot;遍历操作&amp;quot;之外，还有 search 函数的返回值，是一个整型的索引下标。这个整型的下标对于&amp;quot;顺序型的数据结构&amp;quot;是没有问题的，但是对于&amp;quot;非顺序的数据结构&amp;quot;，在语义上都存在问题。&lt;/p>
&lt;p>比如，如果我要在一个 hash table 中查找一个 key，返回什么呢？一定不是返回&amp;quot;索引下标&amp;quot;，因为在 hash table 这样的数据结构中，数据的存放位置不是顺序的，而且还会因为容量不够的问题被重新 hash 后改变，所以返回数组下标是没有意义的。&lt;/p>
&lt;p>对此，我们要把这个事做得泛型和通用一些。如果找到，返回找到的这个元素的一个指针（地址）会更靠谱一些。&lt;/p>
&lt;p>所以，为了解决泛型的问题，我们需要动用以下几个 C++ 的技术。&lt;/p>
&lt;ol>
&lt;li>
&lt;p>使用模板技术来抽象类型，这样可以写出类型无关的数据结构（数据容器）。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>使用一个迭代器来遍历或是操作数据结构内的元素。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>我们来看一下 C++ 版的&lt;code>search()&lt;/code>函数是什么样的。&lt;/p>
&lt;p>先重温一下 C 语言版的代码：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">int&lt;/span> &lt;span style="color:#000">search&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#204a87;font-weight:bold">void&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">*&lt;/span> &lt;span style="color:#000">a&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">size_t&lt;/span> &lt;span style="color:#000">size&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#204a87;font-weight:bold">void&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">*&lt;/span> &lt;span style="color:#000">target&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">size_t&lt;/span> &lt;span style="color:#000">elem_size&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#204a87;font-weight:bold">int&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">*&lt;/span>&lt;span style="color:#000">cmpFn&lt;/span>&lt;span style="color:#000;font-weight:bold">)(&lt;/span>&lt;span style="color:#204a87;font-weight:bold">void&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">*&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#204a87;font-weight:bold">void&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">*&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span> &lt;span style="color:#000;font-weight:bold">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">for&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#204a87;font-weight:bold">int&lt;/span> &lt;span style="color:#000">i&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">0&lt;/span>&lt;span style="color:#000;font-weight:bold">;&lt;/span> &lt;span style="color:#000">i&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#000">size&lt;/span>&lt;span style="color:#000;font-weight:bold">;&lt;/span> &lt;span style="color:#000">i&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">++&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">if&lt;/span> &lt;span style="color:#000;font-weight:bold">(&lt;/span> &lt;span style="color:#000">cmpFn&lt;/span> &lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">a&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">+&lt;/span> &lt;span style="color:#000">elem_size&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">*&lt;/span> &lt;span style="color:#000">i&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">target&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">==&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">0&lt;/span> &lt;span style="color:#000;font-weight:bold">)&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">return&lt;/span> &lt;span style="color:#000">i&lt;/span>&lt;span style="color:#000;font-weight:bold">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">return&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">-&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">1&lt;/span>&lt;span style="color:#000;font-weight:bold">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>我们再来看一下 C++ 泛型版的代码：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c++" data-lang="c++">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">template&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#204a87;font-weight:bold">typename&lt;/span> &lt;span style="color:#000">T&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#204a87;font-weight:bold">typename&lt;/span> &lt;span style="color:#000">Iter&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">Iter&lt;/span> &lt;span style="color:#000">search&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">Iter&lt;/span> &lt;span style="color:#000">pStart&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">Iter&lt;/span> &lt;span style="color:#000">pEnd&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">T&lt;/span> &lt;span style="color:#000">target&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">for&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">Iter&lt;/span> &lt;span style="color:#000">p&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span> &lt;span style="color:#000">pStart&lt;/span>&lt;span style="color:#000;font-weight:bold">;&lt;/span> &lt;span style="color:#000">p&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">!=&lt;/span> &lt;span style="color:#000">pEnd&lt;/span>&lt;span style="color:#000;font-weight:bold">;&lt;/span> &lt;span style="color:#000">p&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">++&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">if&lt;/span> &lt;span style="color:#000;font-weight:bold">(&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">*&lt;/span>&lt;span style="color:#000">p&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">==&lt;/span> &lt;span style="color:#000">target&lt;/span> &lt;span style="color:#000;font-weight:bold">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">return&lt;/span> &lt;span style="color:#000">p&lt;/span>&lt;span style="color:#000;font-weight:bold">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">return&lt;/span> &lt;span style="color:#204a87">NULL&lt;/span>&lt;span style="color:#000;font-weight:bold">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在 C++ 的泛型版本中，我们可以看到：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>使用&lt;code>typename T&lt;/code>抽象了数据结构中存储数据的类型。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>使用&lt;code>typename Iter&lt;/code>，这是不同的数据结构需要自己实现的&amp;quot;迭代器&amp;quot;，这样也就抽象掉了不同类型的数据结构。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>然后，我们对数据容器的遍历使用了&lt;code>Iter&lt;/code>中的&lt;code>++&lt;/code>方法，这是数据容器需要重载的操作符，这样通过操作符重载也就泛型掉了遍历。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>在函数的入参上使用了&lt;code>pStart&lt;/code>和&lt;code>pEnd&lt;/code>来表示遍历的起止。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>使用&lt;code>*Iter&lt;/code>来取得这个&amp;quot;指针&amp;quot;的内容。这也是通过重载 &lt;code>*&lt;/code> 取值操作符来达到的泛型。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>当然，你可能会问，为什么我们不用标准接口&lt;code>Iter.Next()&lt;/code>取代&lt;code>++&lt;/code>， 用&lt;code>Iter.GetValue()&lt;/code>来取代&lt;code>*&lt;/code>，而是通过重载操作符？其实这样做是为了兼容原有 C 语言的编程习惯。&lt;/p>
&lt;p>说明一下，所谓的&lt;code>Iter&lt;/code>，在实际代码中，就是像&lt;code>vector&amp;lt;int&amp;gt;::iterator&lt;/code>或&lt;code>map&amp;lt;int, string&amp;gt;::iterator&lt;/code>这样的东西。这是由相应的数据容器来实现和提供的。&lt;/p>
&lt;p>注：下面是 C++ STL 中的&lt;code>find()&lt;/code>函数的代码。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c++" data-lang="c++">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">template&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#204a87;font-weight:bold">class&lt;/span> &lt;span style="color:#000">InputIterator&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#204a87;font-weight:bold">class&lt;/span> &lt;span style="color:#000">T&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">InputIterator&lt;/span> &lt;span style="color:#000">find&lt;/span> &lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">InputIterator&lt;/span> &lt;span style="color:#000">first&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">InputIterator&lt;/span> &lt;span style="color:#000">last&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#204a87;font-weight:bold">const&lt;/span> &lt;span style="color:#000">T&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">&amp;amp;&lt;/span> &lt;span style="color:#000">val&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">while&lt;/span> &lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">first&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">!=&lt;/span>&lt;span style="color:#000">last&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">if&lt;/span> &lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">*&lt;/span>&lt;span style="color:#000">first&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">==&lt;/span>&lt;span style="color:#000">val&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span> &lt;span style="color:#204a87;font-weight:bold">return&lt;/span> &lt;span style="color:#000">first&lt;/span>&lt;span style="color:#000;font-weight:bold">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ce5c00;font-weight:bold">++&lt;/span>&lt;span style="color:#000">first&lt;/span>&lt;span style="color:#000;font-weight:bold">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">return&lt;/span> &lt;span style="color:#000">last&lt;/span>&lt;span style="color:#000;font-weight:bold">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="c-泛型编程示例---sum-函数">C++ 泛型编程示例 - Sum 函数&lt;/h2>
&lt;p>也许你觉得到这一步，我们的泛型设计就完成了。其实，还远远不够。&lt;code>search&lt;/code>函数只是一个开始，我们还有很多别的算法会让问题变得更为复杂。&lt;/p>
&lt;p>我们再来看一个&lt;code>sum()&lt;/code>函数。&lt;/p>
&lt;p>先看 C 语言版：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">long&lt;/span> &lt;span style="color:#000">sum&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#204a87;font-weight:bold">int&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">*&lt;/span>&lt;span style="color:#000">a&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">size_t&lt;/span> &lt;span style="color:#000">size&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">long&lt;/span> &lt;span style="color:#000">result&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">0&lt;/span>&lt;span style="color:#000;font-weight:bold">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">for&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#204a87;font-weight:bold">int&lt;/span> &lt;span style="color:#000">i&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">0&lt;/span>&lt;span style="color:#000;font-weight:bold">;&lt;/span> &lt;span style="color:#000">i&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#000">size&lt;/span>&lt;span style="color:#000;font-weight:bold">;&lt;/span> &lt;span style="color:#000">i&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">++&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">result&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">+=&lt;/span> &lt;span style="color:#000">a&lt;/span>&lt;span style="color:#000;font-weight:bold">[&lt;/span>&lt;span style="color:#000">i&lt;/span>&lt;span style="color:#000;font-weight:bold">];&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">return&lt;/span> &lt;span style="color:#000">result&lt;/span>&lt;span style="color:#000;font-weight:bold">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>再看一下 C++ 泛型的版本：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c++" data-lang="c++">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">template&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#204a87;font-weight:bold">typename&lt;/span> &lt;span style="color:#000">T&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#204a87;font-weight:bold">typename&lt;/span> &lt;span style="color:#000">Iter&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">T&lt;/span> &lt;span style="color:#000">sum&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">Iter&lt;/span> &lt;span style="color:#000">pStart&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">Iter&lt;/span> &lt;span style="color:#000">pEnd&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">T&lt;/span> &lt;span style="color:#000">result&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">0&lt;/span>&lt;span style="color:#000;font-weight:bold">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">for&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">Iter&lt;/span> &lt;span style="color:#000">p&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>&lt;span style="color:#000">pStart&lt;/span>&lt;span style="color:#000;font-weight:bold">;&lt;/span> &lt;span style="color:#000">p&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">!=&lt;/span>&lt;span style="color:#000">pEnd&lt;/span>&lt;span style="color:#000;font-weight:bold">;&lt;/span> &lt;span style="color:#000">p&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">++&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">result&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">+=&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">*&lt;/span>&lt;span style="color:#000">p&lt;/span>&lt;span style="color:#000;font-weight:bold">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">return&lt;/span> &lt;span style="color:#000">result&lt;/span>&lt;span style="color:#000;font-weight:bold">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>你看到了什么样的问题？这个代码中最大的问题就是 &lt;code>T result = 0;&lt;/code> 这条语句：&lt;/p>
&lt;ul>
&lt;li>那个&lt;code>0&lt;/code>假设了类型是&lt;code>int&lt;/code>；&lt;/li>
&lt;li>那个&lt;code>T&lt;/code>假设了 Iter 中出来的类型是&lt;code>T&lt;/code>。&lt;/li>
&lt;/ul>
&lt;p>这样的假设是有问题的，如果类型不一样，就会导致转型的问题，这会带来非常 buggy 的代码。那么，我们怎么解决呢？&lt;/p>
&lt;h2 id="c-泛型编程的重要技术---迭代器">C++ 泛型编程的重要技术 - 迭代器&lt;/h2>
&lt;p>我们知道&lt;code>Iter&lt;/code>在实际调用者那会是一个具体的像&lt;code>vector&amp;lt;int&amp;gt;::iterator&lt;/code>这样的东西。在这个声明中，&lt;code>int&lt;/code>已经被传入&lt;code>Iter&lt;/code>中了。所以，定义&lt;code>result&lt;/code>的&lt;code>T&lt;/code>应该可以从&lt;code>Iter&lt;/code>中来。这样就可以保证类型是一样的，而且不会有被转型的问题。&lt;/p>
&lt;p>所以，我们需要精心地实现一个&amp;quot;迭代器&amp;quot;。下面是一个&amp;quot;精简版&amp;quot;的迭代器（我没有把 C++ STL 代码里的迭代器列出来，是因为代码太多太复杂，我这里只是为了说明问题）。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c++" data-lang="c++">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">template&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#204a87;font-weight:bold">class&lt;/span> &lt;span style="color:#000">T&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">class&lt;/span> &lt;span style="color:#000">container&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">public&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">class&lt;/span> &lt;span style="color:#000">iterator&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">public&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">typedef&lt;/span> &lt;span style="color:#000">iterator&lt;/span> &lt;span style="color:#000">self_type&lt;/span>&lt;span style="color:#000;font-weight:bold">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">typedef&lt;/span> &lt;span style="color:#000">T&lt;/span> &lt;span style="color:#000">value_type&lt;/span>&lt;span style="color:#000;font-weight:bold">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">typedef&lt;/span> &lt;span style="color:#000">T&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">*&lt;/span> &lt;span style="color:#000">pointer&lt;/span>&lt;span style="color:#000;font-weight:bold">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">typedef&lt;/span> &lt;span style="color:#000">T&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">&amp;amp;&lt;/span> &lt;span style="color:#000">reference&lt;/span>&lt;span style="color:#000;font-weight:bold">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">reference&lt;/span> &lt;span style="color:#204a87;font-weight:bold">operator&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">*&lt;/span>&lt;span style="color:#000;font-weight:bold">();&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">pointer&lt;/span> &lt;span style="color:#204a87;font-weight:bold">operator&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">-&amp;gt;&lt;/span>&lt;span style="color:#000;font-weight:bold">();&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">bool&lt;/span> &lt;span style="color:#204a87;font-weight:bold">operator&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">==&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#204a87;font-weight:bold">const&lt;/span> &lt;span style="color:#000">self_type&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">&amp;amp;&lt;/span> &lt;span style="color:#000">rhs&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span>&lt;span style="color:#a40000">；&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">bool&lt;/span> &lt;span style="color:#204a87;font-weight:bold">operator&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">!=&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#204a87;font-weight:bold">const&lt;/span> &lt;span style="color:#000">self_type&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">&amp;amp;&lt;/span> &lt;span style="color:#000">rhs&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span>&lt;span style="color:#a40000">；&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">self_type&lt;/span> &lt;span style="color:#204a87;font-weight:bold">operator&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">++&lt;/span>&lt;span style="color:#000;font-weight:bold">()&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span> &lt;span style="color:#000">self_type&lt;/span> &lt;span style="color:#000">i&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">*&lt;/span>&lt;span style="color:#204a87;font-weight:bold">this&lt;/span>&lt;span style="color:#000;font-weight:bold">;&lt;/span> &lt;span style="color:#000">ptr_&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">++&lt;/span>&lt;span style="color:#000;font-weight:bold">;&lt;/span> &lt;span style="color:#204a87;font-weight:bold">return&lt;/span> &lt;span style="color:#000">i&lt;/span>&lt;span style="color:#000;font-weight:bold">;&lt;/span> &lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">self_type&lt;/span> &lt;span style="color:#204a87;font-weight:bold">operator&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">++&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#204a87;font-weight:bold">int&lt;/span> &lt;span style="color:#000">junk&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span> &lt;span style="color:#000">ptr_&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">++&lt;/span>&lt;span style="color:#000;font-weight:bold">;&lt;/span> &lt;span style="color:#204a87;font-weight:bold">return&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">*&lt;/span>&lt;span style="color:#204a87;font-weight:bold">this&lt;/span>&lt;span style="color:#000;font-weight:bold">;&lt;/span> &lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">private&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">pointer&lt;/span> &lt;span style="color:#000">_ptr&lt;/span>&lt;span style="color:#000;font-weight:bold">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">};&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">iterator&lt;/span> &lt;span style="color:#000">begin&lt;/span>&lt;span style="color:#000;font-weight:bold">();&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">iterator&lt;/span> &lt;span style="color:#000">end&lt;/span>&lt;span style="color:#000;font-weight:bold">();&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">};&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上面的代码是我写的一个迭代器（这个迭代器在语义上是没有问题的），我没有把所有的代码列出来，而把它的一些基本思路列了出来。这里我说明一下几个关键点。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>首先，一个迭代器需要和一个容器在一起，因为里面是对这个容器的具体的代码实现。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>它需要重载一些操作符，比如：取值操作&lt;code>*&lt;/code>、成员操作&lt;code>-&amp;gt;&lt;/code>、比较操作&lt;code>==&lt;/code>和&lt;code>!=&lt;/code>，还有遍历操作&lt;code>++&lt;/code>，等等。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>然后，还要&lt;code>typedef&lt;/code>一些类型，比如&lt;code>value_type&lt;/code>，告诉我们容器内的数据的实际类型是什么样子。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>还有一些，如&lt;code>begin()&lt;/code>和&lt;code>end()&lt;/code>的基本操作。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>我们还可以看到其中有一个&lt;code>pointer _ptr&lt;/code>的内部指针来指向当前的数据（注意，&lt;code>pointer&lt;/code>就是 &lt;code>T*&lt;/code>）。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>好了，有了这个迭代器后，我们还要解决&lt;code>T result = 0&lt;/code>后面的这个&lt;code>0&lt;/code>的问题。这个事，算法没有办法搞定，最好由用户传入。于是出现了下面最终泛型的&lt;code>sum()&lt;/code>版函数。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c++" data-lang="c++">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">template&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#204a87;font-weight:bold">class&lt;/span> &lt;span style="color:#000">Iter&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">typename&lt;/span> &lt;span style="color:#000">Iter&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">::&lt;/span>&lt;span style="color:#000">value_type&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">sum&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">Iter&lt;/span> &lt;span style="color:#000">start&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">Iter&lt;/span> &lt;span style="color:#000">end&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">T&lt;/span> &lt;span style="color:#000">init&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">typename&lt;/span> &lt;span style="color:#000">Iter&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">::&lt;/span>&lt;span style="color:#000">value_type&lt;/span> &lt;span style="color:#000">result&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span> &lt;span style="color:#000">init&lt;/span>&lt;span style="color:#000;font-weight:bold">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">while&lt;/span> &lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">start&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">!=&lt;/span> &lt;span style="color:#000">end&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">result&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span> &lt;span style="color:#000">result&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">+&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">*&lt;/span>&lt;span style="color:#000">start&lt;/span>&lt;span style="color:#000;font-weight:bold">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">start&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">++&lt;/span>&lt;span style="color:#000;font-weight:bold">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">return&lt;/span> &lt;span style="color:#000">result&lt;/span>&lt;span style="color:#000;font-weight:bold">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>我们可以看到&lt;code>typename Iter::value_type result = init&lt;/code>这条语句是关键。我们解决了所有的问题。&lt;/p>
&lt;p>我们如下使用：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c++" data-lang="c++">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">container&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#204a87;font-weight:bold">int&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">&amp;gt;&lt;/span> &lt;span style="color:#000">c&lt;/span>&lt;span style="color:#000;font-weight:bold">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">container&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#204a87;font-weight:bold">int&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">&amp;gt;::&lt;/span>&lt;span style="color:#000">iterator&lt;/span> &lt;span style="color:#000">it&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span> &lt;span style="color:#000">c&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">begin&lt;/span>&lt;span style="color:#000;font-weight:bold">();&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">sum&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">c&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">begin&lt;/span>&lt;span style="color:#000;font-weight:bold">(),&lt;/span> &lt;span style="color:#000">c&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">end&lt;/span>&lt;span style="color:#000;font-weight:bold">(),&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">0&lt;/span>&lt;span style="color:#000;font-weight:bold">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这就是整个 STL 的泛型方法，其中包括：&lt;/p>
&lt;ul>
&lt;li>泛型的数据容器；&lt;/li>
&lt;li>泛型数据容器的迭代器；&lt;/li>
&lt;li>然后泛型的算法就很容易写了。&lt;/li>
&lt;/ul>
&lt;h1 id="需要更多的抽象">需要更多的抽象&lt;/h1>
&lt;h2 id="更为复杂的需求">更为复杂的需求&lt;/h2>
&lt;p>但是，还能不能做到更为泛型呢？比如：如果我们有这样的一个数据结构 Employee，里面有 vacation 就是休假多少天，以及工资。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c++" data-lang="c++">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">struct&lt;/span> &lt;span style="color:#000">Employee&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">string&lt;/span> &lt;span style="color:#000">name&lt;/span>&lt;span style="color:#000;font-weight:bold">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">string&lt;/span> &lt;span style="color:#000">id&lt;/span>&lt;span style="color:#000;font-weight:bold">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">int&lt;/span> &lt;span style="color:#000">vacation&lt;/span>&lt;span style="color:#000;font-weight:bold">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">double&lt;/span> &lt;span style="color:#000">salary&lt;/span>&lt;span style="color:#a40000">；&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">};&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>现在我想计算员工的总薪水，或是总休假天数。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c++" data-lang="c++">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">vector&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#000">Employee&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">&amp;gt;&lt;/span> &lt;span style="color:#000">staff&lt;/span>&lt;span style="color:#000;font-weight:bold">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">//total salary or total vacation days?
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">&lt;/span>&lt;span style="color:#000">sum&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">staff&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">begin&lt;/span>&lt;span style="color:#000;font-weight:bold">(),&lt;/span> &lt;span style="color:#000">staff&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">end&lt;/span>&lt;span style="color:#000;font-weight:bold">(),&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">0&lt;/span>&lt;span style="color:#000;font-weight:bold">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>我们的&lt;code>sum&lt;/code>完全不知道怎么搞了，因为要累加的是&lt;code>Employee&lt;/code>类中的不同字段，即便我们的 Employee 中重载了&lt;code>+&lt;/code>操作，也不知道要加哪个字段。&lt;/p>
&lt;p>另外，我们可能还会有：求平均值 average，求最小值 min，求最大值 max，求中位数 mean 等等。你会发现，算法写出来基本上都是一样的，只是其中的&amp;quot;累加&amp;quot;操作变成了另外一个操作。就这个例子而言，我想计算员工薪水里面最高的，和休假最少的，或者我想计算全部员工的总共休假多少天。那么面对这么多的需求，我们是否可以泛型一些呢？怎样解决这些问题呢？&lt;/p>
&lt;h2 id="更高维度的抽象">更高维度的抽象&lt;/h2>
&lt;p>要解决这个问题，我希望我的这个算法只管遍历，具体要干什么，那是业务逻辑，由外面的调用方来定义我就好了，和我无关。这样一来，代码的重用度就更高了。&lt;/p>
&lt;p>下面是一个抽象度更高的版本，这个版本再叫&lt;code>sum&lt;/code>就不太合适了。这个版本应该是&lt;code>reduce&lt;/code>&amp;mdash;&amp;mdash;用于把一个数组 reduce 成一个值。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c++" data-lang="c++">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">template&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#204a87;font-weight:bold">class&lt;/span> &lt;span style="color:#000">Iter&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#204a87;font-weight:bold">class&lt;/span> &lt;span style="color:#000">T&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#204a87;font-weight:bold">class&lt;/span> &lt;span style="color:#000">Op&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">T&lt;/span> &lt;span style="color:#000">reduce&lt;/span> &lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">Iter&lt;/span> &lt;span style="color:#000">start&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">Iter&lt;/span> &lt;span style="color:#000">end&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">T&lt;/span> &lt;span style="color:#000">init&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">Op&lt;/span> &lt;span style="color:#000">op&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">T&lt;/span> &lt;span style="color:#000">result&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span> &lt;span style="color:#000">init&lt;/span>&lt;span style="color:#000;font-weight:bold">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">while&lt;/span> &lt;span style="color:#000;font-weight:bold">(&lt;/span> &lt;span style="color:#000">start&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">!=&lt;/span> &lt;span style="color:#000">end&lt;/span> &lt;span style="color:#000;font-weight:bold">)&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">result&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span> &lt;span style="color:#000">op&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span> &lt;span style="color:#000">result&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">*&lt;/span>&lt;span style="color:#000">start&lt;/span> &lt;span style="color:#000;font-weight:bold">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">start&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">++&lt;/span>&lt;span style="color:#000;font-weight:bold">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">return&lt;/span> &lt;span style="color:#000">result&lt;/span>&lt;span style="color:#000;font-weight:bold">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上面的代码中，我们需要传一个函数进来。在 STL 中，它是个函数对象，我们还是这套算法，但是 result 不是像前面那样去加，是把整个迭代器值给你一个 operation，然后由它来做。我把这个方法又拿出去了，所以就会变成这个样子。&lt;/p>
&lt;p>在 C++ STL 中，与我的这个 reduce 函数对应的函数名叫 &lt;code>accumulate()&lt;/code>，其实际代码有两个版本。&lt;/p>
&lt;p>第一个版本就是上面的版本，只不过是用&lt;code>for&lt;/code>语句而不是&lt;code>while&lt;/code>。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c++" data-lang="c++">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">template&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#204a87;font-weight:bold">class&lt;/span> &lt;span style="color:#000">InputIt&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#204a87;font-weight:bold">class&lt;/span> &lt;span style="color:#000">T&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">T&lt;/span> &lt;span style="color:#000">accumulate&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">InputIt&lt;/span> &lt;span style="color:#000">first&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">InputIt&lt;/span> &lt;span style="color:#000">last&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">T&lt;/span> &lt;span style="color:#000">init&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">for&lt;/span> &lt;span style="color:#000;font-weight:bold">(;&lt;/span> &lt;span style="color:#000">first&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">!=&lt;/span> &lt;span style="color:#000">last&lt;/span>&lt;span style="color:#000;font-weight:bold">;&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">++&lt;/span>&lt;span style="color:#000">first&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">init&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span> &lt;span style="color:#000">init&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">+&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">*&lt;/span>&lt;span style="color:#000">first&lt;/span>&lt;span style="color:#000;font-weight:bold">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">return&lt;/span> &lt;span style="color:#000">init&lt;/span>&lt;span style="color:#000;font-weight:bold">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>第二个版本，更为抽象，因为需要传入一个&amp;quot;二元操作函数&amp;quot;&amp;mdash;&amp;mdash;&lt;code>BinaryOperation op&lt;/code>来做 accumulate。accumulate 的语义比 sum 更抽象了。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c++" data-lang="c++">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">template&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#204a87;font-weight:bold">class&lt;/span> &lt;span style="color:#000">InputIt&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#204a87;font-weight:bold">class&lt;/span> &lt;span style="color:#000">T&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#204a87;font-weight:bold">class&lt;/span> &lt;span style="color:#000">BinaryOperation&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">T&lt;/span> &lt;span style="color:#000">accumulate&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">InputIt&lt;/span> &lt;span style="color:#000">first&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">InputIt&lt;/span> &lt;span style="color:#000">last&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">T&lt;/span> &lt;span style="color:#000">init&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">BinaryOperation&lt;/span> &lt;span style="color:#000">op&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">for&lt;/span> &lt;span style="color:#000;font-weight:bold">(;&lt;/span> &lt;span style="color:#000">first&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">!=&lt;/span> &lt;span style="color:#000">last&lt;/span>&lt;span style="color:#000;font-weight:bold">;&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">++&lt;/span>&lt;span style="color:#000">first&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">init&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span> &lt;span style="color:#000">op&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">init&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">*&lt;/span>&lt;span style="color:#000">first&lt;/span>&lt;span style="color:#000;font-weight:bold">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">return&lt;/span> &lt;span style="color:#000">init&lt;/span>&lt;span style="color:#000;font-weight:bold">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>来看看我们在使用中是什么样子的：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c++" data-lang="c++">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">double&lt;/span> &lt;span style="color:#000">sum_salaries&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">reduce&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span> &lt;span style="color:#000">staff&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">begin&lt;/span>&lt;span style="color:#000;font-weight:bold">(),&lt;/span> &lt;span style="color:#000">staff&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">end&lt;/span>&lt;span style="color:#000;font-weight:bold">(),&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">0.0&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>&lt;span style="color:#204a87;font-weight:bold">return&lt;/span> &lt;span style="color:#000">s&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">+&lt;/span> &lt;span style="color:#000">e&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">salary&lt;/span>&lt;span style="color:#000;font-weight:bold">;}&lt;/span> &lt;span style="color:#000;font-weight:bold">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">double&lt;/span> &lt;span style="color:#000">max_salary&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">reduce&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span> &lt;span style="color:#000">staff&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">begin&lt;/span>&lt;span style="color:#000;font-weight:bold">(),&lt;/span> &lt;span style="color:#000">staff&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">end&lt;/span>&lt;span style="color:#000;font-weight:bold">(),&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">0.0&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>&lt;span style="color:#204a87;font-weight:bold">return&lt;/span> &lt;span style="color:#000">s&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">&amp;gt;&lt;/span> &lt;span style="color:#000">e&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">salary&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">?&lt;/span> &lt;span style="color:#f57900">s&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#000">e&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">salary&lt;/span>&lt;span style="color:#000;font-weight:bold">;&lt;/span> &lt;span style="color:#000;font-weight:bold">}&lt;/span> &lt;span style="color:#000;font-weight:bold">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>注意：我这里用了 C++ 的 lambda 表达式。&lt;/p>
&lt;p>你可以很清楚地看到，reduce 这个函数就更通用了，具体要干什么样的事情呢？放在匿名函数里面，它会定义我，我只做一个 reduce。更抽象地来说，我就把一个数组，一个集合，变成一个值。怎么变成一个值呢？由这个函数来决定。&lt;/p>
&lt;h3 id="reduce-函数">Reduce 函数&lt;/h3>
&lt;p>我们来看看如何使用 reduce 和其它函数完成一个更为复杂的功能。&lt;/p>
&lt;p>下面这个示例中，我先定义了一个函数对象&lt;code>counter&lt;/code>。这个函数对象需要一个&lt;code>Cond&lt;/code>的函数对象，它是个条件判断函数，如果满足条件，则加 1，否则加 0。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c++" data-lang="c++">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">template&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#204a87;font-weight:bold">class&lt;/span> &lt;span style="color:#000">T&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#204a87;font-weight:bold">class&lt;/span> &lt;span style="color:#000">Cond&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">struct&lt;/span> &lt;span style="color:#000">counter&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">size_t&lt;/span> &lt;span style="color:#000">operator&lt;/span>&lt;span style="color:#000;font-weight:bold">()(&lt;/span>&lt;span style="color:#000">size_t&lt;/span> &lt;span style="color:#000">c&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">T&lt;/span> &lt;span style="color:#000">t&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span> &lt;span style="color:#204a87;font-weight:bold">const&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">return&lt;/span> &lt;span style="color:#000">c&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">+&lt;/span> &lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">Cond&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">t&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">?&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">1&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">:&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">0&lt;/span>&lt;span style="color:#000;font-weight:bold">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">};&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>然后，我用上面的&lt;code>counter&lt;/code>函数对象和&lt;code>reduce&lt;/code>函数共同来打造一个&lt;code>counter_if&lt;/code>算法（当条件满足的时候我就记个数，也就是统计满足某个条件的个数），我们可以看到，就是一行代码的事。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c++" data-lang="c++">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">template&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#204a87;font-weight:bold">class&lt;/span> &lt;span style="color:#000">Iter&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#204a87;font-weight:bold">class&lt;/span> &lt;span style="color:#000">Cond&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">size_t&lt;/span> &lt;span style="color:#000">count_if&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">Iter&lt;/span> &lt;span style="color:#000">begin&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">Iter&lt;/span> &lt;span style="color:#000">end&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">Cond&lt;/span> &lt;span style="color:#000">c&lt;/span>&lt;span style="color:#000;font-weight:bold">){&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">return&lt;/span> &lt;span style="color:#000">reduce&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">begin&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">end&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">0&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">counter&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#000">Iter&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">::&lt;/span>&lt;span style="color:#000">value_type&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">Cond&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">&amp;gt;&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">c&lt;/span>&lt;span style="color:#000;font-weight:bold">));&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>至于是什么样的条件，这个属于业务逻辑，不是我的流程控制，所以，这应该交给使用方。&lt;/p>
&lt;p>于是，当我需要统计薪资超过 1 万元的员工的数量时，一行代码就完成了。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c++" data-lang="c++">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">size_t&lt;/span> &lt;span style="color:#000">cnt&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span> &lt;span style="color:#000">count_if&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">staff&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">begin&lt;/span>&lt;span style="color:#000;font-weight:bold">(),&lt;/span> &lt;span style="color:#000">staff&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">end&lt;/span>&lt;span style="color:#000;font-weight:bold">(),&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">{&lt;/span> &lt;span style="color:#204a87;font-weight:bold">return&lt;/span> &lt;span style="color:#000">e&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">salary&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">&amp;gt;&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">10000&lt;/span>&lt;span style="color:#000;font-weight:bold">;&lt;/span> &lt;span style="color:#000;font-weight:bold">});&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Reduce 时可以只对结构体中的某些值做 Reduce，比如说只对 &lt;code>salary&amp;gt;10000&lt;/code> 的人做，只选出这个里面的值，它用 Reduce 就可以达到这步，只要传不同的方式给它，你就可以又造出一个新的东西出来。&lt;/p>
&lt;p>说着说着，就到了函数式编程。函数式编程里面，我们可以用很多的像 reduce 这样的函数来完成更多的像 STL 里面的&lt;code>count_if()&lt;/code>这样有具体意义的函数。关于函数式编程，我们会在后面继续具体聊。&lt;/p>
&lt;h1 id="小结">小结&lt;/h1>
&lt;p>在这篇文章中，我们聊到 C++ 语言是如何通过泛型来解决 C 语言遇到的问题，其实这里面主要就是泛型编程和函数式编程的基本方法相关的细节，虽然解决编程语言中类型带来的问题可能有多种方式，不一定就是 C++ 这种方式。&lt;/p>
&lt;p>而我之所以从 C/C++ 开始，目的只是因为 C/C++ 都是比较偏底层的编程语言。从底层的原理上，我们可以更透彻地了解，从 C 到 C++ 的演进这一过程中带来的编程方式的变化。这可以让你看到，在静态类型语言方面解决泛型编程的一些技术和方法，从而感受到其中的奥妙和原理。&lt;/p>
&lt;p>&lt;strong>因为形式是多样的，但是原理是相通的。所以，这个过程会非常有助于你更深刻地了解后面会谈到的更多的编程范式&lt;/strong>。&lt;/p>
&lt;p>以下是《编程范式游记》系列文章的目录，方便你了解这一系列内容的全貌。&lt;strong>这一系列文章中代码量很大，很难用音频体现出来，所以没有录制音频，还望谅解。&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/301">编程范式游记（1）- 起源&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/303">编程范式游记（2）- 泛型编程&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/2017">编程范式游记（3）- 类型系统和泛型的本质&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/2711">编程范式游记（4）- 函数式编程&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/2723">编程范式游记（5）- 修饰器模式&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/2729">编程范式游记（6）- 面向对象编程&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/2741">编程范式游记（7）- 基于原型的编程范式&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/2748">编程范式游记（8）- Go 语言的委托模式&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/2751">编程范式游记（9）- 编程的本质&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/2752">编程范式游记（10）- 逻辑编程范式&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/2754">编程范式游记（11）- 程序世界里的编程范式&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/fc/e9/fcc761001867c60f526665e237f831e9.jpg" alt="">&lt;/p></description></item><item><title>极客专栏: 32丨编程范式游记（3）-类型系统和泛型的本质</title><link>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E/32%E4%B8%A8%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F%E6%B8%B8%E8%AE%B03-%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E5%92%8C%E6%B3%9B%E5%9E%8B%E7%9A%84%E6%9C%AC%E8%B4%A8/</link><pubDate>Fri, 27 May 2022 00:00:00 +0000</pubDate><guid>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E/32%E4%B8%A8%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F%E6%B8%B8%E8%AE%B03-%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E5%92%8C%E6%B3%9B%E5%9E%8B%E7%9A%84%E6%9C%AC%E8%B4%A8/</guid><description>
&lt;p>前面，我们讨论了从 C 到 C++ 的泛型编程方法，并且初探了更为抽象的函数式编程。正如在上一篇文章中所说的，泛型编程的方式并不只有 C++ 这一种类型，我们只是通过这个过程了解一下，底层静态类型语言的泛型编程原理。这样能够方便我们继续后面的历程。&lt;/p>
&lt;p>是的，除了 C++ 那样的泛型，如果你了解其它编程语言一定会发现，在动态类型语言或是某些有语法糖支持的语言中，那个&lt;code>swap()&lt;/code> 或 &lt;code>search()&lt;/code> 函数的泛型其实可以很简单地就实现了。&lt;/p>
&lt;p>比如，你甚至可以把&lt;code>swap()&lt;/code>函数简单地写成下面这个样子（包括 Go 语言也有这样的语法）：&lt;/p>
&lt;pre>&lt;code>b, a = a, b;
&lt;/code>&lt;/pre>
&lt;p>在上一篇文章后面的 Reduce 函数中，可以看到，在编程世界中，我们需要处理好两件事。&lt;/p>
&lt;ul>
&lt;li>第一件事是编程语言中的类型问题。&lt;/li>
&lt;li>第二件事是对真实世界中业务代码的抽象、重用和拼装。&lt;/li>
&lt;/ul>
&lt;p>所以，在这篇文章中，我们还是继续深入地讨论上面这两个问题，着重讨论一下编程语言中的类型系统和泛型编程的本质。&lt;/p>
&lt;h1 id="类型系统">类型系统&lt;/h1>
&lt;p>在计算机科学中，类型系统用于定义如何将编程语言中的数值和表达式归类为许多不同的类型，以及如何操作这些类型，还有这些类型如何互相作用。类型可以确认一个值或者一组值具有特定的意义和目的。&lt;/p>
&lt;p>一般来说，编程语言会有两种类型，一种是内建类型，如 int、float 和 char 等，一种是抽象类型，如 struct、class 和 function 等。抽象类型在程序运行中，可能不表示为值。类型系统在各种语言之间有非常大的不同，也许，最主要的差异存在于编译时期的语法，以及运行时期的操作实现方式。&lt;/p>
&lt;p>编译器可能使用值的静态类型以最优化所需的存储区，并选取对数值运算时的最佳算法。例如，在许多 C 编译器中，&amp;ldquo;浮点数&amp;quot;数据类型是以 32 比特表示、与 IEEE 754 规格一致的单精度浮点数。因此，在数值运算上，C 应用了浮点数规范（浮点数加法、乘法等）。&lt;/p>
&lt;p>类型的约束程度以及评估方法，影响了语言的类型。更进一步，编程语言可能就类型多态性部分，对每一个类型都对应了一个针对于这个类型的算法运算。类型理论研究类型系统，尽管实际的编程语言类型系统，起源于计算机架构的实际问题、编译器实现，以及语言设计。&lt;/p>
&lt;p>程序语言的类型系统主要提供如下的功能。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>程序语言的安全性&lt;/strong> 。使用类型可以让编译器侦测一些代码的错误。例如：可以识别出一个错误无效的表达式。如：&lt;code>&amp;quot;Hello, World&amp;quot; + 3&lt;/code>这样的不同数据类型间操作的问题。强类型语言提供更多的安全性，但是并不能保证绝对的安全。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>利于编译器的优化&lt;/strong> 。 静态类型语言的类型声明，可以让编译器明确地知道程序员的意图。因此，编译器就可以利用这一信息做很多代码优化工作。例如：如果我们指定一个类型是 &lt;code>int&lt;/code> ，那么编译就知道，这个类型会以 4 个字节的倍数进行对齐，编译器就可以非常有效地利用更有效率的机器指令。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>代码的可读性&lt;/strong>。有类型的编程语言，可以让代码更易读和更易维护。代码的语义也更清楚，代码模块的接口（如函数）也更丰富和清楚。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>抽象化&lt;/strong>。类型允许程序设计者对程序以较高层次的方式思考，而不是烦人的低层次实现。例如，我们使用整型或是浮点型来取代底层的字节实现，我们可以将字符串设计成一个值，而不是底层字节的数组。从高层上来说，类型可以用来定义不同模块间的交互协议，比如函数的入参类型和返回类型，从而可以让接口更有语义，而且不同的模块数据交换更为直观和易懂。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>但是，正如前面说的，&lt;strong>类型带来的问题就是我们作用于不同类型的代码，虽然长得非常相似，但是由于类型的问题需要根据不同版本写出不同的算法，如果要做到泛型，就需要涉及比较底层的玩法&lt;/strong>。&lt;/p>
&lt;p>对此，这个世界出现了两类语言，一类是静态类型语言，如 C、C++、Java，一种是动态类型语言，如 Python、PHP、JavaScript 等。&lt;/p>
&lt;p>我们来看一下，一段动态类型语言的代码：&lt;/p>
&lt;pre>&lt;code>x = 5;
x = &amp;quot;hello&amp;quot;;
&lt;/code>&lt;/pre>
&lt;p>在这个示例中，我们可以看到变量 &lt;code>x&lt;/code> 一开始好像是整型，然后又成了字符串型。如果在静态类型的语言中写出这样的代码，那么就会在编译期出错。而在动态类型的语言中，会以类型标记维持程序所有数值的&amp;quot;标记&amp;rdquo;，并在运算任何数值之前检查标记。所以，一个变量的类型是由运行时的解释器来动态标记的，这样就可以动态地和底层的计算机指令或内存布局对应起来。&lt;/p>
&lt;p>我们再来看一个示例，对于 JavaScript 这样的动态语言来说可以定义出下面这样的数据结构（一个数组的元素可以是各式各样的类型），这在静态类型的语言中是很难做到的。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">var&lt;/span> &lt;span style="color:#000">a&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span> &lt;span style="color:#204a87;font-weight:bold">new&lt;/span> &lt;span style="color:#204a87">Array&lt;/span>&lt;span style="color:#000;font-weight:bold">()&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">a&lt;/span>&lt;span style="color:#000;font-weight:bold">[&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">0&lt;/span>&lt;span style="color:#000;font-weight:bold">]&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">2017&lt;/span>&lt;span style="color:#000;font-weight:bold">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">a&lt;/span>&lt;span style="color:#000;font-weight:bold">[&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">1&lt;/span>&lt;span style="color:#000;font-weight:bold">]&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span> &lt;span style="color:#4e9a06">&amp;#34;Hello&amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">a&lt;/span>&lt;span style="color:#000;font-weight:bold">[&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">2&lt;/span>&lt;span style="color:#000;font-weight:bold">]&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>&lt;span style="color:#000">name&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">:&lt;/span> &lt;span style="color:#4e9a06">&amp;#34;Hao Chen&amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">};&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>注：其实，这并不是一个数组，而是一个 &lt;code>key:value&lt;/code>。因为动态语言的类型是动态的，所以，key 和 value 的类型都可以随意。比如，对于 &lt;code>a&lt;/code> 这个数据结构，还可以写成：&lt;code>a[&amp;quot;key&amp;quot;] = &amp;quot;value&amp;quot;&lt;/code> 这样的方式。&lt;/p>
&lt;/blockquote>
&lt;p>在弱类型或是动态类型的语言中，下面代码的执行会有不确定的结果。&lt;/p>
&lt;pre>&lt;code>x = 5;
y = &amp;quot;37&amp;quot;;
z = x + y;
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>
&lt;p>有的像 Visual Basic 语言给出的结果是 42：系统将字符串 &amp;ldquo;37&amp;rdquo; 转换成数字 37，以匹配运算上的直觉。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>而有的像 JavaScript 语言给出的结果是 &amp;ldquo;537&amp;rdquo;：系统将数字 5 转换成字符串 &amp;ldquo;5&amp;rdquo; 并把两者串接起来。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>像 Python 这样的语言则会产生一个运行时错误。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>但是，&lt;strong>我们需要清楚地知道，无论哪种程序语言，都避免不了一个特定的类型系统&lt;/strong>。哪怕是可随意改变变量类型的动态类型的语言，我们在读代码的过程中也需要脑补某个变量在运行时的类型。&lt;/p>
&lt;p>所以，每个语言都需要一个类型检查系统。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>静态类型检查是在编译器进行语义分析时进行的。如果一个语言强制实行类型规则（即通常只允许以不丢失信息为前提的自动类型转换），那么称此处理为强类型，反之称为弱类型。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>动态类型检查系统更多的是在运行时期做动态类型标记和相关检查。所以，动态类型的语言必然要给出一堆诸如：&lt;code>is_array()&lt;/code>, &lt;code>is_int()&lt;/code>, &lt;code>is_string()&lt;/code> 或是 &lt;code>typeof()&lt;/code> 这样的运行时类型检查函数。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>总之，&amp;ldquo;类型&amp;quot;有时候是一个有用的事，有时候又是一件很讨厌的事情。因为类型是对底层内存布局的一个抽象，会让我们的代码要关注于这些非业务逻辑上的东西。而且，我们的代码需要在不同类型的数据间做处理。但是如果程序语言类型检查得过于严格，那么，我们写出来的代码就不能那么随意。&lt;/p>
&lt;p>所以，对于静态类型的语言也开了些&amp;quot;小后门&amp;rdquo;：比如，类型转换，还有 C++、Java 运行时期的类型测试。&lt;/p>
&lt;p>这些小后门也会带来相当讨厌的问题，比如下面这个 C 语言的示例。&lt;/p>
&lt;pre>&lt;code>int x = 5;
char y[] = &amp;quot;37&amp;quot;;
char* z = x + y;
&lt;/code>&lt;/pre>
&lt;p>在上面这个例子中，结果可能和你想的完全不一样。由于 C 语言的底层特性，这个例子中的 &lt;code>z&lt;/code> 会指向一个超过 &lt;code>y&lt;/code> 地址 5 个字节的内存地址，相当于指向 y 字符串的指针之后的两个空字符处。&lt;/p>
&lt;p>静态类型语言的支持者和动态类型自由形式的支持者，经常发生争执。前者主张，在编译的时候就可以较早发现错误，而且还可增进运行时期的性能。&lt;/p>
&lt;p>后者主张，使用更加动态的类型系统，分析代码更为简单，减少出错机会，才能更加轻松快速地编写程序。与此相关的是，后者还主张，考虑到在类型推断的编程语言中，通常不需要手动宣告类型，这部分的额外开销也就自动降低了。&lt;/p>
&lt;p>在本系列内容的前两篇文章中，我们用 C/C++ 语言来做泛型编程的示例，似乎动态类型语言能够比较好地规避类型导致需要出现多个版本代码的问题。这样可以让我们更好地关注于业务。&lt;/p>
&lt;p>但是，我们需要清楚地明白，&lt;strong>任何语言都有类型系统&lt;/strong>，只是动态类型语言在运行时做类型检查。动态语言的代码复杂度比较低，并可以更容易地关注业务，在某些场景下是对的，但有些情况下却并不见得。&lt;/p>
&lt;p>比如：在 JavaScript 中，我们需要做一个变量转型的函数，可能会是下面这个样子：&lt;/p>
&lt;pre>&lt;code>function ToNumber(x) {
switch(typeof x) {
case &amp;quot;number&amp;quot;: return x;
case &amp;quot;undefined&amp;quot;: return NaN;
case &amp;quot;boolean&amp;quot;: return x ? 1 : 0;
case &amp;quot;string&amp;quot;: return Number(x);
case &amp;quot;object&amp;quot;: return NaN;
case &amp;quot;function&amp;quot;: return NaN;
}
}
&lt;/code>&lt;/pre>
&lt;p>我相信，你在动态类型语言的代码中可以看到大量类似 &lt;code>typeof&lt;/code> 这样的类型检查代码。是的，这是动态类型带来的另一个问题，就是运行时识别（这个是比较耗性能的）。&lt;/p>
&lt;p>如果你用过一段时间的动态类型语言，一旦代码量比较大了，我们就会发现，代码中出现&amp;quot;类型问题&amp;quot;而引发整个程序出错的情况实在是太多太多了。而且，这样的出错会让整个程序崩溃掉，太恐怖了。这个时候，我们就很希望提前发现这些类型的问题。&lt;/p>
&lt;p>静态语言的支持者会说编译器能帮我们找到这些问题，而动态语言的支持者则认为，静态语言的编译器也无法找到所有的问题，想真正提前找到问题只能通过测试来解决。其实他们都对。&lt;/p>
&lt;h1 id="泛型的本质">泛型的本质&lt;/h1>
&lt;p>要了解泛型的本质，就需要了解类型的本质。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>类型是对内存的一种抽象。不同的类型，会有不同的内存布局和内存分配的策略。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>不同的类型，有不同的操作。所以，对于特定的类型，也有特定的一组操作。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>所以，要做到泛型，我们需要做下面的事情。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>标准化掉类型的内存分配、释放和访问。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>标准化掉类型的操作。比如：比较操作，I/O 操作，复制操作&amp;hellip;&amp;hellip;&lt;/p>
&lt;/li>
&lt;li>
&lt;p>标准化掉数据容器的操作。比如：查找算法、过滤算法、聚合算法&amp;hellip;&amp;hellip;&lt;/p>
&lt;/li>
&lt;li>
&lt;p>标准化掉类型上特有的操作。需要有标准化的接口来回调不同类型的具体操作&amp;hellip;&amp;hellip;&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>所以，C++ 动用了非常繁多和复杂的技术来达到泛型编程的目标。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>通过类中的构造、析构、拷贝构造，重载赋值操作符，标准化（隐藏）了类型的内存分配、释放和复制的操作。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>通过重载操作符，可以标准化类型的比较等操作。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>通过 iostream，标准化了类型的输入输出控制。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>通过模板技术（包括模板的特化），来为不同的类型生成类型专属的代码。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>通过迭代器来标准化数据容器的遍历操作。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>通过面向对象的接口依赖（虚函数技术），来标准化了特定类型在特定算法上的操作。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>通过函数式（函数对象），来标准化对于不同类型的特定操作。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>通过学习 C++，我们可以看到一个比较完整的泛型编程里所涉及的编程范式，这些编程泛式在其它语言中都会或多或少地体现着。比如，JDK 5 引入的泛型类型，就源自 C++ 的模板。&lt;/p>
&lt;p>泛型编程于 1985 年在论文 &lt;a href="http://stepanovpapers.com/genprog.pdf">Generic Programming&lt;/a> 中被这样定义：&lt;/p>
&lt;blockquote>
&lt;p>Generic programming centers around the idea of abstracting from concrete, efficient algorithms to obtain generic algorithms that can be combined with different data representations to produce a wide variety of useful software.&lt;/p>
&lt;p>&amp;mdash; Musser, David R.; Stepanov, Alexander A., Generic Programming&lt;/p>
&lt;/blockquote>
&lt;p>我理解其本质就是 &amp;mdash;&amp;mdash; &lt;strong>屏蔽掉数据和操作数据的细节，让算法更为通用，让编程者更多地关注算法的结构，而不是在算法中处理不同的数据类型。&lt;/strong>&lt;/p>
&lt;h1 id="小结">小结&lt;/h1>
&lt;p>在编程语言中，类型系统的出现主要是对容许混乱的操作加上了严格的限制，以避免代码以无效的数据使用方式编译或运行。例如，整数运算不可用于字符串；指针的操作不可用于整数上，等等。但是，类型的产生和限制，虽然对底层代码来说是安全的，但是对于更高层次的抽象产生了些负面因素。比如在 C++ 语言里，为了同时满足静态类型和抽象，就导致了模板技术的出现，带来了语言的复杂性。&lt;/p>
&lt;p>我们需要清楚地明白，编程语言本质上帮助程序员屏蔽底层机器代码的实现，而让我们可以更为关注于业务逻辑代码。但是因为，编程语言作为机器代码和业务逻辑的粘合层，是在让程序员可以控制更多底层的灵活性，还是屏蔽底层细节，让程序员可以更多地关注于业务逻辑，这是很难两全需要 trade-off 的事。&lt;/p>
&lt;p>所以，不同的语言在设计上都会做相应的取舍。比如：C 语言偏向于让程序员可以控制更多的底层细节，而 Java 和 Python 则让程序员更多地关注业务功能的实现。而 C++ 则是两者都想要，导致语言在设计上非常复杂。&lt;/p>
&lt;p>以下是《编程范式游记》系列文章的目录，方便你了解这一系列内容的全貌。&lt;strong>这一系列文章中代码量很大，很难用音频体现出来，所以没有录制音频，还望谅解。&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/301">编程范式游记（1）- 起源&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/303">编程范式游记（2）- 泛型编程&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/2017">编程范式游记（3）- 类型系统和泛型的本质&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/2711">编程范式游记（4）- 函数式编程&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/2723">编程范式游记（5）- 修饰器模式&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/2729">编程范式游记（6）- 面向对象编程&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/2741">编程范式游记（7）- 基于原型的编程范式&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/2748">编程范式游记（8）- Go 语言的委托模式&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/2751">编程范式游记（9）- 编程的本质&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/2752">编程范式游记（10）- 逻辑编程范式&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/2754">编程范式游记（11）- 程序世界里的编程范式&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/fc/e9/fcc761001867c60f526665e237f831e9.jpg" alt="">&lt;/p></description></item><item><title>极客专栏: 33丨编程范式游记（4）-函数式编程</title><link>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E/33%E4%B8%A8%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F%E6%B8%B8%E8%AE%B04-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/</link><pubDate>Fri, 27 May 2022 00:00:00 +0000</pubDate><guid>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E/33%E4%B8%A8%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F%E6%B8%B8%E8%AE%B04-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/</guid><description>
&lt;p>从前三章内容中，我们了解到，虽然 C 语言简单灵活，能够让程序员在高级语言特性之上轻松进行底层上的微观控制，被誉为&amp;quot;高级语言中的汇编语言&amp;quot;，但其基于过程和底层的设计初衷又成了它的短板。&lt;/p>
&lt;p>在程序世界中，编程工作更多的是解决业务上的问题，而不是计算机的问题，我们需要更为贴近业务、更为抽象的语言，如典型的面向对象语言 C++ 和 Java 等。&lt;/p>
&lt;p>C++ 很大程度上解决了 C 语言中的各种问题和不便，尤其是通过类、模板、虚函数和运行时识别等解决了 C 语言的泛型编程问题。然而，如何做更为抽象的泛型呢？答案就是函数式编程（Functional Programming）。&lt;/p>
&lt;h1 id="函数式编程">函数式编程&lt;/h1>
&lt;p>相对于计算机的历史而言，函数式编程其实是一个非常古老的概念。函数式编程的基础模型来源于 λ 演算，而 λ 演算并没有设计在计算机上执行。它是由 Alonzo Church 和 Stephen Cole Kleene 在 20 世纪 30 年代引入的一套用于研究函数定义、函数应用和递归的形式系统。&lt;/p>
&lt;p>如 Alonzo 所说，像 booleans、integers 或者其他的数据结构都可以被函数取代掉。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/7f/cd/7fac133e887bb91f6619887e6a6dcfcd.png" alt="">&lt;/p>
&lt;p>我们来看一下函数式编程，它的理念就来自于数学中的代数。&lt;/p>
&lt;pre>&lt;code>f(x)=5x^2+4x+3
g(x)=2f(x)+5=10x^2+8x+11
h(x)=f(x)+g(x)=15x^2+12x+14
&lt;/code>&lt;/pre>
&lt;p>假设 f(x) 是一个函数，g(x) 是第二个函数，把 f(x) 这个函数套下来，并展开。然后还可以定义一个由两个一元函数组合成的二元函数，还可以做递归，下面这个函数定义就是斐波那契数列。&lt;/p>
&lt;pre>&lt;code>f(x)=f(x-1)+f(x-2)
&lt;/code>&lt;/pre>
&lt;p>对于函数式编程来说，它只关心&lt;strong>定义输入数据和输出数据相关的关系，数学表达式里面其实是在做一种映射（mapping），输入的数据和输出的数据关系是什么样的，是用函数来定义的&lt;/strong>。&lt;/p>
&lt;p>函数式编程有以下特点。&lt;/p>
&lt;p>&lt;strong>特征&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>stateless&lt;/strong>：函数不维护任何状态。函数式编程的核心精神是 stateless，简而言之就是它不能存在状态，打个比方，你给我数据我处理完扔出来。里面的数据是不变的。&lt;/li>
&lt;li>&lt;strong>immutable&lt;/strong>：输入数据是不能动的，动了输入数据就有危险，所以要返回新的数据集。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>优势&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>没有状态就没有伤害。&lt;/li>
&lt;li>并行执行无伤害。&lt;/li>
&lt;li>Copy-Paste 重构代码无伤害。&lt;/li>
&lt;li>函数的执行没有顺序上的问题。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/13/a2/134bd812c06ca16d8f29bc40174055a2.png" alt="">&lt;/p>
&lt;p>函数式编程还带来了以下一些好处。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>惰性求值&lt;/strong> 。这需要编译器的支持。表达式不在它被绑定到变量之后就立即求值，而是在该值被取用的时候求值。也就是说，语句如 &lt;code>x:=expression;&lt;/code> (把一个表达式的结果赋值给一个变量) 显式地调用这个表达式被计算并把结果放置到 &lt;code>x&lt;/code> 中，但是先不管实际在 &lt;code>x&lt;/code> 中的是什么，直到通过后面的表达式中到 &lt;code>x&lt;/code> 的引用而有了对它的值的需求的时候，而后面表达式自身的求值也可以被延迟，最终为了生成让外界看到的某个符号而计算这个快速增长的依赖树。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>确定性&lt;/strong> 。所谓确定性，就是像在数学中那样，&lt;code>f(x) = y&lt;/code> 这个函数无论在什么场景下，都会得到同样的结果，而不是像程序中的很多函数那样，同一个参数，在不同的场景下会计算出不同的结果，这个我们称之为函数的确定性。所谓不同的场景，就是我们的函数会根据运行中的状态信息的不同而发生变化。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>我们知道，因为状态，在并行执行和 copy-paste 时引发 bug 的概率是非常高的，所以没有状态就没有伤害，就像没有依赖就没有伤害一样，并行执行无伤害，copy 代码无伤害，因为没有状态，代码怎样拷都行。&lt;/p>
&lt;p>&lt;strong>劣势&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>数据复制比较严重。&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>&lt;strong>注&lt;/strong>：有一些人可能会觉得这会对性能造成影响。其实，这个劣势不见得会导致性能不好。因为没有状态，所以代码在并行上根本不需要锁（不需要对状态修改的锁），所以可以拼命地并发，反而可以让性能很不错。比如：Erlang 就是其中的代表。&lt;/p>
&lt;/blockquote>
&lt;p>对于纯函数式（也就是完全没有状态的函数）的编程来说，各个语言支持的程度如下。&lt;/p>
&lt;ul>
&lt;li>完全纯函数式 Haskell&lt;/li>
&lt;li>容易写纯函数 F#, Ocaml, Clojure, Scala&lt;/li>
&lt;li>纯函数需要花点精力 C#, Java, JavaScript&lt;/li>
&lt;/ul>
&lt;p>完全纯函数的语言，很容易写成函数，纯函数需要花精力。只要所谓的纯函数的问题，传进来的数据不改，改完的东西复制一份拷出去，然后没有状态。&lt;/p>
&lt;p>但是很多人并不习惯函数式编程，因为函数式编程和过程式编程的思维方式完全不一样。过程式编程是在把具体的流程描述出来，所以可以不假思索，而函数式编程的抽象度更大，在实现方式上，函数套函数，函数返回函数，函数里定义函数&amp;hellip;&amp;hellip;把人搞得很糊涂。&lt;/p>
&lt;h1 id="函数式编程用到的技术">函数式编程用到的技术&lt;/h1>
&lt;p>下面是函数式编程用到的一些技术。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>first class function（头等函数）&lt;/strong> ：这个技术可以让你的函数就像变量一样来使用。也就是说，你的函数可以像变量一样被创建、修改，并当成变量一样传递、返回，或是在函数中嵌套函数。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>tail recursion optimization（尾递归优化）&lt;/strong> ： 我们知道递归的害处，那就是如果递归很深的话，stack 受不了，并会导致性能大幅度下降。因此，我们使用尾递归优化技术&amp;mdash;&amp;mdash;每次递归时都会重用 stack，这样能够提升性能。当然，这需要语言或编译器的支持。Python 就不支持。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>map &amp;amp; reduce&lt;/strong> ：这个技术不用多说了，函数式编程最常见的技术就是对一个集合做 Map 和 Reduce 操作。这比起过程式的语言来说，在代码上要更容易阅读。（传统过程式的语言需要使用 for/while 循环，然后在各种变量中把数据倒过来倒过去的）这个很像 C++ STL 中 foreach、find_if、count_if 等函数的玩法。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>pipeline（管道）&lt;/strong>：这个技术的意思是，将函数实例成一个一个的 action，然后将一组 action 放到一个数组或是列表中，再把数据传给这个 action list，数据就像一个 pipeline 一样顺序地被各个函数所操作，最终得到我们想要的结果。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>recursing（递归）&lt;/strong> ：递归最大的好处就简化代码，它可以把一个复杂的问题用很简单的代码描述出来。注意：递归的精髓是描述问题，而这正是函数式编程的精髓。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>currying（柯里化）&lt;/strong> ：将一个函数的多个参数分解成多个函数， 然后将函数多层封装起来，每层函数都返回一个函数去接收下一个参数，这可以简化函数的多个参数。在 C++ 中，这很像 STL 中的 bind1st 或是 bind2nd。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>higher order function（高阶函数）&lt;/strong>：所谓高阶函数就是函数当参数，把传入的函数做一个封装，然后返回这个封装函数。现象上就是函数传进传出，就像面向对象对象满天飞一样。这个技术用来做 Decorator 很不错。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>上面这些技术太抽象了，我们还是从一个最简单的例子开始。&lt;/p>
&lt;pre>&lt;code>// 非函数式，不是 pure funciton，有状态
int cnt;
void increment(){
cnt++;
}
&lt;/code>&lt;/pre>
&lt;p>这里有个全局变量，调这个全局函数变量 ++，这里面是有状态的，这个状态在外部。所以，如果是多线程的话，这里面的代码是不安全的。&lt;/p>
&lt;p>如果写成纯函数，应该是下面这个样子。&lt;/p>
&lt;pre>&lt;code>// 函数式，pure function， 无状态
int increment(int cnt){
return cnt+1;
}
&lt;/code>&lt;/pre>
&lt;p>这个是你传给我什么，我就返回这个值的 +1 值，你会发现，代码随便拷，而且与线程无关，代码在并行时候不用锁，因为是复制了原有的数据，并返回了新的数据。&lt;/p>
&lt;p>我们再来看另一个例子：&lt;/p>
&lt;pre>&lt;code>def inc(x):
def incx(y):
return x+y
return incx
inc2 = inc(2)
inc5 = inc(5)
print inc2(5) # 输出 7
print inc5(5) # 输出 10
&lt;/code>&lt;/pre>
&lt;p>上面这段 Python 的代码，开始有点复杂了。我们可以看到上面那个例子&lt;code>inc()&lt;/code>函数返回了另一个函数&lt;code>incx()&lt;/code>，于是可以用&lt;code>inc()&lt;/code>函数来构造各种版本的 inc 函数，比如：&lt;code>inc2()&lt;/code>和&lt;code>inc5()&lt;/code>。这个技术其实就是上面所说的 currying 技术. 从这个技术上，你可能体会到函数式编程的理念。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>把函数当成变量来用，关注描述问题而不是怎么实现，这样可以让代码更易读&lt;/strong>。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>因为函数返回里面的这个函数，所以函数关注的是表达式，关注的是描述这个问题，而不是怎么实现这个事情&lt;/strong>。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h1 id="lisp-语言介绍">Lisp 语言介绍&lt;/h1>
&lt;p>要说函数式语言，不可避免地要说一下 Lisp。&lt;/p>
&lt;p>下面，我们再来看看 Scheme 语言（Lisp 的一个方言）的函数式玩法。在 Scheme 里，所有的操作都是函数，包括加减乘除这样的东西。所以，一个表达式是这样的形式&amp;mdash;&amp;mdash; &lt;em>（函数名 参数 1 参数 1）&lt;/em>&lt;/p>
&lt;pre>&lt;code>(define (plus x y) (+ x y))
(define (times x y) (* x y))
(define (square x) (times x x))
&lt;/code>&lt;/pre>
&lt;p>上面三个函数：&lt;/p>
&lt;ul>
&lt;li>用内置的 &lt;code>+&lt;/code> 函数定义了一个新的 &lt;code>plus&lt;/code> 函数。&lt;/li>
&lt;li>用内置的 &lt;code>*&lt;/code> 函数定义了一个新的 &lt;code>times&lt;/code> 函数。&lt;/li>
&lt;li>用之前的 &lt;code>times&lt;/code> 函数定义了一个 &lt;code>square&lt;/code> 函数。&lt;/li>
&lt;/ul>
&lt;p>下面这个函数定义了： f(x) = 5 * x^2 +10&lt;/p>
&lt;pre>&lt;code>(define (f1 x) ;;; f(x) = 5 * x^2 + 10
(plus 10 (times 5 (square x))))
&lt;/code>&lt;/pre>
&lt;p>也可以这样定义&amp;mdash;&amp;mdash;使用 lambda 匿名函数。&lt;/p>
&lt;pre>&lt;code>(define f2
(lambda (x)
(define plus
(lambda (a b) (+ a b)))
(define times
(lambda (a b) (* a b)))
(plus 10 (times 5 (times x x)))))
&lt;/code>&lt;/pre>
&lt;p>在上面的这个代码里，我们使用 lambda 来定义函数 &lt;code>f2&lt;/code> ，然后也同样用 lambda 定义了两个函数&amp;mdash;&amp;mdash; &lt;code>plus&lt;/code> 和 &lt;code>times&lt;/code>。 最后，由 &lt;code>(plus 10 (times 5 (times x x)))&lt;/code> 定义了 &lt;code>f2&lt;/code> 。&lt;/p>
&lt;p>我们再来看一个阶乘的示例：&lt;/p>
&lt;pre>&lt;code>;;; recursion
(define factoral (lambda (x)
(if (&amp;lt;= x 1) 1
(* x (factoral (- x 1))))))
(newline)
(display(factoral 6))
&lt;/code>&lt;/pre>
&lt;p>下面是另一个版本的，使用了尾递归。&lt;/p>
&lt;pre>&lt;code>;;; another version of recursion
(define (factoral_x n)
(define (iter product counter)
(if (&amp;lt; counter n)
product
(iter (* counter product) (+ counter 1))))
(iter 1 1))
(newline)
(display(factoral_x 5))
&lt;/code>&lt;/pre>
&lt;h1 id="函数式编程的思维方式">函数式编程的思维方式&lt;/h1>
&lt;p>前面提到过多次，函数式编程关注的是：describe what to do, rather than how to do it。于是，我们把以前的过程式编程范式叫做 Imperative Programming &amp;ndash; 指令式编程，而把函数式编程范式叫做 Declarative Programming &amp;ndash; 声明式编程。&lt;/p>
&lt;h2 id="传统方式的写法">传统方式的写法&lt;/h2>
&lt;p>下面我们看一下相关的示例。比如，我们有 3 辆车比赛，简单起见，我们分别给这 3 辆车 70% 的概率让它们可以往前走一步，一共有 5 次机会，然后打出每一次这 3 辆车的前行状态。&lt;/p>
&lt;p>对于 Imperative Programming 来说，代码如下（Python）：&lt;/p>
&lt;pre>&lt;code>from random import random
time = 5
car_positions = [1, 1, 1]
while time:
# decrease time
time -= 1
print ''
for i in range(len(car_positions)):
# move car
if random() &amp;gt; 0.3:
car_positions[i] += 1
# draw car
print '-' * car_positions[i]
&lt;/code>&lt;/pre>
&lt;p>我们可以把这两重循环变成一些函数模块，这样有利于更容易地阅读代码：&lt;/p>
&lt;pre>&lt;code>from random import random
def move_cars():
for i, _ in enumerate(car_positions):
if random() &amp;gt; 0.3:
car_positions[i] += 1
def draw_car(car_position):
print '-' * car_position
def run_step_of_race():
global time
time -= 1
move_cars()
def draw():
print ''
for car_position in car_positions:
draw_car(car_position)
time = 5
car_positions = [1, 1, 1]
while time:
run_step_of_race()
draw()
&lt;/code>&lt;/pre>
&lt;p>上面的代码，从主循环开始，我们可以很清楚地看到程序的主干，因为我们把程序的逻辑分成了几个函数。这样一来，代码逻辑就会变成几个小碎片，于是我们读代码时要考虑的上下文就少了很多，阅读代码也会更容易。不像第一个示例，如果没有注释和说明，你还是需要花些时间理解一下。而将代码逻辑封装成了函数后，我们就相当于给每个相对独立的程序逻辑取了个名字，于是代码成了自解释的。&lt;/p>
&lt;p>但是，你会发现，封装成函数后，这些函数都会依赖于共享的变量来同步其状态。于是，在读代码的过程中，每当我们进入到函数里，读到访问了一个外部的变量时，我们马上要去查看这个变量的上下文，然后还要在大脑里推演这个变量的状态， 才能知道程序的真正逻辑。也就是说，这些函数必须知道其它函数是怎么修改它们之间的共享变量的，所以，这些函数是有状态的。&lt;/p>
&lt;h2 id="函数式的写法">函数式的写法&lt;/h2>
&lt;p>我们知道，有状态并不是一件很好的事情，无论是对代码重用，还是对代码的并行来说，都是有副作用的。因此，要想个方法把这些状态搞掉，于是出现了函数式编程的编程范式。下面，我们来看看函数式的方式应该怎么写？&lt;/p>
&lt;pre>&lt;code>from random import random
def move_cars(car_positions):
return map(lambda x: x + 1 if random() &amp;gt; 0.3 else x,
car_positions)
def output_car(car_position):
return '-' * car_position
def run_step_of_race(state):
return {'time': state['time'] - 1,
'car_positions': move_cars(state['car_positions'])}
def draw(state):
print ''
print '\n'.join(map(output_car, state['car_positions']))
def race(state):
draw(state)
if state['time']:
race(run_step_of_race(state))
race({'time': 5,
'car_positions': [1, 1, 1]})
&lt;/code>&lt;/pre>
&lt;p>上面的代码依然把程序的逻辑分成了函数。不过这些函数都是函数式的，它们有三个特点：它们之间没有共享的变量；函数间通过参数和返回值来传递数据；在函数里没有临时变量。&lt;/p>
&lt;p>我们还可以看到，for 循环被递归取代了（见 race 函数）&amp;mdash;&amp;mdash; 递归是函数式编程中常用到的技术，正如前面所说的，递归的本质就是描述问题是什么。&lt;/p>
&lt;h1 id="函数式语言的三套件">函数式语言的三套件&lt;/h1>
&lt;p>函数式语言有三套件，&lt;strong>Map&lt;/strong> 、&lt;strong>Reduce&lt;/strong> 和 &lt;strong>Filter&lt;/strong>。这在谈 C++ 的泛型编程时已经介绍过。下面我们来看一下 Python 语言中的一个示例。这个示例的需求是，我们想把一个字符串数组中的字符串都转成小写。&lt;/p>
&lt;p>用常规的面向过程的方式，代码如下所示：&lt;/p>
&lt;pre>&lt;code># 传统的非函数式
upname =['HAO', 'CHEN', 'COOLSHELL']
lowname =[]
for i in range(len(upname)):
lowname.append( upname[i].lower() )
&lt;/code>&lt;/pre>
&lt;p>如果写成函数式，用 &lt;code>map()&lt;/code> 函数，是下面这个样子。&lt;/p>
&lt;pre>&lt;code># 函数式
def toUpper(item):
return item.upper()
upper_name = map(toUpper, [&amp;quot;hao&amp;quot;, &amp;quot;chen&amp;quot;, &amp;quot;coolshell&amp;quot;])
print upper_name
# 输出 ['HAO', 'CHEN', 'COOLSHELL']
&lt;/code>&lt;/pre>
&lt;p>顺便说一下，上面的例子是不是和我们 C++ 语言中的 STL 的&lt;code>transform()&lt;/code>函数有些像？&lt;/p>
&lt;pre>&lt;code>string s=&amp;quot;hello&amp;quot;;
transform(s.begin(), s.end(), back_inserter(out), ::toupper);
&lt;/code>&lt;/pre>
&lt;p>在上面 Python 的那个例子中可以看到，我们定义了一个函数 toUpper，这个函数没有改变传进来的值，只是把传进来的值做个简单的操作，然后返回。然后，我们把它用在 map 函数中，就可以很清楚地描述出我们想要干什么，而不是去理解一个在循环中怎么实现的代码，最终在读了很多循环的逻辑后才发现是什么意思。&lt;/p>
&lt;p>如果你觉得上面的代码在传统的非函数式的方式下还是很容易读的，那么我们再来看一个计算数组平均值的代码：&lt;/p>
&lt;pre>&lt;code># 计算数组中正数的平均值
num = [2, -5, 9, 7, -2, 5, 3, 1, 0, -3, 8]
positive_num_cnt = 0
positive_num_sum = 0
for i in range(len(num)):
if num[i] &amp;gt; 0:
positive_num_cnt += 1
positive_num_sum += num[i]
if positive_num_cnt &amp;gt; 0:
average = positive_num_sum / positive_num_cnt
print average
&lt;/code>&lt;/pre>
&lt;p>上面的代码如果没有注释的话，你需要看一会儿才能明白，只是计算数组中正数的平均值。&lt;/p>
&lt;p>我们再来看看函数式下使用 filter/reduce 函数的玩法。&lt;/p>
&lt;pre>&lt;code># 计算数组中正数的平均值
positive_num = filter(lambda x: x&amp;gt;0, num)
average = reduce(lambda x,y: x+y, positive_num) / len( positive_num )
&lt;/code>&lt;/pre>
&lt;p>首先，我们使用 filter 函数把正数过滤出来（注意： &lt;code>lambda x : x&amp;gt;0&lt;/code> 这个 lambda 表达式），保存在一个新的数组中 &amp;mdash;&amp;mdash; &lt;code>positive_num&lt;/code>。然后，我们使用 reduce 函数对数组 &lt;code>positive_num&lt;/code> 求和后，再除以其个数，就得到正数的平均值了。&lt;/p>
&lt;p>我们可以看到， &lt;strong>隐藏了数组遍历并过滤数组控制流程的 filter 和 reduce， 不仅让代码更为简洁，因为代码里只有业务逻辑了，而且让我们能更容易地理解代码&lt;/strong>。&lt;/p>
&lt;ol>
&lt;li>对 &lt;code>num&lt;/code> 数组 &lt;code>filter&lt;/code> 条件 &lt;code>x &amp;gt; 0&lt;/code> 的数据。&lt;/li>
&lt;li>然后对 &lt;code>positive_num&lt;/code> 进行 &lt;code>x + y&lt;/code> 操作的 reduce，即求和。&lt;/li>
&lt;li>&amp;hellip;&amp;hellip;&lt;/li>
&lt;/ol>
&lt;p>感觉代码更亲切了，不是吗？因为：&lt;/p>
&lt;ul>
&lt;li>数据集、对数据的操作和返回值都放在了一起。&lt;/li>
&lt;li>没有了循环体，就可以少了些临时用来控制程序执行逻辑的变量，也少了把数据倒来倒去的控制逻辑。&lt;/li>
&lt;li>&lt;strong>代码变成了在描述你要干什么，而不是怎么干&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;p>当然，如果你是第一次见到 map/reduce/filter，那你可能还是会有点儿陌生和不解，这只是你不了解罢了。&lt;/p>
&lt;p>对于函数式编程的思路，下图是一个比较形象的例子，面包和蔬菜 map 到切碎的操作上，再把结果给 reduce 成汉堡。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/cf/81/cfbbd404c980f98040514371aceb8881.png" alt="">&lt;/p>
&lt;p>在这个图中，&lt;strong>我们可以看到 map 和 reduce 不关心源输入数据，它们只是控制，并不是业务。控制是描述怎么干，而业务是描述要干什么&lt;/strong>。&lt;/p>
&lt;h1 id="函数式的-pipeline-模式">函数式的 pipeline 模式&lt;/h1>
&lt;p>pipeline（管道）借鉴于 Unix Shell 的管道操作&amp;mdash;&amp;mdash;把若干个命令串起来，前面命令的输出成为后面命令的输入，如此完成一个流式计算。（注：管道绝对是一个伟大的发明，它的设计哲学就是 KISS &amp;ndash; 让每个功能就做一件事，并把这件事做到极致，软件或程序的拼装会变得更为简单和直观。这个设计理念影响非常深远，包括今天的 Web Service、云计算，以及大数据的流式计算等。）&lt;/p>
&lt;p>比如，我们如下的 shell 命令：&lt;/p>
&lt;pre>&lt;code>ps auwwx | awk '{print $2}' | sort -n | xargs echo
&lt;/code>&lt;/pre>
&lt;p>上面的例子是要查看一个用户执行的进程列表，列出来以后，然后取第二列，第二列是它的进程 ID，排个序，再把它显示出来。&lt;/p>
&lt;p>抽象成函数式的样子，我们就可以反过来，一层套一层。&lt;/p>
&lt;pre>&lt;code>xargs( echo, sort(n, awk('print $2', ps(auwwx))) )
&lt;/code>&lt;/pre>
&lt;p>我们也可以把函数放进数组里面，然后顺序执行一下。&lt;/p>
&lt;pre>&lt;code>pids = for_each(result, [ps_auwwx, awk_p2, sort_n, xargs_echo])
&lt;/code>&lt;/pre>
&lt;p>多说一句，如果我们把这些函数比作微服务，那么管道这个事是在干什么呢？其实就是在做服务的编排。像 Unix 这些经典的技术上的实践或理论，往往是可以反映到分布式架构的，所以，一般来说，一个好的分布式架构师，通常都是对这些传统的微观上的经典技术有非常深刻的认识，因为这些东西在方法论上都是相通的。&lt;/p>
&lt;p>好了，还是让我们用一个简单的示例来看一下如何实现 pipeline。&lt;/p>
&lt;p>我们先来看一个程序，这个程序的 process() 有三个步骤：&lt;/p>
&lt;ol>
&lt;li>找出偶数；&lt;/li>
&lt;li>乘以 3；&lt;/li>
&lt;li>转成字符串返回。&lt;/li>
&lt;/ol>
&lt;p>传统的非函数式的实现如下：&lt;/p>
&lt;pre>&lt;code>def process(num):
# filter out non-evens
if num % 2 != 0:
return
num = num * 3
num = 'The Number: %s' % num
return num
nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
for num in nums:
print process(num)
# 输出：
# None
# The Number: 6
# None
# The Number: 12
# None
# The Number: 18
# None
# The Number: 24
# None
# The Number: 30
&lt;/code>&lt;/pre>
&lt;p>我们可以看到，输出的结果并不够完美，另外，代码阅读上如果没有注释，你也会比较晕。下面，我们来看看函数式的 pipeline（第一种方式）应该怎么写？&lt;/p>
&lt;p>第一步，我们先把三个&amp;quot;子需求&amp;quot;写成函数：&lt;/p>
&lt;pre>&lt;code>def even_filter(nums):
for num in nums:
if num % 2 == 0:
yield num
def multiply_by_three(nums):
for num in nums:
yield num * 3
def convert_to_string(nums):
for num in nums:
yield 'The Number: %s' % num
&lt;/code>&lt;/pre>
&lt;p>然后，我们再把这三个函数串起来：&lt;/p>
&lt;pre>&lt;code>nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
pipeline = convert_to_string(multiply_by_three(even_filter(nums)))
for num in pipeline:
print num
# 输出：
# The Number: 6
# The Number: 12
# The Number: 18
# The Number: 24
# The Number: 30
&lt;/code>&lt;/pre>
&lt;p>上面，我们动用了 Python 的关键字 yield，它是一个类似 return 的关键字，只是这个函数返回的是 Generator（生成器）。所谓生成器，指的是 yield 返回的是一个可迭代的对象，并没有真正的执行函数。也就是说，只有其返回的迭代对象被迭代时，yield 函数才会真正运行，运行到 yield 语句时就会停住，然后等下一次的迭代。（ yield 是个比较诡异的关键字）这就是 lazy evluation（懒惰加载）。&lt;/p>
&lt;p>好了，根据前面的原则&amp;mdash;&amp;mdash;&amp;quot;&lt;strong>使用 Map &amp;amp; Reduce，不要使用循环&lt;/strong>&amp;quot;（还记得吗？使用循环会让我们只能使用顺序型的数据结构），那我们用比较纯朴的 Map &amp;amp; Reduce 吧。&lt;/p>
&lt;pre>&lt;code>def even_filter(nums):
return filter(lambda x: x%2==0, nums)
def multiply_by_three(nums):
return map(lambda x: x*3, nums)
def convert_to_string(nums):
return map(lambda x: 'The Number: %s' % x, nums)
nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
pipeline = convert_to_string(
multiply_by_three(
even_filter(nums)
)
)
for num in pipeline:
print num
&lt;/code>&lt;/pre>
&lt;p>上面的代码是不是更容易读了，但需要嵌套使用函数，这个有点儿令人不爽，如果我们能像下面这个样子就好了（第二种方式）。&lt;/p>
&lt;pre>&lt;code>pipeline_func(nums, [even_filter,
multiply_by_three,
convert_to_string])
&lt;/code>&lt;/pre>
&lt;p>可以看到，其实，就是对一堆函数做一个 reduce， 于是，pipeline 函数可以实现成下面这样：&lt;/p>
&lt;pre>&lt;code>def pipeline_func(data, fns):
return reduce(lambda a, x: x(a), fns, data)
&lt;/code>&lt;/pre>
&lt;p>当然，使用 Python 的 &lt;code>force&lt;/code> 函数以及 decorator 模式可以把上面的代码写得更像管道：&lt;/p>
&lt;pre>&lt;code>class Pipe(object):
def __init__(self, func):
self.func = func
def __ror__(self, other):
def generator():
for obj in other:
if obj is not None:
yield self.func(obj)
return generator()
@Pipe
def even_filter(num):
return num if num % 2 == 0 else None
@Pipe
def multiply_by_three(num):
return num*3
@Pipe
def convert_to_string(num):
return 'The Number: %s' % num
@Pipe
def echo(item):
print item
return item
def force(sqs):
for item in sqs: pass
nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
force(nums | even_filter | multiply_by_three | convert_to_string | echo)
&lt;/code>&lt;/pre>
&lt;h1 id="小结">小结&lt;/h1>
&lt;p>相对于计算机发展史，函数式编程是个非常古老的概念，它的核心思想是将运算过程尽量写成一系列嵌套的函数调用，关注的是做什么而不是怎么做，因而被称为声明式编程。以 Stateless（无状态）和 Immutable（不可变）为主要特点，代码简洁，易于理解，能便于进行并行执行，易于做代码重构，函数执行没有顺序上的问题，支持惰性求值，具有函数的确定性&amp;mdash;&amp;mdash;无论在什么场景下都会得到同样的结果。&lt;/p>
&lt;p>本文结合递归、map 和 reduce，以及 pipeline 等技术，对比了非函数式编程和函数式编程在解决相同问题时的不同处理思路，让你对函数式编程范式有了清晰明确的认知。并在文末引入了 decorator（修饰器），使得将普通函数管道化成为一件轻而易举的事情。此时你可能有疑问，decorator 到底是什么呢？怎样使用它呢？敬请关注下一章中的内容，来得到这些答案。&lt;/p>
&lt;p>了解了这么多函数式编程的知识，想请你深入思考一个问题：你是偏好在命令式编程语言中使用函数式编程风格呢，还是坚持使用函数式语言编程？原因是什么？欢迎在评论区留言和我一起探讨。&lt;/p>
&lt;p>以下是《编程范式游记》系列文章的目录，方便你了解这一系列内容的全貌。&lt;strong>这一系列文章中代码量很大，很难用音频体现出来，所以没有录制音频，还望谅解。&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/301">编程范式游记（1）- 起源&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/303">编程范式游记（2）- 泛型编程&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/2017">编程范式游记（3）- 类型系统和泛型的本质&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/2711">编程范式游记（4）- 函数式编程&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/2723">编程范式游记（5）- 修饰器模式&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/2729">编程范式游记（6）- 面向对象编程&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/2741">编程范式游记（7）- 基于原型的编程范式&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/2748">编程范式游记（8）- Go 语言的委托模式&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/2751">编程范式游记（9）- 编程的本质&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/2752">编程范式游记（10）- 逻辑编程范式&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/2754">编程范式游记（11）- 程序世界里的编程范式&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/40/18/40341574317cc135385c6946a17d2818.jpg" alt="">&lt;/p>
&lt;p>&lt;a href="https://time.geekbang.org/activity/sale-poster?utm_source=geektime&amp;amp;utm_medium=chenhao&amp;amp;utm_campaign=201803&amp;amp;utm_content=chenhaofxbanner">戳此获取你的专属海报&lt;/a>&lt;/p></description></item><item><title>极客专栏: 34丨编程范式游记（5）-修饰器模式</title><link>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E/34%E4%B8%A8%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F%E6%B8%B8%E8%AE%B05-%E4%BF%AE%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/</link><pubDate>Fri, 27 May 2022 00:00:00 +0000</pubDate><guid>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E/34%E4%B8%A8%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F%E6%B8%B8%E8%AE%B05-%E4%BF%AE%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/</guid><description>
&lt;p>在上一篇文章中，我们领略了函数式编程的趣味和魅力，主要讲了函数式编程的主要技术。还记得有哪些吗？递归、Map、Reduce、Filter 等，并利用 Python 的 Decorator 和 Generator 功能，将多个函数组合成了管道。&lt;/p>
&lt;p>此时，你心中可能会有个疑问，这个 decorator 又是怎样工作的呢？这就是本文中要讲述的内容，&amp;ldquo;Decorator 模式&amp;rdquo;，又叫&amp;quot;修饰器模式&amp;quot;，或是&amp;quot;装饰器模式&amp;quot;。&lt;/p>
&lt;h1 id="python-的-decorator">Python 的 Decorator&lt;/h1>
&lt;p>Python 的 Decorator 在使用上和 Java 的 Annotation（以及 C# 的 Attribute）很相似，就是在方法名前面加一个 @XXX 注解来为这个方法装饰一些东西。但是，Java/C# 的 Annotation 也很让人望而却步，太过于复杂了。你要玩它，需要先了解一堆 Annotation 的类库文档，感觉几乎就是在学另外一门语言。&lt;/p>
&lt;p>而 Python 使用了一种相对于 Decorator Pattern 和 Annotation 来说非常优雅的方法，这种方法不需要你去掌握什么复杂的 OO 模型或是 Annotation 的各种类库规定，完全就是语言层面的玩法：一种函数式编程的技巧。&lt;/p>
&lt;p>这是我最喜欢的一个模式了，也是一个挺好玩儿的东西，这个模式动用了函数式编程的一个技术&amp;mdash;&amp;mdash;用一个函数来构造另一个函数。&lt;/p>
&lt;p>好了，我们先来点感性认识，看一个 Python 修饰器的 Hello World 代码。&lt;/p>
&lt;pre>&lt;code>def hello(fn):
def wrapper():
print &amp;quot;hello, %s&amp;quot; % fn.__name__
fn()
print &amp;quot;goodbye, %s&amp;quot; % fn.__name__
return wrapper
@hello
def Hao():
print &amp;quot;i am Hao Chen&amp;quot;
Hao()
&lt;/code>&lt;/pre>
&lt;p>代码的执行结果如下：&lt;/p>
&lt;pre>&lt;code>$ python hello.py
hello, Hao
i am Hao Chen
goodbye, Hao
&lt;/code>&lt;/pre>
&lt;p>你可以看到如下的东西：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>函数 &lt;code>Hao&lt;/code> 前面有个 @hello 的&amp;quot;注解&amp;quot;，&lt;code>hello&lt;/code> 就是我们前面定义的函数 &lt;code>hello&lt;/code>；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>在 &lt;code>hello&lt;/code> 函数中，其需要一个 &lt;code>fn&lt;/code> 的参数（这就是用来做回调的函数）；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>hello 函数中返回了一个 inner 函数 &lt;code>wrapper&lt;/code>，这个 &lt;code>wrapper&lt;/code>函数回调了传进来的 &lt;code>fn&lt;/code>，并在回调前后加了两条语句。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>对于 Python 的这个 @注解语法糖（syntactic sugar）来说，当你在用某个 @decorator 来修饰某个函数 &lt;code>func&lt;/code> 时，如下所示:&lt;/p>
&lt;pre>&lt;code>@decorator
def func():
pass
&lt;/code>&lt;/pre>
&lt;p>其解释器会解释成下面这样的语句：&lt;/p>
&lt;pre>&lt;code>func = decorator(func)
&lt;/code>&lt;/pre>
&lt;p>嘿！这不就是把一个函数当参数传到另一个函数中，然后再回调吗？是的。但是，我们需要注意，那里还有一个赋值语句，把 decorator 这个函数的返回值赋值回了原来的 &lt;code>func&lt;/code>。&lt;/p>
&lt;p>我们再来看一个带参数的玩法：&lt;/p>
&lt;pre>&lt;code>def makeHtmlTag(tag, *args, **kwds):
def real_decorator(fn):
css_class = &amp;quot; class='{0}'&amp;quot;.format(kwds[&amp;quot;css_class&amp;quot;]) \
if &amp;quot;css_class&amp;quot; in kwds else &amp;quot;&amp;quot;
def wrapped(*args, **kwds):
return &amp;quot;&amp;lt;&amp;quot;+tag+css_class+&amp;quot;&amp;gt;&amp;quot; + fn(*args, **kwds) + &amp;quot;&amp;lt;/&amp;quot;+tag+&amp;quot;&amp;gt;&amp;quot;
return wrapped
return real_decorator
@makeHtmlTag(tag=&amp;quot;b&amp;quot;, css_class=&amp;quot;bold_css&amp;quot;)
@makeHtmlTag(tag=&amp;quot;i&amp;quot;, css_class=&amp;quot;italic_css&amp;quot;)
def hello():
return &amp;quot;hello world&amp;quot;
print hello()
# 输出：
# &amp;lt;b class='bold_css'&amp;gt;&amp;lt;i class='italic_css'&amp;gt;hello world&amp;lt;/i&amp;gt;&amp;lt;/b&amp;gt;
&lt;/code>&lt;/pre>
&lt;p>在上面这个例子中，我们可以看到：&lt;code>makeHtmlTag&lt;/code>有两个参数。所以，为了让 &lt;code>hello = makeHtmlTag(arg1, arg2)(hello)&lt;/code> 成功， &lt;code>makeHtmlTag&lt;/code> 必需返回一个 decorator（这就是为什么我们在 &lt;code>makeHtmlTag&lt;/code> 中加入了 &lt;code>real_decorator()&lt;/code>）。&lt;/p>
&lt;p>这样一来，我们就可以进入到 decorator 的逻辑中去了&amp;mdash;&amp;mdash;decorator 得返回一个 wrapper，wrapper 里回调 &lt;code>hello&lt;/code>。看似那个 &lt;code>makeHtmlTag()&lt;/code> 写得层层叠叠，但是，已经了解了本质的我们觉得写得很自然。&lt;/p>
&lt;p>我们再来看一个为其它函数加缓存的示例:&lt;/p>
&lt;pre>&lt;code>from functools import wraps
def memoization(fn):
cache = {}
miss = object()
@wraps(fn)
def wrapper(*args):
result = cache.get(args, miss)
if result is miss:
result = fn(*args)
cache[args] = result
return result
return wrapper
@memoization
def fib(n):
if n &amp;lt; 2:
return n
return fib(n - 1) + fib(n - 2)
&lt;/code>&lt;/pre>
&lt;p>上面这个例子中，是一个斐波那契数例的递归算法。我们知道，这个递归是相当没有效率的，因为会重复调用。比如：我们要计算 fib(5)，于是其分解成 &lt;code>fib(4) + fib(3)&lt;/code>，而 &lt;code>fib(4)&lt;/code> 分解成 &lt;code>fib(3) + fib(2)&lt;/code>，&lt;code>fib(3)&lt;/code> 又分解成&lt;code>fib(2) + fib(1)&lt;/code>&amp;hellip;&amp;hellip;你可以看到，基本上来说，&lt;code>fib(3)&lt;/code>, &lt;code>fib(2)&lt;/code>, &lt;code>fib(1)&lt;/code>在整个递归过程中被调用了至少两次。&lt;/p>
&lt;p>而我们用 decorator，在调用函数前查询一下缓存，如果没有才调用，有了就从缓存中返回值。一下子，这个递归从二叉树式的递归成了线性的递归。&lt;code>wraps&lt;/code> 的作用是保证 &lt;code>fib&lt;/code> 的函数名不被 &lt;code>wrapper&lt;/code> 所取代。&lt;/p>
&lt;p>除此之外，Python 还支持类方式的 decorator。&lt;/p>
&lt;pre>&lt;code>class myDecorator(object):
def __init__(self, fn):
print &amp;quot;inside myDecorator.__init__()&amp;quot;
self.fn = fn
def __call__(self):
self.fn()
print &amp;quot;inside myDecorator.__call__()&amp;quot;
@myDecorator
def aFunction():
print &amp;quot;inside aFunction()&amp;quot;
print &amp;quot;Finished decorating aFunction()&amp;quot;
aFunction()
# 输出：
# inside myDecorator.__init__()
# Finished decorating aFunction()
# inside aFunction()
# inside myDecorator.__call__()
&lt;/code>&lt;/pre>
&lt;p>上面这个示例展示了，用类的方式声明一个 decorator。我们可以看到这个类中有两个成员：&lt;/p>
&lt;ol>
&lt;li>一个是&lt;code>__init__()&lt;/code>，这个方法是在我们给某个函数 decorate 时被调用，所以，需要有一个 &lt;code>fn&lt;/code> 的参数，也就是被 decorate 的函数。&lt;/li>
&lt;li>一个是&lt;code>__call__()&lt;/code>，这个方法是在我们调用被 decorate 的函数时被调用的。&lt;/li>
&lt;/ol>
&lt;p>从上面的输出中，可以看到整个程序的执行顺序。这看上去要比&amp;quot;函数式&amp;quot;的方式更易读一些。&lt;/p>
&lt;p>我们来看一个实际点的例子。下面这个示例展示了通过 URL 的路由来调用相关注册的函数示例：&lt;/p>
&lt;pre>&lt;code>class MyApp():
def __init__(self):
self.func_map = {}
def register(self, name):
def func_wrapper(func):
self.func_map[name] = func
return func
return func_wrapper
def call_method(self, name=None):
func = self.func_map.get(name, None)
if func is None:
raise Exception(&amp;quot;No function registered against - &amp;quot; + str(name))
return func()
app = MyApp()
@app.register('/')
def main_page_func():
return &amp;quot;This is the main page.&amp;quot;
@app.register('/next_page')
def next_page_func():
return &amp;quot;This is the next page.&amp;quot;
print app.call_method('/')
print app.call_method('/next_page')
&lt;/code>&lt;/pre>
&lt;p>注意：上面这个示例中 decorator 类不是真正的 decorator，其中也没有&lt;code>__call__()&lt;/code>，并且，wrapper 返回了原函数。所以，原函数没有发生任何变化。&lt;/p>
&lt;h1 id="go-语言的-decorator">Go 语言的 Decorator&lt;/h1>
&lt;p>Python 有语法糖，所以写出来的代码比较酷。但是对于没有修饰器语法糖这类语言，写出来的代码会是怎么样的？我们来看一下 Go 语言的代码。&lt;/p>
&lt;p>还是从一个 Hello World 开始。&lt;/p>
&lt;pre>&lt;code>package main
import &amp;quot;fmt&amp;quot;
func decorator(f func(s string)) func(s string) {
return func(s string) {
fmt.Println(&amp;quot;Started&amp;quot;)
f(s)
fmt.Println(&amp;quot;Done&amp;quot;)
}
}
func Hello(s string) {
fmt.Println(s)
}
func main() {
decorator(Hello)(&amp;quot;Hello, World!&amp;quot;)
}
&lt;/code>&lt;/pre>
&lt;p>可以看到，我们动用了一个高阶函数 &lt;code>decorator()&lt;/code>，在调用的时候，先把 &lt;code>Hello()&lt;/code> 函数传进去，然后其返回一个匿名函数。这个匿名函数中除了运行了自己的代码，也调用了被传入的 &lt;code>Hello()&lt;/code> 函数。&lt;/p>
&lt;p>这个玩法和 Python 的异曲同工，只不过，Go 并不支持像 Python 那样的 @decorator 语法糖。所以，在调用上有些难看。当然，如果要想让代码容易读一些，你可以这样：&lt;/p>
&lt;pre>&lt;code>hello := decorator(Hello)
hello(&amp;quot;Hello&amp;quot;)
&lt;/code>&lt;/pre>
&lt;p>我们再来看一个为函数 log 消耗时间的例子：&lt;/p>
&lt;pre>&lt;code>type SumFunc func(int64, int64) int64
func getFunctionName(i interface{}) string {
return runtime.FuncForPC(reflect.ValueOf(i).Pointer()).Name()
}
func timedSumFunc(f SumFunc) SumFunc {
return func(start, end int64) int64 {
defer func(t time.Time) {
fmt.Printf(&amp;quot;--- Time Elapsed (%s): %v ---\n&amp;quot;,
getFunctionName(f), time.Since(t))
}(time.Now())
return f(start, end)
}
}
func Sum1(start, end int64) int64 {
var sum int64
sum = 0
if start &amp;gt; end {
start, end = end, start
}
for i := start; i &amp;lt;= end; i++ {
sum += i
}
return sum
}
func Sum2(start, end int64) int64 {
if start &amp;gt; end {
start, end = end, start
}
return (end - start + 1) * (end + start) / 2
}
func main() {
sum1 := timedSumFunc(Sum1)
sum2 := timedSumFunc(Sum2)
fmt.Printf(&amp;quot;%d, %d\n&amp;quot;, sum1(-10000, 10000000), sum2(-10000, 10000000))
}
&lt;/code>&lt;/pre>
&lt;p>关于上面的代码：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>有两个 Sum 函数，&lt;code>Sum1()&lt;/code> 函数就是简单地做个循环，&lt;code>Sum2()&lt;/code> 函数动用了数据公式。（注意：&lt;code>start&lt;/code> 和 &lt;code>end&lt;/code> 有可能有负数的情况。）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>代码中使用了 Go 语言的反射机制来获取函数名。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>修饰器函数是 &lt;code>timedSumFunc()&lt;/code>。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>再来看一个 HTTP 路由的例子：&lt;/p>
&lt;pre>&lt;code>func WithServerHeader(h http.HandlerFunc) http.HandlerFunc {
return func(w http.ResponseWriter, r *http.Request) {
log.Println(&amp;quot;---&amp;gt;WithServerHeader()&amp;quot;)
w.Header().Set(&amp;quot;Server&amp;quot;, &amp;quot;HelloServer v0.0.1&amp;quot;)
h(w, r)
}
}
func WithAuthCookie(h http.HandlerFunc) http.HandlerFunc {
return func(w http.ResponseWriter, r *http.Request) {
log.Println(&amp;quot;---&amp;gt;WithAuthCookie()&amp;quot;)
cookie := &amp;amp;http.Cookie{Name: &amp;quot;Auth&amp;quot;, Value: &amp;quot;Pass&amp;quot;, Path: &amp;quot;/&amp;quot;}
http.SetCookie(w, cookie)
h(w, r)
}
}
func WithBasicAuth(h http.HandlerFunc) http.HandlerFunc {
return func(w http.ResponseWriter, r *http.Request) {
log.Println(&amp;quot;---&amp;gt;WithBasicAuth()&amp;quot;)
cookie, err := r.Cookie(&amp;quot;Auth&amp;quot;)
if err != nil || cookie.Value != &amp;quot;Pass&amp;quot; {
w.WriteHeader(http.StatusForbidden)
return
}
h(w, r)
}
}
func WithDebugLog(h http.HandlerFunc) http.HandlerFunc {
return func(w http.ResponseWriter, r *http.Request) {
log.Println(&amp;quot;---&amp;gt;WithDebugLog&amp;quot;)
r.ParseForm()
log.Println(r.Form)
log.Println(&amp;quot;path&amp;quot;, r.URL.Path)
log.Println(&amp;quot;scheme&amp;quot;, r.URL.Scheme)
log.Println(r.Form[&amp;quot;url_long&amp;quot;])
for k, v := range r.Form {
log.Println(&amp;quot;key:&amp;quot;, k)
log.Println(&amp;quot;val:&amp;quot;, strings.Join(v, &amp;quot;&amp;quot;))
}
h(w, r)
}
}
func hello(w http.ResponseWriter, r *http.Request) {
log.Printf(&amp;quot;Received Request %s from %s\n&amp;quot;, r.URL.Path, r.RemoteAddr)
fmt.Fprintf(w, &amp;quot;Hello, World! &amp;quot;+r.URL.Path)
}
&lt;/code>&lt;/pre>
&lt;p>上面的代码中，我们写了多个函数。有写 HTTP 响应头的，有写认证 Cookie 的，有检查认证 Cookie 的，有打日志的&amp;hellip;&amp;hellip;在使用过程中，我们可以把其嵌套起来使用，在修饰过的函数上继续修饰，这样就可以拼装出更复杂的功能。&lt;/p>
&lt;pre>&lt;code>func main() {
http.HandleFunc(&amp;quot;/v1/hello&amp;quot;, WithServerHeader(WithAuthCookie(hello)))
http.HandleFunc(&amp;quot;/v2/hello&amp;quot;, WithServerHeader(WithBasicAuth(hello)))
http.HandleFunc(&amp;quot;/v3/hello&amp;quot;, WithServerHeader(WithBasicAuth(WithDebugLog(hello))))
err := http.ListenAndServe(&amp;quot;:8080&amp;quot;, nil)
if err != nil {
log.Fatal(&amp;quot;ListenAndServe: &amp;quot;, err)
}
}
&lt;/code>&lt;/pre>
&lt;p>当然，如果一层套一层不好看的话，我们可以使用 pipeline 的玩法&amp;mdash;&amp;mdash;我们需要先写一个工具函数&amp;mdash;&amp;mdash;用来遍历并调用各个 decorator：&lt;/p>
&lt;pre>&lt;code>type HttpHandlerDecorator func(http.HandlerFunc) http.HandlerFunc
func Handler(h http.HandlerFunc, decors ...HttpHandlerDecorator) http.HandlerFunc {
for i := range decors {
d := decors[len(decors)-1-i] // iterate in reverse
h = d(h)
}
return h
}
&lt;/code>&lt;/pre>
&lt;p>然后，我们就可以像下面这样使用了。&lt;/p>
&lt;pre>&lt;code>http.HandleFunc(&amp;quot;/v4/hello&amp;quot;, Handler(hello,
WithServerHeader, WithBasicAuth, WithDebugLog))
&lt;/code>&lt;/pre>
&lt;p>这样的代码是不是更易读了一些？pipeline 的功能也就出来了。&lt;/p>
&lt;p>不过，对于 Go 的修饰器模式，还有一个小问题&amp;mdash;&amp;mdash;好像无法做到泛型，就像上面那个计算时间的函数一样，它的代码耦合了需要被修饰的函数的接口类型，无法做到非常通用。如果这个事解决不了，那么，这个修饰器模式还是有点不好用的。&lt;/p>
&lt;p>因为 Go 语言不像 Python 和 Java，Python 是动态语言，而 Java 有语言虚拟机，所以它们可以干许多比较变态的事儿，然而 Go 语言是一个静态的语言，这意味着其类型需要在编译时就要搞定，否则无法编译。不过，Go 语言支持的最大的泛型是 interface{}，还有比较简单的 reflection 机制，在上面做做文章，应该还是可以搞定的。&lt;/p>
&lt;p>废话不说，下面是我用 reflection 机制写的一个比较通用的修饰器（为了便于阅读，我删除了出错判断代码）。&lt;/p>
&lt;pre>&lt;code>func Decorator(decoPtr, fn interface{}) (err error) {
var decoratedFunc, targetFunc reflect.Value
decoratedFunc = reflect.ValueOf(decoPtr).Elem()
targetFunc = reflect.ValueOf(fn)
v := reflect.MakeFunc(targetFunc.Type(),
func(in []reflect.Value) (out []reflect.Value) {
fmt.Println(&amp;quot;before&amp;quot;)
out = targetFunc.Call(in)
fmt.Println(&amp;quot;after&amp;quot;)
return
})
decoratedFunc.Set(v)
return
}
&lt;/code>&lt;/pre>
&lt;p>上面的代码动用了 &lt;code>reflect.MakeFunc()&lt;/code> 函数制作出了一个新的函数。其中的 &lt;code>targetFunc.Call(in)&lt;/code> 调用了被修饰的函数。关于 Go 语言的反射机制，推荐官方文章&amp;mdash;&amp;mdash;《&lt;a href="https://blog.golang.org/laws-of-reflection">The Laws of Reflection&lt;/a>》，在这里我不多说了。&lt;/p>
&lt;p>上面这个 &lt;code>Decorator()&lt;/code> 需要两个参数：&lt;/p>
&lt;ul>
&lt;li>第一个是出参 &lt;code>decoPtr&lt;/code> ，就是完成修饰后的函数。&lt;/li>
&lt;li>第二个是入参 &lt;code>fn&lt;/code> ，就是需要修饰的函数。&lt;/li>
&lt;/ul>
&lt;p>这样写是不是有些二？的确是的。不过，这是我个人在 Go 语言里所能写出来的最好的代码了。如果你知道更优雅的写法，请你一定告诉我！&lt;/p>
&lt;p>好的，让我们来看一下使用效果。首先，假设我们有两个需要修饰的函数：&lt;/p>
&lt;pre>&lt;code>func foo(a, b, c int) int {
fmt.Printf(&amp;quot;%d, %d, %d \n&amp;quot;, a, b, c)
return a + b + c
}
func bar(a, b string) string {
fmt.Printf(&amp;quot;%s, %s \n&amp;quot;, a, b)
return a + b
}
&lt;/code>&lt;/pre>
&lt;p>然后，我们可以这样做：&lt;/p>
&lt;pre>&lt;code>type MyFoo func(int, int, int) int
var myfoo MyFoo
Decorator(&amp;amp;myfoo, foo)
myfoo(1, 2, 3)
&lt;/code>&lt;/pre>
&lt;p>你会发现，使用 &lt;code>Decorator()&lt;/code> 时，还需要先声明一个函数签名，感觉好傻啊。一点都不泛型，不是吗？谁叫这是有类型的静态编译的语言呢？&lt;/p>
&lt;p>嗯。如果你不想声明函数签名，那么也可以这样：&lt;/p>
&lt;pre>&lt;code>mybar := bar
Decorator(&amp;amp;mybar, bar)
mybar(&amp;quot;hello,&amp;quot;, &amp;quot;world!&amp;quot;)
&lt;/code>&lt;/pre>
&lt;p>好吧，看上去不是那么的漂亮，但是 it does work。看样子 Go 语言目前本身的特性无法做成像 Java 或 Python 那样，对此，我们只能多求 Go 语言多放糖了！&lt;/p>
&lt;h1 id="小结">小结&lt;/h1>
&lt;p>好了，讲了那么多的例子，看了那么多的代码，我估计你可能有点晕，让我们来做个小结吧。&lt;/p>
&lt;p>通过上面 Python 和 Go 修饰器的例子，我们可以看到，所谓的修饰器模式其实是在做下面的几件事。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>表面上看，修饰器模式就是扩展现有的一个函数的功能，让它可以干一些其他的事，或是在现有的函数功能上再附加上一些别的功能。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>除了我们可以感受到&lt;strong>函数式编程&lt;/strong>下的代码扩展能力，我们还能感受到函数的互相和随意拼装带来的好处。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>但是深入一下，我们不难发现，Decorator 这个函数其实是可以修饰几乎所有的函数的。于是，这种可以通用于其它函数的编程方式，可以很容易地将一些非业务功能的、属于控制类型的代码给抽象出来（所谓的控制类型的代码就是像 for-loop，或是打日志，或是函数路由，或是求函数运行时间之类的非业务功能性的代码）。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>以下是《编程范式游记》系列文章的目录，方便你了解这一系列内容的全貌。&lt;strong>这一系列文章中代码量很大，很难用音频体现出来，所以没有录制音频，还望谅解。&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/301">编程范式游记（1）- 起源&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/303">编程范式游记（2）- 泛型编程&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/2017">编程范式游记（3）- 类型系统和泛型的本质&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/2711">编程范式游记（4）- 函数式编程&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/2723">编程范式游记（5）- 修饰器模式&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/2729">编程范式游记（6）- 面向对象编程&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/2741">编程范式游记（7）- 基于原型的编程范式&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/2748">编程范式游记（8）- Go 语言的委托模式&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/2751">编程范式游记（9）- 编程的本质&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/2752">编程范式游记（10）- 逻辑编程范式&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/2754">编程范式游记（11）- 程序世界里的编程范式&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/fc/e9/fcc761001867c60f526665e237f831e9.jpg" alt="">&lt;/p></description></item><item><title>极客专栏: 35丨编程范式游记（6）-面向对象编程</title><link>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E/35%E4%B8%A8%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F%E6%B8%B8%E8%AE%B06-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/</link><pubDate>Fri, 27 May 2022 00:00:00 +0000</pubDate><guid>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E/35%E4%B8%A8%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F%E6%B8%B8%E8%AE%B06-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/</guid><description>
&lt;p>前面我们谈了函数式编程，函数式编程总结起来就是把一些功能或逻辑代码通过函数拼装方式来组织的玩法。这其中涉及最多的是函数，也就是编程中的代码逻辑。但我们知道，代码中还是需要处理数据的，这些就是所谓的&amp;quot;状态&amp;quot;，函数式编程需要我们写出无状态的代码。&lt;/p>
&lt;p>而这天下并不存在没有状态没有数据的代码，如果函数式编程不处理状态这些东西，那么，状态会放在什么地方呢？总是需要一个地方放这些数据的。&lt;/p>
&lt;p>对于状态和数据的处理，我们有必要提一下&amp;quot;面向对象编程&amp;quot;（Object-oriented programming，缩写为 OOP）这个编程范式了。我们知道，&lt;strong>面向对象的编程有三大特性：封装、继承和多态&lt;/strong>。&lt;/p>
&lt;p>面向对象编程是一种具有对象概念的程序编程范型，同时也是一种程序开发的抽象方针。它可能包含数据、属性、代码与方法。对象则指的是类的实例。它将对象作为程序的基本单元，将程序和数据封装其中，以提高软件的可重用性、灵活性和可扩展性，对象里的程序可以访问及修改对象相关联的数据。在面向对象编程里，计算机程序会被设计成彼此相关的对象。&lt;/p>
&lt;p>面向对象程序设计可以看作一种在程序中包含各种独立而又互相调用的对象的思想，这与传统的思想刚好相反：传统的程序设计主张将程序看作一系列函数的集合，或者直接就是一系列对计算机下达的指令。面向对象程序设计中的每一个对象都应该能够接受数据、处理数据并将数据传达给其它对象，因此它们都可以被看作一个小型的&amp;quot;机器&amp;quot;，即对象。&lt;/p>
&lt;p>目前已经被证实的是，面向对象程序设计推广了程序的灵活性和可维护性，并且在大型项目设计中广为应用。此外，支持者声称面向对象程序设计要比以往的做法更加便于学习，因为它能够让人们更简单地设计并维护程序，使得程序更加便于分析、设计、理解。&lt;/p>
&lt;p>现在，几乎所有的主流语言都支持面向对象，比如：Common Lisp、Python、C++、Objective-C、Smalltalk、Delphi、Java、Swift、C#、Perl、Ruby 与 PHP 等。&lt;/p>
&lt;p>说起面向对象，就不得不提由 Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides 合作出版的《&lt;a href="https://book.douban.com/subject/1052241/">设计模式：可复用面向对象软件的基础&lt;/a>》（Design Patterns - Elements of Reusable Object-Oriented Software）一书，在此书中共收录了 23 种设计模式。&lt;/p>
&lt;p>这本书的 23 个经典的设计模式，基本上就是说了两个面向对象的核心理念。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>&amp;ldquo;Program to an &amp;lsquo;interface&amp;rsquo;, not an &amp;lsquo;implementation&amp;rsquo;.&amp;rdquo;&lt;/strong>
&lt;ul>
&lt;li>使用者不需要知道数据类型、结构、算法的细节。&lt;/li>
&lt;li>使用者不需要知道实现细节，只需要知道提供的接口。&lt;/li>
&lt;li>利于抽象、封装、动态绑定、多态。&lt;/li>
&lt;li>符合面向对象的特质和理念。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>&amp;ldquo;Favor &amp;lsquo;object composition&amp;rsquo; over &amp;lsquo;class inheritance&amp;rsquo;.&amp;rdquo;&lt;/strong>
&lt;ul>
&lt;li>继承需要给子类暴露一些父类的设计和实现细节。&lt;/li>
&lt;li>父类实现的改变会造成子类也需要改变。&lt;/li>
&lt;li>我们以为继承主要是为了代码重用，但实际上在子类中需要重新实现很多父类的方法。&lt;/li>
&lt;li>继承更多的应该是为了多态。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h1 id="示例一拼装对象">示例一：拼装对象&lt;/h1>
&lt;p>好，我们先来看一个示例，假设我们有如下的描述：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>四个物体&lt;/strong>：木头桌子、木头椅子、塑料桌子、塑料椅子&lt;/li>
&lt;li>&lt;strong>四个属性&lt;/strong>：燃点、密度、价格、重量&lt;/li>
&lt;/ul>
&lt;p>那么，我们怎么用面向对象的方式来设计我们的类呢？&lt;/p>
&lt;p>参看下图：&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/21/b7/21f0377bc34b52e5c007a3f7c76054b7.png" alt="">&lt;/p>
&lt;ul>
&lt;li>图的左边是&amp;quot;材质类&amp;quot; Material。其属性有燃点和密度。&lt;/li>
&lt;li>图的右边是&amp;quot;家具类&amp;quot; Furniture。其属性有价格和体积。&lt;/li>
&lt;li>在 Furniture 中耦合了 Material。而具体的 Material 是 Wood 还是 Plastic，这是在构造对象的时候注入到 Furniture 里就好了。&lt;/li>
&lt;li>这样，在家具类中，通过材料的密度属性和家具的体积属性就可以计算出重量属性。&lt;/li>
&lt;/ul>
&lt;p>这样设计的优点显而易见，它能和现实世界相对应起来。而且，材料类是可以重用的。这个模式也表现了面向对象的拼装数据的另一个精髓&amp;mdash;&amp;mdash;喜欢组合，而不是继承。这个模式在设计模式里叫&amp;quot;桥接模式&amp;quot;。&lt;/p>
&lt;p>和函数式编程来比较，函数式强调动词，而面向对象强调名词，面向对象更多的关注接口间的关系，而通过多态来适配不同的具体实现。&lt;/p>
&lt;h1 id="示例二拼装功能">示例二：拼装功能&lt;/h1>
&lt;p>再来看一个示例。我们的需求是：处理电商系统中的订单，处理订单有一个关键的动作就是计算订单的价格。有的订单需要打折，有的则不打折。&lt;/p>
&lt;p>在进行面向对象编程时，假设我们用 Java 语言，我们需要先写一个接口&amp;mdash;&amp;mdash; &lt;code>BillingStrategy&lt;/code>，其中就是一个方法：&lt;code>GetActPrice(double rawPrice)&lt;/code>，输入一个原始的价格，输出一个根据相应的策略计算出来的价格。&lt;/p>
&lt;pre>&lt;code>interface BillingStrategy {
public double GetActPrice(double rawPrice);
}
&lt;/code>&lt;/pre>
&lt;p>这个接口很简单，只是对接口的抽象，而与实现无关。现在我们需要对这个接口进行实现。&lt;/p>
&lt;pre>&lt;code>// Normal billing strategy (unchanged price)
class NormalStrategy implements BillingStrategy {
@Override
public double GetActPrice(double rawPrice) {
return rawPrice;
}
}
// Strategy for Happy hour (50% discount)
class HappyHourStrategy implements BillingStrategy {
@Override
public double GetActPrice(double rawPrice) {
return rawPrice * 0.5;
}
}
&lt;/code>&lt;/pre>
&lt;p>上面的代码实现了两个策略，一个是不打折的：&lt;code>NormalStrategy&lt;/code>，一个是打了 5 折的：&lt;code>HappyHourStrategy&lt;/code>。&lt;/p>
&lt;p>于是，我们先封装订单项 &lt;code>OrderItem&lt;/code>，其包含了每个商品的原始价格和数量，以及计算价格的策略。&lt;/p>
&lt;pre>&lt;code>class OrderItem {
public String Name;
public double Price;
public int Quantity;
public BillingStrategy Strategy;
public OrderItem(String name, double price, int quantity, BillingStrategy strategy) {
this.Name = name;
this.Price = price;
this.Quantity = quantity;
this.Strategy = strategy;
}
}
&lt;/code>&lt;/pre>
&lt;p>然后，在我们的订单类&amp;mdash;&amp;mdash; &lt;code>Order&lt;/code> 中封装了 &lt;code>OrderItem&lt;/code> 的列表，即商品列表。并在操作订单添加购买商品时，加入一个计算价格的 &lt;code>BillingStrategy&lt;/code>。&lt;/p>
&lt;pre>&lt;code>class Order {
private List&amp;lt;OrderItem&amp;gt; orderItems = new ArrayList&amp;lt;OrderItem&amp;gt;();
private BillingStrategy strategy = new NormalStrategy();
public void Add(String name, double price, int quantity, BillingStrategy strategy) {
orderItems.add(new OrderItem(name, price, quantity, strategy));
}
// Payment of bill
public void PayBill() {
double sum = 0;
for (OrderItem item : orderItems) {
actPrice = item.Strategy.GetActPrice(item.price * item.quantity);
sum += actPrice;
System.out.println(&amp;quot;%s -- %f(%d) - %f&amp;quot;,
item.name, item.price, item.quantity, actPrice);
}
System.out.println(&amp;quot;Total due: &amp;quot; + sum);
}
}
&lt;/code>&lt;/pre>
&lt;p>最终，我们在 &lt;code>PayBill()&lt;/code> 函数中，把整个订单的价格明细和总价打印出来。&lt;/p>
&lt;p>在上面这个示例中，可以看到，我把定价策略和订单处理的流程分开了。这么做的好处是，我们可以随时给不同的商品注入不同的价格计算策略，这样一来就有很高的灵活度了。剩下的事就交给我们的运营人员来配置不同的商品使用什么样的价格计算策略了。&lt;/p>
&lt;p>注意，现实社会中，订单价格计算会比这个事复杂得多，比如：有会员价，有打折卡，还有商品的打包价等，而且还可以叠加不同的策略（叠加策略用前面说的函数式的 pipeline 或 decorator 就可以实现）。我们这里只是为了说明面向对象编程范式，所以故意简单化了。&lt;/p>
&lt;p>其实，这个设计模式叫&amp;mdash;&amp;mdash;策略模式。我认为，这是设计模式中最为经典的模式了，其充分体现了面向对象编程的方式。&lt;/p>
&lt;h1 id="示例三资源管理">示例三：资源管理&lt;/h1>
&lt;p>先看一段代码：&lt;/p>
&lt;pre>&lt;code>mutex m;
void foo() {
m.lock();
Func();
if ( ! everythingOk() ) return;
...
...
m.unlock();
}
&lt;/code>&lt;/pre>
&lt;p>可以看到，上面这段代码是有问题的，原因是，那个 &lt;code>if&lt;/code> 语句返回时没有把锁给 unlock 掉，这会导致锁没有被释放。如果我们要把代码写对，需要在 return 前 unlock 一下。&lt;/p>
&lt;pre>&lt;code>mutex m;
void foo() {
m.lock();
Func();
if ( ! everythingOk() ) {
m.unlock();
return;
}
...
...
m.unlock();
}
&lt;/code>&lt;/pre>
&lt;p>但是，在所有的函数退出的地方都要加上 &lt;code>m.unlock();&lt;/code> 语句，这会让我们很难维护代码。于是可以使用面向对象的编程模式，我们先设计一个代理类。&lt;/p>
&lt;pre>&lt;code>class lock_guard {
private:
mutex &amp;amp;_m;
public:
lock_guard(mutex &amp;amp;m):_m(m) { _m.lock(); }
~lock_guard() { _m.unlock(); }
};
&lt;/code>&lt;/pre>
&lt;p>然后，我们的代码就可以这样写了：&lt;/p>
&lt;pre>&lt;code>mutex m;
void foo() {
lock_guard guard(m);
Func();
if ( ! everythingOk() ) {
return;
}
...
...
}
&lt;/code>&lt;/pre>
&lt;p>这个技术叫 RAII（Resource Acquisition Is Initialization）， 是 C++ 中的一个利用了面向对象的技术。这个设计模式叫&amp;quot;代理模式&amp;quot;。我们可以把一些控制资源分配和释放的逻辑交给这些代理类，然后，只需要关注业务逻辑代码了。而且，在我们的业务逻辑代码中，减少了这些和业务逻辑不相关的程序控制的代码。&lt;/p>
&lt;p>从上面的代码中，我们可以看到下面几个面向对象的事情。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>我们使用接口抽象了具体的实现类。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>然后其它类耦合的是接口而不是实现类。这就是多态，其增加了程序的可扩展性。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>因为这就是接口编程，所谓接口也就是一种&amp;quot;协议&amp;quot;，就像 HTTP 协议一样。浏览器和后端的程序都依赖于这一种协议，而不是具体实现（如果是依赖具体实现，那么浏览器就要依赖后端的编程语言或中间件了，这就太恶心了）。于是，浏览器和后端的程序就完全解开依赖关系，而去依赖于一个标准的协议。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>这就是面向对象的编程范式的精髓！同样也是 IoC/DIP（控制反转 / 依赖倒置）的本质。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h1 id="ioc-控制反转">IoC 控制反转&lt;/h1>
&lt;p>关于 IoC 的的概念提出来已经很多年了，其被用于一种面向对象的设计。我在这里再简单地回顾一下这个概念。我先谈技术，再说管理。&lt;/p>
&lt;p>话说，我们有一个开关要控制一个灯的开和关这两个动作，最常见也是最没有技术含量的实现会是这个样子：&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/60/ca/6095b6ad1e168cb3bd973bf41489b1ca.jpg" alt="">&lt;/p>
&lt;p>然后，有一天，我们发现需要对灯泡扩展一下，于是做了个抽象类：&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/9f/c3/9f8d0a147a15fe6c0273796bedce1dc3.jpg" alt="">&lt;/p>
&lt;p>但是，如果有一天，我们发现这个开关可能还要控制别的不单单是灯泡的东西，就会发现这个开关耦合了灯泡这种类别，非常不利于扩展，于是反转控制出现了。&lt;/p>
&lt;p>就像现实世界一样，造开关的工厂根本不关心要控制的东西是什么，它只做一个开关应该做好的事，就是把电接通，把电断开（不管是手动的，还是声控的，还是光控，还是遥控的）。而我们造的各种各样的灯泡（不管是日光灯，白炽灯）的工厂也不关心你用什么样的开关，反正我只管把灯的电源接口给做出来。然后，开关厂和电灯厂依赖于一个标准的通电和断电的接口。于是产生了 IoC 控制反转，如下图。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/4d/13/4d1b95052b62dc82dc099302c8612613.jpg" alt="">&lt;/p>
&lt;p>所谓控制反转的意思是，开关从以前设备的专用开关，转变到了控制电源的开关，而以前的设备要反过来依赖于开关厂声明的电源连接接口。只要符合开关厂定义的电源连接的接口，这个开关可以控制所有符合这个电源连接接口的设备。也就是说，开关从依赖设备这种情况，变成了，设备反过来依赖于开关所定义的接口。&lt;/p>
&lt;p>这样的例子在生活中太多见了。比如说：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>钱就是一个很好的例子。以前大家都是&amp;quot;以物易物&amp;quot;，所以，在各种物品之前都需要相应的&amp;quot;交易策略&amp;quot;，比如：一头羊换 2 袋米，一袋米换一斤猪后腿肉&amp;hellip;&amp;hellip;这种换算太复杂了。于是，&amp;ldquo;钱&amp;quot;就出来了，所谓&amp;quot;钱&amp;rdquo;，其实就是一种交易协议，所有的商品都依赖这个协议，而不用再互相依赖了。于是整个世界的运作就简单了很多。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>在交易的过程中，卖家向买家卖东西，一手交钱一手交货，所以，基本上来说卖家和买家必需强耦合（必需见面）。这个时候，银行出来做担保，买家把钱先垫到银行，银行让卖家发货，买家验货后，银行再把钱打给卖家。这就是反转控制。买卖双方把对对方的直接依赖和控制，反转到了让对方来依赖一个标准的交易模型的接口。股票交易也是一样的，证交所就是买卖双方的标准交易模型接口。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>上面这个例子，可能还不明显，再举一个例子。海尔公司作为一个电器制商需要把自己的商品分销到全国各地，但是发现，不同的分销渠道有不同的玩法，于是派出了各种销售代表玩不同的玩法。随着渠道越来越多，发现，每增加一个渠道就要新增一批人和一个新的流程，严重耦合并依赖各渠道商的玩法。&lt;/p>
&lt;p>实在受不了了，于是制定业务标准，开发分销信息化系统，只有符合这个标准的渠道商才能成为海尔的分销商。让各个渠道商反过来依赖自己标准。反转了控制，倒置了依赖。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>这个思维方式其实还深远地影响了很多东西，比如我们的系统架构。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>云计算平台中有很多的云产品线。一些底层服务的开发团队只管开发底层的技术，然后什么也不管了，就交给上层的开发人员。上层开发人员在底层团队开发出来的产品上面开发各种管理这个底层资源的东西，比如：生产底层资源的业务，底层资源的控制台，底层资源的监控系统。&lt;/p>
&lt;p>然而，随着接入的资源越来越多，上层为各个云资源控制生产，开发控制台和监控的团队，完全干不过来了。这个时候依赖倒置和反转控制又可以解决问题了。为了有统一体验，各个云产品线需要遵从一定的协议或规范来开发。比如，每个云产品团队需要按照标准定义相关资源的生命周期管理，提供控制台，接入整体监控系统，通过标准的协议开发控制系统。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>集中式处理电子商务订单的流程。各个垂直业务线都需要通过这个平台来处理自己的交易业务，但是垂直业务线上的个性化需求太多。于是，这个技术平台开始发现，对来自各个业务方的需求应接不暇，各种变态需求严重干扰系统，各种技术决策越来越不好做，导致需求排期排不过来。&lt;/p>
&lt;p>这个时候，也可以使用依赖倒置和反转控制的思想来解决问题：开发一个插件模型、工作流引擎和 Pub/Sub 系统，让业务方的个性化需求支持以插件的方式插入订单流程中。业务方自己的数据存在自己的库中，业务逻辑也不要侵入系统，并可以使用工作流引擎或 Pub/Sub 的协议标准来自己定义工作流的各个步骤（甚至把工作流引擎的各个步骤的 decider 交给各个业务方自行处理）。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>让各个业务方来依赖于标准插件和工作流接口，反转控制，让它们来控制系统，依赖倒置，让它们来依赖标准。&lt;/p>
&lt;p>上面这些我想说什么？我想说的是：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>我们每天都在标准化和定制化中纠结。我们痛苦于哪些应该是平台要做的，哪些应该要甩出去的。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>这里面会出现大量的与业务无关的软件或中间件，包括协议、数据、接口&amp;hellip;&amp;hellip;&lt;/p>
&lt;/li>
&lt;li>
&lt;p>通过面向对象的这些方式，我们可以通过抽象来解耦，通过中间件来解耦，这样可以降低软件的复杂度。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>总而言之，我们就是想通过一种标准来让业务更为规范。&lt;/p>
&lt;h1 id="小结">小结&lt;/h1>
&lt;p>不过，我们也需要知道面向对象的优缺点。&lt;/p>
&lt;p>&lt;strong>优点&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>能和真实的世界交相辉映，符合人的直觉。&lt;/li>
&lt;li>面向对象和数据库模型设计类型，更多地关注对象间的模型设计。&lt;/li>
&lt;li>强调于&amp;quot;名词&amp;quot;而不是&amp;quot;动词&amp;quot;，更多地关注对象和对象间的接口。&lt;/li>
&lt;li>根据业务的特征形成一个个高内聚的对象，有效地分离了抽象和具体实现，增强了可重用性和可扩展性。&lt;/li>
&lt;li>拥有大量非常优秀的设计原则和设计模式。&lt;/li>
&lt;li>S.O.L.I.D（单一功能、开闭原则、里氏替换、接口隔离以及依赖反转，是面向对象设计的五个基本原则）、IoC/DIP&amp;hellip;&amp;hellip;&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>缺点&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>代码都需要附着在一个类上，从一侧面上说，其鼓励了类型。&lt;/li>
&lt;li>代码需要通过对象来达到抽象的效果，导致了相当厚重的&amp;quot;代码粘合层&amp;quot;。&lt;/li>
&lt;li>因为太多的封装以及对状态的鼓励，导致了大量不透明并在并发下出现很多问题。&lt;/li>
&lt;/ul>
&lt;p>还是好多人并不是喜欢面向对象，尤其是喜欢函数式和泛型那些人，似乎都是非常讨厌面向对象的。&lt;/p>
&lt;p>通过对象来达到抽象结果，把代码分散在不同的类里面，然后，要让它们执行起来，就需要把这些类粘合起来。所以，它另外一方面鼓励相当厚重的代码黏合层（代码黏合层就是把代码黏合到这里面）。&lt;/p>
&lt;p>在 Java 里有很多注入方式，像 Spring 那些注入，鼓励黏合，导致了大量的封装，完全不知道里面在干什么事情。而且封装屏蔽了细节，具体发生啥事你还不知道。这些都是面向对象不太好的地方。&lt;/p>
&lt;p>以下是《编程范式游记》系列文章的目录，方便你了解这一系列内容的全貌。&lt;strong>这一系列文章中代码量很大，很难用音频体现出来，所以没有录制音频，还望谅解。&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/301">编程范式游记（1）- 起源&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/303">编程范式游记（2）- 泛型编程&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/2017">编程范式游记（3）- 类型系统和泛型的本质&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/2711">编程范式游记（4）- 函数式编程&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/2723">编程范式游记（5）- 修饰器模式&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/2729">编程范式游记（6）- 面向对象编程&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/2741">编程范式游记（7）- 基于原型的编程范式&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/2748">编程范式游记（8）- Go 语言的委托模式&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/2751">编程范式游记（9）- 编程的本质&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/2752">编程范式游记（10）- 逻辑编程范式&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/2754">编程范式游记（11）- 程序世界里的编程范式&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/fc/e9/fcc761001867c60f526665e237f831e9.jpg" alt="">&lt;/p></description></item><item><title>极客专栏: 36丨编程范式游记（7）-基于原型的编程范式</title><link>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E/36%E4%B8%A8%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F%E6%B8%B8%E8%AE%B07-%E5%9F%BA%E4%BA%8E%E5%8E%9F%E5%9E%8B%E7%9A%84%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F/</link><pubDate>Fri, 27 May 2022 00:00:00 +0000</pubDate><guid>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E/36%E4%B8%A8%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F%E6%B8%B8%E8%AE%B07-%E5%9F%BA%E4%BA%8E%E5%8E%9F%E5%9E%8B%E7%9A%84%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F/</guid><description>
&lt;p>基于原型（prototype）的编程其实也是面向对象编程的一种方式。没有 class 化的，直接使用对象。又叫，基于实例的编程。其主流的语言就是 JavaScript。与传统的面对象编程的比较如下。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>在基于类的编程当中，对象总共有两种类型。类定义了对象的基本布局和函数特性，而接口是&amp;quot;可以使用的&amp;quot;对象，它基于特定类的样式。在此模型中，类表现为行为和结构的集合，对所有接口来说这些类的行为和结构都是相同的。因而，区分规则首先是基于行为和结构，而后才是状态。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>原型编程的主张者经常争论说，基于类的语言提倡使用一个关注分类和类之间关系的开发模型。与此相对，原型编程看起来提倡程序员关注一系列对象实例的行为，而之后才关心如何将这些对象划分到最近的使用方式相似的原型对象，而不是分成类。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>因为如此，很多基于原型的系统提倡运行时原型的修改，而只有极少数基于类的面向对象系统（比如第一个动态面向对象的系统 Smalltalk）允许类在程序运行时被修改。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>在基于类的语言中，一个新的实例通过类构造器和构造器可选的参数来构造，结果实例由类选定的行为和布局创建模型。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>在基于原型的系统中构造对象有两种方法，通过复制已有的对象或者通过扩展空对象创建。很多基于原型的系统提倡运行时原型的修改，而基于类的面向对象系统只有动态语言允许类在运行时被修改（Common Lisp、Dylan、Objective-C、Perl、Python、Ruby 和 Smalltalk）。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h1 id="javascript-的原型概念">JavaScript 的原型概念&lt;/h1>
&lt;p>这里，我们主要以 JavaScript 举例，面向对象里面要有个 Class。但是 JavaScript 觉得不是这样的，它就是要基于原型编程，就不要 Class，就直接在对象上改就行了。基于编程的修改，直接对类型进行修改。&lt;/p>
&lt;p>我们先来看一个示例。&lt;/p>
&lt;pre>&lt;code>var foo = {name: &amp;quot;foo&amp;quot;, one: 1, two: 2};
var bar = {three: 3};
&lt;/code>&lt;/pre>
&lt;p>每个对象都有一个 &lt;code>__proto__&lt;/code> 的属性，这个就是&amp;quot;原型&amp;quot;。对于上面的两个对象，如果我们把 &lt;code>foo&lt;/code> 赋值给 &lt;code>bar.__proto__&lt;/code>，那就意味着，&lt;code>bar&lt;/code> 的原型就成了 &lt;code>foo&lt;/code>的。&lt;/p>
&lt;pre>&lt;code>bar.__proto__ = foo; // foo is now the prototype of bar.
&lt;/code>&lt;/pre>
&lt;p>于是，我们就可以在 &lt;code>bar&lt;/code> 里面访问 &lt;code>foo&lt;/code> 的属性了。&lt;/p>
&lt;pre>&lt;code>// If we try to access foo's properties from bar
// from now on, we'll succeed.
bar.one // Resolves to 1.
// The child object's properties are also accessible.
bar.three // Resolves to 3.
// Own properties shadow prototype properties
bar.name = &amp;quot;bar&amp;quot;;
foo.name; // unaffected, resolves to &amp;quot;foo&amp;quot;
bar.name; // Resolves to &amp;quot;bar&amp;quot;
&lt;/code>&lt;/pre>
&lt;p>需要解释一下 JavaScript 的两个东西，一个是 &lt;code>__proto__&lt;/code>，另一个是 &lt;code>prototype&lt;/code>，这两个东西很容易混淆。这里说明一下：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>&lt;code>__proto__&lt;/code>&lt;/strong> 主要是安放在一个实际的对象中，用它来产生一个链接，一个原型链，用于寻找方法名或属性，等等。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>&lt;code>prototype&lt;/code>&lt;/strong> 是用 &lt;code>new&lt;/code> 来创建一个对象时构造 &lt;code>__proto__&lt;/code> 用的。它是构造函数的一个属性。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>在 JavaScript 中，对象有两种表现形式， 一种是 &lt;code>Object&lt;/code> (&lt;a href="http://www.ecma-international.org/ecma-262/5.1/#sec-15.2">ES5 关于 Object 的文档&lt;/a>)，一种是 &lt;code>Function&lt;/code> （&lt;a href="http://www.ecma-international.org/ecma-262/5.1/#sec-15.2">ES5 关于 Function 的文档&lt;/a>）。&lt;/p>
&lt;p>我们可以简单地认为，&lt;code>__proto__&lt;/code> 是所有对象用于链接原型的一个指针，而 &lt;code>prototype&lt;/code> 则是 Function 对象的属性，其主要是用来当需要 new 一个对象时让 &lt;code>__proto__&lt;/code> 指针所指向的地方。 对于超级对象 &lt;code>Function&lt;/code> 而言， &lt;code>Function.__proto__&lt;/code> 就是 &lt;code>Function.prototype&lt;/code>。&lt;/p>
&lt;p>比如我们有如下的代码：&lt;/p>
&lt;pre>&lt;code>var a = {
x: 10,
calculate: function (z) {
return this.x + this.y + z;
}
};
var b = {
y: 20,
__proto__: a
};
var c = {
y: 30,
__proto__: a
};
// call the inherited method
b.calculate(30); // 60
c.calculate(40); // 80
&lt;/code>&lt;/pre>
&lt;p>其中的&amp;quot;原型链&amp;quot;如下所示：&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/f8/7d/f846c45434ca650ab34e518421397d7d.png" alt="">&lt;/p>
&lt;p>注意：ES5 中，规定原型继承需要使用 &lt;code>Object.create()&lt;/code> 函数。如下所示：&lt;/p>
&lt;pre>&lt;code>var b = Object.create(a, {y: {value: 20}});
var c = Object.create(a, {y: {value: 30}});
&lt;/code>&lt;/pre>
&lt;p>好了，我们再来看一段代码：&lt;/p>
&lt;pre>&lt;code>// 一种构造函数写法
function Foo(y) {
this.y = y;
}
// 修改 Foo 的 prototype，加入一个成员变量 x
Foo.prototype.x = 10;
// 修改 Foo 的 prototype，加入一个成员函数 calculate
Foo.prototype.calculate = function (z) {
return this.x + this.y + z;
};
// 现在，我们用 Foo 这个原型来创建 b 和 c
var b = new Foo(20);
var c = new Foo(30);
// 调用原型中的方法，可以得到正确的值
b.calculate(30); // 60
c.calculate(40); // 80
&lt;/code>&lt;/pre>
&lt;p>那么，在内存中的布局是怎么样的呢？大概是下面这个样子。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/e4/80/e4a5053894b27759103976720d29ab80.png" alt="">&lt;/p>
&lt;p>这个图应该可以让你很好地看明白 &lt;code>__proto__&lt;/code> 和 &lt;code>prototype&lt;/code> 的差别了。&lt;/p>
&lt;p>我们可以测试一下：&lt;/p>
&lt;pre>&lt;code>b.__proto__ === Foo.prototype, // true
c.__proto__ === Foo.prototype, // true
b.constructor === Foo, // true
c.constructor === Foo, // true
Foo.prototype.constructor === Foo, // true
b.calculate === b.__proto__.calculate, // true
b.__proto__.calculate === Foo.prototype.calculate // true
&lt;/code>&lt;/pre>
&lt;p>这里需要说明的是&amp;mdash;&amp;mdash;&lt;/p>
&lt;p>&lt;strong>&lt;code>Foo.prototype&lt;/code> 自动创建了一个属性 &lt;code>constructor&lt;/code>，这是一个指向函数自己的一个 reference。这样一来，对于实例 &lt;code>b&lt;/code> 或 &lt;code>c&lt;/code> 来说，就能访问到这个继承的 &lt;code>constructor&lt;/code> 了。&lt;/strong>&lt;/p>
&lt;p>有了这些基本概念，我们就可以讲一下 JavaScript 的面向对象编程了。&lt;/p>
&lt;blockquote>
&lt;p>注： 上面示例和图示来源于 &lt;a href="http://dmitrysoshnikov.com/ecmascript/javascript-the-core/">JavaScript, The Core&lt;/a> 一文。&lt;/p>
&lt;/blockquote>
&lt;h1 id="javascript-原型编程的面向对象">JavaScript 原型编程的面向对象&lt;/h1>
&lt;p>我们再来重温一下上面讲述的内容：&lt;/p>
&lt;pre>&lt;code>function Person(){}
var p = new Person();
Person.prototype.name = &amp;quot;Hao Chen&amp;quot;;
Person.prototype.sayHello = function(){
console.log(&amp;quot;Hi, I am &amp;quot; + this.name);
}
console.log(p.name); // &amp;quot;Hao Chen&amp;quot;
p.sayHello(); // &amp;quot;Hi, I am Hao Chen&amp;quot;
&lt;/code>&lt;/pre>
&lt;p>在上面这个例子中：&lt;/p>
&lt;ul>
&lt;li>我们先生成了一个空的函数对象 &lt;code>Person()&lt;/code>；&lt;/li>
&lt;li>然后将这个空的函数对象 &lt;code>new&lt;/code> 出另一个对象，存在 &lt;code>p&lt;/code> 中；&lt;/li>
&lt;li>这时再改变 &lt;code>Person.prototype&lt;/code>，让其有一个 &lt;code>name&lt;/code> 的属性和一个 &lt;code>sayHello()&lt;/code> 的方法；&lt;/li>
&lt;li>我们发现，另外那个 &lt;code>p&lt;/code> 的对象也跟着一起改变了。&lt;/li>
&lt;/ul>
&lt;p>注意一下，&lt;/p>
&lt;ul>
&lt;li>当创建 &lt;code>function Person(){}&lt;/code> 时，&lt;code>Person.__proto__&lt;/code> 指向 &lt;code>Function.prototype&lt;/code>;&lt;/li>
&lt;li>当创建 &lt;code>var p = new Person()&lt;/code> 时，&lt;code>p.__proto__&lt;/code> 指向 &lt;code>Person.prototype&lt;/code>;&lt;/li>
&lt;li>当修改了 &lt;code>Person.prototype&lt;/code> 的内容后，&lt;code>p.__proto__&lt;/code> 的内容也就被改变了。&lt;/li>
&lt;/ul>
&lt;p>好了，我们再来看一下&amp;quot;原型编程&amp;quot;中面向对象的编程玩法。&lt;/p>
&lt;p>首先，我们定义一个 &lt;code>Person&lt;/code> 类。&lt;/p>
&lt;pre>&lt;code>//Define human class
var Person = function (fullName, email) {
this.fullName = fullName;
this.email = email;
this.speak = function(){
console.log(&amp;quot;I speak English!&amp;quot;);
};
this.introduction = function(){
console.log(&amp;quot;Hi, I am &amp;quot; + this.fullName);
};
}
&lt;/code>&lt;/pre>
&lt;p>上面这个对象中，包含了：&lt;/p>
&lt;ul>
&lt;li>属性： &lt;code>fullName&lt;/code> 和 &lt;code>email&lt;/code>；&lt;/li>
&lt;li>方法： &lt;code>speak()&lt;/code> 和 &lt;code>introduction()&lt;/code>。&lt;/li>
&lt;/ul>
&lt;p>其实，所谓的方法也是属性。&lt;/p>
&lt;p>然后，我们可以定义一个 &lt;code>Student&lt;/code> 对象。&lt;/p>
&lt;pre>&lt;code>//Define Student class
var Student = function(fullName, email, school, courses) {
Person.call(this, fullName, email);
// Initialize our Student properties
this.school = school;
this.courses = courses;
// override the &amp;quot;introduction&amp;quot; method
this.introduction= function(){
console.log(&amp;quot;Hi, I am &amp;quot; + this.fullName +
&amp;quot;. I am a student of &amp;quot; + this.school +
&amp;quot;, I study &amp;quot;+ this.courses +&amp;quot;.&amp;quot;);
};
// Add a &amp;quot;exams&amp;quot; method
this.takeExams = function(){
console.log(&amp;quot;This is my exams time!&amp;quot;);
};
};
&lt;/code>&lt;/pre>
&lt;p>在上面的代码中：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>使用了 &lt;code>Person.call(this, fullName, email)&lt;/code>，&lt;code>call()&lt;/code> 或 &lt;code>apply()&lt;/code> 都是为了动态改变 &lt;code>this&lt;/code> 所指向的对象的内容而出现的。这里的 &lt;code>this&lt;/code> 就是 &lt;code>Student&lt;/code>。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>上面的例子中，我们重载了 &lt;code>introduction()&lt;/code> 方法，并新增加了一个 &lt;code>takeExams()&lt;/code>的方法。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>虽然，我们这样定义了 &lt;code>Student&lt;/code>，但是它还没有和 &lt;code>Person&lt;/code> 发生继承关系。为了要让它们发生关系，我们就需要修改 &lt;code>Student&lt;/code> 的原型。&lt;/p>
&lt;p>我们可以简单粗暴地做赋值：&lt;code>Student.__proto__ = Person.prototype&lt;/code> ，但是，这太粗暴了。&lt;/p>
&lt;p>我们还是使用比较规范的方式：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>先用 &lt;code>Object.create()&lt;/code> 来将&lt;code>Person.prototype&lt;/code> 和 &lt;code>Student.prototype&lt;/code> 关联上。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>然后，修改一下构造函数 &lt;code>Student.prototype.constructor = Student;&lt;/code>。&lt;/p>
&lt;p>// Create a Student.prototype object that inherits
// from Person.prototype.
Student.prototype = Object.create(Person.prototype);&lt;/p>
&lt;p>// Set the &amp;ldquo;constructor&amp;rdquo; property to refer to Student
Student.prototype.constructor = Student;&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>这样，我们就可以这样使用了。&lt;/p>
&lt;pre>&lt;code>var student = new Student(&amp;quot;Hao Chen&amp;quot;,
&amp;quot;haoel@hotmail.com&amp;quot;,
&amp;quot;XYZ University&amp;quot;,
&amp;quot;Computer Science&amp;quot;);
student.introduction();
student.speak();
student.takeExams();
// Check that instanceof works correctly
console.log(student instanceof Person); // true
console.log(student instanceof Student); // true
&lt;/code>&lt;/pre>
&lt;p>上述就是基于原型的面向对象编程的玩法了。&lt;/p>
&lt;blockquote>
&lt;p>注：在 ECMAScript 标准的第四版开始寻求使 JavaScript 提供基于类的构造，且 ECMAScript 第六版有提供 &amp;ldquo;class&amp;rdquo;(类) 作为原有的原型架构之上的语法糖，提供构建对象与处理继承时的另一种语法。&lt;/p>
&lt;/blockquote>
&lt;h1 id="小结">小结&lt;/h1>
&lt;p>我们可以看到，这种玩法就是一种委托的方式。在使用委托的基于原型的语言中，运行时语言可以&amp;quot;仅仅通过序列的指针找到匹配&amp;quot;这样的方式来定位属性或者寻找正确的数据。所有这些创建行为共享的行为需要的是委托指针。&lt;/p>
&lt;p>不像是基于类的面向对象语言中类和接口的关系，原型和它的分支之间的关系并不要求子对象有相似的内存结构，因为如此，子对象可以继续修改而无需像基于类的系统那样整理结构。还有一个要提到的地方是，不仅仅是数据，方法也能被修改。因为这个原因，大多数基于原型的语言把数据和方法提作&amp;quot;slots&amp;quot;。&lt;/p>
&lt;p>这种在对象里面直接修改的玩法，虽然这个特性可以带来运行时的灵活性，我们可以在运行时修改一个 prototype，给它增加甚至删除属性和方法。但是其带来了执行的不确定性，也有安全性的问题，而代码还变得不可预测，这有点黑科技的味道了。因为这些不像静态类型系统，没有一个不可变的契约对代码的确定性有保证，所以，需要使用者来自己保证。&lt;/p>
&lt;p>以下是《编程范式游记》系列文章的目录，方便你了解这一系列内容的全貌。&lt;strong>这一系列文章中代码量很大，很难用音频体现出来，所以没有录制音频，还望谅解。&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/301">编程范式游记（1）- 起源&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/303">编程范式游记（2）- 泛型编程&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/2017">编程范式游记（3）- 类型系统和泛型的本质&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/2711">编程范式游记（4）- 函数式编程&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/2723">编程范式游记（5）- 修饰器模式&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/2729">编程范式游记（6）- 面向对象编程&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/2741">编程范式游记（7）- 基于原型的编程范式&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/2748">编程范式游记（8）- Go 语言的委托模式&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/2751">编程范式游记（9）- 编程的本质&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/2752">编程范式游记（10）- 逻辑编程范式&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/2754">编程范式游记（11）- 程序世界里的编程范式&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/fc/e9/fcc761001867c60f526665e237f831e9.jpg" alt="">&lt;/p></description></item><item><title>极客专栏: 37丨编程范式游记（8）-Go语言的委托模式</title><link>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E/37%E4%B8%A8%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F%E6%B8%B8%E8%AE%B08-go%E8%AF%AD%E8%A8%80%E7%9A%84%E5%A7%94%E6%89%98%E6%A8%A1%E5%BC%8F/</link><pubDate>Fri, 27 May 2022 00:00:00 +0000</pubDate><guid>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E/37%E4%B8%A8%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F%E6%B8%B8%E8%AE%B08-go%E8%AF%AD%E8%A8%80%E7%9A%84%E5%A7%94%E6%89%98%E6%A8%A1%E5%BC%8F/</guid><description>
&lt;p>我们再来看 Go 语言这个模式，Go 语言的这个模式挺好玩儿的。声明一个 struct，跟 C 很一样，然后直接把这个 struct 类型放到另一个 struct 里。&lt;/p>
&lt;h1 id="委托的简单示例">委托的简单示例&lt;/h1>
&lt;p>我们来看几个示例：&lt;/p>
&lt;pre>&lt;code>type Widget struct {
X, Y int
}
type Label struct {
Widget // Embedding (delegation)
Text string // Aggregation
X int // Override
}
func (label Label) Paint() {
// [0xc4200141e0] - Label.Paint(&amp;quot;State&amp;quot;)
fmt.Printf(&amp;quot;[%p] - Label.Paint(%q)\n&amp;quot;,
&amp;amp;label, label.Text)
}
&lt;/code>&lt;/pre>
&lt;p>上面，&lt;/p>
&lt;ul>
&lt;li>
&lt;p>我们声明了一个 &lt;code>Widget&lt;/code>，其有 &lt;code>X&lt;/code>,&lt;code>Y&lt;/code>；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>然后用它来声明一个 &lt;code>Label&lt;/code>，直接把 &lt;code>Widget&lt;/code> 委托进去；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>然后再给 &lt;code>Label&lt;/code> 声明并实现了一个 &lt;code>Paint()&lt;/code> 方法。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>于是，我们就可以这样编程了：&lt;/p>
&lt;pre>&lt;code>label := Label{Widget{10, 10}, &amp;quot;State&amp;quot;, 100}
// X=100, Y=10, Text=State, Widget.X=10
fmt.Printf(&amp;quot;X=%d, Y=%d, Text=%s Widget.X=%d\n&amp;quot;,
label.X, label.Y, label.Text,
label.Widget.X)
fmt.Println()
// {Widget:{X:10 Y:10} Text:State X:100}
// {{10 10} State 100}
fmt.Printf(&amp;quot;%+v\n%v\n&amp;quot;, label, label)
label.Paint()
&lt;/code>&lt;/pre>
&lt;p>我们可以看到，如果有成员变量重名，则需要手动地解决冲突。&lt;/p>
&lt;p>我们继续扩展代码。&lt;/p>
&lt;p>先来一个 &lt;code>Button&lt;/code>：&lt;/p>
&lt;pre>&lt;code>type Button struct {
Label // Embedding (delegation)
}
func NewButton(x, y int, text string) Button {
return Button{Label{Widget{x, y}, text, x}}
}
func (button Button) Paint() { // Override
fmt.Printf(&amp;quot;[%p] - Button.Paint(%q)\n&amp;quot;,
&amp;amp;button, button.Text)
}
func (button Button) Click() {
fmt.Printf(&amp;quot;[%p] - Button.Click()\n&amp;quot;, &amp;amp;button)
}
&lt;/code>&lt;/pre>
&lt;p>再来一个 &lt;code>ListBox&lt;/code>：&lt;/p>
&lt;pre>&lt;code>type ListBox struct {
Widget // Embedding (delegation)
Texts []string // Aggregation
Index int // Aggregation
}
func (listBox ListBox) Paint() {
fmt.Printf(&amp;quot;[%p] - ListBox.Paint(%q)\n&amp;quot;,
&amp;amp;listBox, listBox.Texts)
}
func (listBox ListBox) Click() {
fmt.Printf(&amp;quot;[%p] - ListBox.Click()\n&amp;quot;, &amp;amp;listBox)
}
&lt;/code>&lt;/pre>
&lt;p>然后，声明两个接口用于多态：&lt;/p>
&lt;pre>&lt;code>type Painter interface {
Paint()
}
type Clicker interface {
Click()
}
&lt;/code>&lt;/pre>
&lt;p>于是我们就可以这样泛型地使用（注意其中的两个 for 循环）：&lt;/p>
&lt;pre>&lt;code>button1 := Button{Label{Widget{10, 70}, &amp;quot;OK&amp;quot;, 10}}
button2 := NewButton(50, 70, &amp;quot;Cancel&amp;quot;)
listBox := ListBox{Widget{10, 40},
[]string{&amp;quot;AL&amp;quot;, &amp;quot;AK&amp;quot;, &amp;quot;AZ&amp;quot;, &amp;quot;AR&amp;quot;}, 0}
fmt.Println()
//[0xc4200142d0] - Label.Paint(&amp;quot;State&amp;quot;)
//[0xc420014300] - ListBox.Paint([&amp;quot;AL&amp;quot; &amp;quot;AK&amp;quot; &amp;quot;AZ&amp;quot; &amp;quot;AR&amp;quot;])
//[0xc420014330] - Button.Paint(&amp;quot;OK&amp;quot;)
//[0xc420014360] - Button.Paint(&amp;quot;Cancel&amp;quot;)
for _, painter := range []Painter{label, listBox, button1, button2} {
painter.Paint()
}
fmt.Println()
//[0xc420014450] - ListBox.Click()
//[0xc420014480] - Button.Click()
//[0xc4200144b0] - Button.Click()
for _, widget := range []interface{}{label, listBox, button1, button2} {
if clicker, ok := widget.(Clicker); ok {
clicker.Click()
}
}
&lt;/code>&lt;/pre>
&lt;h1 id="一个-undo-的委托重构">一个 Undo 的委托重构&lt;/h1>
&lt;p>上面这个是 Go 语中的委托和接口多态的编程方式，其实是面向对象和原型编程综合的玩法。这个玩法可不可以玩得更有意思呢？这是可以的。&lt;/p>
&lt;p>首先，我们先声明一个数据容器，其中有 &lt;code>Add()&lt;/code>、 &lt;code>Delete()&lt;/code> 和 &lt;code>Contains()&lt;/code> 方法。还有一个转字符串的方法。&lt;/p>
&lt;pre>&lt;code>type IntSet struct {
data map[int]bool
}
func NewIntSet() IntSet {
return IntSet{make(map[int]bool)}
}
func (set *IntSet) Add(x int) {
set.data[x] = true
}
func (set *IntSet) Delete(x int) {
delete(set.data, x)
}
func (set *IntSet) Contains(x int) bool {
return set.data[x]
}
func (set *IntSet) String() string { // Satisfies fmt.Stringer interface
if len(set.data) == 0 {
return &amp;quot;{}&amp;quot;
}
ints := make([]int, 0, len(set.data))
for i := range set.data {
ints = append(ints, i)
}
sort.Ints(ints)
parts := make([]string, 0, len(ints))
for _, i := range ints {
parts = append(parts, fmt.Sprint(i))
}
return &amp;quot;{&amp;quot; + strings.Join(parts, &amp;quot;,&amp;quot;) + &amp;quot;}&amp;quot;
}
&lt;/code>&lt;/pre>
&lt;p>我们如下使用这个数据容器：&lt;/p>
&lt;pre>&lt;code>ints := NewIntSet()
for _, i := range []int{1, 3, 5, 7} {
ints.Add(i)
fmt.Println(ints)
}
for _, i := range []int{1, 2, 3, 4, 5, 6, 7} {
fmt.Print(i, ints.Contains(i), &amp;quot; &amp;quot;)
ints.Delete(i)
fmt.Println(ints)
}
&lt;/code>&lt;/pre>
&lt;p>这个数据容器平淡无奇，我们想给它加一个 Undo 的功能。我们可以这样来：&lt;/p>
&lt;pre>&lt;code>type UndoableIntSet struct { // Poor style
IntSet // Embedding (delegation)
functions []func()
}
func NewUndoableIntSet() UndoableIntSet {
return UndoableIntSet{NewIntSet(), nil}
}
func (set *UndoableIntSet) Add(x int) { // Override
if !set.Contains(x) {
set.data[x] = true
set.functions = append(set.functions, func() { set.Delete(x) })
} else {
set.functions = append(set.functions, nil)
}
}
func (set *UndoableIntSet) Delete(x int) { // Override
if set.Contains(x) {
delete(set.data, x)
set.functions = append(set.functions, func() { set.Add(x) })
} else {
set.functions = append(set.functions, nil)
}
}
func (set *UndoableIntSet) Undo() error {
if len(set.functions) == 0 {
return errors.New(&amp;quot;No functions to undo&amp;quot;)
}
index := len(set.functions) - 1
if function := set.functions[index]; function != nil {
function()
set.functions[index] = nil // Free closure for garbage collection
}
set.functions = set.functions[:index]
return nil
}
&lt;/code>&lt;/pre>
&lt;p>于是就可以这样使用了：&lt;/p>
&lt;pre>&lt;code>ints := NewUndoableIntSet()
for _, i := range []int{1, 3, 5, 7} {
ints.Add(i)
fmt.Println(ints)
}
for _, i := range []int{1, 2, 3, 4, 5, 6, 7} {
fmt.Println(i, ints.Contains(i), &amp;quot; &amp;quot;)
ints.Delete(i)
fmt.Println(ints)
}
fmt.Println()
for {
if err := ints.Undo(); err != nil {
break
}
fmt.Println(ints)
}
&lt;/code>&lt;/pre>
&lt;p>但是，需要注意的是，我们用了一个新的 &lt;code>UndoableIntSet&lt;/code> 几乎重写了所有的 &lt;code>IntSet&lt;/code> 和 &amp;ldquo;写&amp;rdquo; 相关的方法，这样就可以把操作记录下来，然后 &lt;strong>Undo&lt;/strong> 了。&lt;/p>
&lt;p>但是，可能别的类也需要 Undo 的功能，我是不是要重写所有的需要这个功能的类啊？这样的代码类似，就是因为数据容器不一样，我就要去重写它们，这太二了。&lt;/p>
&lt;p>我们能不能利用前面学到的泛型编程、函数式编程、IoC 等范式来把这个事干得好一些呢？当然是可以的。&lt;/p>
&lt;p>如下所示：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>我们先声明一个 &lt;code>Undo[]&lt;/code> 的函数数组（其实是一个栈）。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>并实现一个通用 &lt;code>Add()&lt;/code>。其需要一个函数指针，并把这个函数指针存放到 &lt;code>Undo[]&lt;/code> 函数数组中。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>在 &lt;code>Undo()&lt;/code> 的函数中，我们会遍历&lt;code>Undo[]&lt;/code>函数数组，并执行之，执行完后就弹栈。&lt;/p>
&lt;p>type Undo []func()&lt;/p>
&lt;p>func (undo *Undo) Add(function func()) {
*undo = append(*undo, function)
}&lt;/p>
&lt;p>func (undo *Undo) Undo() error {
functions := *undo
if len(functions) == 0 {
return errors.New(&amp;ldquo;No functions to undo&amp;rdquo;)
}
index := len(functions) - 1
if function := functions[index]; function != nil {
function()
functions[index] = nil // Free closure for garbage collection
}
*undo = functions[:index]
return nil
}&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>那么我们的 &lt;code>IntSet&lt;/code> 就可以改写成如下的形式：&lt;/p>
&lt;pre>&lt;code>type IntSet struct {
data map[int]bool
undo Undo
}
func NewIntSet() IntSet {
return IntSet{data: make(map[int]bool)}
}
&lt;/code>&lt;/pre>
&lt;p>然后在其中的 &lt;code>Add&lt;/code> 和 &lt;code>Delete&lt;/code>中实现 Undo 操作。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;code>Add&lt;/code> 操作时加入 &lt;code>Delete&lt;/code> 操作的 Undo。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>Delete&lt;/code> 操作时加入 &lt;code>Add&lt;/code> 操作的 Undo。&lt;/p>
&lt;p>func (set *IntSet) Add(x int) {
if !set.Contains(x) {
set.data[x] = true
set.undo.Add(func() { set.Delete(x) })
} else {
set.undo.Add(nil)
}
}&lt;/p>
&lt;p>func (set *IntSet) Delete(x int) {
if set.Contains(x) {
delete(set.data, x)
set.undo.Add(func() { set.Add(x) })
} else {
set.undo.Add(nil)
}
}&lt;/p>
&lt;p>func (set *IntSet) Undo() error {
return set.undo.Undo()
}&lt;/p>
&lt;p>func (set *IntSet) Contains(x int) bool {
return set.data[x]
}&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>我们再次看到，Go 语言的 Undo 接口把 Undo 的流程给抽象出来，而要怎么 Undo 的事交给了业务代码来维护（通过注册一个 Undo 的方法）。这样在 Undo 的时候，就可以回调这个方法来做与业务相关的 Undo 操作了。&lt;/p>
&lt;h1 id="小结">小结&lt;/h1>
&lt;p>这是不是和最一开始的 C++ 的泛型编程很像？也和 map、reduce、filter 这样的只关心控制流程，不关心业务逻辑的做法很像？而且，一开始用一个 UndoableIntSet 来包装&lt;code>IntSet&lt;/code>类，到反过来在&lt;code>IntSet&lt;/code>里依赖&lt;code>Undo&lt;/code>类，这就是控制反转 IoC。&lt;/p>
&lt;p>以下是《编程范式游记》系列文章的目录，方便你了解这一系列内容的全貌。&lt;strong>这一系列文章中代码量很大，很难用音频体现出来，所以没有录制音频，还望谅解。&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/301">编程范式游记（1）- 起源&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/303">编程范式游记（2）- 泛型编程&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/2017">编程范式游记（3）- 类型系统和泛型的本质&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/2711">编程范式游记（4）- 函数式编程&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/2723">编程范式游记（5）- 修饰器模式&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/2729">编程范式游记（6）- 面向对象编程&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/2741">编程范式游记（7）- 基于原型的编程范式&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/2748">编程范式游记（8）- Go 语言的委托模式&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/2751">编程范式游记（9）- 编程的本质&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/2752">编程范式游记（10）- 逻辑编程范式&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/2754">编程范式游记（11）- 程序世界里的编程范式&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/fc/e9/fcc761001867c60f526665e237f831e9.jpg" alt="">&lt;/p></description></item><item><title>极客专栏: 38丨编程范式游记（9）-编程的本质</title><link>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E/38%E4%B8%A8%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F%E6%B8%B8%E8%AE%B09-%E7%BC%96%E7%A8%8B%E7%9A%84%E6%9C%AC%E8%B4%A8/</link><pubDate>Fri, 27 May 2022 00:00:00 +0000</pubDate><guid>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E/38%E4%B8%A8%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F%E6%B8%B8%E8%AE%B09-%E7%BC%96%E7%A8%8B%E7%9A%84%E6%9C%AC%E8%B4%A8/</guid><description>
&lt;p>前面我们讲了各式各样的不同语言的编程范式，从 C 语言的泛型，讲到 C++ 的泛型，再讲到函数式的 Map/Reduce/Filter，以及 Pipeline 和 Decorator，还有面向对象的多态通过依赖接口而不是实现的桥接模式、策略模式和代理模式，以及面向对象的 IoC，还有 JavaScript 的原型编程在运行时对对象原型进行修改，以及 Go 语言的委托模式&amp;hellip;&amp;hellip;&lt;/p>
&lt;p>所有的这一切，不知道你是否看出一些端倪，或是其中的一些共性来了？&lt;/p>
&lt;h1 id="两篇论文">两篇论文&lt;/h1>
&lt;p>1976 年，瑞士计算机科学家，Algol W，Modula，Oberon 和 Pascal 语言的设计师 &lt;a href="https://en.wikipedia.org/wiki/Niklaus_Wirth">Niklaus Emil Wirth&lt;/a>写了一本非常经典的书《&lt;a href="http://www.ethoberon.ethz.ch/WirthPubl/AD.pdf">Algorithms + Data Structures = Programs&lt;/a>》（链接为 1985 年版） ，即算法 + 数据结构 = 程序。&lt;/p>
&lt;p>这本书主要写了算法和数据结构的关系，这本书对计算机科学的影响深远，尤其在计算机科学的教育中。&lt;/p>
&lt;p>1979 年，英国逻辑学家和计算机科学家 &lt;a href="https://en.wikipedia.org/wiki/Robert_Kowalski">Robert Kowalski&lt;/a> 发表论文 &lt;a href="https://www.doc.ic.ac.uk/~rak/papers/algorithm%20=%20logic%20+%20control.pdf">Algorithm = Logic + Control&lt;/a>，并且主要开发&amp;quot;逻辑编程&amp;quot;相关的工作。&lt;/p>
&lt;p>Robert Kowalski 是一位逻辑学家和计算机科学家，从 20 世纪 70 年代末到整个 80 年代致力于数据库的研究，并在用计算机证明数学定理等当年的重要应用上颇有建树，尤其是在逻辑、控制和算法等方面提出了革命性的理论，极大地影响了数据库、编程语言，直至今日的人工智能。&lt;/p>
&lt;p>Robert Kowalski 在这篇论文里提到：&lt;/p>
&lt;blockquote>
&lt;p>An algorithm can be regarded as consisting of a logic component, which specifies the knowledge to be used in solving problems, and a control component, which determines the problem-solving strategies by means of which that knowledge is used. The logic component determines the meaning of the algorithm whereas the control component only affects its efficiency. The efficiency of an algorithm can often be improved by improving the control component without changing the logic of the algorithm. We argue that computer programs would be more often correct and more easily improved and modified if their logic and control aspects were identified and separated in the program text.&lt;/p>
&lt;/blockquote>
&lt;p>翻译过来的意思大概就是：&lt;/p>
&lt;blockquote>
&lt;p>任何算法都会有两个部分， 一个是 Logic 部分，这是用来解决实际问题的。另一个是 Control 部分，这是用来决定用什么策略来解决问题。Logic 部分是真正意义上的解决问题的算法，而 Control 部分只是影响解决这个问题的效率。程序运行的效率问题和程序的逻辑其实是没有关系的。我们认为，如果将 Logic 和 Control 部分有效地分开，那么代码就会变得更容易改进和维护。&lt;/p>
&lt;/blockquote>
&lt;p>注意，最后一句话是重点&amp;mdash;&amp;mdash;&lt;strong>如果将 Logic 和 Control 部分有效地分开，那么代码就会变得更容易改进和维护。&lt;/strong>&lt;/p>
&lt;h1 id="编程的本质">编程的本质&lt;/h1>
&lt;p>两位老先生的两个表达式：&lt;/p>
&lt;ul>
&lt;li>Programs = Algorithms + Data Structures&lt;/li>
&lt;li>Algorithm = Logic + Control&lt;/li>
&lt;/ul>
&lt;p>第一个表达式倾向于数据结构和算法，它是想把这两个拆分，早期都在走这条路。他们认为，如果数据结构设计得好，算法也会变得简单，而且一个好的通用的算法应该可以用在不同的数据结构上。&lt;/p>
&lt;p>第二个表达式则想表达的是数据结构不复杂，复杂的是算法，也就是我们的业务逻辑是复杂的。我们的算法由两个逻辑组成，一个是真正的业务逻辑，另外一种是控制逻辑。程序中有两种代码，一种是真正的业务逻辑代码，另一种代码是控制我们程序的代码，叫控制代码，这根本不是业务逻辑，业务逻辑不关心这个事情。&lt;/p>
&lt;p>算法的效率往往可以通过提高控制部分的效率来实现，而无须改变逻辑部分，也就无无须改变算法的意义。举个阶乘的例子： X(n)！= X(n) * X(n-1) * X(n-2) * X(n-3)* &amp;hellip; * 3 * 2 * 1。逻辑部分用来定义阶乘：1） 1 是 0 的阶乘； 2）如果 v 是 x 的阶乘，且 u=v*(x+1)，那么 u 是 x+1 的阶乘。&lt;/p>
&lt;p>用这个定义，既可以从上往下地将 x+1 的阶乘缩小为先计算 x 的阶乘，再将结果乘以 1（recursive，递归），也可以由下而上逐个计算一系列阶乘的结果（iteration，遍历）。&lt;/p>
&lt;p>控制部分用来描述如何使用逻辑。最粗略的看法可以认为&amp;quot;控制&amp;quot;是解决问题的策略，而不会改变算法的意义，因为算法的意义是由逻辑决定的。对同一个逻辑，使用不同控制，所得到的算法，本质是等价的，因为它们解决同样的问题，并得到同样的结果。&lt;/p>
&lt;p>因此，我们可以通过逻辑分析，来提高算法的效率，保持它的逻辑，而更好地使用这一逻辑。比如，有时用自上而下的控制替代自下而上，能提高效率。而将自上而下的顺序执行改为并行执行，也会提高效率。&lt;/p>
&lt;p>总之，通过这两个表达式，我们可以得出：&lt;/p>
&lt;p>&lt;strong>Program = Logic + Control + Data Structure&lt;/strong>&lt;/p>
&lt;p>前面讲了这么多的编程范式，或是程序设计的方法。其实，我们都是在围绕着这三件事来做的。比如：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>就像函数式编程中的 Map/Reduce/Filter，它们都是一种控制。而传给这些控制模块的那个 Lambda 表达式才是我们要解决的问题的逻辑，它们共同组成了一个算法。最后，我再把数据放在数据结构里进行处理，最终就成为了我们的程序。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>就像我们 Go 语言的委托模式的那个 Undo 示例一样。Undo 这个事是我们想要解决的问题，是 Logic，但是 Undo 的流程是控制。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>就像我们面向对象中依赖于接口而不是实现一样，接口是对逻辑的抽象，真正的逻辑放在不同的具现类中，通过多态或是依赖注入这样的控制来完成对数据在不同情况下的不同处理。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>如果你再仔细地结合我们之前讲的各式各样的编程范式来思考上述这些概念的话，你是否会觉得，所有的语言或编程范式都在解决上面的这些问题。也就下面的这几个事。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Control 是可以标准化的。比如：遍历数据、查找数据、多线程、并发、异步等，都是可以标准化的。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>因为 Control 需要处理数据，所以标准化 Control，需要标准化 Data Structure，我们可以通过泛型编程来解决这个事。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>而 Control 还要处理用户的业务逻辑，即 Logic。所以，我们可以通过标准化接口 / 协议来实现，我们的 Control 模式可以适配于任何的 Logic。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>上述三点，就是编程范式的本质。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>有效地分离 Logic、Control 和 Data 是写出好程序的关键所在！&lt;/strong>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>有效地分离 Logic、Control 和 Data 是写出好程序的关键所在！&lt;/strong>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>有效地分离 Logic、Control 和 Data 是写出好程序的关键所在！&lt;/strong>&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>我们在写代码当中，就会看到好多这种代码，会把控制逻辑和业务逻辑放在一块。里面有些变量和流程是跟业务相关的，有些是不相关的。业务逻辑决定了程序的复杂度，业务逻辑本身就复杂，你的代码就不可能写得简单。&lt;/p>
&lt;p>Logic，它是程序复杂度的的下限，然后，我们为了控制程序，需要再搞出很多控制代码，于是 Logic+Control 的相互交织成为了最终的程序复杂度。&lt;/p>
&lt;h1 id="把逻辑和控制混淆的示例">把逻辑和控制混淆的示例&lt;/h1>
&lt;p>我们来看一个示例，这是我在 leetcode 上做的一道题，这是通配符匹配，给两个字符串匹配。需求如下：&lt;/p>
&lt;pre>&lt;code>通配符匹配
isMatch(&amp;quot;aa&amp;quot;,&amp;quot;a&amp;quot;) → false
isMatch(&amp;quot;aa&amp;quot;,&amp;quot;aa&amp;quot;) → true
isMatch(&amp;quot;aaa&amp;quot;,&amp;quot;aa&amp;quot;) → false
isMatch(&amp;quot;aa&amp;quot;, &amp;quot;*&amp;quot;) → true
isMatch(&amp;quot;aa&amp;quot;, &amp;quot;a*&amp;quot;) → true
isMatch(&amp;quot;ab&amp;quot;, &amp;quot;?*&amp;quot;) → true
isMatch(&amp;quot;aab&amp;quot;, &amp;quot;c*a*b&amp;quot;) → false
&lt;/code>&lt;/pre>
&lt;p>现在你再看看我写出来的代码：&lt;/p>
&lt;pre>&lt;code>bool isMatch(const char *s, const char *p) {
const char *last_s = NULL;
const char *last_p = NULL;
while ( *s != '\0' ) {
if ( *p == '*' ) {
p++;
if ( *p == '\0' ) return true;
last_s = s;
last_p = p;
} else if ( *p == '?' || *s == *p ) {
s++;
p++;
} else if ( last_s != NULL ） {
p = last_p;
s = ++last_s;
} else {
return false;
}
}
while ( *p == '*' ) p++;
return *p == '\0';
}
&lt;/code>&lt;/pre>
&lt;p>我也不知道我怎么写出来的，好像是为了要通过，我需要关注于性能，你看，上面这段代码有多乱。如果我不写注释你可能都看不懂了。就算我写了注释以后，你敢改吗？你可能连动都不敢动（哈哈）。上面这些代码里面很多都不是业务逻辑，是用来控制程序的逻辑。&lt;/p>
&lt;p>业务逻辑是相对复杂的，但是控制逻辑跟业务逻辑交叉在一块，虽然代码写得不多，但是这个代码已经够复杂了。两三天以后，我回头看，我到底写的什么，我也不懂，为什么会写成这样？我当时脑子是怎么想的？我完全不知道。我现在就是这种感觉。&lt;/p>
&lt;p>那么，怎么把上面那段代码写得更好一些呢？&lt;/p>
&lt;ul>
&lt;li>
&lt;p>首先，我们需要一个比较通用的状态机（NFA，非确定有限自动机，或者 DFA，确定性有限自动机），来维护匹配的开始和结束的状态。这属于 Control。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>如果我们做得好的话，还可以抽像出一个像程序的文法分析一样的东西。这也是 Control。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>然后，我们把匹配 &lt;code>*&lt;/code> 和 &lt;code>?&lt;/code> 的算法形成不同的匹配策略。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>这样，我们的代码就会变得漂亮一些了，而且也会快速一些。&lt;/p>
&lt;p>这里有篇正则表达式的高效算法的论文&lt;a href="https://swtch.com/~rsc/regexp/regexp1.html">Regular Expression Matching Can Be Simple And Fast&lt;/a>，推荐你读一读，里面有相关的实现，我在这里就不多说了。&lt;/p>
&lt;p>这里，想说的程序的本质是 Logic+Control+Data，而其中，Logic 和 Control 是关键。注意，这个和系统架构也有相通的地方，逻辑是你的业务逻辑，逻辑过程的抽象，加上一个由术语表示的数据结构的定义，控制逻辑跟你的业务逻辑是没关系的，你控制它执行。&lt;/p>
&lt;p>控制一个程序流转的方式，即程序执行的方式，并行还是串行，同步还是异步，以及调度不同执行路径或模块，数据之间的存储关系，这些和业务逻辑没有关系。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/4a/92/4a8c7c77df1f1a6b3ff701577986ee92.png" alt="">&lt;/p>
&lt;p>如果你看过那些混乱不堪的代码，你会发现其中最大的问题是我们把这 Logic 和 Control 纠缠在一起了，所以会导致代码很混乱，难以维护，Bug 很多。绝大多数程序复杂的原因就是这个问题。就如同下面这幅图中表现的情况一样。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/5f/e2/5f45a22a027375c5960f5a6b31159ce2.png" alt="">&lt;/p>
&lt;h1 id="再来一个简单的示例">再来一个简单的示例&lt;/h1>
&lt;p>这里给一个简单的示例。&lt;/p>
&lt;p>下面是一段检查用户表单信息的常见代码，我相信这样的代码你见得多了。&lt;/p>
&lt;pre>&lt;code>function check_form_x() {
var name = $('#name').val();
if (null == name || name.length &amp;lt;= 3) {
return { status : 1, message: 'Invalid name' };
}
var password = $('#password').val();
if (null == password || password.length &amp;lt;= 8) {
return { status : 2, message: 'Invalid password' };
}
var repeat_password = $('#repeat_password').val();
if (repeat_password != password.length) {
return { status : 3, message: 'Password and repeat password mismatch' };
}
var email = $('#email').val();
if (check_email_format(email)) {
return { status : 4, message: 'Invalid email' };
}
\.\.\.
return { status : 0, message: 'OK' };
}
&lt;/code>&lt;/pre>
&lt;p>但其实，我们可以做一个 DSL+ 一个 DSL 的解析器，比如：&lt;/p>
&lt;pre>&lt;code>var meta_create_user = {
form_id : 'create_user',
fields : [
{ id : 'name', type : 'text', min_length : 3 },
{ id : 'password', type : 'password', min_length : 8 },
{ id : 'repeat-password', type : 'password', min_length : 8 },
{ id : 'email', type : 'email' }
]
};
var r = check_form(meta_create_user);
&lt;/code>&lt;/pre>
&lt;p>这样，DSL 的描述是&amp;quot;Logic&amp;quot;，而我们的 &lt;code>check_form&lt;/code> 则成了&amp;quot;Control&amp;quot;，代码就非常好看了。&lt;/p>
&lt;h1 id="小结">小结&lt;/h1>
&lt;p>代码复杂度的原因：&lt;/p>
&lt;ul>
&lt;li>业务逻辑的复杂度决定了代码的复杂度；&lt;/li>
&lt;li>控制逻辑的复杂度 + 业务逻辑的复杂度 ==&amp;gt; 程序代码的混乱不堪；&lt;/li>
&lt;li>绝大多数程序复杂混乱的根本原因：&lt;strong>业务逻辑与控制逻辑的耦合&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;p>如何分离 control 和 logic 呢？我们可以使用下面的这些技术来解耦。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>State Machine&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>状态定义&lt;/li>
&lt;li>状态变迁条件&lt;/li>
&lt;li>状态的 action&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>DSL &amp;ndash; Domain Specific Language&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>HTML，SQL，Unix Shell Script，AWK，正则表达式&amp;hellip;&amp;hellip;&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>编程范式&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>面向对象：委托、策略、桥接、修饰、IoC/DIP、MVC&amp;hellip;&amp;hellip;&lt;/li>
&lt;li>函数式编程：修饰、管道、拼装&lt;/li>
&lt;li>逻辑推导式编程：Prolog&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>这就是编程的本质：&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Logic 部分才是真正有意义的（What）&lt;/strong>&lt;/li>
&lt;li>&lt;strong>Control 部分只是影响 Logic 部分的效率（How）&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>以下是《编程范式游记》系列文章的目录，方便你了解这一系列内容的全貌。&lt;strong>这一系列文章中代码量很大，很难用音频体现出来，所以没有录制音频，还望谅解。&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/301">编程范式游记（1）- 起源&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/303">编程范式游记（2）- 泛型编程&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/2017">编程范式游记（3）- 类型系统和泛型的本质&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/2711">编程范式游记（4）- 函数式编程&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/2723">编程范式游记（5）- 修饰器模式&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/2729">编程范式游记（6）- 面向对象编程&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/2741">编程范式游记（7）- 基于原型的编程范式&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/2748">编程范式游记（8）- Go 语言的委托模式&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/2751">编程范式游记（9）- 编程的本质&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/2752">编程范式游记（10）- 逻辑编程范式&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/2754">编程范式游记（11）- 程序世界里的编程范式&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/fc/e9/fcc761001867c60f526665e237f831e9.jpg" alt="">&lt;/p></description></item><item><title>极客专栏: 39丨编程范式游记（10）-逻辑编程范式</title><link>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E/39%E4%B8%A8%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F%E6%B8%B8%E8%AE%B010-%E9%80%BB%E8%BE%91%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F/</link><pubDate>Fri, 27 May 2022 00:00:00 +0000</pubDate><guid>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E/39%E4%B8%A8%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F%E6%B8%B8%E8%AE%B010-%E9%80%BB%E8%BE%91%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F/</guid><description>
&lt;p>这篇文章重点介绍 Prolog 语言。Prolog（Programming in Logic 的缩写）是一种逻辑编程语言。它创建在逻辑学的理论基础之上，最初被运用于自然语言等研究领域。现在它已被广泛地应用在人工智能的研究中，可以用来建造专家系统、自然语言理解、智能知识库等。&lt;/p>
&lt;p>Prolog 语言最早由艾克斯马赛大学（Aix-Marseille University）的 Alain Colmerauer 与 Philippe Roussel 等人于 20 年代 60 年代末研究开发的。1972 年被公认为是 Prolog 语言正式诞生的年份，自 1972 年以后，分支出多种 Prolog 的方言。&lt;/p>
&lt;p>最主要的两种方言为 Edinburgh 和 Aix-Marseille。最早的 Prolog 解释器由 Roussel 建造，而第一个 Prolog 编译器则是 David Warren 编写的。&lt;/p>
&lt;p>Prolog 一直在北美和欧洲被广泛使用。日本政府曾经为了建造智能计算机而用 Prolog 来开发 ICOT 第五代计算机系统。在早期的机器智能研究领域，Prolog 曾经是主要的开发工具。&lt;/p>
&lt;p>20 世纪 80 年代 Borland 开发的 Turbo Prolog，进一步普及了 Prolog 的使用。1995 年确定了 ISO Prolog 标准。&lt;/p>
&lt;p>有别于一般的函数式语言，Prolog 的程序是基于谓词逻辑的理论。最基本的写法是定立对象与对象之间的关系，之后可以用询问目标的方式来查询各种对象之间的关系。系统会自动进行匹配及回溯，找出所询问的答案。&lt;/p>
&lt;p>Prolog 代码中以大写字母开头的元素是变量，字符串、数字或以小写字母开头的元素是常量，下划线（_）被称为匿名变量。&lt;/p>
&lt;h1 id="prolog-的语言特征">Prolog 的语言特征&lt;/h1>
&lt;p>逻辑编程是靠推理，比如下面的示例：&lt;/p>
&lt;pre>&lt;code>program mortal(X) :- philosopher(X).
philosopher(Socrates).
philosopher(Plato).
philosopher(Aristotle).
mortal_report:-
write('Known mortals are:'), nl, mortal(X),
write(X),nl,
fail.
&lt;/code>&lt;/pre>
&lt;p>我们可以看到下面的几个步骤。&lt;/p>
&lt;ol>
&lt;li>先定义一个规则：哲学家是人类。&lt;/li>
&lt;li>然后陈述事实：苏格拉底、亚里士多德、柏拉图都是哲学家。&lt;/li>
&lt;li>然后，我们问，谁是人类？于是就会输出苏格拉底、亚里士多德、柏拉图。&lt;/li>
&lt;/ol>
&lt;p>下面是逻辑编程范式的几个特征。&lt;/p>
&lt;ul>
&lt;li>逻辑编程的要点是将正规的逻辑风格带入计算机程序设计之中。&lt;/li>
&lt;li>逻辑编程建立了描述一个问题里的世界的逻辑模型。&lt;/li>
&lt;li>逻辑编程的目标是对它的模型建立新的陈述。&lt;/li>
&lt;li>通过陈述事实&amp;mdash;&amp;mdash;因果关系。&lt;/li>
&lt;li>程序自动推导出相关的逻辑。&lt;/li>
&lt;/ul>
&lt;h1 id="经典问题地图着色问题">经典问题：地图着色问题&lt;/h1>
&lt;p>我们再来看一个经典的四色地图问题。任何一个地图，相邻区域不能用相同颜色，只要用四种不同的颜色就够了。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/db/cb/db670cfbe7497d71eba70d60d8aa0fcb.png" alt="">&lt;/p>
&lt;p>首先，定义四种颜色。&lt;/p>
&lt;pre>&lt;code>color(red).
color(green).
color(blue).
color(yellow).
&lt;/code>&lt;/pre>
&lt;p>然后，定义一个规则：相邻的两个地区不能用相同的颜色。&lt;/p>
&lt;pre>&lt;code>neighbor(StateAColor, StateBColor) :- color(StateAColor), color(StateBColor),
StateAColor \= StateBColor. /* \= is the not equal operator */
&lt;/code>&lt;/pre>
&lt;p>最前面的两个条件：&lt;code>color(StateAColor)&lt;/code> 和 &lt;code>color(StateBColor)&lt;/code> 表明了两个变量 &lt;code>StateAColor&lt;/code> 和 &lt;code>StateBColor&lt;/code>。然后，第三个条件： &lt;code>StateAColor \= StateBColor&lt;/code> 表示颜色不能相同。&lt;/p>
&lt;p>接下来的事就比较简单了。我们描述事实就好了，描述哪些区域是相邻的事实。&lt;/p>
&lt;p>比如，下面描述了 BW 和 BY 是相邻的。&lt;/p>
&lt;p>&lt;code>germany(BW, BY) :- neighbor(BW, BY).&lt;/code>&lt;/p>
&lt;p>下面则描述多个区 BW、 BY、 SL、 RP、 和 ND 的相邻关系：&lt;/p>
&lt;p>&lt;code>germany(BW, BY, SL, RP, HE) :- neighbor(BW, BY), neighbor(BW, RP), neighbor(BW, HE).&lt;/code>&lt;/p>
&lt;p>于是，我们就可以描述整个德国地图的相邻关系了。&lt;/p>
&lt;pre>&lt;code>germany(SH, MV, HH, HB, NI, ST, BE, BB, SN, NW, HE, TH, RP, SL, BW, BY) :-
neighbor(SH, NI), neighbor(SH, HH), neighbor(SH, MV),
neighbor(HH, NI),
neighbor(MV, NI), neighbor(MV, BB),
neighbor(NI, HB), neighbor(NI, BB), neighbor(NI, ST), neighbor(NI, TH),
neighbor(NI, HE), neighbor(NI, NW),
neighbor(ST, BB), neighbor(ST, SN), neighbor(ST, TH),
neighbor(BB, BE), neighbor(BB, SN),
neighbor(NW, HE), neighbor(NW, RP),
neighbor(SN, TH), neighbor(SN, BY),
neighbor(RP, SL), neighbor(RP, HE), neighbor(RP, BW),
neighbor(HE, BW), neighbor(HE, TH), neighbor(HE, BY),
neighbor(TH, BY),
neighbor(BW, BY).
&lt;/code>&lt;/pre>
&lt;p>最后，我们使用如下语句，就可以让 Prolog 推导到各个地区的颜色。&lt;/p>
&lt;pre>&lt;code>?- germany(SH, MV, HH, HB, NI, ST, BE, BB, SN, NW, HE, TH, RP, SL, BW, BY).
&lt;/code>&lt;/pre>
&lt;h1 id="小结">小结&lt;/h1>
&lt;p>Prolog 这种逻辑编程，把业务逻辑或是说算法抽象成只关心规则、事实和问题的推导这样的标准方式，不需要关心程序控制，也不需要关心具体的实现算法。只需要给出可以用于推导的规则和相关的事实，问题就可以被通过逻辑推导来解决掉。是不是很有意思，也很好玩？&lt;/p>
&lt;p>如果有兴趣，你可以学习一下，这里推荐两个学习资源：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="http://www.doc.gold.ac.uk/~mas02gw/prolog_tutorial/prologpages/">Prolog Tutorial&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://www.learnprolognow.org">Learn Prolog Now!&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>以下是《编程范式游记》系列文章的目录，方便你了解这一系列内容的全貌。&lt;strong>这一系列文章中代码量很大，很难用音频体现出来，所以没有录制音频，还望谅解。&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/301">编程范式游记（1）- 起源&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/303">编程范式游记（2）- 泛型编程&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/2017">编程范式游记（3）- 类型系统和泛型的本质&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/2711">编程范式游记（4）- 函数式编程&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/2723">编程范式游记（5）- 修饰器模式&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/2729">编程范式游记（6）- 面向对象编程&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/2741">编程范式游记（7）- 基于原型的编程范式&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/2748">编程范式游记（8）- Go 语言的委托模式&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/2751">编程范式游记（9）- 编程的本质&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/2752">编程范式游记（10）- 逻辑编程范式&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/2754">编程范式游记（11）- 程序世界里的编程范式&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/fc/e9/fcc761001867c60f526665e237f831e9.jpg" alt="">&lt;/p></description></item><item><title>极客专栏: 40丨编程范式游记（11）-程序世界里的编程范式</title><link>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E/40%E4%B8%A8%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F%E6%B8%B8%E8%AE%B011-%E7%A8%8B%E5%BA%8F%E4%B8%96%E7%95%8C%E9%87%8C%E7%9A%84%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F/</link><pubDate>Fri, 27 May 2022 00:00:00 +0000</pubDate><guid>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E/40%E4%B8%A8%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F%E6%B8%B8%E8%AE%B011-%E7%A8%8B%E5%BA%8F%E4%B8%96%E7%95%8C%E9%87%8C%E7%9A%84%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F/</guid><description>
&lt;p>这个世界到今天已经有很多很多的编程范式，相当复杂。下面这个图比较好地描绘了这些各式各样的编程范式。这个图越往左边就越是&amp;quot;声明式的&amp;quot;，越往右边就越不是&amp;quot;声明式的&amp;quot;（指令式的），我们可以看到，函数式编程、逻辑编程，都在左边，而右边是指令式的，有状态的，有类型的。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/9d/8d/9d6ac4820cc070a6b567d3f514d9ea8d.png" alt="">&lt;/p>
&lt;p>上面这个图有点乱，不过总体说来，我们可以简单地把这世界上纷乱的编程范式，分成这几类：&lt;strong>声明式&lt;/strong> 、&lt;strong>命名式&lt;/strong> 、&lt;strong>逻辑的&lt;/strong> 、&lt;strong>函数式&lt;/strong> 、&lt;strong>面向对象的&lt;/strong> 、&lt;strong>面向过程的&lt;/strong>。&lt;/p>
&lt;p>于是我们归纳一下，就可以得到下面这个简单的图。简单描述一下，&lt;/p>
&lt;ul>
&lt;li>中间两个声明式编程范式（函数式和逻辑式）偏向于你定义要什么，而不是怎么做。&lt;/li>
&lt;li>而两边的命令式编程范式和面向对象编程范式，偏向于怎么做，而不是要做什么。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/d6/50/d64bf8275ee9e0eac3112dcd342d9350.png" alt="">&lt;/p>
&lt;p>我们再归纳一下，基本上来说，就是两大分支，一边是在解决数据和算法，一边是在解决逻辑和控制。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/bf/ef/bf6945c2ca2ec5564ecbbf1c81503eef.png" alt="">&lt;/p>
&lt;p>下面再给一张表格说明一下这世界上四大编程范式的类别，它们的特性和主要的编程语言。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/fc/ab/fcd2780bcb35c17e475eedb94b1f66ab.png" alt="">&lt;/p>
&lt;p>程序编程范式。一个是左脑，一个右脑。我们程序员基本上是在用左脑，左脑是理性分析，喜欢数据证据，线性思维，陷入细节，具体化的，不抽象。但是实际上玩儿出这些东西的都在右脑，函数式，还有像逻辑式的抽象能力都在右脑。所以我们非线性的想象力都在这边，而标准化教育把我们这边已经全部干掉了，我们只剩左边。我们陷入细节，我一说 Java 是最好的程序设计语言，一堆人就来了，找各种各样的细节问题跟你纠缠。&lt;/p>
&lt;p>离我们最近的是函数式编程，但既然函数式编程这么好，为什么函数式编程火不起来呢？首先，这里有个逻辑上的问题，并不是用的人越多的东西就越好。因为还要看是不是大多数人都能理解的东西。函数式编程或是声明式编程，需要的是用我们的右脑，而指令式的则需要用我们的左脑。&lt;/p>
&lt;p>参看下图：&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/11/c7/11f63d119d5954724b42024f9d6a64c7.png" alt="">&lt;/p>
&lt;p>我们可以看到，&lt;/p>
&lt;p>&lt;strong>人的左脑的特性是&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>理性分析型&lt;/li>
&lt;li>喜欢数据证据&lt;/li>
&lt;li>线性思维&lt;/li>
&lt;li>陷入细节&lt;/li>
&lt;li>具体化的&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>人的右脑的特性是&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>直觉型&lt;/li>
&lt;li>想象力&lt;/li>
&lt;li>非线性&lt;/li>
&lt;li>宏观思维&lt;/li>
&lt;li>抽象化的&lt;/li>
&lt;/ul>
&lt;p>人类社会中，绝大多数人都是左脑型的人，而只有少数人是右脑型的人，比如那些哲学家、艺术家，以及能够创造理论知识的人。这些人在这个世界上太少了。&lt;/p>
&lt;p>这是为什么很多人理解和使用声明式的编程范式比较有困难，因为这要用你的右脑，但是我们习惯于用我们的左脑，左脑用多了以后右脑就有点跟不上了。&lt;/p>
&lt;p>说到人类的大脑了，已经到了不是我专长的地方了，这个话题太大了，所以，也是时候结束《编程范式游记》这一系列文章了。希望你能从这一系列文章中有所收获。如果有什么疑问或是我有什么没有讲对的，还希望得到你的批评和指正。先谢谢了。&lt;/p>
&lt;p>以下是《编程范式游记》系列文章的目录，方便你了解这一系列内容的全貌。&lt;strong>这一系列文章中代码量很大，很难用音频体现出来，所以没有录制音频，还望谅解。&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/301">编程范式游记（1）- 起源&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/303">编程范式游记（2）- 泛型编程&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/2017">编程范式游记（3）- 类型系统和泛型的本质&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/2711">编程范式游记（4）- 函数式编程&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/2723">编程范式游记（5）- 修饰器模式&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/2729">编程范式游记（6）- 面向对象编程&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/2741">编程范式游记（7）- 基于原型的编程范式&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/2748">编程范式游记（8）- Go 语言的委托模式&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/2751">编程范式游记（9）- 编程的本质&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/2752">编程范式游记（10）- 逻辑编程范式&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/2754">编程范式游记（11）- 程序世界里的编程范式&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/fc/e9/fcc761001867c60f526665e237f831e9.jpg" alt="">&lt;/p></description></item><item><title>极客专栏: 41丨弹力设计篇之“认识故障和弹力设计”</title><link>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E/41%E4%B8%A8%E5%BC%B9%E5%8A%9B%E8%AE%BE%E8%AE%A1%E7%AF%87%E4%B9%8B%E8%AE%A4%E8%AF%86%E6%95%85%E9%9A%9C%E5%92%8C%E5%BC%B9%E5%8A%9B%E8%AE%BE%E8%AE%A1/</link><pubDate>Fri, 27 May 2022 00:00:00 +0000</pubDate><guid>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E/41%E4%B8%A8%E5%BC%B9%E5%8A%9B%E8%AE%BE%E8%AE%A1%E7%AF%87%E4%B9%8B%E8%AE%A4%E8%AF%86%E6%95%85%E9%9A%9C%E5%92%8C%E5%BC%B9%E5%8A%9B%E8%AE%BE%E8%AE%A1/</guid><description>
&lt;p>我前面写的《分布式系统架构的本质》系列文章，从分布式系统的业务层、中间件层、数据库层等各个层面介绍了高并发架构、异地多活架构、容器化架构、微服务架构、高可用架构、弹性化架构等，也就是所谓的&amp;quot;纲&amp;quot;。通过这个&amp;quot;纲&amp;quot;，你能够按图索骥，掌握分布式系统中每个部件的用途与总体架构思路。&lt;/p>
&lt;p>为了让你更深入地了解分布式系统，在接下来的几期中，我想谈谈分布式系统中一些比较关键的设计模式，其中包括容错、性能、管理等几个方面。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>容错设计又叫弹力设计&lt;/strong>，其中着眼于分布式系统的各种&amp;quot;容忍&amp;quot;能力，包括容错能力（服务隔离、异步调用、请求幂等性）、可伸缩性（有 / 无状态的服务）、一致性（补偿事务、重试）、应对大流量的能力（熔断、降级）。可以看到，在确保系统正确性的前提下，系统的可用性是弹力设计保障的重点。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>管理篇&lt;/strong>会讲述一些管理分布式系统架构的一些设计模式，比如网关方面的，边车模式，还有一些刚刚开始流行的，如 Service Mesh 相关的设计模式。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>性能设计篇&lt;/strong>会讲述一些缓存、CQRS、索引表、优先级队列、业务分片等相关的架构模式。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>我相信，你在掌握了这些设计模式之后，无论是对于部署一个分布式系统，开发一个分布式的业务模块，还是研发一个新的分布式系统中间件，都会有所裨益。&lt;/p>
&lt;p>今天分享的就是《分布式系统设计模式》系列文章中的第一篇《弹力设计篇之&amp;quot;认识故障和弹力设计&amp;quot;》。&lt;/p>
&lt;h1 id="系统可用性测量">系统可用性测量&lt;/h1>
&lt;p>对于分布式系统的容错设计，在英文中又叫 Resiliency（弹力）。意思是，系统在不健康、不顺，甚至出错的情况下有能力 hold 得住，挺得住，还有能在这种逆境下力挽狂澜的能力。&lt;/p>
&lt;p>要做好一个设计，我们需要一个设计目标，或是一个基准线，通过这个基准线或目标来指导我们的设计，否则在没有明确基准线的指导下，设计会变得非常不明确，并且也不可预测，不可测量。可测试和可测量性是软件设计中非常重要的事情。&lt;/p>
&lt;p>我们知道，容错主要是为了可用性，那么，我们是怎样计算一个系统的可用性的呢？下面是一个工业界里使用的一个公式：&lt;/p>
&lt;p>Availability=MTTFMTTF+MTTR &lt;math xmlns="http://www.w3.org/1998/Math/MathML" display="block"> A v a i l a b i l i t y = M T T F M T T F + M T T R &lt;/math>&lt;/p>
&lt;br />
&lt;p>其中，&lt;/p>
&lt;ul>
&lt;li>
&lt;p>MTTF 是 Mean Time To Failure，平均故障前的时间，即系统平均能够正常运行多长时间才发生一次故障。系统的可靠性越高，MTTF 越长。（注意：从字面上来说，看上去有 Failure 的字样，但其实是正常运行的时间。）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>MTTR 是 Mean Time To Recovery，平均修复时间，即从故障出现到故障修复的这段时间，这段时间越短越好。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>这个公式就是计算系统可用性的，也就是我们常说的，多少个 9，如下表所示。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/c3/72/c3ac18852cc1067b3d7df4223a340372.png" alt="">&lt;/p>
&lt;p>根据上面的这个公式，为了提高可用性，我们要么提高系统的无故障时间，要么减少系统的故障恢复时间。&lt;/p>
&lt;p>然而，我们要明白，我们运行的是一个分布式系统，对于一个分布式系统来说，要不出故障简直是太难了。&lt;/p>
&lt;h1 id="故障原因">故障原因&lt;/h1>
&lt;p>老实说，我们很难计算我们设计的系统有多少的可用性，因为影响一个系统的因素实在是太多了，除了软件设计，还有硬件，还有第三方服务（如电信联通的宽带 SLA），当然包括&amp;quot;建筑施工队的挖掘机&amp;quot;。&lt;/p>
&lt;p>所以，正如 SLA 的定义，这不只是一个技术指标，而是一种服务提供商和用户之间的 contract 或契约。这种工业级的玩法，就像飞机一样，并不是把飞机造出来就好了，还有大量的无比专业的配套设施、工具、流程、管理和运营。&lt;/p>
&lt;p>简而言之，SLA 的几个 9 就是能持续提供可用服务的级别。不过，工业界中，会把服务不可用的因素分成两种：一种是有计划的，一种是无计划的。&lt;/p>
&lt;p>无计划的宕机原因。下图来自 Oracle 的 &lt;a href="https://docs.oracle.com/cd/A91202_01/901_doc/rac.901/a89867/pshavdtl.htm">High Availability Concepts and Best Practices&lt;/a>。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/9a/e6/9a722dcc85d2da71dc4b25a1667caee6.png" alt="">&lt;/p>
&lt;p>有计划的宕机原因。下图来自 Oracle 的&lt;a href="https://docs.oracle.com/cd/A91202_01/901_doc/rac.901/a89867/pshavdtl.htm">High Availability Concepts and Best Practices&lt;/a>。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/0b/64/0b0d8e7a190531b582fcee010b8ba164.png" alt="">&lt;/p>
&lt;p>可以看到，宕机原因主要有以下这些。&lt;/p>
&lt;p>&lt;strong>无计划的&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>系统级故障，包括主机、操作系统、中间件、数据库、网络、电源以及外围设备。&lt;/li>
&lt;li>数据和中介的故障，包括人员误操作、硬盘故障、数据乱了。&lt;/li>
&lt;li>还有自然灾害、人为破坏，以及供电问题等。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>有计划的&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>日常任务：备份，容量规划，用户和安全管理，后台批处理应用。&lt;/li>
&lt;li>运维相关：数据库维护、应用维护、中间件维护、操作系统维护、网络维护。&lt;/li>
&lt;li>升级相关：数据库、应用、中间件、操作系统、网络，包括硬件升级。&lt;/li>
&lt;/ul>
&lt;p>我们再给它们归个类。&lt;/p>
&lt;ol>
&lt;li>&lt;strong>网络问题&lt;/strong>。网络链接出现问题，网络带宽出现拥塞&amp;hellip;&amp;hellip;&lt;/li>
&lt;li>&lt;strong>性能问题&lt;/strong>。数据库慢 SQL、Java Full GC、硬盘 IO 过大、CPU 飙高、内存不足&amp;hellip;&amp;hellip;&lt;/li>
&lt;li>&lt;strong>安全问题&lt;/strong>。被网络攻击，如 DDoS 等。&lt;/li>
&lt;li>&lt;strong>运维问题&lt;/strong>。系统总是在被更新和修改，架构也在不断地被调整，监控问题&amp;hellip;&amp;hellip;&lt;/li>
&lt;li>&lt;strong>管理问题&lt;/strong>。没有梳理出关键服务以及服务的依赖关系，运行信息没有和控制系统同步&amp;hellip;&amp;hellip;&lt;/li>
&lt;li>&lt;strong>硬件问题&lt;/strong>。硬盘损坏、网卡出问题、交换机出问题、机房掉电、挖掘机问题&amp;hellip;&amp;hellip;&lt;/li>
&lt;/ol>
&lt;h1 id="故障不可避免">故障不可避免&lt;/h1>
&lt;p>如果你看过我写过的《分布式系统架构的本质》和《故障处理》这两个系列的文章，就会知道要管理好一个分布式系统是一件非常难的事。对于大规模的分布式系统，出现故障基本上就是常态，甚至还有些你根本就不知道会出问题的地方。&lt;/p>
&lt;p>在今天来说，一个分布式系统的故障已经非常复杂了，因为故障是分布式的、多米诺骨牌式的。就像我在《分布式系统架构的本质》中展示过的这个图一样。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/bd/3e/bd48fbd74405e8380defdf708b6b3e3e.png" alt="">&lt;/p>
&lt;p>如果你在云平台上，或者使用了&amp;quot;微服务&amp;quot;，面对大量的 IoT 设备以及不受控制的用户流量，那么系统故障会更为复杂和变态。因为上面这些因素增加了整个系统的复杂度。&lt;/p>
&lt;p>所以，要充分地意识到下面两个事。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>故障是正常的，而且是常见的&lt;/strong>。&lt;/li>
&lt;li>&lt;strong>故障是不可预测突发的，而且相当难缠&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;p>所以，亚马逊的 AWS 才会把 Design for Failure 做为其七大 Design Principle 的重点。这告诉我们，不要尝试着去避免故障，而是要把处理故障的代码当成正常的功能做在架构里写在代码里。&lt;/p>
&lt;p>因为我们要干的事儿就是想尽一切手段来降低 MTTR&amp;mdash;&amp;mdash;故障的修复时间。&lt;/p>
&lt;p>这就是为什么我们把这个设计叫做弹力（Resiliency）。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>一方面，在好的情况下，这个事对于我们的用户和内部运维来说是完全透明的，系统自动修复不需要人的干预。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>另一方面，如果修复不了，系统能够做自我保护，而不让事态变糟糕。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>这就是所谓的&amp;quot;弹力&amp;quot;&amp;mdash;&amp;mdash;能上能下。这让我想到三国杀里赵云的技能&amp;mdash;&amp;mdash;&amp;ldquo;能进能退乃真正法器&amp;rdquo;，哈哈。&lt;/p>
&lt;h1 id="小结">小结&lt;/h1>
&lt;p>好了，今天的内容就到这里。相信通过今天的学习，你应该已经明白了弹力设计的真正目的，并对系统可用性的衡量指标和故障的各种原因有所了解。下一篇文章，我们将开始罗列一些相关的设计模式。&lt;/p>
&lt;p>在文章的最后，很想听听大家在设计一个分布式系统时，设定了多高的可用性指标？实现的难点在哪里？踩过什么样的坑？你是如何应对的？&lt;/p>
&lt;p>文末给出了《分布式系统设计模式》系列文章的目录，希望你能在这个列表里找到自己感兴趣的内容。&lt;/p>
&lt;ul>
&lt;li>弹力设计篇
&lt;ul>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/3912">认识故障和弹力设计&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/3917">隔离设计 Bulkheads&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/3926">异步通讯设计 Asynchronous&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/4050">幂等性设计 Idempotency&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/4086">服务的状态 State&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/4087">补偿事务 Compensating Transaction&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/4121">重试设计 Retry&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/4241">熔断设计 Circuit Breaker&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/4245">限流设计 Throttle&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/4252">降级设计 degradation&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/4253">弹力设计总结&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>管理设计篇
&lt;ul>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/5175">分布式锁 Distributed Lock&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/5819">配置中心 Configuration Management&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/5909">边车模式 Sidecar&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/5920">服务网格 Service Mesh&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/6086">网关模式 Gateway&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/6283">部署升级策略&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>性能设计篇
&lt;ul>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/6282">缓存 Cache&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/7036">异步处理 Asynchronous&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/7045">数据库扩展&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/7047">秒杀 Flash Sales&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/7086">边缘计算 Edge Computing&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul></description></item><item><title>极客专栏: 42丨弹力设计篇之“隔离设计”</title><link>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E/42%E4%B8%A8%E5%BC%B9%E5%8A%9B%E8%AE%BE%E8%AE%A1%E7%AF%87%E4%B9%8B%E9%9A%94%E7%A6%BB%E8%AE%BE%E8%AE%A1/</link><pubDate>Fri, 27 May 2022 00:00:00 +0000</pubDate><guid>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E/42%E4%B8%A8%E5%BC%B9%E5%8A%9B%E8%AE%BE%E8%AE%A1%E7%AF%87%E4%B9%8B%E9%9A%94%E7%A6%BB%E8%AE%BE%E8%AE%A1/</guid><description>
&lt;p>隔离设计对应的单词是 Bulkheads，中文翻译为隔板。但其实，这个术语是用在造船上的，也就是船舱里防漏水的隔板。一般的船无论大小都会有这个东西，大一点的船都会把船舱隔成若干个空间。这样，如果船舱漏水，只会进到一个小空间里，不会让整个船舱都进水而导致整艘船都沉了，如下图所示。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/0d/c4/0d73168bd1af3e1266c24c2064d391c4.png" alt="">&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/53/97/53ae45b51f9e2678ec7e8661ef233297.png" alt="">&lt;/p>
&lt;p>我们的软件设计当然也&amp;quot;漏水&amp;quot;，所以为了不让这个&amp;quot;故障&amp;quot;蔓延开来，需要使用&amp;quot;隔板&amp;quot;技术，来将架构分隔成多个&amp;quot;船舱&amp;quot;来隔离故障。&lt;/p>
&lt;p>多扯一句，著名的泰坦尼克号也有 Bulkheads 设计，然而其设计上有个缺陷。如下图所示，当其撞上冰山漏水时，因为船体倾斜，导到水漫过了隔板，从而下沉了。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/5b/bf/5bfda0399c45e1ae6a53860698740dbf.png" alt="">&lt;/p>
&lt;p>在分布式软件架构中，我们同样需要使用类似这样的技术来让我们的故障得到隔离。这就需要我们对系统进行分离。一般来说，对于系统的分离有两种方式，一种是以服务的种类来做分离，一种是以用户来做分离。下面具体说明一下这两种方式。&lt;/p>
&lt;h1 id="按服务的种类来做分离">按服务的种类来做分离&lt;/h1>
&lt;p>下面这个图中，说明了按服务种类来做分离的情况。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/34/eb/34e3b94399f89a825a0046234607f9eb.png" alt="">&lt;/p>
&lt;p>上图中，我们将系统分成了用户、商品、社区三个版块。三个板块分别使用不同的域名、服务器和数据库，做到从接入层到应用层再到数据层三层完全隔离。这样一来，在物理上来说，一个版块的故障就不会影响到另一版块。&lt;/p>
&lt;p>在亚马逊，每个服务都有自己的一个数据库，每个数据库中都保存着和这个业务相关的数据和相应的处理状态。而每个服务从一开始就准备好了对外暴露。同时，这也是微服务所推荐的架构方式。&lt;/p>
&lt;p>然而任何架构都有其好和不好的地方，上面这种架构虽然在系统隔离上做得比较好，但是也存在以下一些问题。&lt;/p>
&lt;ul>
&lt;li>如果我们需要同时获得多个版块的数据，那么就需要调用多个服务，这会降低性能。注意，这里性能降低指的是响应时间，而不是吞吐量（相反，在这种架构下，吞吐量可以得到提高）。&lt;/li>
&lt;/ul>
&lt;p>对于这样的问题，一般来说，我们需要小心地设计用户交互，最好不要让用户在一个页面上获得所有的数据。对于目前的手机端上来说，因为手机屏幕尺寸比较小，所以，也不可能在一个屏幕页上展示太多的内容。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>如果有大数据平台，就需要把这些数据都抽取到一个数据仓库中进行计算，这也增加了数据合并的复杂度。对于这个问题，我们需要一个框架或是一个中间件来对数据进行相应的抽取。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>另外，如果我们的业务逻辑或是业务流程需要跨版块的话，那么一个版块的故障也会导致整个流程走不下去，同样会导致整体业务故障。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>对于这个问题，一方面，我们需要保证这个业务流程中各个子系统的高可用性，并且在业务流程上做成 Step-by-Step 的方式，这样用户交互的每一步都可以保存，以便故障恢复后可以继续执行，而不是从头执行。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>还有，如果需要有跨版块的交互也会变得有点复杂。对此我们需要一个类似于 Pub/Sub 的高可用的并可以持久化的消息订阅通知的中间件来打通各个版块的数据和信息交换。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>最后还会有在多个版块中分布式事务的问题。对此，我们需要&amp;quot;二阶段提交&amp;quot;这样的方案。在亚马逊中，使用的是 Plan &amp;ndash; Reserve &amp;ndash; Commit/Cancel 模式。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>也就是说，先做一个 plan 的 API 调用，然后各个子系统 reserve 住相应的资源，如果成功，则 Commit；如果有一个失败，则整体 Cancel。这其实很像阿里的 TCC &amp;ndash; try confirm/cancel。&lt;/p>
&lt;p>可见，隔离了的系统在具体的业务场景中还是有很多问题的，是需要我们小心和处理的。对此，我们不可掉以轻心。根据我的经验，这样的系统通常会引入大量的异步处理模型。&lt;/p>
&lt;h1 id="按用户的请求来做分离">按用户的请求来做分离&lt;/h1>
&lt;p>下图是一个按用户请求来做分离的图示。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/a7/5e/a7293c5fe813a7e8e2498aac34c4825e.png" alt="">&lt;/p>
&lt;p>在这个图中，可以看到，我们将用户分成不同的组，并把后端的同一个服务根据这些不同的组分成不同的实例。让同一个服务对于不同的用户进行冗余和隔离，这样一来，当服务实例挂掉时，只会影响其中一部分用户，而不会导致所有的用户无法访问。&lt;/p>
&lt;p>这种分离和上面按功能的分离可以融合。说白了，这就是所谓的&amp;quot;多租户&amp;quot;模式。对于一些比较大的客户，我们可以为他们设置专门独立的服务实例，或是服务集群与其他客户隔离开来，对于一些比较小的用户来说，可以让他们共享一个服务实例，这样可以节省相关的资源。&lt;/p>
&lt;p>对于&amp;quot;多租户&amp;quot;的架构来说，会引入一些系统设计的复杂度。一方面，如果完全隔离，资源使用上会比较浪费，如果共享，又会导致程序设计的一些复杂度。&lt;/p>
&lt;p>通常来说多租户的做法有三种。&lt;/p>
&lt;ol>
&lt;li>
&lt;p>完全独立的设计。每个租户有自己完全独立的服务和数据。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>独立的数据分区，共享的服务。多租户的服务是共享的，但数据是分开隔离的。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>共享的服务，共享的数据分区。每个租户的数据和服务都是共享的。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>这三种方案各有优缺点，如图所示。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/0c/9c/0c7cb0d25fb2c65a8db011ba61b8729c.png" alt="">&lt;/p>
&lt;p>通过上图，可以看到：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>如果使用完全独立的方案，在开发实现上和资源隔离度方面会非常好，然而，成本会比较高，计算资源也会有一定的浪费。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>如果使用完全共享的方案，在资源利用和成本上会非常好，然而，开发难度非常大，而且数据和资源隔离非常不好。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>所以，一般来说，技术方案会使用折衷方案，也就是中间方案，服务是共享的，数据通过分区来隔离，而对于一些比较重要的租户（需要好的隔离性），则使用完全独立的方式。&lt;/p>
&lt;p>然而，在虚拟化技术非常成熟的今天，我们完全可以使用&amp;quot;完全独立&amp;quot;（完全隔离）的方案，通过底层的虚拟化技术（Hypervisor 的技术，如 KVM，或是 Linux Container 的技术，如 Docker）来实现物理资源的共享和成本的节约。&lt;/p>
&lt;h1 id="隔离设计的重点">隔离设计的重点&lt;/h1>
&lt;p>要能做好隔离设计，我们需要有如下的一些设计考量。&lt;/p>
&lt;ol>
&lt;li>
&lt;p>我们需要定义好隔离业务的大小和粒度，过大和过小都不好。这需要认真地做业务上的需求和系统分析。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>无论是做系统版块还是多租户的隔离，你都需要考虑系统的复杂度、成本、性能、资源使用的问题，找到一个合适的均衡方案，或是分布实施的方案尤其重要，这其中需要你定义好要什么和不要什么。因为，我们不可能做出一个什么都能满足的系统。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>隔离模式需要配置一些高可用、重试、异步、消息中间件，流控、熔断等设计模式的方式配套使用。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>不要忘记了分布式系统中的运维的复杂度的提升，要能驾驭得好的话，还需要很多自动化运维的工具，尤其是使用像容器或是虚拟机这样的虚拟化技术可以帮助我们更方便地管理，和对比资源更好地利用。否则做出来了也管理不好。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>最后，你需要一个非常完整的能够看得到所有服务的监控系统，这点非常重要。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h1 id="小结">小结&lt;/h1>
&lt;p>好了，我们来总结一下今天分享的主要内容。首先，我从船体水密舱的设计，引出了分布式系统设计中的隔离设计。然后我介绍了常见的隔离有两种，一种是按服务种类隔离，另一种是按用户隔离（即多租户）。下篇文章中，我们讲述异步通讯设计。希望对你有帮助。&lt;/p>
&lt;p>也欢迎你分享一下你是如何为分布式系统做隔离设计的。&lt;/p>
&lt;p>文末给出了《分布式系统设计模式》系列文章的目录，希望你能在这个列表里找到自己感兴趣的内容。&lt;/p>
&lt;ul>
&lt;li>弹力设计篇
&lt;ul>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/3912">认识故障和弹力设计&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/3917">隔离设计 Bulkheads&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/3926">异步通讯设计 Asynchronous&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/4050">幂等性设计 Idempotency&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/4086">服务的状态 State&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/4087">补偿事务 Compensating Transaction&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/4121">重试设计 Retry&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/4241">熔断设计 Circuit Breaker&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/4245">限流设计 Throttle&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/4252">降级设计 degradation&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/4253">弹力设计总结&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>管理设计篇
&lt;ul>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/5175">分布式锁 Distributed Lock&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/5819">配置中心 Configuration Management&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/5909">边车模式 Sidecar&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/5920">服务网格 Service Mesh&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/6086">网关模式 Gateway&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/6283">部署升级策略&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>性能设计篇
&lt;ul>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/6282">缓存 Cache&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/7036">异步处理 Asynchronous&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/7045">数据库扩展&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/7047">秒杀 Flash Sales&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/7086">边缘计算 Edge Computing&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/fc/e9/fcc761001867c60f526665e237f831e9.jpg" alt="">&lt;/p></description></item><item><title>极客专栏: 43丨弹力设计篇之“异步通讯设计”</title><link>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E/43%E4%B8%A8%E5%BC%B9%E5%8A%9B%E8%AE%BE%E8%AE%A1%E7%AF%87%E4%B9%8B%E5%BC%82%E6%AD%A5%E9%80%9A%E8%AE%AF%E8%AE%BE%E8%AE%A1/</link><pubDate>Fri, 27 May 2022 00:00:00 +0000</pubDate><guid>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E/43%E4%B8%A8%E5%BC%B9%E5%8A%9B%E8%AE%BE%E8%AE%A1%E7%AF%87%E4%B9%8B%E5%BC%82%E6%AD%A5%E9%80%9A%E8%AE%AF%E8%AE%BE%E8%AE%A1/</guid><description>
&lt;p>前面所说的隔离设计通常都需要对系统做解耦设计，而把一个单体系统解耦，不单单是把业务功能拆分出来，正如上面所说，拆分完后还会面对很多的问题。其中一个重要的问题就是这些系统间的通讯。&lt;/p>
&lt;p>通讯一般来说分同步和异步两种。同步通讯就像打电话，需要实时响应，而异步通讯就像发邮件，不需要马上回复。各有千秋，我们很难说谁比谁好。但是在面对超高吐吞量的场景下，异步处理就比同步处理有比较大的优势了，这就好像一个人不可能同时接打很多电话，但是他可以同时接收很多的电子邮件一样。&lt;/p>
&lt;p>同步调用虽然让系统间只耦合于接口，而且实时性也会比异步调用要高，但是我们也需要知道同步调用会带来如下几个问题。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>同步调用需要被调用方的吞吐不低于调用方的吞吐。否则会导致被调用方因为性能不足而拖死调用方。换句话说，整个同步调用链的性能会由最慢的那个服务所决定。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>同步调用会导致调用方一直在等待被调用方完成，如果一层接一层地同步调用下去，所有的参与方会有相同的等待时间。这会非常消耗调用方的资源。因为调用方需要保存现场（Context）等待远端返回，所以对于并发比较高的场景来说，这样的等待可能会极度消耗资源。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>同步调用只能是一对一的，很难做到一对多。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>同步调用最不好的是，如果被调用方有问题，那么其调用方就会跟着出问题，于是会出现多米诺骨牌效应，故障一下就蔓延开来。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>所以，异步通讯相对于同步通讯来说，除了可以增加系统的吞吐量之外，最大的一个好处是其可以让服务间的解耦更为彻底，系统的调用方和被调用方可以按照自己的速率而不是步调一致，从而可以更好地保护系统，让系统更有弹力。&lt;/p>
&lt;p>异步通讯通常来说有三种方式。&lt;/p>
&lt;h1 id="异步通讯的三种方式">异步通讯的三种方式&lt;/h1>
&lt;h2 id="请求响应式">请求响应式&lt;/h2>
&lt;p>在这种情况下，发送方（sender）会直接请求接收方（receiver），被请求方接收到请求后，直接返回&amp;mdash;&amp;mdash;收到请求，正在处理。&lt;/p>
&lt;p>对于返回结果，有两种方法，一种是发送方时不时地去轮询一下，问一下干没干完。另一种方式是发送方注册一个回调方法，也就是接收方处理完后回调请求方。这种架构模型在以前的网上支付中比较常见，页面先从商家跳转到支付宝或银行，商家会把回调的 URL 传给支付页面，支付完后，再跳转回商家的 URL。&lt;/p>
&lt;p>很明显，这种情况下还是有一定耦合的。是发送方依赖于接收方，并且要把自己的回调发送给接收方，处理完后回调。&lt;/p>
&lt;h2 id="通过订阅的方式">通过订阅的方式&lt;/h2>
&lt;p>这种情况下，接收方（receiver）会来订阅发送方（sender）的消息，发送方会把相关的消息或数据放到接收方所订阅的队列中，而接收方会从队列中获取数据。&lt;/p>
&lt;p>这种方式下，发送方并不关心订阅方的处理结果，它只是告诉订阅方有事要干，收完消息后给个 ACK 就好了，你干成啥样我不关心。这个方式常用于像 MVC（Model-View-Control）这样的设计模式下，如下图所示。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/d8/37/d8d96ed4e4616626b9e079dc13637937.png" alt="">&lt;/p>
&lt;p>这就好像下订单的时候，一旦用户支付完成了，就需要把这个事件通知给订单处理以及物流，订单处理变更状态，物流服务需要从仓库服务分配相应的库存并准备配送，后续这些处理的结果无需告诉支付服务。&lt;/p>
&lt;p>为什么要做成这样？好了，重点来了！前面那种请求响应的方式就像函数调用一样，这种方式有数据有状态的往来（也就是说需要有请求数据、返回数据，服务里面还可能需要保存调用的状态），所以服务是有状态的。如果我们把服务的状态给去掉（通过第三方的状态服务来保证），那么服务间的依赖就只有事件了。&lt;/p>
&lt;p>你知道，分布式系统的服务设计是需要向无状态服务（Stateless）努力的，这其中有太多的好处，无状态意味着你可以非常方便地运维。所以，事件通讯成为了异步通讯中最重要的一个设计模式。&lt;/p>
&lt;p>就上面支付的那个例子，商家这边只需要订阅一个支付完成的事件，这个事件带一个订单号，而不需要让支付方知道自己的回调 URL，这样的异步是不是更干净一些？&lt;/p>
&lt;p>但是，在这种方式下，接收方需要向发送方订阅事件，所以是接收方依赖于发送方。这种方式还是有一定的耦合。&lt;/p>
&lt;h2 id="通过-broker-的方式">通过 Broker 的方式&lt;/h2>
&lt;p>所谓 Broker，就是一个中间人，发送方（sender）和接收方（receiver）都互相看不到对方，它们看得到的是一个 Broker，发送方向 Broker 发送消息，接收方向 Broker 订阅消息。如下图所示。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/aa/17/aa1c6db18e706012e8028b4d1bddb917.png" alt="">&lt;/p>
&lt;p>这是完全的解耦。所有的服务都不需要相互依赖，而是依赖于一个中间件 Broker。这个 Broker 是一个像数据总线一样的东西，所有的服务要接收数据和发送数据都发到这个总线上，这个总线就像协议一样，让服务间的通讯变得标准和可控。&lt;/p>
&lt;p>在 Broker 这种模式下，发送方的服务和接收方的服务最大程度地解耦。但是所有人都依赖于一个总线，所以这个总线就需要有如下的特性：&lt;/p>
&lt;ul>
&lt;li>必须是高可用的，因为它成了整个系统的关键；&lt;/li>
&lt;li>必须是高性能而且是可以水平扩展的；&lt;/li>
&lt;li>必须是可以持久化不丢数据的。&lt;/li>
&lt;/ul>
&lt;p>要做到这三条还是比较难的。当然，好在现在开源软件或云平台上 Broker 的软件是非常成熟的，所以节省了我们很多的精力。&lt;/p>
&lt;h1 id="事件驱动设计">事件驱动设计&lt;/h1>
&lt;p>上述的第二种和第三种方式就是比较著名的事件驱动架构（EDA &amp;ndash; Event Driven Architecture）。正如前面所说，事件驱动最好是使用 Broker 方式，服务间通过交换消息来完成交流和整个流程的驱动。&lt;/p>
&lt;p>如下图所示，这是一个订单处理流程。下单服务通知订单服务有订单要处理，而订单服务生成订单后发出通知，库存服务和支付服务得到通知后，一边是占住库存，另一边是让用户支付，等待用户支付完成后通知配送服务进行商品配送。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/aa/59/aa95556d053e22be38a8beb40cf28759.png" alt="">&lt;/p>
&lt;p>每个服务都是&amp;quot;自包含&amp;quot;的。所谓&amp;quot;自包含&amp;quot;也就是没有和别人产生依赖。而要把整个流程给串联起来，我们需要一系列的&amp;quot;消息通道（Channel）&amp;quot;。各个服务做完自己的事后，发出相应的事件，而又有一些服务在订阅着某些事件来联动。&lt;/p>
&lt;p>事件驱动方式的好处至少有五个。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>服务间的依赖没有了，服务间是平等的，每个服务都是高度可重用并可被替换的。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>服务的开发、测试、运维，以及故障处理都是高度隔离的。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>服务间通过事件关联，所以服务间是不会相互 block 的。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>在服务间增加一些 Adapter（如日志、认证、版本、限流、降级、熔断等）相当容易。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>服务间的吞吐也被解开了，各个服务可以按照自己的处理速度处理。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>我们知道任何设计都有好有不好的方式。事件驱动的架构也会有一些不好的地方。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>业务流程不再那么明显和好管理。整个架构变得比较复杂。解决这个问题需要有一些可视化的工具来呈现整体业务流程。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>事件可能会乱序。这会带来非常 Bug 的事。解决这个问题需要很好地管理一个状态机的控制。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>事务处理变得复杂。需要使用两阶段提交来做强一致性，或是退缩到最终一致性。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h1 id="异步通讯的设计重点">异步通讯的设计重点&lt;/h1>
&lt;p>首先，我们需要知道，为什么要异步通讯。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>异步通讯最重要的是解耦服务间的依赖。最佳解耦的方式是通过 Broker 的机制。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>解耦的目的是让各个服务的隔离性更好，这样不会出现&amp;quot;一倒倒一片&amp;quot;的故障。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>异步通讯的架构可以获得更大的吞吐量，而且各个服务间的性能不受干扰相对独立。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>利用 Broker 或队列的方式还可以达到把抖动的吞吐量变成均匀的吞吐量，这就是所谓的&amp;quot;削峰&amp;quot;，这对后端系统是个不错的保护。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>服务相对独立，在部署、扩容和运维上都可以做到独立不受其他服务的干扰。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>但我们需要知道这样的方式带来的问题，所以在设计成异步通信的时候需要注意如下事宜。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>用于异步通讯的中间件 Broker 成为了关键，需要设计成高可用不丢消息的。另外，因为是分布式的，所以可能很难保证消息的顺序，因此你的设计最好不依赖于消息的顺序。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>异步通讯会导致业务处理流程不那么直观，因为像接力一样，所以在 Broker 上需要有相关的服务消息跟踪机制，否则出现问题后不容易调试。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>因为服务间只通过消息交互，所以业务状态最好由一个总控方来管理，这个总控方维护一个业务流程的状态变迁逻辑，以便系统发生故障后知道业务处理到了哪一步，从而可以在故障清除后继续处理。&lt;/p>
&lt;p>这样的设计常见于银行的对账程序，银行系统会有大量的外部系统通讯，比如跨行的交易、跨企业的交易，等等。所以，为了保证整体数据的一致性，或是避免漏处理及处理错的交易，需要有对账系统，这其实就是那个总控，这也是为什么银行有的交易是 T+1（隔天结算），就是因为要对个账，确保数据是对的。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>消息传递中，可能有的业务逻辑会有像 TCP 协议那样的 send 和 ACK 机制。比如：A 服务发出一个消息之后，开始等待处理方的 ACK，如果等不到的话，就需要做重传。此时，需要处理方有幂等的处理，即同一件消息无论收到多少次都只处理一次。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h1 id="小结">小结&lt;/h1>
&lt;p>好了，我们来总结一下今天分享的主要内容。首先，同步调用有四个问题：影响吞吐量、消耗系统资源、只能一对一，以及有多米诺骨牌效应。于是，我们想用异步调用来避免该问题。&lt;/p>
&lt;p>异步调用有三种方式：请求响应、直接订阅和中间人订阅。最后，我介绍了事件驱动设计的特点和异步通讯设计的重点。下篇文章中，我们讲述幂等性设计。希望对你有帮助。&lt;/p>
&lt;p>也欢迎你分享一下你在分布式服务的设计中，哪些情况下使用异步通讯？是怎样设计的？又有哪些情况使用同步通讯？&lt;/p>
&lt;p>文末给出了《分布式系统设计模式》系列文章的目录，希望你能在这个列表里找到自己感兴趣的内容。&lt;/p>
&lt;ul>
&lt;li>弹力设计篇
&lt;ul>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/3912">认识故障和弹力设计&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/3917">隔离设计 Bulkheads&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/3926">异步通讯设计 Asynchronous&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/4050">幂等性设计 Idempotency&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/4086">服务的状态 State&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/4087">补偿事务 Compensating Transaction&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/4121">重试设计 Retry&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/4241">熔断设计 Circuit Breaker&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/4245">限流设计 Throttle&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/4252">降级设计 degradation&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/4253">弹力设计总结&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>管理设计篇
&lt;ul>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/5175">分布式锁 Distributed Lock&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/5819">配置中心 Configuration Management&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/5909">边车模式 Sidecar&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/5920">服务网格 Service Mesh&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/6086">网关模式 Gateway&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/6283">部署升级策略&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>性能设计篇
&lt;ul>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/6282">缓存 Cache&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/7036">异步处理 Asynchronous&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/7045">数据库扩展&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/7047">秒杀 Flash Sales&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/7086">边缘计算 Edge Computing&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/fc/e9/fcc761001867c60f526665e237f831e9.jpg" alt="">&lt;/p></description></item><item><title>极客专栏: 44丨弹力设计篇之“幂等性设计”</title><link>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E/44%E4%B8%A8%E5%BC%B9%E5%8A%9B%E8%AE%BE%E8%AE%A1%E7%AF%87%E4%B9%8B%E5%B9%82%E7%AD%89%E6%80%A7%E8%AE%BE%E8%AE%A1/</link><pubDate>Fri, 27 May 2022 00:00:00 +0000</pubDate><guid>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E/44%E4%B8%A8%E5%BC%B9%E5%8A%9B%E8%AE%BE%E8%AE%A1%E7%AF%87%E4%B9%8B%E5%B9%82%E7%AD%89%E6%80%A7%E8%AE%BE%E8%AE%A1/</guid><description>
&lt;p>所谓幂等性设计，就是说，一次和多次请求某一个资源应该具有同样的副作用。用数学的语言来表达就是：f(x) = f(f(x))。&lt;/p>
&lt;p>比如，求绝对值的函数，abs(x) = abs(abs(x))。&lt;/p>
&lt;p>为什么我们需要这样的操作？说白了，就是在我们把系统解耦隔离后，服务间的调用可能会有三个状态，一个是成功（Success），一个是失败（Failed），一个是超时（Timeout）。前两者都是明确的状态，而超时则是完全不知道是什么状态。&lt;/p>
&lt;p>比如，超时原因是网络传输丢包的问题，可能是请求时就没有请求到，也有可能是请求到了，返回结果时没有正常返回等等情况。于是我们完全不知道下游系统是否收到了请求，而收到了请求是否处理了，成功 / 失败的状态在返回时是否遇到了网络问题。总之，请求方完全不知道是怎么回事。&lt;/p>
&lt;p>举几个例子:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>订单创建接口，第一次调用超时了，然后调用方重试了一次。是否会多创建一笔订单？&lt;/p>
&lt;/li>
&lt;li>
&lt;p>订单创建时，我们需要去扣减库存，这时接口发生了超时，调用方重试了一次。是否会多扣一次库存？&lt;/p>
&lt;/li>
&lt;li>
&lt;p>当这笔订单开始支付，在支付请求发出之后，在服务端发生了扣钱操作，接口响应超时了，调用方重试了一次。是否会多扣一次钱？&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>因为系统超时，而调用户方重试一下，会给我们的系统带来不一致的副作用。&lt;/p>
&lt;p>在这种情况下，一般有两种处理方式。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>一种是需要下游系统提供相应的查询接口。上游系统在 timeout 后去查询一下。如果查到了，就表明已经做了，成功了就不用做了，失败了就走失败流程。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>另一种是通过幂等性的方式。也就是说，把这个查询操作交给下游系统，我上游系统只管重试，下游系统保证一次和多次的请求结果是一样的。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>对于第一种方式，需要对方提供一个查询接口来做配合。而第二种方式则需要下游的系统提供支持幂等性的交易接口。&lt;/p>
&lt;h1 id="全局-id">全局 ID&lt;/h1>
&lt;p>要做到幂等性的交易接口，需要有一个唯一的标识，来标志交易是同一笔交易。而这个交易 ID 由谁来分配是一件比较头疼的事。因为这个标识要能做到全局唯一。&lt;/p>
&lt;p>如果由一个中心系统来分配，那么每一次交易都需要找那个中心系统来。 这样增加了程序的性能开销。如果由上游系统来分配，则可能会出现 ID 分配重复的问题。因为上游系统可能会是一个集群，它们同时承担相同的工作。&lt;/p>
&lt;p>为了解决分配冲突的问题，我们需要使用一个不会冲突的算法，比如使用 UUID 这样冲突非常小的算法。但 UUID 的问题是，它的字符串占用的空间比较大，索引的效率非常低，生成的 ID 太过于随机，完全不是人读的，而且没有递增，如果要按前后顺序排序的话，基本不可能。&lt;/p>
&lt;p>在全局唯一 ID 的算法中，这里介绍一个 Twitter 的开源项目 Snowflake。它是一个分布式 ID 的生成算法。其核心思想是，产生一个 long 型的 ID，其中：&lt;/p>
&lt;ul>
&lt;li>41bits 作为毫秒数。大概可以用 69.7 年。&lt;/li>
&lt;li>10bits 作为机器编号（5bits 是数据中心，5bits 的机器 ID），支持 1024 个实例。&lt;/li>
&lt;li>12bits 作为毫秒内的序列号。一毫秒可以生成 4096 个序号。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/2b/28/2bda719052cb3b584c0db93e89d32528.png" alt="">&lt;/p>
&lt;p>其他的像 Redis 或 MongoDB 的全局 ID 生成都和这个算法大同小异。我在这里就不多说了。你可以根据实际情况加上业务的编号。&lt;/p>
&lt;h1 id="处理流程">处理流程&lt;/h1>
&lt;p>对于幂等性的处理流程来说，说白了就是要过滤一下已经收到的交易。要做到这个事，我们需要一个存储来记录收到的交易。&lt;/p>
&lt;p>于是，当收到交易请求的时候，我们就会到这个存储中去查询。如果查找到了，那么就不再做查询了，并把上次做的结果返回。如果没有查到，那么我们就记录下来。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/4c/1b/4c078da5bf5833cebc08a57bfb332b1b.png" alt="">&lt;/p>
&lt;p>但是，上面这个流程有个问题。因为绝大多数请求应该都不会是重新发过来的，所以让 100% 的请求都到这个存储里去查一下，这会导致处理流程变得很慢。&lt;/p>
&lt;p>所以，最好是当这个存储出现冲突的时候会报错。也就是说，我们收到交易请求后，直接去存储里记录这个 ID（相对于数据的 Insert 操作），如果出现 ID 冲突了的异常，那么我们就知道这个之前已经有人发过来了，所以就不用再做了。比如，数据库中你可以使用 &lt;code>insert into ... values ... on DUPLICATE KEY UPDATE ...&lt;/code> 这样的操作。&lt;/p>
&lt;p>对于更新的场景来说，如果只是状态更新，可以使用如下的方式。如果出错，要么是非法操作，要么是已被更新，要么是状态不对，总之多次调用是不会有副作用的。&lt;/p>
&lt;p>&lt;code>update table set status = &amp;quot;paid&amp;quot; where id = xxx and status = &amp;quot;unpaid&amp;quot;;&lt;/code>&lt;/p>
&lt;p>当然，网上还有 MVCC 通过使用版本号等其他方式，我觉得这些都不标准，我们希望我们有一个标准的方式来做这个事，所以，最好还是用一个 ID。&lt;/p>
&lt;p>因为我们的幂等性服务也是分布式的，所以，需要这个存储也是共享的。这样每个服务就变成没有状态的了。但是，这个存储就成了一个非常关键的依赖，其扩展性和可用性也成了非常关键的指标。&lt;/p>
&lt;p>你可以使用关系型数据库，或是 key-value 的 NoSQL（如 MongoDB）来构建这个存储系统。&lt;/p>
&lt;h1 id="http-的幂等性">HTTP 的幂等性&lt;/h1>
&lt;p>&lt;strong>HTTP GET 方法用于获取资源，不应有副作用，所以是幂等的&lt;/strong> 。比如：GET &lt;code>http://www.bank.com/account/123456&lt;/code>，不会改变资源的状态，不论调用一次还是 N 次都没有副作用。请注意，这里强调的是一次和 N 次具有相同的副作用，而不是每次 GET 的结果相同。GET &lt;code>http://www.news.com/latest-news&lt;/code>这个 HTTP 请求可能会每次得到不同的结果，但它本身并没有产生任何副作用，因而是满足幂等性的。&lt;/p>
&lt;p>&lt;strong>HTTP HEAD 和 GET 本质是一样的，区别在于 HEAD 不含有呈现数据，而仅仅是 HTTP 头信息，不应用有副作用，也是幂等的&lt;/strong>。有的人可能觉得这个方法没什么用，其实不是这样的。想象一个业务情景：欲判断某个资源是否存在，我们通常使用 GET，但这里用 HEAD 则意义更加明确。也就是说，HEAD 方法可以用来做探活使用。&lt;/p>
&lt;p>&lt;strong>HTTP OPTIONS 主要用于获取当前 URL 所支持的方法，所以也是幂等的&lt;/strong>。若请求成功，则它会在 HTTP 头中包含一个名为&amp;quot;Allow&amp;quot;的头，值是所支持的方法，如&amp;quot;GET, POST&amp;quot;。&lt;/p>
&lt;p>&lt;strong>HTTP DELETE 方法用于删除资源，有副作用，但它应该满足幂等性&lt;/strong> 。比如：DELETE &lt;code>http://www.forum.com/article/4231&lt;/code>，调用一次和 N 次对系统产生的副作用是相同的，即删掉 ID 为 4231 的帖子。因此，调用者可以多次调用或刷新页面而不必担心引起错误。&lt;/p>
&lt;p>&lt;strong>HTTP POST 方法用于创建资源，所对应的 URI 并非创建的资源本身，而是去执行创建动作的操作者，有副作用，不满足幂等性&lt;/strong> 。比如：POST &lt;code>http://www.forum.com/articles&lt;/code>的语义是在&lt;code>http://www.forum.com/articles&lt;/code>下创建一篇帖子，HTTP 响应中应包含帖子的创建状态以及帖子的 URI。两次相同的 POST 请求会在服务器端创建两份资源，它们具有不同的 URI；所以，POST 方法不具备幂等性。&lt;/p>
&lt;p>&lt;strong>HTTP PUT 方法用于创建或更新操作，所对应的 URI 是要创建或更新的资源本身，有副作用，它应该满足幂等性&lt;/strong> 。比如：PUT &lt;code>http://www.forum/articles/4231&lt;/code>的语义是创建或更新 ID 为 4231 的帖子。对同一 URI 进行多次 PUT 的副作用和一次 PUT 是相同的；因此，PUT 方法具有幂等性。&lt;/p>
&lt;p>所以，对于 POST 的方式，很可能会出现多次提交的问题，就好比，我们在论坛中发贴时，有时候因为网络有问题，可能会对同一篇贴子出现多次提交的情况。对此的一般的幂等性的设计如下。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>首先，在表单中需要隐藏一个 token，这个 token 可以是前端生成的一个唯一的 ID。用于防止用户多次点击了表单提交按钮，而导致后端收到了多次请求，却不能分辨是否是重复的提交。这个 token 是表单的唯一标识。（这种情况其实是通过前端生成 ID 把 POST 变成了 PUT。）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>然后，当用户点击提交后，后端会把用户提示的数据和这个 token 保存在数据库中。如果有重复提交，那么数据库中的 token 会做排它限制，从而做到幂等性。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>当然，更为稳妥的做法是，后端成功后向前端返回 302 跳转，把用户的前端页跳转到 GET 请求，把刚刚 POST 的数据给展示出来。如果是 Web 上的最好还把之前的表单设置成过期，这样用户不能通过浏览器后退按钮来重新提交。这个模式又叫做 &lt;a href="https://en.wikipedia.org/wiki/Post/Redirect/Get">PRG 模式&lt;/a>（Post/Redirect/Get）。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h1 id="小结">小结&lt;/h1>
&lt;p>好了，我们来总结一下今天分享的主要内容。首先，幂等性的含义是，一个调用被发送多次所产生的副作用和被发送一次所产生的副作用是一样的。而服务调用有三种结果：成功、失败和超时，其中超时是我们需要解决的问题。&lt;/p>
&lt;p>解决手段可以是超时后查询调用结果，也可以是在被调用的服务中实现幂等性。为了在分布式系统中实现幂等性，我们需要实现全局 ID。Twitter 的 Snowflake 就是一个比较好用的全局 ID 实现。最后，我给出了幂等性接口的处理流程。&lt;/p>
&lt;p>下篇文章中，我们讲述服务的状态。希望对你有帮助。&lt;/p>
&lt;p>也欢迎你分享一下你的分布式服务中所有交易接口是否都实现了幂等性？你所使用的全局 ID 算法又是什么呢？&lt;/p>
&lt;p>文末给出了《分布式系统设计模式》系列文章的目录，希望你能在这个列表里找到自己感兴趣的内容。&lt;/p>
&lt;ul>
&lt;li>弹力设计篇
&lt;ul>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/3912">认识故障和弹力设计&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/3917">隔离设计 Bulkheads&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/3926">异步通讯设计 Asynchronous&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/4050">幂等性设计 Idempotency&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/4086">服务的状态 State&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/4087">补偿事务 Compensating Transaction&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/4121">重试设计 Retry&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/4241">熔断设计 Circuit Breaker&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/4245">限流设计 Throttle&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/4252">降级设计 degradation&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/4253">弹力设计总结&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>管理设计篇
&lt;ul>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/5175">分布式锁 Distributed Lock&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/5819">配置中心 Configuration Management&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/5909">边车模式 Sidecar&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/5920">服务网格 Service Mesh&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/6086">网关模式 Gateway&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/6283">部署升级策略&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>性能设计篇
&lt;ul>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/6282">缓存 Cache&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/7036">异步处理 Asynchronous&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/7045">数据库扩展&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/7047">秒杀 Flash Sales&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/7086">边缘计算 Edge Computing&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/fc/e9/fcc761001867c60f526665e237f831e9.jpg" alt="">&lt;/p></description></item><item><title>极客专栏: 45丨弹力设计篇之“服务的状态”</title><link>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E/45%E4%B8%A8%E5%BC%B9%E5%8A%9B%E8%AE%BE%E8%AE%A1%E7%AF%87%E4%B9%8B%E6%9C%8D%E5%8A%A1%E7%9A%84%E7%8A%B6%E6%80%81/</link><pubDate>Fri, 27 May 2022 00:00:00 +0000</pubDate><guid>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E/45%E4%B8%A8%E5%BC%B9%E5%8A%9B%E8%AE%BE%E8%AE%A1%E7%AF%87%E4%B9%8B%E6%9C%8D%E5%8A%A1%E7%9A%84%E7%8A%B6%E6%80%81/</guid><description>
&lt;p>之前在我们讲的幂等设计中，为了过滤掉已经处理过的请求，其中需要保存处理过的状态，为了把服务做成无状态的，我们引入了第三方的存储。而这一篇中，我们来聊聊服务的状态这个话题。我认为，只有清楚地了解了状态这个事，我们才有可能设计出更好或是更有弹力的系统架构。&lt;/p>
&lt;p>所谓&amp;quot;状态&amp;quot;，就是为了保留程序的一些数据或是上下文。比如之前幂等性设计中所说的需要保留每一次请求的状态，或是像用户登录时的 Session，我们需要这个 Session 来判断这个请求的合法性，还有一个业务流程中需要让多个服务组合起来形成一个业务逻辑的运行上下文 Context。这些都是所谓的状态。&lt;/p>
&lt;p>我们的代码中基本上到处都是这样的状态。&lt;/p>
&lt;h1 id="无状态的服务-stateless">无状态的服务 Stateless&lt;/h1>
&lt;p>一直以来，无状态的服务都被当作分布式服务设计的最佳实践和铁律。因为无状态的服务对于扩展性和运维实在是太方便了。没有状态的服务，可以随意地增加和减少结点，同样可以随意地搬迁。而且，无状态的服务可以大幅度降低代码的复杂度以及 Bug 数，因为没有状态，所以也没有明显的&amp;quot;副作用&amp;quot;。&lt;/p>
&lt;p>基本上来说，无状态的服务和&amp;quot;函数式编程&amp;quot;的思维方式如出一辙。在函数式编程中，一个铁律是，函数是无状态的。换句话说，函数是 immutable 不变的，所有的函数只描述其逻辑和算法，根本不保存数据，也不会修改输入的数据，而是把计算好的结果返回出去，哪怕要把输入的数据重新拷贝一份并只做少量的修改（关于函数式编程可以参看我在 CoolShell 上的文章《&lt;a href="https://coolshell.cn/articles/10822.html">函数式编程&lt;/a>》）。&lt;/p>
&lt;p>但是，现实世界是一定会有状态的。这些状态可能表现在如下的几个方面。&lt;/p>
&lt;ul>
&lt;li>程序调用的结果。&lt;/li>
&lt;li>服务组合下的上下文。&lt;/li>
&lt;li>服务的配置。&lt;/li>
&lt;/ul>
&lt;p>为了做出无状态的服务，我们通常需要把状态保存到其他的地方。比如，不太重要的数据可以放到 Redis 中，重要的数据可以放到 MySQL 中，或是像 ZooKeeper/Etcd 这样的高可用的强一致性的存储中，或是分布式文件系统中。&lt;/p>
&lt;p>于是，我们为了做成无状态的服务，会导致这些服务需要耦合第三方有状态的存储服务。一方面是有依赖，另一方面也增加了网络开销，导致服务的响应时间也会变慢。&lt;/p>
&lt;p>所以，第三方的这些存储服务也必须要做成高可用高扩展的方式。而且，为了减少网络开销，还需要在无状态的服务中增加缓存机制。然而，下次这个用户的请求并不一定会在同一台机器，所以，这个缓存会在所有的机器上都创建，也算是一种浪费吧。&lt;/p>
&lt;p>这种&amp;quot;转移责任&amp;quot;的玩法也催生出了对分布式存储的强烈需求。正如之前在《分布式系统架构的本质》系列文章中谈到的关键技术之一的&amp;quot;&lt;a href="https://time.geekbang.org/column/article/1609">状态 / 数据调度&lt;/a>&amp;ldquo;所说的，因为数据层的 scheme 众多，所以，很难做出一个放之四海皆准的分布式存储系统。&lt;/p>
&lt;p>这也是为什么无状态的服务需要依赖于像 ZooKeeper/Etcd 这样的高可用的有强一致的服务，或是依赖于底层的分布式文件系统（像开源的 Ceph 和 GlusterFS）。而现在分布式数据库也开始将服务和存储分离，也是为了让自己的系统更有弹力。&lt;/p>
&lt;h1 id="有状态的服务-stateful">有状态的服务 Stateful&lt;/h1>
&lt;p>在今天看来，有状态的服务在今天看上去的确比较&amp;quot;反动&amp;rdquo;，但是，我们也需要比较一下它和无状态服务的优劣。&lt;/p>
&lt;p>正如上面所说的，无状态服务在程序 Bug 上和水平扩展上有非常优秀的表现，但是其需要把状态存放在一个第三方存储上，增加了网络开销，而在服务内的缓存需要在所有的服务实例上都有（因为每次请求不会都落在同一个服务实例上），这是比较浪费资源的。&lt;/p>
&lt;p>而有状态的服务有这些好处。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>数据本地化（Data Locality）&lt;/strong>。一方面状态和数据是本机保存，这方面不但有更低的延时，而且对于数据密集型的应用来说，这会更快。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>更高的可用性和更强的一致性&lt;/strong>。也就是 CAP 原理中的 A 和 C。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>为什么会这样呢？因为对于有状态的服务，我们需要对于客户端传来的请求，都必需保证其落在同一个实例上，这叫 Sticky Session 或是 Sticky Connection。这样一来，我们完全不需要考虑数据要被加载到不同的结点上去，而且这样的模型更容易理解和实现。&lt;/p>
&lt;p>可见，最重要的区别就是，无状态的服务需要我们把数据同步到不同的结点上，而有状态的服务通过 Sticky Session 做数据分片（当然，同步有同步的问题，分片也有分片的问题，这两者没有谁比谁好，都有 trade-off）。&lt;/p>
&lt;p>这种 Sticky Session 是怎么实现的呢？&lt;/p>
&lt;p>最简单的实现就是用持久化的长连接。就算是 HTTP 协议也要用长连接。或是通过一个简单的哈希（hash）算法，比如，通过 uid 求模的方式，走一致性哈希的玩法，也可以方便地做水平扩展。&lt;/p>
&lt;p>然而，这种方式也会带来问题，那就是，结点的负载和数据并不会很均匀。尤其是长连接的方式，连上了就不断了。所以，玩长连接的玩法一般都会有一种叫&amp;quot;反向压力 (Back Pressure)&amp;quot;。也就是说，如果服务端成为了热点，那么就主动断连接，这种玩法也比较危险，需要客户端的配合，否则容易出 Bug。&lt;/p>
&lt;p>如果要做到负载和数据均匀的话，我们需要有一个元数据索引来映射后端服务实例和请求的对应关键，还需要一个路由结点，这个路由结点会根据元数据索引来路由，而这个元数据索引表会根据后端服务的压力来重新组织相关的映射。&lt;/p>
&lt;p>当然，我们可以把这个路由结点给去掉，让有状态的服务直接路由。要做到这点，一般来说，有两种方式。一种是直接使用配置，在节点启动时把其元数据读到内存中，但是这样一来增加或减少结点都需要更新这个配置，会导致其它结点也一同要重新读入。&lt;/p>
&lt;p>另一种比较好的做法是使用到 Gossip 协议，通过这个协议在各个节点之间互相散播消息来同步元数据，这样新增或减少结点，集群内部可以很容易重新分配（听起来要实现好真的好复杂）。&lt;/p>
&lt;p>在有状态的服务上做自动化伸缩的是有一些相关的真实案例的。比如，Facebook 的 Scuba，这是一个分布式的内存数据库，它使用了静态的方式，也就是上面的第一种方式。Uber 的 Ringpop 是一个开源的 Node.js 的根据地理位置分片的路由请求的库（开源地址为：&lt;a href="https://github.com/uber-node/ringpop-node">https://github.com/uber-node/ringpop-node&lt;/a> ）。&lt;/p>
&lt;p>还有微软的 Orleans，Halo 4 就是基于其开发的，其使用了 Gossip 协议，一致性哈希和 DHT 技术相结合的方式。用户通过其 ID 的一致性哈希算法映射到一个节点上，而这个节点保存了这个用户对应的 DHT，再通过 DHT 定位到处理用户请求的位置，这个项目也是开源的（开源地址为： &lt;a href="https://github.com/dotnet/orleans">https://github.com/dotnet/orleans&lt;/a> ）。&lt;/p>
&lt;p>关于可扩展的有状态服务，这里强烈推荐 Twitter 的美女工程师 Caitie McCaffrey 的演讲 Youtube 视频《Building Scalable Stateful Service》(演讲 PPT)，其文字版是在 High Scalability 上的这篇文章《Making the Case for Building Scalable Stateful Services in the Modern Era》&lt;/p>
&lt;h1 id="服务状态的容错设计">服务状态的容错设计&lt;/h1>
&lt;p>在容错设计中，服务状态是一件非常复杂的事。尤其对于运维来说，因为你要调度服务就需要调度服务的状态，迁移服务的状态就需要迁移服务的数据。在数据量比较大的情况下，这一点就变得更为困难了。&lt;/p>
&lt;p>虽然上述有状态的服务的调度通过 Sticky Session 的方式是一种方式，但我依然觉得理论上来说虽然可以这么干，这实际在运维的过程中，这么干还是件挺麻烦的事儿，不是很好的玩法。&lt;/p>
&lt;p>很多系统的高可用的设计都会采取数据在运行时就复制的方案，比如：ZooKeeper、Kafka、Redis 或是 ElasticSearch 等等。在运行时进行数据复制就需要考虑一致性的问题，所以，强一致性的系统一般会使用两阶段提交。&lt;/p>
&lt;p>这要求所有的结点都需要有一致的结果，这是 CAP 里的 CA 系统。而也有的系统采用的是大多数人一致就可以了，比如 Paxos 算法，这是 CP 系统。&lt;/p>
&lt;p>但我们需要知道，即使是这样，当一个结点挂掉了以后，在另外一个地方重新恢复这个结点时，这个结点需要把数据同步过来才能提供服务。然而，如果数据量过大，这个过程可能会很漫长，这也会影响我们系统的可用性。&lt;/p>
&lt;p>所以，我们需要使用底层的分布式文件系统，对于有状态的数据不但在运行时进行多结点间的复制，同时为了避免挂掉，还需要把数据持久化在硬盘上，这个硬盘可以是挂载到本地硬盘的一个外部分布式的文件卷。&lt;/p>
&lt;p>这样当结点挂掉以后，以另外一个宿主机上启动一个新的服务实例时，这个服务可以从远程把之前的文件系统挂载过来。然后，在启动的过程中就装载好了大多数的数据，从而可以从网络其它结点上同步少量的数据，因而可以快速地恢复和提供服务。&lt;/p>
&lt;p>这一点，对于有状态的服务来说非常关键。所以，使用一个分布式文件系统是调度有状态服务的关键。&lt;/p>
&lt;h1 id="小结">小结&lt;/h1>
&lt;p>好了，我们来总结一下今天分享的主要内容。首先，我讲了无状态的服务。无状态的服务就像一个函数一样，对于给定的输入，它会给出唯一确定的输出。它的好处是很容易运维和伸缩，但需要底层有分布式的数据库支持。&lt;/p>
&lt;p>接着，我讲了有状态的服务，它们通过 Sticky Session、一致性 Hash 和 DHT 等技术实现状态和请求的关联，并将数据同步到分布式数据库中；利用分布式文件系统，还能在节点挂掉时快速启动新实例。下篇文章中，我们讲述补偿事务。希望对你有帮助。&lt;/p>
&lt;p>也欢迎你分享一下你所实现的分布式服务是无状态的，还是有状态的？用到了哪些技术？&lt;/p>
&lt;p>文末给出了《分布式系统设计模式》系列文章的目录，希望你能在这个列表里找到自己感兴趣的内容。&lt;/p>
&lt;ul>
&lt;li>弹力设计篇
&lt;ul>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/3912">认识故障和弹力设计&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/3917">隔离设计 Bulkheads&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/3926">异步通讯设计 Asynchronous&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/4050">幂等性设计 Idempotency&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/4086">服务的状态 State&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/4087">补偿事务 Compensating Transaction&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/4121">重试设计 Retry&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/4241">熔断设计 Circuit Breaker&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/4245">限流设计 Throttle&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/4252">降级设计 degradation&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/4253">弹力设计总结&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>管理设计篇
&lt;ul>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/5175">分布式锁 Distributed Lock&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/5819">配置中心 Configuration Management&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/5909">边车模式 Sidecar&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/5920">服务网格 Service Mesh&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/6086">网关模式 Gateway&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/6283">部署升级策略&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>性能设计篇
&lt;ul>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/6282">缓存 Cache&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/7036">异步处理 Asynchronous&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/7045">数据库扩展&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/7047">秒杀 Flash Sales&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/7086">边缘计算 Edge Computing&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/fc/e9/fcc761001867c60f526665e237f831e9.jpg" alt="">&lt;/p></description></item><item><title>极客专栏: 46丨弹力设计篇之“补偿事务”</title><link>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E/46%E4%B8%A8%E5%BC%B9%E5%8A%9B%E8%AE%BE%E8%AE%A1%E7%AF%87%E4%B9%8B%E8%A1%A5%E5%81%BF%E4%BA%8B%E5%8A%A1/</link><pubDate>Fri, 27 May 2022 00:00:00 +0000</pubDate><guid>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E/46%E4%B8%A8%E5%BC%B9%E5%8A%9B%E8%AE%BE%E8%AE%A1%E7%AF%87%E4%B9%8B%E8%A1%A5%E5%81%BF%E4%BA%8B%E5%8A%A1/</guid><description>
&lt;p>前面，我们说过，分布式系统有一个比较明显的问题就是，一个业务流程需要组合一组服务。这样的事情在微服务下就更为明显了，因为这需要业务上一致性的保证。也就是说，如果一个步骤失败了，那么要么回滚到以前的服务调用，要么不断重试保证所有的步骤都成功。&lt;/p>
&lt;p>这里，如果需要强一致性，那在业务层上就需要使用&amp;quot;两阶段提交&amp;quot;这样的方式。但是好在我们的很多情况下并不需要这么强的一致性，而且强一致性的最佳保证基本都是在底层完成的，或是像之前说的那样 Stateful 的 Sticky Session 那样在一台机器上完成。在我们接触到的大多数业务中，其实只需要最终一致性就够了。&lt;/p>
&lt;h1 id="acid-和-base">ACID 和 BASE&lt;/h1>
&lt;p>谈到这里，有必要先说一下 ACID 和 BASE 的差别。传统关系型数据库系统的事务都有 ACID 属性，即原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation，又称独立性）、持久性（Durability）。下面我逐一做下解释：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>原子性&lt;/strong>：整个事务中的所有操作，要么全部完成，要么全部失败，不可能停滞在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>一致性&lt;/strong>：在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>隔离性&lt;/strong>：两个事务的执行是互不干扰的，一个事务不可能看到其他事务运行时中间某一时刻的数据。两个事务不会发生交互。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>持久性&lt;/strong>：在事务完成以后，该事务对数据库所做的更改便持久地保存在数据库之中，并不会被回滚。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>事务的 ACID 属性保证了数据库的一致性，比如银行系统中，转账就是一个事务，从原账户扣除金额，以及向目标账户添加金额，这两个数据库操作的总和构成一个完整的逻辑过程，是不可拆分的原子操作，从而保证了整个系统中的总金额没有变化。&lt;/p>
&lt;p>然而，这对于我们的分布式系统来说，尤其是微服务来说，这样的方式是很难满足高性能要求的。我们都很熟悉 CAP 理论&amp;mdash;&amp;mdash;在分布式的服务架构中，一致性（Consistency）、可用性（Availability）、分区容忍性（Partition Tolerance），在现实中不能都满足，最多只能满足其中两个。&lt;/p>
&lt;p>所以，为了提高性能，出现了 ACID 的一个变种 BASE。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>Basic Availability&lt;/strong>：基本可用。这意味着，系统可以出现暂时不可用的状态，而后面会快速恢复。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Soft-state&lt;/strong>：软状态。它是我们前面的&amp;quot;有状态&amp;quot;和&amp;quot;无状态&amp;quot;的服务的一种中间状态。也就是说，为了提高性能，我们可以让服务暂时保存一些状态或数据，这些状态和数据不是强一致性的。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Eventual Consistency&lt;/strong>：最终一致性，系统在一个短暂的时间段内是不一致的，但最终整个系统看到的数据是一致的。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>可以看到，BASE 系统是允许或是容忍系统出现暂时性问题的，这样一来，我们的系统就能更有弹力。因为我们知道，在分布式系统的世界里，故障是不可避免的，我们能做的就是把故障处理当成功能写入代码中，这就是 Design for Failure。&lt;/p>
&lt;p>BASE 的系统倾向于设计出更加有弹力的的系统，这种系统的设计特点是，要保证在短时间内，就算是有数据不同步的风险，我们也应该允许新的交易可以发生，而后面我们在业务上将可能出现问题的事务给处理掉，以保证最终的一致性。&lt;/p>
&lt;p>举个例子，网上卖书的场景。&lt;/p>
&lt;p>ACID 的玩法就是，大家在买同一本书的过程中，每个用户的购买请求都需要把库存锁住，等减完库存后，把锁释放出来，后续的人才能进行购买。于是，在 ACID 的玩法下，我们在同一时间不可能有多个用户下单，我们的订单流程需要有排队的情况，这样一来，我们就不可能做出性能比较高的系统来。&lt;/p>
&lt;p>BASE 的玩法是，大家都可以同时下单，这个时候不需要去真正地分配库存，然后系统异步地处理订单，而且是批量的处理。因为下单的时候没有真正去扣减库存，所以，有可能会有超卖的情况。而后台的系统会异步地处理订单时，发现库存没有了，于是才会告诉用户你没有购买成功。&lt;/p>
&lt;p>BASE 这种玩法，其实就是亚马逊的玩法，因为要根据用户的地址去不同的仓库查看库存，这个操作非常耗时，所以，不想做成异步的都不行。&lt;/p>
&lt;p>在亚马逊上买东西，你会收到一封邮件说，系统收到你的订单了，然后过一会儿你会收到你的订单被确认的邮件，这时候才是真正地分配了库存。所以，有某些时候，你会遇到你先收到了下单的邮件，过一会又收到了没有库存的致歉的邮件。&lt;/p>
&lt;p>有趣的是，ACID 的意思是酸，而 BASE 却是碱的意思，因此这是一个对立的东西。其实，从本质上来讲，酸（ACID）强调的是一致性（CAP 中的 C），而碱（BASE）强调的是可用性（CAP 中的 A）。&lt;/p>
&lt;h1 id="业务补偿">业务补偿&lt;/h1>
&lt;p>有了上面对 ACID 和 BASE 的分析，我们知道，在很多情况下，我们是无法做到强一致的 ACID 的。特别是我们需要跨多个系统的时候，而且这些系统还不是由一个公司所提供的。比如，在我们的日常生活中，我们经常会遇到这样的情况，就是要找很多方协调很多事，而且要保证我们每一件事都成功，否则整件事就做不到。&lt;/p>
&lt;p>比如，要出门旅游， 我们需要干这么几件事。第一，向公司请假，拿到相应的假期；第二，订飞机票或是火车票；第三，订酒店；第四，租车。这四件事中，前三件必需完全成功，我们才能出行，而第四件事只是一个锦上添花的事，但第四件事一旦确定，那么也会成为整个事务的一部分。这些事都是要向不同的组织或系统请求。我们可以并行地做这些事，而如果某个事有变化，其它的事都会跟着出现一些变化。&lt;/p>
&lt;p>设想下面的几种情况。&lt;/p>
&lt;ol>
&lt;li>
&lt;p>我没有订到返程机票，那么我就去不了了。我需要把订到的去程机票，酒店、租到的车都给取消了，并且把请的假也取消了。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>如果我假也请好了，机票，酒店也订好了，只是车没租到，那么并不影响我出行这个事，整个事还是可以继续的。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>如果我的飞机因为天气原因取消或是晚点了，那么我被迫要去调整和修改我的酒店预订和租车的预订。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>从人类的实际生活当中，我们可以看出，上述的这些情况都是天天在发生的事情。所以，我们的分布式系统也是一样的，也是需要处理这样的事情&amp;mdash;&amp;mdash;就是当条件不满足，或是有变化的时候，需要从业务上做相应的整体事务的补偿。&lt;/p>
&lt;p>一般来说，业务的事务补偿都是需要一个工作流引擎的。亚马逊是一个超级喜欢工作流引擎的公司，这个工作流引擎把各式各样的服务给串联在一起，并在工作流上做相应的业务补偿，整个过程设计成为最终一致性的。&lt;/p>
&lt;p>对于业务补偿来说，首先需要将服务做成幂等性的，如果一个事务失败了或是超时了，我们需要不断地重试，努力地达到最终我们想要的状态。然后，如果我们不能达到这个我们想要的状态，我们需要把整个状态恢复到之前的状态。另外，如果有变化的请求，我们需要启动整个事务的业务更新机制。&lt;/p>
&lt;p>所以，一个好的业务补偿机制需要做到下面这几点。&lt;/p>
&lt;ol>
&lt;li>
&lt;p>要能清楚地描述出要达到什么样的状态（比如：请假、机票、酒店这三个都必须成功，租车是可选的），以及如果其中的条件不满足，那么，我们要回退到哪一个状态。这就是所谓的整个业务的起始状态定义。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>当整条业务跑起来的时候，我们可以串行或并行地做这些事。对于旅游订票是可以并行的，但是对于网购流程（下单、支付、送货）是不能并行的。总之，我们的系统需要努力地通过一系列的操作达到一个我们想要的状态。如果达不到，就需要通过补偿机制回滚到之前的状态。&lt;strong>这就是所谓的状态拟合&lt;/strong>。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>对于已经完成的事务进行整体修改，可以考虑成一个修改事务。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>其实，在纯技术的世界里也有这样的事。比如，线上运维系统需要发布一个新的服务或是对一个已有的服务进行水平扩展，我们需要先找到相应的机器，然后初始化环境，再部署上应用，再做相应的健康检查，最后接入流量。这一系列的动作都要完全成功，所以，我们的部署系统就需要管理好整个过程和相关的运行状态。&lt;/p>
&lt;h1 id="业务补偿的设计重点">业务补偿的设计重点&lt;/h1>
&lt;p>业务补偿主要做两件事。&lt;/p>
&lt;ol>
&lt;li>努力地把一个业务流程执行完成。&lt;/li>
&lt;li>如果执行不下去，需要启动补偿机制，回滚业务流程。&lt;/li>
&lt;/ol>
&lt;p>所以，下面是几个重点。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>因为要把一个业务流程执行完成，需要这个流程中所涉及的服务方支持幂等性。并且在上游有重试机制。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>我们需要小心维护和监控整个过程的状态，所以，千万不要把这些状态放到不同的组件中，最好是一个业务流程的控制方来做这个事，也就是一个工作流引擎。所以，这个工作流引擎是需要高可用和稳定的。这就好像旅行代理机构一样，我们把需求告诉它，它会帮我们搞定所有的事。如果有问题，也会帮我们回滚和补偿的。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>补偿的业务逻辑和流程不一定非得是严格反向操作。有时候可以并行，有时候，可能会更简单。总之，设计业务正向流程的时候，也需要设计业务的反向补偿流程。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>我们要清楚地知道，业务补偿的业务逻辑是强业务相关的，很难做成通用的。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>下层的业务方最好提供短期的资源预留机制。就像电商中的把货品的库存预先占住等待用户在 15 分钟内支付。如果没有收到用户的支付，则释放库存。然后回滚到之前的下单操作，等待用户重新下单。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h1 id="小结">小结&lt;/h1>
&lt;p>好了，我们来总结一下今天分享的主要内容。首先，我介绍了 ACID 和 BASE 两种不同级别的一致性。在分布式系统中，ACID 有更强的一致性，但可伸缩性非常差，仅在必要时使用；BASE 的一致性较弱，但有很好的可伸缩性，还可以异步批量处理；大多数分布式事务适合 BASE。&lt;/p>
&lt;p>要实现 BASE 事务，需要实现补偿逻辑，因为事务可能失败，此时需要协调各方进行撤销。补偿的各个步骤可以根据具体业务来确定是串行还是并行。由于补偿事务是和业务强相关的，所以必须实现在业务逻辑里。下篇文章中，我们讲述重试设计。希望对你有帮助。&lt;/p>
&lt;p>也欢迎你分享一下你的分布式服务用到了怎样的一致性？你是怎么实现补偿事务的？&lt;/p>
&lt;p>文末给出了《分布式系统设计模式》系列文章的目录，希望你能在这个列表里找到自己感兴趣的内容。&lt;/p>
&lt;ul>
&lt;li>弹力设计篇
&lt;ul>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/3912">认识故障和弹力设计&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/3917">隔离设计 Bulkheads&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/3926">异步通讯设计 Asynchronous&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/4050">幂等性设计 Idempotency&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/4086">服务的状态 State&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/4087">补偿事务 Compensating Transaction&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/4121">重试设计 Retry&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/4241">熔断设计 Circuit Breaker&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/4245">限流设计 Throttle&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/4252">降级设计 degradation&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/4253">弹力设计总结&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>管理设计篇
&lt;ul>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/5175">分布式锁 Distributed Lock&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/5819">配置中心 Configuration Management&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/5909">边车模式 Sidecar&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/5920">服务网格 Service Mesh&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/6086">网关模式 Gateway&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/6283">部署升级策略&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>性能设计篇
&lt;ul>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/6282">缓存 Cache&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/7036">异步处理 Asynchronous&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/7045">数据库扩展&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/7047">秒杀 Flash Sales&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/7086">边缘计算 Edge Computing&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/fc/e9/fcc761001867c60f526665e237f831e9.jpg" alt="">&lt;/p></description></item><item><title>极客专栏: 47丨弹力设计篇之“重试设计”</title><link>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E/47%E4%B8%A8%E5%BC%B9%E5%8A%9B%E8%AE%BE%E8%AE%A1%E7%AF%87%E4%B9%8B%E9%87%8D%E8%AF%95%E8%AE%BE%E8%AE%A1/</link><pubDate>Fri, 27 May 2022 00:00:00 +0000</pubDate><guid>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E/47%E4%B8%A8%E5%BC%B9%E5%8A%9B%E8%AE%BE%E8%AE%A1%E7%AF%87%E4%B9%8B%E9%87%8D%E8%AF%95%E8%AE%BE%E8%AE%A1/</guid><description>
&lt;p>关于重试，这个模式应该是一个很普遍的设计模式了。当我们把单体应用服务化，尤其是微服务化，本来在一个进程内的函数调用就成了远程调用，这样就会涉及到网络上的问题。&lt;/p>
&lt;p>网络上有很多的各式各样的组件，如：DNS 服务、网卡、交换机、路由器、负载均衡等设备，这些设备都不一定是稳定的，在数据传输的整个过程中，只要一个环节出了问题，那么都会导致问题。&lt;/p>
&lt;h1 id="重试的场景">重试的场景&lt;/h1>
&lt;p>所以，我们需要一个重试的机制。但是，我们需要明白的是，&lt;strong>&amp;ldquo;重试&amp;quot;的语义是我们认为这个故障是暂时的，而不是永久的，所以，我们会去重试&lt;/strong>。&lt;/p>
&lt;p>我认为，设计重试时，我们需要定义出什么情况下需要重试，例如，调用超时、被调用端返回了某种可以重试的错误（如繁忙中、流控中、维护中、资源不足等）。&lt;/p>
&lt;p>而对于一些别的错误，则最好不要重试，比如：业务级的错误（如没有权限、或是非法数据等错误），技术上的错误（如：HTTP 的 503 等，这种原因可能是触发了代码的 bug，重试下去没有意义）。&lt;/p>
&lt;h1 id="重试的策略">重试的策略&lt;/h1>
&lt;p>关于重试的设计，一般来说，都需要有个重试的最大值，经过一段时间不断的重试后，就没有必要再重试了，应该报故障了。在重试过程中，每一次重试失败时都应该休息一会儿再重试，这样可以避免因为重试过快而导致网络上的负担加重。&lt;/p>
&lt;p>在重试的设计中，我们一般都会引入，Exponential Backoff 的策略，也就是所谓的 &amp;quot; 指数级退避 &amp;ldquo;。在这种情况下，每一次重试所需要的休息时间都会成倍增加。这种机制主要是用来让被调用方能够有更多的时间来从容处理我们的请求。这其实和 TCP 的拥塞控制有点像。&lt;/p>
&lt;p>如果我们写成代码应该是下面这个样子。&lt;/p>
&lt;p>首先，我们定义一个调用返回的枚举类型，其中包括了 5 种返回错误&amp;mdash;&amp;mdash;成功 SUCCESS、维护中 NOT_READY、流控中 TOO_BUSY、没有资源 NO_RESOURCE、系统错误 SERVER_ERROR。&lt;/p>
&lt;pre>&lt;code>public enum Results {
SUCCESS,
NOT_READY,
TOO_BUSY,
NO_RESOURCE,
SERVER_ERROR
}
&lt;/code>&lt;/pre>
&lt;p>接下来，我们定义一个 Exponential Backoff 的函数，其返回 2 的指数。这样，每多一次重试就需要多等一段时间。如：第一次等 200ms，第二次要 400ms，第三次要等 800ms&amp;hellip;&amp;hellip;&lt;/p>
&lt;pre>&lt;code>public static long getWaitTimeExp(int retryCount) {
long waitTime = ((long) Math.pow(2, retryCount) );
return waitTime;
}
&lt;/code>&lt;/pre>
&lt;p>下面是真正的重试逻辑。我们可以看到，在成功的情况下，以及不属于我们定义的错误下，我们是不需要重试的，而两次重试间需要等的时间是以指数上升的。&lt;/p>
&lt;pre>&lt;code>public static void doOperationAndWaitForResult() {
// Do some asynchronous operation.
long token = asyncOperation();
int retries = 0;
boolean retry = false;
do {
// Get the result of the asynchronous operation.
Results result = getAsyncOperationResult(token);
if (Results.SUCCESS == result) {
retry = false;
} else if ( (Results.NOT_READY == result) ||
(Results.TOO_BUSY == result) ||
(Results.NO_RESOURCE == result) ||
(Results.SERVER_ERROR == result) ) {
retry = true;
} else {
retry = false;
}
if (retry) {
long waitTime = Math.min(getWaitTimeExp(retries), MAX_WAIT_INTERVAL);
// Wait for the next Retry.
Thread.sleep(waitTime);
}
} while (retry &amp;amp;&amp;amp; (retries++ &amp;lt; MAX_RETRIES));
}
&lt;/code>&lt;/pre>
&lt;p>上面的代码是非常基本的重试代码，没有什么新鲜的，我们来看看 Spring 中所支持的一些重试策略。&lt;/p>
&lt;h1 id="spring-的重试策略">Spring 的重试策略&lt;/h1>
&lt;p>&lt;a href="https://github.com/spring-projects/spring-retry">Spring Retry&lt;/a> 是一个单独实现重试功能的项目，我们可以通过 Annotation 的方式使用。具体如下。&lt;/p>
&lt;pre>&lt;code>@Service
public interface MyService {
@Retryable(
value = { SQLException.class },
maxAttempts = 2,
backoff = @Backoff(delay = 5000))
void retryService(String sql) throws SQLException;
...
}
&lt;/code>&lt;/pre>
&lt;p>配置 @Retryable 注解，只对 SQLException 的异常进行重试，重试两次，每次延时 5000ms。相关的细节可以看相应的文档。我在这里，只想让你看一下 Spring 有哪些重试的策略。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>NeverRetryPolicy：只允许调用 RetryCallback 一次，不允许重试。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>AlwaysRetryPolicy：允许无限重试，直到成功，此方式逻辑不当会导致死循环。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>SimpleRetryPolicy：固定次数重试策略，默认重试最大次数为 3 次，RetryTemplate 默认使用的策略。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>TimeoutRetryPolicy：超时时间重试策略，默认超时时间为 1 秒，在指定的超时时间内允许重试。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>CircuitBreakerRetryPolicy：有熔断功能的重试策略，需设置 3 个参数 openTimeout、resetTimeout 和 delegate；关于熔断，会在后面描述。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>CompositeRetryPolicy：组合重试策略。有两种组合方式，乐观组合重试策略是指只要有一个策略允许重试即可以，悲观组合重试策略是指只要有一个策略不允许重试即不可以。但不管哪种组合方式，组合中的每一个策略都会执行。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>关于 Backoff 的策略如下。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>NoBackOffPolicy：无退避算法策略，即当重试时是立即重试；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>FixedBackOffPolicy：固定时间的退避策略，需设置参数 sleeper 和 backOffPeriod，sleeper 指定等待策略，默认是 Thread.sleep，即线程休眠，backOffPeriod 指定休眠时间，默认 1 秒。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>UniformRandomBackOffPolicy：随机时间退避策略，需设置 sleeper、minBackOffPeriod 和 maxBackOffPeriod。该策略在 [minBackOffPeriod, maxBackOffPeriod] 之间取一个随机休眠时间，minBackOffPeriod 默认为 500 毫秒，maxBackOffPeriod 默认为 1500 毫秒。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>ExponentialBackOffPolicy：指数退避策略，需设置参数 sleeper、initialInterval、maxInterval 和 multiplier。initialInterval 指定初始休眠时间，默认为 100 毫秒。maxInterval 指定最大休眠时间，默认为 30 秒。multiplier 指定乘数，即下一次休眠时间为当前休眠时间 *multiplier。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>ExponentialRandomBackOffPolicy：随机指数退避策略，引入随机乘数，之前说过固定乘数可能会引起很多服务同时重试导致 DDos，使用随机休眠时间来避免这种情况。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h1 id="重试设计的重点">重试设计的重点&lt;/h1>
&lt;p>重试的设计重点主要如下：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>要确定什么样的错误下需要重试；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>重试的时间和重试的次数。这种在不同的情况下要有不同的考量。有时候，而对一些不是很重要的问题时，我们应该更快失败而不是重试一段时间若干次。比如一个前端的交互需要用到后端的服务。这种情况下，在面对错误的时候，应该快速失败报错（比如：网络错误请重试）。而面对其它的一些错误，比如流控，那么应该使用指数退避的方式，以避免造成更多的流量。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>如果超过重试次数，或是一段时间，那么重试就没有意义了。这个时候，说明这个错误不是一个短暂的错误，那么我们对于新来的请求，就没有必要再进行重试了，这个时候对新的请求直接返回错误就好了。但是，这样一来，如果后端恢复了，我们怎么知道呢，此时需要使用我们的熔断设计了。这个在后面会说。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>重试还需要考虑被调用方是否有幂等的设计。如果没有，那么重试是不安全的，可能会导致一个相同的操作被执行多次。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>重试的代码比较简单也比较通用，完全可以不用侵入到业务代码中。这里有两个模式。一个是代码级的，像 Java 那样可以使用 Annotation 的方式（在 Spring 中你可以用到这样的注解），如果没有注解也可以包装在底层库或是 SDK 库中不需要让上层业务感知到。另外一种是走 Service Mesh 的方式（关于 Service Mesh 的方式，我会在后面的文章中介绍）。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>对于有事务相关的操作。我们可能会希望能重试成功，而不至于走业务补偿那样的复杂的回退流程。对此，我们可能需要一个比较长的时间来做重试，但是我们需要保存请求的上下文，这可能对程序的运行有比较大的开销，因此，有一些设计会先把这样的上下文暂存在本机或是数据库中，然后腾出资源来做别的事，过一会再回来把之前的请求从存储中捞出来重试。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h1 id="小结">小结&lt;/h1>
&lt;p>好了，我们来总结一下今天分享的主要内容。首先，我讲了重试的场景，比如流控，但并不是所有的失败场景都适合重试。接着我讲了重试的策略，包括简单的指数退避策略，和 Spring 实现的多种策略。&lt;/p>
&lt;p>这些策略可以用 Java 的 Annotation 来实现，或者用 Service Mesh 的方式，从而不必写在业务逻辑里。最后，我总结了重试设计的重点。下篇文章中，我们讲述熔断设计。希望对你有帮助。&lt;/p>
&lt;p>也欢迎你分享一下你实现过哪些场景下的重试？所采用的策略是什么？实现的过程中遇到过哪些坑？&lt;/p>
&lt;p>文末给出了《分布式系统设计模式》系列文章的目录，希望你能在这个列表里找到自己感兴趣的内容。&lt;/p>
&lt;ul>
&lt;li>弹力设计篇
&lt;ul>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/3912">认识故障和弹力设计&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/3917">隔离设计 Bulkheads&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/3926">异步通讯设计 Asynchronous&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/4050">幂等性设计 Idempotency&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/4086">服务的状态 State&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/4087">补偿事务 Compensating Transaction&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/4121">重试设计 Retry&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/4241">熔断设计 Circuit Breaker&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/4245">限流设计 Throttle&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/4252">降级设计 degradation&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/4253">弹力设计总结&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>管理设计篇
&lt;ul>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/5175">分布式锁 Distributed Lock&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/5819">配置中心 Configuration Management&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/5909">边车模式 Sidecar&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/5920">服务网格 Service Mesh&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/6086">网关模式 Gateway&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/6283">部署升级策略&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>性能设计篇
&lt;ul>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/6282">缓存 Cache&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/7036">异步处理 Asynchronous&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/7045">数据库扩展&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/7047">秒杀 Flash Sales&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/7086">边缘计算 Edge Computing&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/fc/e9/fcc761001867c60f526665e237f831e9.jpg" alt="">&lt;/p></description></item><item><title>极客专栏: 48丨弹力设计篇之“熔断设计”</title><link>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E/48%E4%B8%A8%E5%BC%B9%E5%8A%9B%E8%AE%BE%E8%AE%A1%E7%AF%87%E4%B9%8B%E7%86%94%E6%96%AD%E8%AE%BE%E8%AE%A1/</link><pubDate>Fri, 27 May 2022 00:00:00 +0000</pubDate><guid>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E/48%E4%B8%A8%E5%BC%B9%E5%8A%9B%E8%AE%BE%E8%AE%A1%E7%AF%87%E4%B9%8B%E7%86%94%E6%96%AD%E8%AE%BE%E8%AE%A1/</guid><description>
&lt;p>熔断机制这个词对你来说肯定不陌生，它的灵感来源于我们电闸上的 &amp;quot; 保险丝 &amp;ldquo;，当电压有问题时（比如短路），自动跳闸，此时电路就会断开，我们的电器就会受到保护。不然，会导致电器被烧坏，如果人没在家或是人在熟睡中，还会导致火灾。所以，在电路世界通常都会有这样的自我保护装置。&lt;/p>
&lt;p>同样，在我们的分布式系统设计中，也应该有这样的方式。前面说过重试机制，如果错误太多，或是在短时间内得不到修复，那么我们重试也没有意义了，此时应该开启我们的熔断操作，尤其是后端太忙的时候，使用熔断设计可以保护后端不会过载。&lt;/p>
&lt;h1 id="熔断设计">熔断设计&lt;/h1>
&lt;p>熔断器模式可以防止应用程序不断地尝试执行可能会失败的操作，使得应用程序继续执行而不用等待修正错误，或者浪费 CPU 时间去等待长时间的超时产生。熔断器模式也可以使应用程序能够诊断错误是否已经修正。如果已经修正，应用程序会再次尝试调用操作。&lt;/p>
&lt;p>换句话来说，我觉得熔断器模式就像是那些容易导致错误的操作的一种代理。这种代理能够记录最近调用发生错误的次数，然后决定允许操作继续，或者立即返回错误。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/85/93/850b613bae392236fdd097c70f7a5093.png" alt="">&lt;br>
（本图来自 Martin Fowler 的 Circuit Breaker）&lt;/p>
&lt;p>熔断器可以使用状态机来实现，内部模拟以下几种状态。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>闭合（Closed）状态&lt;/strong>：我们需要一个调用失败的计数器，如果调用失败，则使失败次数加 1。如果最近失败次数超过了在给定时间内允许失败的阈值，则切换到断开 (Open) 状态。此时开启了一个超时时钟，当该时钟超过了该时间，则切换到半断开（Half-Open）状态。该超时时间的设定是给了系统一次机会来修正导致调用失败的错误，以回到正常工作的状态。在 Closed 状态下，错误计数器是基于时间的。在特定的时间间隔内会自动重置。这能够防止由于某次的偶然错误导致熔断器进入断开状态。也可以基于连续失败的次数。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>断开 (Open) 状态&lt;/strong>：在该状态下，对应用程序的请求会立即返回错误响应，而不调用后端的服务。这样也许比较粗暴，有些时候，我们可以 cache 住上次成功请求，直接返回缓存（当然，这个缓存放在本地内存就好了），如果没有缓存再返回错误（缓存的机制最好用在全站一样的数据，而不是用在不同的用户间不同的数据，因为后者需要缓存的数据有可能会很多）。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>半开（Half-Open）状态&lt;/strong>：允许应用程序一定数量的请求去调用服务。如果这些请求对服务的调用成功，那么可以认为之前导致调用失败的错误已经修正，此时熔断器切换到闭合状态，同时将错误计数器重置。&lt;/p>
&lt;p>如果这一定数量的请求有调用失败的情况，则认为导致之前调用失败的问题仍然存在，熔断器切回到断开状态，然后重置计时器来给系统一定的时间来修正错误。半断开状态能够有效防止正在恢复中的服务被突然而来的大量请求再次拖垮。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/34/7f/34151c1a1caa1bd57a6fcdd3c92b7d7f.png" alt="">&lt;br>
（本图来自 Martin Fowler 的 Circuit Breaker）&lt;/p>
&lt;p>实现熔断器模式使得系统更加稳定和有弹性，在系统从错误中恢复的时候提供稳定性，并且减少了错误对系统性能的影响。它快速地拒绝那些有可能导致错误的服务调用，而不会去等待操作超时或者永远不返回结果来提高系统的响应时间。&lt;/p>
&lt;p>如果熔断器设计模式在每次状态切换的时候会发出一个事件，这种信息可以用来监控服务的运行状态，能够通知管理员在熔断器切换到断开状态时进行处理。&lt;/p>
&lt;p>下图是 Netflix 的开源项目&lt;a href="https://github.com/Netflix/Hystrix">Hystrix&lt;/a>中的熔断的实现逻辑（&lt;a href="https://github.com/Netflix/Hystrix/wiki/How-it-Works#CircuitBreaker">其出处在这里&lt;/a>）。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/90/e4/908a291d5698db2dc4734119371241e4.png" alt="">&lt;/p>
&lt;p>从这个流程图中，可以看到：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>有请求来了，首先 allowRequest() 函数判断是否在熔断中，如果不是则放行，如果是的话，还要看有没有到达一个熔断时间片，如果熔断时间片到了，也放行，否则直接返回出错。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>每次调用都有两个函数 markSuccess(duration) 和 markFailure(duration) 来统计一下在一定的 duration 内有多少调用是成功还是失败的。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>判断是否熔断的条件 isOpen()，是计算一下 failure/(success+failure) 当前的错误率，如果高于一个阈值，那么打开熔断，否则关闭。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Hystrix 会在内存中维护一个数组，其中记录着每一个周期的请求结果的统计。超过时长长度的元素会被删除掉。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h1 id="熔断设计的重点">熔断设计的重点&lt;/h1>
&lt;p>在实现熔断器模式的时候，以下这些因素需可能需要考虑。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>错误的类型&lt;/strong>。需要注意的是请求失败的原因会有很多种。你需要根据不同的错误情况来调整相应的策略。所以，熔断和重试一样，需要对返回的错误进行识别。一些错误先走重试的策略（比如限流，或是超时），重试几次后再打开熔断。一些错误是远程服务挂掉，恢复时间比较长；这种错误不必走重试，就可以直接打开熔断策略。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>日志监控&lt;/strong>。熔断器应该能够记录所有失败的请求，以及一些可能会尝试成功的请求，使得管理员能够监控使用熔断器保护服务的执行情况。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>测试服务是否可用&lt;/strong>。在断开状态下，熔断器可以采用定期地 ping 一下远程服务的健康检查接口，来判断服务是否恢复，而不是使用计时器来自动切换到半开状态。这样做的一个好处是，在服务恢复的情况下，不需要真实的用户流量就可以把状态从半开状态切回关闭状态。否则在半开状态下，即便服务已恢复了，也需要用户真实的请求来恢复，这会影响用户的真实请求。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>手动重置&lt;/strong>。在系统中对于失败操作的恢复时间是很难确定的，提供一个手动重置功能能够使得管理员可以手动地强制将熔断器切换到闭合状态。同样的，如果受熔断器保护的服务暂时不可用的话，管理员能够强制将熔断器设置为断开状态。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>并发问题&lt;/strong>。相同的熔断器有可能被大量并发请求同时访问。熔断器的实现不应该阻塞并发的请求或者增加每次请求调用的负担。尤其是其中对调用结果的统计，一般来说会成为一个共享的数据结构，它会导致有锁的情况。在这种情况下，最好使用一些无锁的数据结构，或是 atomic 的原子操作。这样会带来更好的性能。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>资源分区&lt;/strong>。有时候，我们会把资源分布在不同的分区上。比如，数据库的分库分表，某个分区可能出现问题，而其它分区还可用。在这种情况下，单一的熔断器会把所有的分区访问给混为一谈，从而，一旦开始熔断，那么所有的分区都会受到熔断影响。或是出现一会儿熔断一会儿又好，来来回回的情况。所以，熔断器需要考虑这样的问题，只对有问题的分区进行熔断，而不是整体。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>重试错误的请求&lt;/strong>。有时候，错误和请求的数据和参数有关系，所以，记录下出错的请求，在半开状态下重试能够准确地知道服务是否真的恢复。当然，这需要被调用端支持幂等调用，否则会出现一个操作被执行多次的副作用。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h1 id="小结">小结&lt;/h1>
&lt;p>好了，我们来总结一下今天分享的主要内容。首先，熔断设计是受了电路设计中保险丝的启发，其需要实现三个状态：闭合、断开和半开，分别对应于正常、故障和故障后检测故障是否已被修复的场景，并介绍了 Netflix 的 Hystrix 对熔断的实现。最后，我总结了熔断设计的几个重点。下篇文章中，我们讲述限流设计。希望对你有帮助。&lt;/p>
&lt;p>也欢迎你分享一下你实现过的熔断使用了怎样的算法？实现的过程中遇到过什么坑？&lt;/p>
&lt;p>文末给出了《分布式系统设计模式》系列文章的目录，希望你能在这个列表里找到自己感兴趣的内容。&lt;/p>
&lt;ul>
&lt;li>弹力设计篇
&lt;ul>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/3912">认识故障和弹力设计&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/3917">隔离设计 Bulkheads&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/3926">异步通讯设计 Asynchronous&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/4050">幂等性设计 Idempotency&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/4086">服务的状态 State&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/4087">补偿事务 Compensating Transaction&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/4121">重试设计 Retry&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/4241">熔断设计 Circuit Breaker&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/4245">限流设计 Throttle&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/4252">降级设计 degradation&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/4253">弹力设计总结&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>管理设计篇
&lt;ul>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/5175">分布式锁 Distributed Lock&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/5819">配置中心 Configuration Management&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/5909">边车模式 Sidecar&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/5920">服务网格 Service Mesh&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/6086">网关模式 Gateway&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/6283">部署升级策略&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>性能设计篇
&lt;ul>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/6282">缓存 Cache&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/7036">异步处理 Asynchronous&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/7045">数据库扩展&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/7047">秒杀 Flash Sales&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/7086">边缘计算 Edge Computing&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/fc/e9/fcc761001867c60f526665e237f831e9.jpg" alt="">&lt;/p></description></item><item><title>极客专栏: 49丨弹力设计篇之“限流设计”</title><link>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E/49%E4%B8%A8%E5%BC%B9%E5%8A%9B%E8%AE%BE%E8%AE%A1%E7%AF%87%E4%B9%8B%E9%99%90%E6%B5%81%E8%AE%BE%E8%AE%A1/</link><pubDate>Fri, 27 May 2022 00:00:00 +0000</pubDate><guid>/%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F/%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E/49%E4%B8%A8%E5%BC%B9%E5%8A%9B%E8%AE%BE%E8%AE%A1%E7%AF%87%E4%B9%8B%E9%99%90%E6%B5%81%E8%AE%BE%E8%AE%A1/</guid><description>
&lt;p>保护系统不会在过载的情况下出现问题，我们就需要限流。&lt;/p>
&lt;p>我们在一些系统中都可以看到这样的设计，比如，我们的数据库访问的连接池，还有我们的线程池，还有 Nginx 下的用于限制瞬时并发连接数的 limit_conn 模块，限制每秒平均速率的 limit_req 模块，还有限制 MQ 的生产速，等等。&lt;/p>
&lt;h1 id="限流的策略">限流的策略&lt;/h1>
&lt;p>限流的目的是通过对并发访问进行限速，相关的策略一般是，一旦达到限制的速率，那么就会触发相应的限流行为。一般来说，触发的限流行为如下。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>拒绝服务&lt;/strong>。把多出来的请求拒绝掉。一般来说，好的限流系统在受到流量暴增时，会统计当前哪个客户端来的请求最多，直接拒掉这个客户端，这种行为可以把一些不正常的或者是带有恶意的高并发访问挡在门外。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>服务降级&lt;/strong>。关闭或是把后端服务做降级处理。这样可以让服务有足够的资源来处理更多的请求。降级有很多方式，一种是把一些不重要的服务给停掉，把 CPU、内存或是数据的资源让给更重要的功能；一种是不再返回全量数据，只返回部分数据。&lt;/p>
&lt;p>因为全量数据需要做 SQL Join 操作，部分的数据则不需要，所以可以让 SQL 执行更快，还有最快的一种是直接返回预设的缓存，以牺牲一致性的方式来获得更大的性能吞吐。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>特权请求&lt;/strong>。所谓特权请求的意思是，资源不够了，我只能把有限的资源分给重要的用户，比如：分给权利更高的 VIP 用户。在多租户系统下，限流的时候应该保大客户的，所以大客户有特权可以优先处理，而其它的非特权用户就得让路了。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>延时处理&lt;/strong>。在这种情况下，一般会有一个队列来缓冲大量的请求，这个队列如果满了，那么就只能拒绝用户了，如果这个队列中的任务超时了，也要返回系统繁忙的错误了。使用缓冲队列只是为了减缓压力，一般用于应对短暂的峰刺请求。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>弹性伸缩&lt;/strong>。动用自动化运维的方式对相应的服务做自动化的伸缩。这个需要一个应用性能的监控系统，能够感知到目前最繁忙的 TOP 5 的服务是哪几个。&lt;/p>
&lt;p>然后去伸缩它们，还需要一个自动化的发布、部署和服务注册的运维系统，而且还要快，越快越好。否则，系统会被压死掉了。当然，如果是数据库的压力过大，弹性伸缩应用是没什么用的，这个时候还是应该限流。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h1 id="限流的实现方式">限流的实现方式&lt;/h1>
&lt;h2 id="计数器方式">计数器方式&lt;/h2>
&lt;p>最简单的限流算法就是维护一个计数器 Counter，当一个请求来时，就做加一操作，当一个请求处理完后就做减一操作。如果这个 Counter 大于某个数了（我们设定的限流阈值），那么就开始拒绝请求以保护系统的负载了。&lt;/p>
&lt;p>这个算法足够的简单粗暴。&lt;/p>
&lt;h2 id="队列算法">队列算法&lt;/h2>
&lt;p>在这个算法下，请求的速度可以是波动的，而处理的速度则是非常均速的。这个算法其实有点像一个 FIFO 的算法。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/c8/3d/c8f774f88ab8a4b72378971263c0393d.png" alt="">&lt;/p>
&lt;p>在上面这个 FIFO 的队列上，我们可以扩展出一些别的玩法。&lt;/p>
&lt;p>一个是有优先级的队列，处理时先处理高优先级的队列，然后再处理低优先级的队列。 如下图所示，只有高优先级的队列被处理完成后，才会处理低优先级的队列。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/de/80/de51d6fc68df3d8c808b84e4bc455580.png" alt="">&lt;/p>
&lt;p>有优先级的队列可能会导致低优先级队列长时间得不到处理。为了避免低优先级的队列被饿死，一般来说是分配不同比例的处理时间到不同的队列上，于是我们有了带权重的队列。&lt;/p>
&lt;p>如下图所示。有三个队列的权重分布是 3:2:1，这意味着我们需要在权重为 3 的这个队列上处理 3 个请求后，再去权重为 2 的队列上处理 2 个请求，最后再去权重为 1 的队列上处理 1 个请求，如此反复。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/c7/54/c775345e3b8f599e26a4d7f64941cd54.png" alt="">&lt;/p>
&lt;p>队列流控是以队列的的方式来处理请求。如果处理过慢，那么就会导致队列满，而开始触发限流。&lt;/p>
&lt;p>但是，这样的算法需要用队列长度来控制流量，在配置上比较难操作。如果队列过长，导致后端服务在队列没有满时就挂掉了。一般来说，这样的模型不能做 push，而是 pull 方式会好一些。&lt;/p>
&lt;h2 id="漏斗算法-leaky-bucket">漏斗算法 Leaky Bucket&lt;/h2>
&lt;p>漏斗算法可以参看 Wikipedia 的相关词条 &lt;a href="https://en.wikipedia.org/wiki/Leaky_bucket">Leaky Bucket&lt;/a>。&lt;/p>
&lt;p>下图是一个&lt;a href="https://www.slideshare.net/vimal25792/leaky-bucket-tocken-buckettraffic-shaping">漏斗算法的示意图&lt;/a> 。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/95/00/95326ea1624d4206a26ff275b39efc00.png" alt="">&lt;/p>
&lt;p>我们可以看到，就像一个漏斗一样，进来的水量就好像访问流量一样，而出去的水量就像是我们的系统处理请求一样。当访问流量过大时这个漏斗中就会积水，如果水太多了就会溢出。&lt;/p>
&lt;p>一般来说，这个&amp;quot;漏斗&amp;quot;是用一个队列来实现的，当请求过多时，队列就会开始积压请求，如果队列满了，就会开拒绝请求。很多系统都有这样的设计，比如 TCP。当请求的数量过多时，就会有一个 sync backlog 的队列来缓冲请求，或是 TCP 的滑动窗口也是用于流控的队列。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/d4/a0/d4b8b6ceb8de4400dfc97f3ff0feeaa0.png" alt="">&lt;/p>
&lt;p>我们可以看到，漏斗算法其实就是在队列请求中加上一个限流器，来让 Processor 以一个均匀的速度处理请求。&lt;/p>
&lt;h2 id="令牌桶算法-token-bucket">令牌桶算法 Token Bucket&lt;/h2>
&lt;p>关于令牌桶算法，主要是有一个中间人。在一个桶内按照一定的速率放入一些 token，然后，处理程序要处理请求时，需要拿到 token，才能处理；如果拿不到，则不处理。&lt;/p>
&lt;p>下面这个图很清楚地说明了这个算法。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/99/f0/996b8d60ed90c470ce839f8826e375f0.png" alt="">&lt;/p>
&lt;p>从理论上来说，令牌桶的算法和漏斗算法不一样的是，漏斗算法中，处理请求是以一个常量和恒定的速度处理的，而令牌桶算法则是在流量小的时候&amp;quot;攒钱&amp;quot;，流量大的时候，可以快速处理。&lt;/p>
&lt;p>然而，我们可能会问，Processor 的处理速度因为有队列的存在，所以其总是能以最大处理能力来处理请求，这也是我们所希望的方式。因此，令牌桶和漏斗都是受制于 Processor 的最大处理能力。无论令牌桶里有多少令牌，也无论队列中还有多少请求。总之，Processor 在大流量来临时总是按照自己最大的处理能力来处理的。&lt;/p>
&lt;p>但是，试想一下，如果我们的 Processor 只是一个非常简单的任务分配器，比如像 Nginx 这样的基本没有什么业务逻辑的网关，那么它的处理速度一定很快，不会有什么瓶颈，而其用来把请求转发给后端服务，那么在这种情况下，这两个算法就有不一样的情况了。&lt;/p>
&lt;p>漏斗算法会以一个稳定的速度转发，而令牌桶算法平时流量不大时在&amp;quot;攒钱&amp;quot;，流量大时，可以一次发出队列里有的请求，而后就受到令牌桶的流控限制。&lt;/p>
&lt;p>另外，令牌桶还可能做成第三方的一个服务，这样可以在分布式的系统中对全局进行流控，这也是一个很好的方式。&lt;/p>
&lt;h2 id="基于响应时间的动态限流">基于响应时间的动态限流&lt;/h2>
&lt;p>上面的算法有个不好的地方，就是需要设置一个确定的限流值。这就要求我们每次发布服务时都做相应的性能测试，找到系统最大的性能值。&lt;/p>
&lt;p>当然，性能测试并不是很容易做的。有关性能测试的方法请参看我在 CoolShell 上的这篇文章《&lt;a href="https://coolshell.cn/articles/17381.html">性能测试应该怎么做&lt;/a>》。虽然性能测试比较不容易，但是还是应该要做的。&lt;/p>
&lt;p>然而，在很多时候，我们却并不知道这个限流值，或是很难给出一个合适的值。其基本会有如下的一些因素：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>实际情况下，很多服务会依赖于数据库。所以，不同的用户请求，会对不同的数据集进行操作。就算是相同的请求，可能数据集也不一样，比如，现在很多应用都会有一个时间线 Feed 流，不同的用户关心的主题人人不一样，数据也不一样。&lt;/p>
&lt;p>而且数据库的数据是在不断变化的，可能前两天性能还行，因为数据量增加导致性能变差。在这种情况下，我们很难给出一个确定的一成不变的值，因为关系型数据库对于同一条 SQL 语句的执行时间其实是不可预测的（NoSQL 的就比 RDBMS 的可预测性要好）。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>不同的 API 有不同的性能。我们要在线上为每一个 API 配置不同的限流值，这点太难配置，也很难管理。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>而且，现在的服务都是能自动化伸缩的，不同大小的集群的性能也不一样，所以，在自动化伸缩的情况下，我们要动态地调整限流的阈值，这点太难做到了。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>基于上述这些原因，我们限流的值是很难被静态地设置成恒定的一个值。&lt;/p>
&lt;p>我们想使用一种动态限流的方式。这种方式，不再设定一个特定的流控值，而是能够动态地感知系统的压力来自动化地限流。&lt;/p>
&lt;p>这方面设计的典范是 TCP 协议的拥塞控制的算法。TCP 使用 RTT - Round Trip Time 来探测网络的延时和性能，从而设定相应的&amp;quot;滑动窗口&amp;quot;的大小，以让发送的速率和网络的性能相匹配。这个算法是非常精妙的，我们完全可以借鉴在我们的流控技术中。&lt;/p>
&lt;p>我们记录下每次调用后端请求的响应时间，然后在一个时间区间内（比如，过去 10 秒）的请求计算一个响应时间的 P90 或 P99 值，也就是把过去 10 秒内的请求的响应时间排个序，然后看 90% 或 99% 的位置是多少。&lt;/p>
&lt;p>这样，我们就知道有多少请求大于某个响应时间。如果这个 P90 或 P99 超过我们设定的阈值，那么我们就自动限流。&lt;/p>
&lt;p>这个设计中有几个要点。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>你需要计算的一定时间内的 P90 或 P99。在有大量请求的情况下，这个非常地耗内存也非常地耗 CPU，因为需要对大量的数据进行排序。&lt;/p>
&lt;p>解决方案有两种，一种是不记录所有的请求，采样就好了，另一种是使用一个叫蓄水池的近似算法。关于这个算法这里我不就多说了，《编程珠玑》里讲过这个算法，你也可以自行 Google，英文叫 &lt;a href="https://en.wikipedia.org/wiki/Reservoir_sampling">Reservoir Sampling&lt;/a>。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>这种动态流控需要像 TCP 那样，你需要记录一个当前的 QPS. 如果发现后端的 P90/P99 响应太慢，那么就可以把这个 QPS 减半，然后像 TCP 一样走慢启动的方式，直接到又开始变慢，然后减去 1/4 的 QPS，再慢启动，然后再减去 1/8 的 QPS&amp;hellip;&amp;hellip;&lt;/p>
&lt;p>这个过程有点像个阻尼运行的过程，然后整个限流的流量会在一个值上下做小幅振动。这么做的目的是，如果后端扩容伸缩后性能变好，系统会自动适应后端的最大性能。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>这种动态限流的方式实现起来并不容易。大家可以看一下 TCP 的算法。TCP 相关的一些算法，我写在了 CoolShell 上的《&lt;a href="https://coolshell.cn/articles/11609.html">TCP 的那些事（下）&lt;/a>》这篇文章中。你可以用来做参考来实现。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>我在现在创业中的 Ease Gateway 的产品中实现了这个算法。&lt;/p>
&lt;h1 id="限流的设计要点">限流的设计要点&lt;/h1>
&lt;p>限流主要是有四个目的。&lt;/p>
&lt;ol>
&lt;li>
&lt;p>为了向用户承诺 SLA。我们保证我们的系统在某个速度下的响应时间以及可用性。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>同时，也可以用来阻止在多租户的情况下，某一用户把资源耗尽而让所有的用户都无法访问的问题。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>为了应对突发的流量。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>节约成本。我们不会为了一个不常见的尖峰来把我们的系统扩容到最大的尺寸。而是在有限的资源下能够承受比较高的流量。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>在设计上，我们还要有以下的考量。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>限流应该是在架构的早期考虑。当架构形成后，限流不是很容易加入。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>限流模块性能必须好，而且对流量的变化也是非常灵敏的，否则太过迟钝的限流，系统早因为过载而挂掉了。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>限流应该有个手动的开关，这样在应急的时候，可以手动操作。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>当限流发生时，应该有个监控事件通知。让我们知道有限流事件发生，这样，运维人员可以及时跟进。而且还可以自动化触发扩容或降级，以缓解系统压力。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>当限流发生时，对于拒掉的请求，我们应该返回一个特定的限流错误码。这样，可以和其它错误区分开来。而客户端看到限流，可以调整发送速度，或是走重试机制。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>限流应该让后端的服务感知到。限流发生时，我们应该在协议头中塞进一个标识，比如 HTTP Header 中，放入一个限流的级别，告诉后端服务目前正在限流中。这样，后端服务可以根据这个标识决定是否做降级。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h1 id="小结">小结&lt;/h1>
&lt;p>好了，我们来总结一下今天分享的主要内容。&lt;/p>
&lt;p>首先，限流的目的是为了保护系统不在过载的情况下导致问题。接着讲了几种限流的策略。然后讲了，限流的算法，包括计数器、队列、漏斗和令牌桶。然后讨论了如何基于响应时间来限流。最后，我总结了限流设计的要点。下篇文章中，我们讲述降级设计。希望对你有帮助。&lt;/p>
&lt;p>也欢迎你分享一下你实现过怎样的限流机制？&lt;/p>
&lt;p>文末给出了《分布式系统设计模式》系列文章的目录，希望你能在这个列表里找到自己感兴趣的内容。&lt;/p>
&lt;ul>
&lt;li>弹力设计篇
&lt;ul>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/3912">认识故障和弹力设计&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/3917">隔离设计 Bulkheads&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/3926">异步通讯设计 Asynchronous&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/4050">幂等性设计 Idempotency&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/4086">服务的状态 State&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/4087">补偿事务 Compensating Transaction&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/4121">重试设计 Retry&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/4241">熔断设计 Circuit Breaker&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/4245">限流设计 Throttle&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/4252">降级设计 degradation&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/4253">弹力设计总结&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>管理设计篇
&lt;ul>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/5175">分布式锁 Distributed Lock&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/5819">配置中心 Configuration Management&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/5909">边车模式 Sidecar&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/5920">服务网格 Service Mesh&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/6086">网关模式 Gateway&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/6283">部署升级策略&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>性能设计篇
&lt;ul>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/6282">缓存 Cache&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/7036">异步处理 Asynchronous&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/7045">数据库扩展&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/7047">秒杀 Flash Sales&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://time.geekbang.org/column/article/7086">边缘计算 Edge Computing&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://static001.geekbang.org/resource/image/fc/e9/fcc761001867c60f526665e237f831e9.jpg" alt="">&lt;/p></description></item></channel></rss>